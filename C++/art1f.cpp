#include <fem.hpp>  // Fortran EMulation library of fable module

namespace AMPT {

using namespace fem::major_types;

void aknel(...) {
  throw std::runtime_error("Missing function implementation: aknel");
}

void aknlam(...) {
  throw std::runtime_error("Missing function implementation: aknlam");
}

void aknpsg(...) {
  throw std::runtime_error("Missing function implementation: aknpsg");
}

void aknsgm(...) {
  throw std::runtime_error("Missing function implementation: aknsgm");
}

void akpel(...) {
  throw std::runtime_error("Missing function implementation: akpel");
}

void akplam(...) {
  throw std::runtime_error("Missing function implementation: akplam");
}

void akpsgm(...) {
  throw std::runtime_error("Missing function implementation: akpsgm");
}

void hbtout(...) {
  throw std::runtime_error("Missing function implementation: hbtout");
}

void iarflv(...) {
  throw std::runtime_error("Missing function implementation: iarflv");
}

void inidcy(...) {
  throw std::runtime_error("Missing function implementation: inidcy");
}

void invflv(...) {
  throw std::runtime_error("Missing function implementation: invflv");
}

void newka(...) {
  throw std::runtime_error("Missing function implementation: newka");
}

void ranart(...) {
  throw std::runtime_error("Missing function implementation: ranart");
}

void resdec(...) {
  throw std::runtime_error("Missing function implementation: resdec");
}

struct common_ee {
  static const int maxstr = 150001;

  arr<int> id;
  arr<int> lb;

  common_ee()
      : id(dimension(maxstr), fem::fill0), lb(dimension(maxstr), fem::fill0) {}
};

const int common_ee::maxstr;

struct common_zz {
  int zta;
  int zpr;

  common_zz() : zta(fem::int0), zpr(fem::int0) {}
};

struct common_bb {
  static const int maxstr = 150001;

  arr<float, 2> p;

  common_bb() : p(dimension(3, maxstr), fem::fill0) {}
};

const int common_bb::maxstr;

struct common_cc {
  static const int maxstr = 150001;

  arr<float> e;

  common_cc() : e(dimension(maxstr), fem::fill0) {}
};

const int common_cc::maxstr;

struct common_bg {
  float betax;
  float betay;
  float betaz;
  float gamma;

  common_bg()
      : betax(fem::float0),
        betay(fem::float0),
        betaz(fem::float0),
        gamma(fem::float0) {}
};

struct common_aa {
  static const int maxstr = 150001;

  arr<float, 2> r;

  common_aa() : r(dimension(3, maxstr), fem::fill0) {}
};

const int common_aa::maxstr;

struct common_leadng {
  int lb1;
  float px1;
  float py1;
  float pz1;
  float em1;
  float e1;
  float xfnl;
  float yfnl;
  float zfnl;
  float tfnl;
  float px1n;
  float py1n;
  float pz1n;
  float dp1n;

  common_leadng()
      : lb1(fem::int0),
        px1(fem::float0),
        py1(fem::float0),
        pz1(fem::float0),
        em1(fem::float0),
        e1(fem::float0),
        xfnl(fem::float0),
        yfnl(fem::float0),
        zfnl(fem::float0),
        tfnl(fem::float0),
        px1n(fem::float0),
        py1n(fem::float0),
        pz1n(fem::float0),
        dp1n(fem::float0) {}
};

struct common_dpi {
  float em2;
  int lb2;

  common_dpi() : em2(fem::float0), lb2(fem::int0) {}
};

struct common_rndf77 {
  int nseed;

  common_rndf77() : nseed(fem::int0) {}
};

struct common_table {
  arr<float> xarray;
  arr<float> earray;

  common_table()
      : xarray(dim1(0, 1000), fem::fill0), earray(dim1(0, 1000), fem::fill0) {}
};

struct common_input1 {
  int masspr;
  int massta;
  int iseed;
  int iavoid;
  float dt;

  common_input1()
      : masspr(fem::int0),
        massta(fem::int0),
        iseed(fem::int0),
        iavoid(fem::int0),
        dt(fem::float0) {}
};

struct common_para8 {
  int idpert;
  int npertd;
  int idxsec;

  common_para8() : idpert(fem::int0), npertd(fem::int0), idxsec(fem::int0) {}
};

struct common_arevt {
  int iaevt;
  int iarun;
  int miss;

  common_arevt() : iaevt(fem::int0), iarun(fem::int0), miss(fem::int0) {}
};

struct common_ff {
  static const int mx = 4;
  static const int my = 4;
  static const int mz = 8;
  static const int mpx = 4;
  static const int mpy = 4;
  static const int mpz = 10;
  static const int mpzp = 10;

  arr<float, 6> f;

  common_ff()
      : f(dim1(-mx, mx)
              .dim2(-my, my)
              .dim3(-mz, mz)
              .dim4(-mpx, mpx)
              .dim5(-mpy, mpy)
              .dim6(-mpz, mpzp),
          fem::fill0) {}
};

const int common_ff::mx;
const int common_ff::my;
const int common_ff::mz;
const int common_ff::mpx;
const int common_ff::mpy;
const int common_ff::mpz;
const int common_ff::mpzp;

struct common_gg {
  float dx;
  float dy;
  float dz;
  float dpx;
  float dpy;
  float dpz;

  common_gg()
      : dx(fem::float0),
        dy(fem::float0),
        dz(fem::float0),
        dpx(fem::float0),
        dpy(fem::float0),
        dpz(fem::float0) {}
};

struct common_input {
  int nstar;
  int ndirct;
  float dir;

  common_input() : nstar(fem::int0), ndirct(fem::int0), dir(fem::float0) {}
};

struct common_nn {
  int nnn;

  common_nn() : nnn(fem::int0) {}
};

struct common_run {
  int num;

  common_run() : num(fem::int0) {}
};

struct common_pa {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 3> rpion;

  common_pa() : rpion(dimension(3, maxstr, maxr), fem::fill0) {}
};

const int common_pa::maxstr;
const int common_pa::maxr;

struct common_pb {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 3> ppion;

  common_pb() : ppion(dimension(3, maxstr, maxr), fem::fill0) {}
};

const int common_pb::maxstr;
const int common_pb::maxr;

struct common_pc {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> epion;

  common_pc() : epion(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_pc::maxstr;
const int common_pc::maxr;

struct common_pd {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<int, 2> lpion;

  common_pd() : lpion(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_pd::maxstr;
const int common_pd::maxr;

struct common_dpert {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> dpertt;
  arr<float> dpertp;
  arr<float> dplast;
  arr<float> dpdcy;
  arr<float, 2> dpdpi;
  arr<float, 2> dpt;
  arr<float, 2> dpp1;
  arr<float, 2> dppion;

  common_dpert()
      : dpertt(dimension(maxstr, maxr), fem::fill0),
        dpertp(dimension(maxstr), fem::fill0),
        dplast(dimension(maxstr), fem::fill0),
        dpdcy(dimension(maxstr), fem::fill0),
        dpdpi(dimension(maxstr, maxr), fem::fill0),
        dpt(dimension(maxstr, maxr), fem::fill0),
        dpp1(dimension(maxstr, maxr), fem::fill0),
        dppion(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_dpert::maxstr;
const int common_dpert::maxr;

struct common_ppbmas {
  arr<int> niso;
  int nstate;
  arr<float, 2> ppbm;
  arr<float> thresh;
  arr<float> weight;

  common_ppbmas()
      : niso(dimension(15), fem::fill0),
        nstate(fem::int0),
        ppbm(dimension(15, 2), fem::fill0),
        thresh(dimension(15), fem::fill0),
        weight(dimension(15), fem::fill0) {}
};

struct common_ppb1 {
  float ene;
  arr<float> factr2;
  float fsum;
  float ppinnb;
  float s;
  float wtot;

  common_ppb1()
      : ene(fem::float0),
        factr2(dimension(6), fem::fill0),
        fsum(fem::float0),
        ppinnb(fem::float0),
        s(fem::float0),
        wtot(fem::float0) {}
};

struct common_ppmm {
  float pprr;
  float ppee;
  float pppe;
  float rpre;
  float xopoe;
  float rree;

  common_ppmm()
      : pprr(fem::float0),
        ppee(fem::float0),
        pppe(fem::float0),
        rpre(fem::float0),
        xopoe(fem::float0),
        rree(fem::float0) {}
};

struct common_dd {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> rho;
  arr<float, 3> rhop;
  arr<float, 3> rhon;

  common_dd()
      : rho(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rhop(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rhon(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
             fem::fill0) {}
};

const int common_dd::maxx;
const int common_dd::maxz;

struct common_tdecay {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float> tfdcy;
  arr<float, 2> tfdpi;
  arr<float> tft;

  common_tdecay()
      : tfdcy(dimension(maxstr), fem::fill0),
        tfdpi(dimension(maxstr, maxr), fem::fill0),
        tft(dimension(maxstr), fem::fill0) {}
};

const int common_tdecay::maxstr;
const int common_tdecay::maxr;

struct common_input2 {
  int ilab;
  int manyb;
  int ntmax;
  int icoll;
  int insys;
  int ipot;
  int mode;
  int imomen;
  int nfreq;
  int icflow;
  int icrho;
  int icou;
  int kpoten;
  int kmul;

  common_input2()
      : ilab(fem::int0),
        manyb(fem::int0),
        ntmax(fem::int0),
        icoll(fem::int0),
        insys(fem::int0),
        ipot(fem::int0),
        mode(fem::int0),
        imomen(fem::int0),
        nfreq(fem::int0),
        icflow(fem::int0),
        icrho(fem::int0),
        icou(fem::int0),
        kpoten(fem::int0),
        kmul(fem::int0) {}
};

struct common_hh {
  static const int maxstr = 150001;

  arr<float> proper;

  common_hh() : proper(dimension(maxstr), fem::fill0) {}
};

const int common_hh::maxstr;

struct common_pe {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> propi;

  common_pe() : propi(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_pe::maxstr;
const int common_pe::maxr;

struct common_rr {
  static const int maxr = 1;

  arr<int> massr;

  common_rr() : massr(dim1(0, maxr), fem::fill0) {}
};

const int common_rr::maxr;

struct common_dpifsl {
  int lbnn1;
  int lbnn2;
  int lbnd1;
  int lbnd2;
  int lbns1;
  int lbns2;
  int lbnp1;
  int lbnp2;
  int lbdd1;
  int lbdd2;
  int lbds1;
  int lbds2;
  int lbdp1;
  int lbdp2;
  int lbss1;
  int lbss2;
  int lbsp1;
  int lbsp2;
  int lbpp1;
  int lbpp2;

  common_dpifsl()
      : lbnn1(fem::int0),
        lbnn2(fem::int0),
        lbnd1(fem::int0),
        lbnd2(fem::int0),
        lbns1(fem::int0),
        lbns2(fem::int0),
        lbnp1(fem::int0),
        lbnp2(fem::int0),
        lbdd1(fem::int0),
        lbdd2(fem::int0),
        lbds1(fem::int0),
        lbds2(fem::int0),
        lbdp1(fem::int0),
        lbdp2(fem::int0),
        lbss1(fem::int0),
        lbss2(fem::int0),
        lbsp1(fem::int0),
        lbsp2(fem::int0),
        lbpp1(fem::int0),
        lbpp2(fem::int0) {}
};

struct common_dpifsm {
  float xmnn1;
  float xmnn2;
  float xmnd1;
  float xmnd2;
  float xmns1;
  float xmns2;
  float xmnp1;
  float xmnp2;
  float xmdd1;
  float xmdd2;
  float xmds1;
  float xmds2;
  float xmdp1;
  float xmdp2;
  float xmss1;
  float xmss2;
  float xmsp1;
  float xmsp2;
  float xmpp1;
  float xmpp2;

  common_dpifsm()
      : xmnn1(fem::float0),
        xmnn2(fem::float0),
        xmnd1(fem::float0),
        xmnd2(fem::float0),
        xmns1(fem::float0),
        xmns2(fem::float0),
        xmnp1(fem::float0),
        xmnp2(fem::float0),
        xmdd1(fem::float0),
        xmdd2(fem::float0),
        xmds1(fem::float0),
        xmds2(fem::float0),
        xmdp1(fem::float0),
        xmdp2(fem::float0),
        xmss1(fem::float0),
        xmss2(fem::float0),
        xmsp1(fem::float0),
        xmsp2(fem::float0),
        xmpp1(fem::float0),
        xmpp2(fem::float0) {}
};

struct common_dpisig {
  float sdmel;
  float sdmnn;
  float sdmnd;
  float sdmns;
  float sdmnp;
  float sdmdd;
  float sdmds;
  float sdmdp;
  float sdmss;
  float sdmsp;
  float sdmpp;

  common_dpisig()
      : sdmel(fem::float0),
        sdmnn(fem::float0),
        sdmnd(fem::float0),
        sdmns(fem::float0),
        sdmnp(fem::float0),
        sdmdd(fem::float0),
        sdmds(fem::float0),
        sdmdp(fem::float0),
        sdmss(fem::float0),
        sdmsp(fem::float0),
        sdmpp(fem::float0) {}
};

struct common_ss {
  arr<int> inout;

  common_ss() : inout(dimension(20), fem::fill0) {}
};

struct common_kkk {
  arr<float> tkaon;
  arr<float, 2> ekaon;

  common_kkk()
      : tkaon(dimension(7), fem::fill0),
        ekaon(dim1(7).dim2(0, 2000), fem::fill0) {}
};

struct common_kaon {
  arr<float, 3> ak;
  arr<float, 3> speck;
  int mf;

  common_kaon()
      : ak(dimension(3, 50, 36), fem::fill0),
        speck(dimension(50, 36, 7), fem::fill0),
        mf(fem::int0) {}
};

struct common_lastt {
  int itimeh;
  float bimp;

  common_lastt() : itimeh(fem::int0), bimp(fem::float0) {}
};

struct common_hbt {
  static const int maxstr = 150001;

  arr<int> lblast;
  arr<float, 2> xlast;
  arr<float, 2> plast;
  int nlast;

  common_hbt()
      : lblast(dimension(maxstr), fem::fill0),
        xlast(dimension(4, maxstr), fem::fill0),
        plast(dimension(4, maxstr), fem::fill0),
        nlast(fem::int0) {}
};

const int common_hbt::maxstr;

struct common_resdcy {
  int nsav;
  int iksdcy;

  common_resdcy() : nsav(fem::int0), iksdcy(fem::int0) {}
};

struct common_ftmax {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float> ftsv;
  arr<float, 2> ftsvt;

  common_ftmax()
      : ftsv(dimension(maxstr), fem::fill0),
        ftsvt(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_ftmax::maxstr;
const int common_ftmax::maxr;

struct common_phidcy {
  int iphidcy;
  float pttrig;
  int ntrig;
  int maxmiss;
  int ipi0dcy;

  common_phidcy()
      : iphidcy(fem::int0),
        pttrig(fem::float0),
        ntrig(fem::int0),
        maxmiss(fem::int0),
        ipi0dcy(fem::int0) {}
};

struct common_ddpi {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> pirho;

  common_ddpi()
      : pirho(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
              fem::fill0) {}
};

const int common_ddpi::maxx;
const int common_ddpi::maxz;

struct common_tt {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> pel;
  arr<float, 3> rxy;

  common_tt()
      : pel(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rxy(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0) {
  }
};

const int common_tt::maxx;
const int common_tt::maxz;

struct common_bbb {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> bxx;
  arr<float, 3> byy;
  arr<float, 3> bzz;

  common_bbb()
      : bxx(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        byy(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        bzz(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0) {
  }
};

const int common_bbb::maxx;
const int common_bbb::maxz;

struct common_pp {
  arr<float, 2> prho;

  common_pp() : prho(dim1(-20, 20).dim2(-24, 24), fem::fill0) {}
};

struct common_qq {
  static const int maxz = 24;

  arr<float, 2> phrho;

  common_qq() : phrho(dim1(-maxz, maxz).dim2(-24, 24), fem::fill0) {}
};

const int common_qq::maxz;

struct common_input3 {
  float plab;
  float elab;
  float zeropt;
  float b0;
  float bi;
  float bm;
  float dencut;
  float cycbox;

  common_input3()
      : plab(fem::float0),
        elab(fem::float0),
        zeropt(fem::float0),
        b0(fem::float0),
        bi(fem::float0),
        bm(fem::float0),
        dencut(fem::float0),
        cycbox(fem::float0) {}
};

struct common_arprnt {
  arr<float> arpar1;
  arr<int> iapar2;
  arr<float> arint1;
  arr<int> iaint2;

  common_arprnt()
      : arpar1(dimension(100), fem::fill0),
        iapar2(dimension(50), fem::fill0),
        arint1(dimension(100), fem::fill0),
        iaint2(dimension(50), fem::fill0) {}
};

struct common_arercp {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> pro1;

  common_arercp() : pro1(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_arercp::maxstr;
const int common_arercp::maxr;

struct common_arerc1 {
  static const int maxr = 1;

  arr<int> multi1;

  common_arerc1() : multi1(dimension(maxr), fem::fill0) {}
};

const int common_arerc1::maxr;

struct common_arprc1 {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<int, 2> ityp1;
  arr<float, 2> gx1;
  arr<float, 2> gy1;
  arr<float, 2> gz1;
  arr<float, 2> ft1;
  arr<float, 2> px1;
  arr<float, 2> py1;
  arr<float, 2> pz1;
  arr<float, 2> ee1;
  arr<float, 2> xm1;

  common_arprc1()
      : ityp1(dimension(maxstr, maxr), fem::fill0),
        gx1(dimension(maxstr, maxr), fem::fill0),
        gy1(dimension(maxstr, maxr), fem::fill0),
        gz1(dimension(maxstr, maxr), fem::fill0),
        ft1(dimension(maxstr, maxr), fem::fill0),
        px1(dimension(maxstr, maxr), fem::fill0),
        py1(dimension(maxstr, maxr), fem::fill0),
        pz1(dimension(maxstr, maxr), fem::fill0),
        ee1(dimension(maxstr, maxr), fem::fill0),
        xm1(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_arprc1::maxstr;
const int common_arprc1::maxr;

struct common_snn {
  float efrm;
  int npart1;
  int npart2;
  float epsipz;
  float epsipt;
  float pzproj;
  float pztarg;

  common_snn()
      : efrm(fem::float0),
        npart1(fem::int0),
        npart2(fem::int0),
        epsipz(fem::float0),
        epsipt(fem::float0),
        pzproj(fem::float0),
        pztarg(fem::float0) {}
};

struct common_hparnt {
  arr<float> hipr1;
  arr<int> ihpr2;
  arr<float> hint1;
  arr<int> ihnt2;

  common_hparnt()
      : hipr1(dimension(100), fem::fill0),
        ihpr2(dimension(50), fem::fill0),
        hint1(dimension(100), fem::fill0),
        ihnt2(dimension(50), fem::fill0) {}
};

struct common : fem::common,
                common_ee,
                common_zz,
                common_bb,
                common_cc,
                common_bg,
                common_aa,
                common_leadng,
                common_dpi,
                common_rndf77,
                common_table,
                common_input1,
                common_para8,
                common_arevt,
                common_ff,
                common_gg,
                common_input,
                common_nn,
                common_run,
                common_pa,
                common_pb,
                common_pc,
                common_pd,
                common_dpert,
                common_ppbmas,
                common_ppb1,
                common_ppmm,
                common_dd,
                common_tdecay,
                common_input2,
                common_hh,
                common_pe,
                common_rr,
                common_dpifsl,
                common_dpifsm,
                common_dpisig,
                common_ss,
                common_kkk,
                common_kaon,
                common_lastt,
                common_hbt,
                common_resdcy,
                common_ftmax,
                common_phidcy,
                common_ddpi,
                common_tt,
                common_bbb,
                common_pp,
                common_qq,
                common_input3,
                common_arprnt,
                common_arercp,
                common_arerc1,
                common_arprc1,
                common_snn,
                common_hparnt {
  fem::cmn_sve coulin_sve;
  fem::cmn_sve cms_sve;
  fem::cmn_sve distce_sve;
  fem::cmn_sve width_sve;
  fem::cmn_sve fde_sve;
  fem::cmn_sve w1535_sve;
  fem::cmn_sve fd5_sve;
  fem::cmn_sve fns_sve;
  fem::cmn_sve sigma_sve;
  fem::cmn_sve ang_sve;
  fem::cmn_sve n1535_sve;
  fem::cmn_sve ptdis_sve;
  fem::cmn_sve ptr_sve;
  fem::cmn_sve fmassd_sve;
  fem::cmn_sve w1440_sve;
  fem::cmn_sve fmassn_sve;
  fem::cmn_sve fmassr_sve;
  fem::cmn_sve rmasdd_sve;
  fem::cmn_sve ddp2_sve;
  fem::cmn_sve frho_sve;
  fem::cmn_sve rhomas_sve;
  fem::cmn_sve ddrho_sve;
  fem::cmn_sve pprho_sve;
  fem::cmn_sve ppomga_sve;
  fem::cmn_sve x2pi_sve;
  fem::cmn_sve x3pi_sve;
  fem::cmn_sve x33pi_sve;
  fem::cmn_sve pp1_sve;
  fem::cmn_sve s1535_sve;
  fem::cmn_sve pplpk_sve;
  fem::cmn_sve ppk0_sve;
  fem::cmn_sve ppk1_sve;
  fem::cmn_sve x4pi_sve;
  fem::cmn_sve fkaon_sve;
  fem::cmn_sve fdelta_sve;
  fem::cmn_sve rmass_sve;
  fem::cmn_sve bbkaon_sve;
  fem::cmn_sve xrho_sve;
  fem::cmn_sve omega_sve;
  fem::cmn_sve rotate_sve;
  fem::cmn_sve sbbdm_sve;
  fem::cmn_sve bbdangle_sve;
  fem::cmn_sve crnn_sve;
  fem::cmn_sve rhores_sve;
  fem::cmn_sve bbarfs_sve;
  fem::cmn_sve crpp_sve;
  fem::cmn_sve denom_sve;
  fem::cmn_sve m1535_sve;
  fem::cmn_sve crnd_sve;
  fem::cmn_sve reab2d_sve;
  fem::cmn_sve crdd_sve;
  fem::cmn_sve dkine_sve;
  fem::cmn_sve decay_sve;
  fem::cmn_sve dkine2_sve;
  fem::cmn_sve decay2_sve;
  fem::cmn_sve dreson_sve;
  fem::cmn_sve xnpi_sve;
  fem::cmn_sve pnlka_sve;
  fem::cmn_sve pnska_sve;
  fem::cmn_sve wida1_sve;
  fem::cmn_sve xn1535_sve;
  fem::cmn_sve pp2_sve;
  fem::cmn_sve ppt_sve;
  fem::cmn_sve ppxs_sve;
  fem::cmn_sve twopi_sve;
  fem::cmn_sve threpi_sve;
  fem::cmn_sve fourpi_sve;
  fem::cmn_sve crpn_sve;
  fem::cmn_sve cren_sve;
  fem::cmn_sve crdir_sve;
  fem::cmn_sve crpd_sve;
  fem::cmn_sve crrd_sve;
  fem::cmn_sve crlaba_sve;
  fem::cmn_sve crkn_sve;
  fem::cmn_sve pbarfs_sve;
  fem::cmn_sve crppba_sve;
  fem::cmn_sve crkhyp_sve;
  fem::cmn_sve crlan_sve;
  fem::cmn_sve crkpla_sve;
  fem::cmn_sve crkkpi_sve;
  fem::cmn_sve pipik_sve;
  fem::cmn_sve xkkann_sve;
  fem::cmn_sve xkksan_sve;
  fem::cmn_sve crkspi_sve;
  fem::cmn_sve crkphi_sve;
  fem::cmn_sve crksph_sve;
  fem::cmn_sve pionpp_sve;
  fem::cmn_sve pipp1_sve;
  fem::cmn_sve reab_sve;
  fem::cmn_sve xpp_sve;
  fem::cmn_sve xnp_sve;
  fem::cmn_sve xnd_sve;
  fem::cmn_sve xddin_sve;
  fem::cmn_sve dirct1_sve;
  fem::cmn_sve dirct2_sve;
  fem::cmn_sve fdr_sve;
  fem::cmn_sve erhon_sve;
  fem::cmn_sve fd1_sve;
  fem::cmn_sve dirct3_sve;
  fem::cmn_sve fd2_sve;
  fem::cmn_sve dpion_sve;
  fem::cmn_sve xppbar_sve;
  fem::cmn_sve xphib_sve;
  fem::cmn_sve crphib_sve;
  fem::cmn_sve pibphi_sve;
  fem::cmn_sve phimes_sve;
  fem::cmn_sve crphim_sve;
  fem::cmn_sve xkhype_sve;
  fem::cmn_sve getnst_sve;
  fem::cmn_sve ppbbar_sve;
  fem::cmn_sve prbbar_sve;
  fem::cmn_sve rrbbar_sve;
  fem::cmn_sve pobbar_sve;
  fem::cmn_sve robbar_sve;
  fem::cmn_sve oobbar_sve;
  fem::cmn_sve ptor_sve;
  fem::cmn_sve ptoe_sve;
  fem::cmn_sve pptope_sve;
  fem::cmn_sve rptore_sve;
  fem::cmn_sve xop2oe_sve;
  fem::cmn_sve eetorr_sve;
  fem::cmn_sve ksreso_sve;
  fem::cmn_sve pertur_sve;
  fem::cmn_sve crhb_sve;
  fem::cmn_sve lambar_sve;
  fem::cmn_sve distc0_sve;
  fem::cmn_sve sdmbb_sve;
  fem::cmn_sve dmangle_sve;
  fem::cmn_sve dmelangle_sve;
  fem::cmn_sve crdmbb_sve;
  fem::cmn_sve sdbelastic_sve;
  fem::cmn_sve dbelangle_sve;
  fem::cmn_sve crdbel_sve;
  fem::cmn_sve relcol_sve;
  fem::cmn_sve init_sve;
  fem::cmn_sve dens_sve;
  fem::cmn_sve gradu_sve;
  fem::cmn_sve graduk_sve;
  fem::cmn_sve gradup_sve;
  fem::cmn_sve gradun_sve;
  fem::cmn_sve tablem_sve;
  fem::cmn_sve flow_sve;
  fem::cmn_sve artmn_sve;
  fem::cmn_sve blockdata_ppbdat_sve;

  common(int argc, char const* argv[]) : fem::common(argc, argv) {}
};

struct coulin_save {
  int i;
  int irun;
  int mass;

  coulin_save() : i(fem::int0), irun(fem::int0), mass(fem::int0) {}
};

// C*********************************
void coulin(common& cmn, int const& masspr, int const& massta, int const& num) {
  FEM_CMN_SVE(coulin);
  // COMMON ee
  const int maxstr = 150001;
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON zz
  int& zta = cmn.zta;
  int& zpr = cmn.zpr;
  //
  // SAVE
  int& i = sve.i;
  int& irun = sve.irun;
  int& mass = sve.mass;
  //
  // C                                                                      *
  // C     purpose:   initialization of array zet() and lb() for all runs  *
  // C                lb(i) = 1   =>  proton                               *
  // C                lb(i) = 2   =>  neutron                              *
  // C*********************************
  // Cc      SAVE /EE/
  // Cc      SAVE /zz/
  mass = massta + masspr;
  FEM_DO_SAFE(irun, 1, num) {
    FEM_DO_SAFE(i, 1 + (irun - 1) * mass, zta + (irun - 1) * mass) {
      lb(i) = 1;
    }
    FEM_DO_SAFE(i, zta + 1 + (irun - 1) * mass, massta + (irun - 1) * mass) {
      lb(i) = 2;
    }
    FEM_DO_SAFE(i, massta + 1 + (irun - 1) * mass,
                massta + zpr + (irun - 1) * mass) {
      lb(i) = 1;
    }
    FEM_DO_SAFE(i, massta + zpr + 1 + (irun - 1) * mass,
                massta + masspr + (irun - 1) * mass) {
      lb(i) = 2;
    }
  }
}

struct cms_save {
  double dbetax;
  double dbetay;
  double dbetaz;
  double dgamma;
  double e1;
  double e2;
  double em1;
  double em2;
  double etotal;
  double p1beta;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double s;
  double scheck;
  double transf;

  cms_save()
      : dbetax(fem::double0),
        dbetay(fem::double0),
        dbetaz(fem::double0),
        dgamma(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        em1(fem::double0),
        em2(fem::double0),
        etotal(fem::double0),
        p1beta(fem::double0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        s(fem::double0),
        scheck(fem::double0),
        transf(fem::double0) {}
};

// C
// Clin-9/2012: use double precision for S in CMS(): to avoid crash
// C     (segmentation fault due to s<0, which happened at high energies
// C     such as LHC with large NTMAX for two almost-comoving hadrons
// C     that have small Pt but large |Pz|):
// C***************************************
// C            SUBROUTINE CMS(I1,I2,PX1CM,PY1CM,PZ1CM,SRT)
// C PURPOSE : FIND THE MOMENTA OF PARTICLES IN THE CMS OF THE
// C          TWO COLLIDING PARTICLES
// C VARIABLES :
// C****************************************
// C            PARAMETER (MAXSTR=150001)
// C            COMMON   /AA/  R(3,MAXSTR)
// Ccc      SAVE /AA/
// C            COMMON   /BB/  P(3,MAXSTR)
// Ccc      SAVE /BB/
// C            COMMON   /CC/  E(MAXSTR)
// Ccc      SAVE /CC/
// C            COMMON   /BG/  BETAX,BETAY,BETAZ,GAMMA
// Ccc      SAVE /BG/
// C            SAVE
// C            PX1=P(1,I1)
// C            PY1=P(2,I1)
// C            PZ1=P(3,I1)
// C            PX2=P(1,I2)
// C            PY2=P(2,I2)
// C            PZ2=P(3,I2)
// C            EM1=E(I1)
// C            EM2=E(I2)
// C            E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
// C            E2=SQRT(EM2**2 + PX2**2 + PY2**2 + PZ2**2 )
// C            S=(E1+E2)**2-(PX1+PX2)**2-(PY1+PY2)**2-(PZ1+PZ2)**2
// C            SRT=SQRT(S)
// C*LORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
// C              ETOTAL = E1 + E2
// C              BETAX  = (PX1+PX2) / ETOTAL
// C              BETAY  = (PY1+PY2) / ETOTAL
// C              BETAZ  = (PZ1+PZ2) / ETOTAL
// C              GAMMA  = 1.0 / SQRT(1.0-BETAX**2-BETAY**2-BETAZ**2)
// C*TRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
// C              P1BETA = PX1*BETAX + PY1*BETAY + PZ1 * BETAZ
// C              TRANSF = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) - E1 )
// C              PX1CM  = BETAX * TRANSF + PX1
// C              PY1CM  = BETAY * TRANSF + PY1
// C              PZ1CM  = BETAZ * TRANSF + PZ1
// C              RETURN
// C              END
// C***************************************
void cms(common& cmn, int const& i1, int const& i2, float& px1cm, float& py1cm,
         float& pz1cm, float& srt) {
  FEM_CMN_SVE(cms);
  common_write write(cmn);
  // COMMON bb
  const int maxstr = 150001;
  arr_cref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON cc
  arr_cref<float> e(cmn.e, dimension(maxstr));
  //
  // SAVE
  double& dbetax = sve.dbetax;
  double& dbetay = sve.dbetay;
  double& dbetaz = sve.dbetaz;
  double& dgamma = sve.dgamma;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  double& em1 = sve.em1;
  double& em2 = sve.em2;
  double& etotal = sve.etotal;
  double& p1beta = sve.p1beta;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& s = sve.s;
  double& scheck = sve.scheck;
  double& transf = sve.transf;
  //
  // C PURPOSE : FIND THE MOMENTA OF PARTICLES IN THE CMS OF THE
  // C          TWO COLLIDING PARTICLES
  // C VARIABLES :
  // C****************************************
  px1 = fem::dble(p(1, i1));
  py1 = fem::dble(p(2, i1));
  pz1 = fem::dble(p(3, i1));
  px2 = fem::dble(p(1, i2));
  py2 = fem::dble(p(2, i2));
  pz2 = fem::dble(p(3, i2));
  em1 = fem::dble(e(i1));
  em2 = fem::dble(e(i2));
  e1 = fem::dsqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                  fem::pow2(pz1));
  e2 = fem::dsqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                  fem::pow2(pz2));
  s = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) - fem::pow2((py1 + py2)) -
      fem::pow2((pz1 + pz2));
  if (s <= 0) {
    s = 0e0;
  }
  srt = fem::sngl(fem::dsqrt(s));
  // CLORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
  etotal = e1 + e2;
  dbetax = (px1 + px2) / etotal;
  dbetay = (py1 + py2) / etotal;
  dbetaz = (pz1 + pz2) / etotal;
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.e0 - fem::pow2(dbetax) - fem::pow2(dbetay) - fem::pow2(dbetaz);
  if (scheck <= 0e0) {
    write(99, star), "scheck1: ", scheck;
    FEM_STOP(0);
  }
  dgamma = 1.e0 / fem::dsqrt(scheck);
  // CTRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
  p1beta = px1 * dbetax + py1 * dbetay + pz1 * dbetaz;
  transf = dgamma * (dgamma * p1beta / (dgamma + 1e0) - e1);
  px1cm = fem::sngl(dbetax * transf + px1);
  py1cm = fem::sngl(dbetay * transf + py1);
  pz1cm = fem::sngl(dbetaz * transf + pz1);
  cmn.betax = fem::sngl(dbetax);
  cmn.betay = fem::sngl(dbetay);
  cmn.betaz = fem::sngl(dbetaz);
  cmn.gamma = fem::sngl(dgamma);
}

struct distce_save {
  float bbb;
  float ddd;
  float drbeta;
  float drcm;
  float dxcm;
  float dycm;
  float dzcm;
  float dzz;
  float e2;
  float p1beta;
  float prcm;
  float px2;
  float py2;
  float pz2;
  float relvel;
  float rsqare;
  float s;
  float transf;
  float x1;
  float x2;
  float y1;
  float y2;
  float z1;
  float z2;

  distce_save()
      : bbb(fem::float0),
        ddd(fem::float0),
        drbeta(fem::float0),
        drcm(fem::float0),
        dxcm(fem::float0),
        dycm(fem::float0),
        dzcm(fem::float0),
        dzz(fem::float0),
        e2(fem::float0),
        p1beta(fem::float0),
        prcm(fem::float0),
        px2(fem::float0),
        py2(fem::float0),
        pz2(fem::float0),
        relvel(fem::float0),
        rsqare(fem::float0),
        s(fem::float0),
        transf(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        z1(fem::float0),
        z2(fem::float0) {}
};

// Clin-9/2012-end
// C
// C**************************************
void distce(common& cmn, int const& i1, int const& i2, float const& deltar,
            float const& ds, float const& dt, float const& ec, float const& srt,
            int& ic, float const& px1cm, float const& py1cm,
            float const& pz1cm) {
  FEM_CMN_SVE(distce);
  const int maxstr = 150001;
  arr_cref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_cref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_cref<float> e(cmn.e, dimension(maxstr));
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  float& em2 = cmn.em2;
  //
  float& bbb = sve.bbb;
  float& ddd = sve.ddd;
  float& drbeta = sve.drbeta;
  float& drcm = sve.drcm;
  float& dxcm = sve.dxcm;
  float& dycm = sve.dycm;
  float& dzcm = sve.dzcm;
  float& dzz = sve.dzz;
  float& e2 = sve.e2;
  float& p1beta = sve.p1beta;
  float& prcm = sve.prcm;
  float& px2 = sve.px2;
  float& py2 = sve.py2;
  float& pz2 = sve.pz2;
  float& relvel = sve.relvel;
  float& rsqare = sve.rsqare;
  float& s = sve.s;
  float& transf = sve.transf;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& y1 = sve.y1;
  float& y2 = sve.y2;
  float& z1 = sve.z1;
  float& z2 = sve.z2;
  // C PURPOSE : CHECK IF THE COLLISION BETWEEN TWO PARTICLES CAN HAPPEN
  // C           BY CHECKING
  // C                      (1) IF THE DISTANCE BETWEEN THEM IS SMALLER
  // C           THAN THE MAXIMUM DISTANCE DETERMINED FROM THE CROSS SECTION.
  // C                      (2) IF PARTICLE WILL PASS EACH OTHER WITHIN
  // C           TWO HARD CORE RADIUS.
  // C                      (3) IF PARTICLES WILL GET CLOSER.
  // C VARIABLES :
  // C           IC=1 COLLISION HAPPENED
  // C           IC=-1 COLLISION CAN NOT HAPPEN
  // C****************************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /BG/
  ic = 0;
  x1 = r(1, i1);
  y1 = r(2, i1);
  z1 = r(3, i1);
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  x2 = r(1, i2);
  y2 = r(2, i2);
  z2 = r(3, i2);
  px2 = p(1, i2);
  py2 = p(2, i2);
  pz2 = p(3, i2);
  em1 = e(i1);
  em2 = e(i2);
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  // C            IF (ABS(X1-X2) .GT. DELTAR) GO TO 400
  // C            IF (ABS(Y1-Y2) .GT. DELTAR) GO TO 400
  // C            IF (ABS(Z1-Z2) .GT. DELTAR) GO TO 400
  rsqare = fem::pow2((x1 - x2)) + fem::pow2((y1 - y2)) + fem::pow2((z1 - z2));
  if (rsqare > fem::pow2(deltar)) {
    goto statement_400;
  }
  // CNOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
  e2 = fem::sqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                 fem::pow2(pz2));
  s = srt * srt;
  if (s < ec) {
    goto statement_400;
  }
  // CNOW THERE IS ENOUGH ENERGY AVAILABLE !
  // CLORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
  // C BETAX, BETAY, BETAZ AND GAMMA HAVE BEEN GIVEN IN THE SUBROUTINE CMS
  // CTRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
  p1beta = px1 * betax + py1 * betay + pz1 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) - e1);
  prcm = fem::sqrt(fem::pow2(px1cm) + fem::pow2(py1cm) + fem::pow2(pz1cm));
  if (prcm <= 0.00001f) {
    goto statement_400;
  }
  // CTRANSFORMATION OF SPATIAL DISTANCE
  drbeta = betax * (x1 - x2) + betay * (y1 - y2) + betaz * (z1 - z2);
  transf = gamma * gamma * drbeta / (gamma + 1);
  dxcm = betax * transf + x1 - x2;
  dycm = betay * transf + y1 - y2;
  dzcm = betaz * transf + z1 - z2;
  // CDETERMINING IF THIS IS THE POINT OF CLOSEST APPROACH
  drcm = fem::sqrt(fem::pow2(dxcm) + fem::pow2(dycm) + fem::pow2(dzcm));
  dzz = (px1cm * dxcm + py1cm * dycm + pz1cm * dzcm) / prcm;
  if ((fem::pow2(drcm) - fem::pow2(dzz)) <= 0.f) {
    bbb = 0.f;
  } else {
    bbb = fem::sqrt(fem::pow2(drcm) - fem::pow2(dzz));
  }
  // CWILL PARTICLE PASS EACH OTHER WITHIN 2 * HARD CORE RADIUS ?
  if (bbb > ds) {
    goto statement_400;
  }
  relvel = prcm * (1.0f / e1 + 1.0f / e2);
  ddd = relvel * dt * 0.5f;
  // CWILL PARTICLES GET CLOSER ?
  if (fem::abs(ddd) < fem::abs(dzz)) {
    goto statement_400;
  }
  ic = 1;
  goto statement_500;
statement_400:
  ic = -1;
statement_500:;
}

struct width_save {
  float aux;
  float avmass;
  float pimass;
  float qavail;

  width_save()
      : aux(fem::float0),
        avmass(fem::float0),
        pimass(fem::float0),
        qavail(fem::float0) {}
};

// C FUNCTION WIDTH(DMASS) GIVES THE DELTA DECAY WIDTH FOR A GIVEN DELTA MASS
// C HERE THE FORMULA GIVEN BY KITAZOE IS USED
float width(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(width);
  // SAVE
  float& aux = sve.aux;
  float& avmass = sve.avmass;
  float& pimass = sve.pimass;
  float& qavail = sve.qavail;
  //
  avmass = 0.938868f;
  pimass = 0.137265f;
  aux = 0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(avmass) -
                           fem::pow2(pimass))) -
        fem::pow2((avmass * pimass));
  if (aux > 0.f) {
    qavail = fem::sqrt(aux / fem::pow2(dmass));
  } else {
    qavail = 1.e-06f;
  }
  return_value =
      0.47f * fem::pow3(qavail) /
      (fem::pow2(pimass) * (1.f + 0.6f * fem::pow2((qavail / pimass))));
  // C       width=0.115
  return return_value;
}

struct fde_save {
  float am0;
  float amn;
  float avpi;
  float fd;
  float p1;
  float p11;

  fde_save()
      : am0(fem::float0),
        amn(fem::float0),
        avpi(fem::float0),
        fd(fem::float0),
        p1(fem::float0),
        p11(fem::float0) {}
};

// C
// C-----------------------------------------------------------------------------
// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
// CKITAZOE'S FORMULA
float fde(common& cmn, float& dmass, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fde);
  // SAVE
  float& am0 = sve.am0;
  float& amn = sve.amn;
  float& avpi = sve.avpi;
  float& fd = sve.fd;
  float& p1 = sve.p1;
  float& p11 = sve.p11;
  //
  amn = 0.938869f;
  avpi = 0.13803333f;
  am0 = 1.232f;
  fd = 4.f * (fem::pow2(am0)) * width(cmn, dmass) /
       (fem::pow2((fem::pow2(dmass) - fem::pow2(1.232f))) +
        fem::pow2(am0) * fem::pow2(width(cmn, dmass)));
  if (con == 1.f) {
    p11 = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
              (4.f * fem::pow2(srt)) -
          fem::pow2(dmass);
    if (p11 <= 0) {
      p11 = 1.e-06f;
    }
    p1 = fem::sqrt(p11);
  } else {
    dmass = amn + avpi;
    p11 = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
              (4.f * fem::pow2(srt)) -
          fem::pow2(dmass);
    if (p11 <= 0) {
      p11 = 1.e-06f;
    }
    p1 = fem::sqrt(p11);
  }
  return_value = fd * p1 * dmass;
  return return_value;
}

struct w1535_save {
  float aux;
  float avmass;
  float pimass;
  float qavail;

  w1535_save()
      : aux(fem::float0),
        avmass(fem::float0),
        pimass(fem::float0),
        qavail(fem::float0) {}
};

// C***********************************
// C FUNCTION W1535(DMASS) GIVES THE N*(1535) DECAY WIDTH
// C     FOR A GIVEN N*(1535) MASS
// C HERE THE FORMULA GIVEN BY KITAZOE IS USED
float w1535(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(w1535);
  // SAVE
  float& aux = sve.aux;
  float& avmass = sve.avmass;
  float& pimass = sve.pimass;
  float& qavail = sve.qavail;
  //
  avmass = 0.938868f;
  pimass = 0.137265f;
  aux = 0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(avmass) -
                           fem::pow2(pimass))) -
        fem::pow2((avmass * pimass));
  if (aux > 0.f) {
    qavail = fem::sqrt(aux / fem::pow2(dmass));
  } else {
    qavail = 1.e-06f;
  }
  return_value = 0.15f * qavail / 0.467f;
  // C       W1535=0.15
  return return_value;
}

struct fd5_save {
  float am0;
  float amn;
  float avpi;
  float fd;
  float p1;
  float scheck;

  fd5_save()
      : am0(fem::float0),
        amn(fem::float0),
        avpi(fem::float0),
        fd(fem::float0),
        p1(fem::float0),
        scheck(fem::float0) {}
};

// C-------------------------------------------------------------
// CFUNCTION FDE(DMASS) GIVES N*(1535) MASS DISTRIBUTION BY USING OF
// CKITAZOE'S FORMULA
float fd5(common& cmn, float& dmass, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fd5);
  common_write write(cmn);
  // SAVE
  float& am0 = sve.am0;
  float& amn = sve.amn;
  float& avpi = sve.avpi;
  float& fd = sve.fd;
  float& p1 = sve.p1;
  float& scheck = sve.scheck;
  //
  amn = 0.938869f;
  avpi = 0.13803333f;
  am0 = 1.535f;
  fd = 4.f * (fem::pow2(am0)) * w1535(cmn, dmass) /
       (fem::pow2((fem::pow2(dmass) - fem::pow2(1.535f))) +
        fem::pow2(am0) * fem::pow2(w1535(cmn, dmass)));
  if (con == 1.f) {
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck11: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    // C           P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    // C     1          /(4.*SRT**2)-DMASS**2)
    // C
  } else {
    dmass = amn + avpi;
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck12: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    // C        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    // C     1  /(4.*SRT**2)-DMASS**2)
    // C
  }
  return_value = fd * p1 * dmass;
  return return_value;
}

struct fns_save {
  float amn;
  float an0;
  float avpi;
  float fn;
  float p1;
  float scheck;
  float width;

  fns_save()
      : amn(fem::float0),
        an0(fem::float0),
        avpi(fem::float0),
        fn(fem::float0),
        p1(fem::float0),
        scheck(fem::float0),
        width(fem::float0) {}
};

// C--------------------------------------------------------------------------
// CFUNCTION FNS(DMASS) GIVES N* MASS DISTRIBUTION
// C     BY USING OF BREIT-WIGNER FORMULA
float fns(common& cmn, float& dmass, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fns);
  common_write write(cmn);
  // SAVE
  float& amn = sve.amn;
  float& an0 = sve.an0;
  float& avpi = sve.avpi;
  float& fn = sve.fn;
  float& p1 = sve.p1;
  float& scheck = sve.scheck;
  float& width = sve.width;
  //
  width = 0.2f;
  amn = 0.938869f;
  avpi = 0.13803333f;
  an0 = 1.43f;
  fn = 4.f * (fem::pow2(an0)) * width /
       (fem::pow2((fem::pow2(dmass) - fem::pow2(1.44f))) +
        fem::pow2(an0) * fem::pow2(width));
  if (con == 1.f) {
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck13: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    // C        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    // C     1  /(4.*SRT**2)-DMASS**2)
    // C
  } else {
    dmass = amn + avpi;
    // Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck14: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    // C        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    // C     1  /(4.*SRT**2)-DMASS**2)
    // C
  }
  return_value = fn * p1 * dmass;
  return return_value;
}

struct sigma_save {
  float alfa;
  float am0;
  float amass;
  float amass0;
  float beta;
  float deln;
  float p0;
  float p02;
  float p2;
  float pr;
  float pr2;
  float q;
  float q0;
  float q02;
  float q2;
  float s;
  float s0;
  float scheck;
  float ss;
  float ss0;
  float t;
  float t0;
  float zminus;
  float zplus;

  sigma_save()
      : alfa(fem::float0),
        am0(fem::float0),
        amass(fem::float0),
        amass0(fem::float0),
        beta(fem::float0),
        deln(fem::float0),
        p0(fem::float0),
        p02(fem::float0),
        p2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        q(fem::float0),
        q0(fem::float0),
        q02(fem::float0),
        q2(fem::float0),
        s(fem::float0),
        s0(fem::float0),
        scheck(fem::float0),
        ss(fem::float0),
        ss0(fem::float0),
        t(fem::float0),
        t0(fem::float0),
        zminus(fem::float0),
        zplus(fem::float0) {}
};

// C------------------------------------------------------------------------------
// C****************************************
float sigma(common& cmn, float const& srt, int const& id, int const& ioi,
            int const& iof) {
  float return_value = fem::float0;
  FEM_CMN_SVE(sigma);
  common_write write(cmn);
  // SAVE
  float& alfa = sve.alfa;
  float& am0 = sve.am0;
  float& amass = sve.amass;
  float& amass0 = sve.amass0;
  float& beta = sve.beta;
  float& deln = sve.deln;
  float& p0 = sve.p0;
  float& p02 = sve.p02;
  float& p2 = sve.p2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& q = sve.q;
  float& q0 = sve.q0;
  float& q02 = sve.q02;
  float& q2 = sve.q2;
  float& s = sve.s;
  float& s0 = sve.s0;
  float& scheck = sve.scheck;
  float& ss = sve.ss;
  float& ss0 = sve.ss0;
  float& t = sve.t;
  float& t0 = sve.t0;
  float& zminus = sve.zminus;
  float& zplus = sve.zplus;
  //
  // CPURPOSE : THIS IS THE PROGRAM TO CALCULATE THE ISOSPIN DECOMPOSED CROSS
  // C       SECTION BY USING OF B.J.VerWEST AND R.A.ARNDT'S PARAMETERIZATION
  // CREFERENCE: PHYS. REV. C25(1982)1979
  // CQUANTITIES: IOI -- INITIAL ISOSPIN OF THE TWO NUCLEON SYSTEM
  // C            IOF -- FINAL   ISOSPIN -------------------------
  // C            ID -- =1 FOR DELTA RESORANCE
  // C                  =2 FOR N*    RESORANCE
  // CDATE : MAY 15,1990
  // C****************************************
  if (id == 1) {
    amass0 = 1.22f;
    t0 = 0.12f;
  } else {
    amass0 = 1.43f;
    t0 = 0.2f;
  }
  if ((ioi == 1) && (iof == 1)) {
    alfa = 3.772f;
    beta = 1.262f;
    am0 = 1.188f;
    t = 0.09902f;
  }
  if ((ioi == 1) && (iof == 0)) {
    alfa = 15.28f;
    beta = 0.f;
    am0 = 1.245f;
    t = 0.1374f;
  }
  if ((ioi == 0) && (iof == 1)) {
    alfa = 146.3f;
    beta = 0.f;
    am0 = 1.472f;
    t = 0.02649f;
  }
  const float amu = 0.9383f;
  zplus = (srt - amu - amass0) * 2.f / t0;
  const float amp = 0.1384f;
  zminus = (amu + amp - amass0) * 2.f / t0;
  deln = fem::atan(zplus) - fem::atan(zminus);
  if (deln == 0) {
    deln = 1.e-06f;
  }
  amass = amass0 +
          (t0 / 4.f) *
              fem::alog((1.f + fem::pow2(zplus)) / (1.f + fem::pow2(zminus))) /
              deln;
  s = fem::pow2(srt);
  p2 = s / 4.f - fem::pow2(amu);
  s0 = fem::pow2((amu + am0));
  p02 = s0 / 4.f - fem::pow2(amu);
  p0 = fem::sqrt(p02);
  pr2 = (s - fem::pow2((amu - amass))) * (s - fem::pow2((amu + amass))) /
        (4.f * s);
  if (pr2 > 1.e-06f) {
    pr = fem::sqrt(pr2);
  } else {
    pr = 0.f;
    return_value = 1.e-06f;
    return return_value;
  }
  ss = fem::pow2(amass);
  q2 = (ss - fem::pow2((amu - amp))) * (ss - fem::pow2((amu + amp))) /
       (4.f * ss);
  if (q2 > 1.e-06f) {
    q = fem::sqrt(q2);
  } else {
    q = 0.f;
    return_value = 1.e-06f;
    return return_value;
  }
  ss0 = fem::pow2(am0);
  q02 = (ss0 - fem::pow2((amu - amp))) * (ss0 - fem::pow2((amu + amp))) /
        (4.f * ss0);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = q02;
  if (scheck < 0) {
    write(99, star), "scheck20: ", scheck;
    scheck = 0.f;
  }
  q0 = fem::sqrt(scheck);
  // C        Q0=SQRT(Q02)
  // C
  const float pi = 3.1415926f;
  const float hc = 0.19733f;
  return_value =
      pi * fem::pow2((hc)) / (2.f * p2) * alfa * fem::pow((pr / p0), beta) *
      fem::pow2(am0) * fem::pow2(t) * fem::pow3((q / q0)) /
      (fem::pow2((ss - fem::pow2(am0))) + fem::pow2(am0) * fem::pow2(t));
  return_value = return_value * 10.f;
  if (return_value == 0) {
    return_value = 1.e-06f;
  }
  return return_value;
}

struct ang_save {
  float ang1;
  float ang2;
  float b1s;
  float b2s;
  float p;
  float q;
  float x;

  ang_save()
      : ang1(fem::float0),
        ang2(fem::float0),
        b1s(fem::float0),
        b2s(fem::float0),
        p(fem::float0),
        q(fem::float0),
        x(fem::float0) {}
};

// C*********************************
// C subroutine : ang.FOR
// C PURPOSE : Calculate the angular distribution of Delta production process
// C DATE    : Nov. 19, 1992
// C REFERENCE: G. WOLF ET. AL., NUCL. PHYS. A517 (1990) 615
// C Note: this function applies when srt is larger than 2.14 GeV,
// C for less energetic reactions, we assume the angular distribution
// C is isotropic.
// C**********************************
float ang(common& cmn, float const& srt, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ang);
  // SAVE
  float& ang1 = sve.ang1;
  float& ang2 = sve.ang2;
  float& b1s = sve.b1s;
  float& b2s = sve.b2s;
  float& p = sve.p;
  float& q = sve.q;
  float& x = sve.x;
  //
  // Cc      SAVE /RNDF77/
  // C        if(srt.le.2.14)then
  // C       b1s=0.5
  // C       b2s=0.
  // C      endif
  if ((srt > 2.14f) && (srt <= 2.4f)) {
    b1s = 29.03f - 23.75f * srt + 4.865f * fem::pow2(srt);
    b2s = -30.33f + 25.53f * srt - 5.301f * fem::pow2(srt);
  }
  if (srt > 2.4f) {
    b1s = 0.06f;
    b2s = 0.4f;
  }
  x = ranart(cmn.nseed);
  p = b1s / b2s;
  q = (2.f * x - 1.f) * (b1s + b2s) / b2s;
  if ((-q / 2.f + fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))) >=
      0.f) {
    ang1 = fem::pow(
        (-q / 2.f + fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  } else {
    ang1 = -fem::pow(
        (q / 2.f - fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  }
  if ((-q / 2.f - fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f))) >=
       0.f)) {
    ang2 = fem::pow(
        (-q / 2.f - fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  } else {
    ang2 = -fem::pow(
        (q / 2.f + fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  }
  return_value = ang1 + ang2;
  return return_value;
}

struct n1535_save {
  float s0;
  float sigma;

  n1535_save() : s0(fem::float0), sigma(fem::float0) {}
};

// C************************
// C cross section for N*(1535) production in NN collisions
// C VARIABLES:
// C LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
// C SRT IS THE CMS ENERGY
// C X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
// C NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA
// C PRODUCTION CROSS SECTION
// C DATE: MAY 18, 1994
// C ***********************
void n1535(common& cmn, int const& lb1, int const& lb2, float const& srt,
           float& x1535) {
  FEM_CMN_SVE(n1535);
  // SAVE
  float& s0 = sve.s0;
  float& sigma = sve.sigma;
  //
  s0 = 2.424f;
  x1535 = 0.f;
  if (srt <= s0) {
    return;
  }
  sigma = 2.f * 0.102f * (srt - s0) / (0.058f + fem::pow2((srt - s0)));
  // C I N*(1535) PRODUCTION IN NUCLEON-NUCLEON COLLISIONS
  // C(1) pp->pN*(+)(1535), nn->nN*(0)(1535)
  // Cbdbg11/25/98
  // C       IF((LB1*LB2.EQ.1).OR.(LB1*LB2.EQ.4))then
  if ((lb1 * lb2 == 1) || (lb1 == 2 && lb2 == 2)) {
    // Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  // C(2) pn->pN*(0)(1535),pn->nN*(+)(1535)
  if (lb1 * lb2 == 2) {
    x1535 = 3.f * sigma;
    return;
  }
  // C III N*(1535) PRODUCTION IN DELTA+DELTA REACTIONS
  // C (5) D(++)+D(0), D(+)+D(+),D(+)+D(-),D(0)+D(0)
  // Cbz11/25/98
  // C       IF((LB1*LB2.EQ.63).OR.(LB1*LB2.EQ.64).OR.(LB1*LB2.EQ.48).
  // C     1  OR.(LB1*LB2.EQ.49))then
  if ((lb1 * lb2 == 63 && (lb1 == 7 || lb2 == 7)) ||
      (lb1 * lb2 == 64 && (lb1 == 8 || lb2 == 8)) ||
      (lb1 * lb2 == 48 && (lb1 == 6 || lb2 == 6)) ||
      (lb1 * lb2 == 49 && (lb1 == 7 || lb2 == 7))) {
    // Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  // C (6) D(++)+D(-),D(+)+D(0)
  // Cbz11/25/98
  // C       IF((LB1*LB2.EQ.54).OR.(LB1*LB2.EQ.56))then
  if ((lb1 * lb2 == 54 && (lb1 == 6 || lb2 == 6)) ||
      (lb1 * lb2 == 56 && (lb1 == 7 || lb2 == 7))) {
    // Cbz11/25/98end
    x1535 = 3.f * sigma;
    return;
  }
  // C IV N*(1535) PRODUCTION IN N*(1440)+N*(1440) REACTIONS
  // Cbz11/25/98
  // C       IF((LB1*LB2.EQ.100).OR.(LB1*LB2.EQ.11*11))X1535=SIGMA
  if ((lb1 == 10 && lb2 == 10) || (lb1 == 11 && lb2 == 11)) {
    x1535 = sigma;
  }
  // C       IF(LB1*LB2.EQ.110)X1535=3.*SIGMA
  if (lb1 * lb2 == 110 && (lb1 == 10 || lb2 == 10)) {
    x1535 = 3.f * sigma;
  }
  // Cbdbg11/25/98end
}

struct ptdis_save {
  float b;
  float c;
  float d;

  ptdis_save() : b(fem::float0), c(fem::float0), d(fem::float0) {}
};

// C********************************
float ptdis(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptdis);
  // SAVE
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  //
  // C NUCLEON TRANSVERSE MOMENTUM DISTRIBUTION AT HIGH ENERGIES
  // C DATE: Aug. 11, 1994
  // C********************************
  b = 3.78f;
  c = 0.47f;
  d = 3.60f;
  // C       b=b*3
  // C       d=d*3
  return_value = 1.f / (2.f * b) * (1.f - fem::exp(-b * fem::pow2(x))) -
                 c / d * x * fem::exp(-d * x) -
                 c / fem::pow2(d) * (fem::exp(-d * x) - 1.f);
  return return_value;
}

struct ptr_save {
  int ie;
  float tryial;
  float xmax;
  float xmin;
  float xt;
  float ymax;
  float ymin;

  ptr_save()
      : ie(fem::int0),
        tryial(fem::float0),
        xmax(fem::float0),
        xmin(fem::float0),
        xt(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C******************************
float ptr(common& cmn, float& ptmax, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptr);
  arr_cref<float> xarray(cmn.xarray, dim1(0, 1000));
  arr_cref<float> earray(cmn.earray, dim1(0, 1000));
  //
  int& ie = sve.ie;
  float& tryial = sve.tryial;
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& xt = sve.xt;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  // C (2) Generate the transverse momentum
  // C     OF nucleons
  // C******************************
  // Cc      SAVE /TABLE/
  // Cc      SAVE /RNDF77/
  return_value = 0.f;
  if (ptmax <= 1.e-02f) {
    return_value = ptmax;
    return return_value;
  }
  if (ptmax > 2.01f) {
    ptmax = 2.01f;
  }
  tryial = ptdis(cmn, ptmax) / ptdis(cmn, 2.01f);
  xt = ranart(cmn.nseed) * tryial;
  // C look up the table and
  // CInterpolate double logarithmically to find pt
  FEM_DO_SAFE(ie, 1, 200) {
    if (earray(ie) == xt) {
      return_value = xarray(ie);
      return return_value;
    }
    if (xarray(ie - 1) <= 0.00001f) {
      goto statement_50;
    }
    if (xarray(ie) <= 0.00001f) {
      goto statement_50;
    }
    if (earray(ie - 1) <= 0.00001f) {
      goto statement_50;
    }
    if (earray(ie) <= 0.00001f) {
      goto statement_50;
    }
    if (earray(ie) > xt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(xt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      if (return_value > ptmax) {
        return_value = ptmax;
      }
      return return_value;
    }
  statement_50:;
  }
  return return_value;
}

struct fmassd_save {
  float am0;

  fmassd_save() : am0(fem::float0) {}
};

// CFUNCTION Fmassd(DMASS) GIVES the delta MASS DISTRIBUTION
float fmassd(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fmassd);
  // SAVE
  float& am0 = sve.am0;
  //
  am0 = 1.232f;
  return_value = am0 * width(cmn, dmass) /
                 (fem::pow2((fem::pow2(dmass) - fem::pow2(am0))) +
                  fem::pow2(am0) * fem::pow2(width(cmn, dmass)));
  return return_value;
}

struct w1440_save {
  float aux;
  float avmass;
  float pimass;
  float qavail;

  w1440_save()
      : aux(fem::float0),
        avmass(fem::float0),
        pimass(fem::float0),
        qavail(fem::float0) {}
};

// C***********************************
// C FUNCTION W1440(DMASS) GIVES THE N*(1440) DECAY WIDTH
// C     FOR A GIVEN N*(1535) MASS
// C HERE THE FORMULA GIVEN BY KITAZOE IS USED
float w1440(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(w1440);
  // SAVE
  float& aux = sve.aux;
  float& avmass = sve.avmass;
  float& pimass = sve.pimass;
  float& qavail = sve.qavail;
  //
  avmass = 0.938868f;
  pimass = 0.137265f;
  aux = 0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(avmass) -
                           fem::pow2(pimass))) -
        fem::pow2((avmass * pimass));
  if (aux > 0.f) {
    qavail = fem::sqrt(aux) / dmass;
  } else {
    qavail = 1.e-06f;
  }
  // C              w1440=0.2
  return_value = 0.2f * fem::pow3((qavail / 0.397f));
  return return_value;
}

struct fmassn_save {
  float am0;

  fmassn_save() : am0(fem::float0) {}
};

// CFUNCTION Fmassn(DMASS) GIVES the N* MASS DISTRIBUTION
float fmassn(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fmassn);
  // SAVE
  float& am0 = sve.am0;
  //
  am0 = 1.44f;
  return_value = am0 * w1440(cmn, dmass) /
                 (fem::pow2((fem::pow2(dmass) - fem::pow2(am0))) +
                  fem::pow2(am0) * fem::pow2(w1440(cmn, dmass)));
  return return_value;
}

struct fmassr_save {
  float am0;
  float wid;

  fmassr_save() : am0(fem::float0), wid(fem::float0) {}
};

// CFUNCTION Fmassr(DMASS) GIVES the rho MASS DISTRIBUTION
float fmassr(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fmassr);
  // SAVE
  float& am0 = sve.am0;
  float& wid = sve.wid;
  //
  am0 = 0.77f;
  wid = 0.153f;
  return_value = am0 * wid /
                 (fem::pow2((fem::pow2(dmass) - fem::pow2(am0))) +
                  fem::pow2(am0) * fem::pow2(wid));
  return return_value;
}

struct rmasdd_save {
  float amn;
  float amp;
  float dmax1;
  float dmax2;
  float fff;
  float fm1;
  float fm2;
  int ictrl;
  int ntry;
  int ntry1;
  int ntry2;
  float prob;
  float prob0;
  float q2;

  rmasdd_save()
      : amn(fem::float0),
        amp(fem::float0),
        dmax1(fem::float0),
        dmax2(fem::float0),
        fff(fem::float0),
        fm1(fem::float0),
        fm2(fem::float0),
        ictrl(fem::int0),
        ntry(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        prob(fem::float0),
        prob0(fem::float0),
        q2(fem::float0) {}
};

// C**************************8
// C   MASS GENERATOR for two resonances simultaneously
void rmasdd(common& cmn, float const& srt, float const& am10, float const& am20,
            float const& dmin1, float const& dmin2, int const& /* iseed */,
            int const& ic, float& dm1, float& dm2) {
  FEM_CMN_SVE(rmasdd);
  int& nseed = cmn.nseed;
  //
  float& dmax1 = sve.dmax1;
  float& dmax2 = sve.dmax2;
  float& fff = sve.fff;
  float& fm1 = sve.fm1;
  float& fm2 = sve.fm2;
  int& ictrl = sve.ictrl;
  int& ntry = sve.ntry;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& prob = sve.prob;
  float& prob0 = sve.prob0;
  float& q2 = sve.q2;
  // Cc      SAVE /RNDF77/
  sve.amn = 0.94f;
  sve.amp = 0.14f;
  // C the maximum mass for resonance 1
  dmax1 = srt - dmin2;
// C generate the mass for the first resonance
statement_5:
  ntry1 = 0;
  ntry2 = 0;
  ntry = 0;
  ictrl = 0;
statement_10:
  dm1 = ranart(nseed) * (dmax1 - dmin1) + dmin1;
  ntry1++;
  // C the maximum mass for resonance 2
  if (ictrl == 0) {
    dmax2 = srt - dm1;
  }
// C generate the mass for the second resonance
statement_20:
  dm2 = ranart(nseed) * (dmax2 - dmin2) + dmin2;
  ntry2++;
  // C check the energy-momentum conservation with two masses
  // C q2 in the following is q**2*4*srt**2
  q2 = (fem::pow2((fem::pow2(srt) - fem::pow2(dm1) - fem::pow2(dm2))) -
        4.f * fem::pow2(dm1) * fem::pow2(dm2));
  if (q2 <= 0) {
    dmax2 = dm2 - 0.01f;
    // C         dmax1=dm1-0.01
    ictrl = 1;
    goto statement_20;
  }
  // C determine the weight of the mass pair
  if (dmax1 < am10) {
    if (ic == 1) {
      fm1 = fmassd(cmn, dmax1);
    }
    if (ic == 2) {
      fm1 = fmassn(cmn, dmax1);
    }
    if (ic == 3) {
      fm1 = fmassd(cmn, dmax1);
    }
    if (ic == 4) {
      fm1 = fmassd(cmn, dmax1);
    }
  } else {
    if (ic == 1) {
      fm1 = fmassd(cmn, am10);
    }
    if (ic == 2) {
      fm1 = fmassn(cmn, am10);
    }
    if (ic == 3) {
      fm1 = fmassd(cmn, am10);
    }
    if (ic == 4) {
      fm1 = fmassd(cmn, am10);
    }
  }
  if (dmax2 < am20) {
    if (ic == 1) {
      fm2 = fmassd(cmn, dmax2);
    }
    if (ic == 2) {
      fm2 = fmassn(cmn, dmax2);
    }
    if (ic == 3) {
      fm2 = fmassn(cmn, dmax2);
    }
    if (ic == 4) {
      fm2 = fmassr(cmn, dmax2);
    }
  } else {
    if (ic == 1) {
      fm2 = fmassd(cmn, am20);
    }
    if (ic == 2) {
      fm2 = fmassn(cmn, am20);
    }
    if (ic == 3) {
      fm2 = fmassn(cmn, am20);
    }
    if (ic == 4) {
      fm2 = fmassr(cmn, am20);
    }
  }
  if (fm1 == 0.f) {
    fm1 = 1.e-04f;
  }
  if (fm2 == 0.f) {
    fm2 = 1.e-04f;
  }
  prob0 = fm1 * fm2;
  if (ic == 1) {
    prob = fmassd(cmn, dm1) * fmassd(cmn, dm2);
  }
  if (ic == 2) {
    prob = fmassn(cmn, dm1) * fmassn(cmn, dm2);
  }
  if (ic == 3) {
    prob = fmassd(cmn, dm1) * fmassn(cmn, dm2);
  }
  if (ic == 4) {
    prob = fmassd(cmn, dm1) * fmassr(cmn, dm2);
  }
  if (prob <= 1.e-06f) {
    prob = 1.e-06f;
  }
  fff = prob / prob0;
  ntry++;
  if (ranart(nseed) > fff && ntry <= 20) {
    goto statement_10;
  }
  // C
  // Clin-2/26/03 limit the mass of (rho,Delta,N*1440) below a certain value
  // C     (here taken as its central value + 2* B-W fullwidth):
  if ((fem::abs(am10 - 0.77f) <= 0.01f && dm1 > 1.07f) ||
      (fem::abs(am10 - 1.232f) <= 0.01f && dm1 > 1.47f) ||
      (fem::abs(am10 - 1.44f) <= 0.01f && dm1 > 2.14f)) {
    goto statement_5;
  }
  if ((fem::abs(am20 - 0.77f) <= 0.01f && dm2 > 1.07f) ||
      (fem::abs(am20 - 1.232f) <= 0.01f && dm2 > 1.47f) ||
      (fem::abs(am20 - 1.44f) <= 0.01f && dm2 > 2.14f)) {
    goto statement_5;
  }
  // C
}

struct ddp2_save {
  float amn;
  float amp;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float scheck;
  float sig;
  float srt1;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  ddp2_save()
      : amn(fem::float0),
        amp(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        srt1(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

// C***********************************
void ddp2(common& cmn, float const& srt, int const& iseed, float& px, float& py,
          float& pz, float& dm1, float& pnx, float& pny, float& pnz, float& dm2,
          float& ppx, float& ppy, float& ppz, int& icou1) {
  FEM_CMN_SVE(ddp2);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  //
  float& amp = sve.amp;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& srt1 = sve.srt1;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  // C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  // C THE PROCESS N+N--->D1+D2+PION
  // C       DATE : July 25, 1994
  // C Generate the masses and momentum for particles in the NN-->DDpi process
  // C for a given center of mass energy srt, the momenta are given in the
  // center C of mass of the NN C**************************************** Cc SAVE
  // /TABLE/ Cc      SAVE /RNDF77/
  icou1 = 0;
  pi = 3.1415926f;
  sve.amn = 938.925f / 1000.f;
  amp = 137.265f / 1000.f;
  // C (1) GENGRATE THE MASS OF DELTA1 AND DELTA2 USING
  srt1 = srt - amp - 0.02f;
  ntrym = 0;
statement_8:
  rmasdd(cmn, srt1, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
  ntrym++;
  // C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  // C FOR ONE OF THE RESONANCES
  v = 0.43f;
  w = -0.84f;
  // C (2) Generate the transverse momentum
  // C     OF DELTA1
  // C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  if (ptmax2 <= 0) {
    goto statement_8;
  }
  ptmax = fem::sqrt(ptmax2) * 1.f / 3.f;
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  // C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-09f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  // C (3.2) THE GENERATED X IS
  // C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  // Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  // C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  // C The x and y components of the deltA1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  // C find the momentum of delta2 and pion
  // C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  // C (1) Generate the momentum of the delta2 in the cms of delta2 and pion
  // C     the energy of the cms of DP
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  // C beta and gamma of the cms of delta2+pion
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck22: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  // C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  // C
  // C the momentum of delta2 and pion in their cms frame
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  // C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  // Clin-10/25/02-end
  // C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck23: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  // C       pnz=SIG*SQRT(pn**2-PNT**2)
  // C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  // C (2) the momentum for the pion
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  // C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  // C (4) for the pion, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct frho_save {
  float am0;
  float fd;
  float wid;

  frho_save() : am0(fem::float0), fd(fem::float0), wid(fem::float0) {}
};

// C
// C------------------------------------------------------------------
// C THE Breit Wigner FORMULA
float frho(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(frho);
  // SAVE
  float& am0 = sve.am0;
  float& fd = sve.fd;
  float& wid = sve.wid;
  //
  am0 = 0.77f;
  wid = 0.153f;
  fd = 0.25f * fem::pow2(wid) /
       (fem::pow2((dmass - am0)) + 0.25f * fem::pow2(wid));
  return_value = fd;
  return return_value;
}

struct rhomas_save {
  float dm;
  float dmin;
  float fm;
  int ntry1;

  rhomas_save()
      : dm(fem::float0), dmin(fem::float0), fm(fem::float0), ntry1(fem::int0) {}
};

// C**************************8
// C   RHO MASS GENERATOR
float rhomas(common& cmn, float const& dmax, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rhomas);
  int& nseed = cmn.nseed;
  //
  float& dm = sve.dm;
  float& dmin = sve.dmin;
  float& fm = sve.fm;
  int& ntry1 = sve.ntry1;
  // Cc      SAVE /RNDF77/
  // C THE MINIMUM MASS FOR DELTA
  dmin = 0.28f;
  // C RHO(770) production
  if (dmax < 0.77f) {
    fm = frho(cmn, dmax);
  } else {
    fm = 1.f;
  }
  if (fm == 0.f) {
    fm = 1.e-06f;
  }
  ntry1 = 0;
statement_10:
  dm = ranart(nseed) * (dmax - dmin) + dmin;
  ntry1++;
  if ((ranart(nseed) > frho(cmn, dm) / fm) && (ntry1 <= 10)) {
    goto statement_10;
  }
  // Clin-2/26/03 limit the rho mass below a certain value
  // C     (here taken as its central value + 2* B-W fullwidth):
  if (dm > 1.07f) {
    goto statement_10;
  }
  // C
  return_value = dm;
  return return_value;
}

struct ddrho_save {
  float amn;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float rhomax;
  float scheck;
  float sig;
  float srt1;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  ddrho_save()
      : amn(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        rhomax(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        srt1(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

// C***************************************
void ddrho(common& cmn, float const& srt, int const& iseed, float& px,
           float& py, float& pz, float& dm1, float& pnx, float& pny, float& pnz,
           float& dm2, float& ppx, float& ppy, float& ppz, float& amp,
           int& icou1) {
  FEM_CMN_SVE(ddrho);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  //
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& rhomax = sve.rhomax;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& srt1 = sve.srt1;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  // C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  // C THE PROCESS N+N--->D1+D2+rho
  // C       DATE : Nov.5, 1994
  // C Generate the masses and momentum for particles in the NN-->DDrho process
  // C for a given center of mass energy srt, the momenta are given in the
  // center C of mass of the NN C**************************************** Cc SAVE
  // /TABLE/ Cc      SAVE /RNDF77/
  icou1 = 0;
  pi = 3.1415926f;
  sve.amn = 938.925f / 1000.f;
  amp = 770.f / 1000.f;
  // C (1) GENGRATE THE MASS OF DELTA1 AND DELTA2 USING
  srt1 = srt - amp - 0.02f;
  ntrym = 0;
statement_8:
  rmasdd(cmn, srt1, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
  ntrym++;
  // C GENERATE THE MASS FOR THE RHO
  rhomax = srt - dm1 - dm2 - 0.02f;
  if (rhomax <= 0 && ntrym <= 20) {
    goto statement_8;
  }
  amp = rhomas(cmn, rhomax, iseed);
  // C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  // C FOR ONE OF THE RESONANCES
  v = 0.43f;
  w = -0.84f;
  // C (2) Generate the transverse momentum
  // C     OF DELTA1
  // C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = ptmax2;
  if (scheck < 0) {
    write(99, star), "scheck24: ", scheck;
    scheck = 0.f;
  }
  ptmax = fem::sqrt(scheck) * 1.f / 3.f;
// C       PTMAX=SQRT(PTMAX2)*1./3.
// C
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  // C (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
  // C     USING THE GIVEN DISTRIBUTION
  // C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-06f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  // C (3.2) THE GENERATED X IS
  // C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  // Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  // C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  // C The x and y components of the delta1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  // C find the momentum of delta2 and rho
  // C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  // C (1) Generate the momentum of the delta2 in the cms of delta2 and rho
  // C     the energy of the cms of Drho
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  // C beta and gamma of the cms of delta2 and rho
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck25: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  // C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  // C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  // C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  // Clin-10/25/02-end
  // C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck26: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  // C       pnz=SIG*SQRT(pn**2-PNT**2)
  // C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  // C (2) the momentum for the rho
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  // C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  // C (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct pprho_save {
  float amn;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int icou;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float rhomax;
  float scheck;
  float sig;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  pprho_save()
      : amn(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        icou(fem::int0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        rhomax(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

// C***************************************
void pprho(common& cmn, float const& srt, int const& iseed, float& px,
           float& py, float& pz, float& dm1, float& pnx, float& pny, float& pnz,
           float& dm2, float& ppx, float& ppy, float& ppz, float& amp,
           int& icou1) {
  FEM_CMN_SVE(pprho);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  //
  float& amn = sve.amn;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& rhomax = sve.rhomax;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  // C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  // C THE PROCESS N+N--->N1+N2+rho
  // C       DATE : Nov.5, 1994
  // C Generate the masses and momentum for particles in the NN--> process
  // C for a given center of mass energy srt, the momenta are given in the
  // center C of mass of the NN C**************************************** Cc SAVE
  // /TABLE/ Cc      SAVE /RNDF77/
  ntrym = 0;
  icou1 = 0;
  pi = 3.1415926f;
  amn = 938.925f / 1000.f;
  // C        AMP=770./1000.
  dm1 = amn;
  dm2 = amn;
  // C GENERATE THE MASS FOR THE RHO
  rhomax = srt - dm1 - dm2 - 0.02f;
  if (rhomax <= 0) {
    sve.icou = -1;
    return;
  }
  amp = rhomas(cmn, rhomax, iseed);
  // C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  // C FOR ONE OF THE nucleons
  v = 0.43f;
  w = -0.84f;
  // C (2) Generate the transverse momentum
  // C     OF p1
  // C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = ptmax2;
  if (scheck < 0) {
    write(99, star), "scheck27: ", scheck;
    scheck = 0.f;
  }
  ptmax = fem::sqrt(scheck) * 1.f / 3.f;
// C       PTMAX=SQRT(PTMAX2)*1./3.
// C
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  // C (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
  // C     USING THE GIVEN DISTRIBUTION
  // C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  ntrym++;
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-06f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  // C (3.2) THE GENERATED X IS
  // C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  // Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  // C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  // C The x and y components of the delta1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  // C find the momentum of delta2 and rho
  // C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  // C (1) Generate the momentum of the delta2 in the cms of delta2 and rho
  // C     the energy of the cms of Drho
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  // C beta and gamma of the cms of the two partciles
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck28: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  // C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  // C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  // C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  // Clin-10/25/02-end
  // C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck29: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  // C       pnz=SIG*SQRT(pn**2-PNT**2)
  // C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  // C (2) the momentum for the rho
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  // C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  // C (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct ppomga_save {
  float amn;
  float amp;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float scheck;
  float sig;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  ppomga_save()
      : amn(fem::float0),
        amp(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

// C**************************8
// C***************************************
void ppomga(common& cmn, float const& srt, int const& iseed, float& px,
            float& py, float& pz, float& dm1, float& pnx, float& pny,
            float& pnz, float& dm2, float& ppx, float& ppy, float& ppz,
            int& icou1) {
  FEM_CMN_SVE(ppomga);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  //
  float& amn = sve.amn;
  float& amp = sve.amp;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  // C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  // C THE PROCESS N+N--->N1+N2+OMEGA
  // C       DATE : Nov.5, 1994
  // C Generate the masses and momentum for particles in the NN--> process
  // C for a given center of mass energy srt, the momenta are given in the
  // center C of mass of the NN C**************************************** Cc SAVE
  // /TABLE/ Cc      SAVE /RNDF77/
  ntrym = 0;
  icou1 = 0;
  pi = 3.1415926f;
  amn = 938.925f / 1000.f;
  amp = 782.f / 1000.f;
  dm1 = amn;
  dm2 = amn;
  // C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  // C FOR ONE OF THE nucleons
  v = 0.43f;
  w = -0.84f;
  // C (2) Generate the transverse momentum
  // C     OF p1
  // C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = ptmax2;
  if (scheck < 0) {
    write(99, star), "scheck30: ", scheck;
    scheck = 0.f;
  }
  ptmax = fem::sqrt(scheck) * 1.f / 3.f;
// C       PTMAX=SQRT(PTMAX2)*1./3.
// C
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  // C (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
  // C     USING THE GIVEN DISTRIBUTION
  // C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  ntrym++;
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-09f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  // C (3.2) THE GENERATED X IS
  // C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  // Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  // C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  // C The x and y components of the delta1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  // C find the momentum of delta2 and rho
  // C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  // C (1) Generate the momentum of the delta2 in the cms of delta2 and rho
  // C     the energy of the cms of Drho
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck31: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  // C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  // C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  // C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  // Clin-10/25/02-end
  // C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck32: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  // C       pnz=SIG*SQRT(pn**2-PNT**2)
  // C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  // C (2) the momentum for the rho
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  // C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  // C (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct x2pi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  x2pi_save()
      : earray(dimension(15), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(15), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for pp-->pp+2pi
// C      real*4 function X2pi(srt)
float x2pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x2pi);
  // SAVE
  arr_ref<float> earray(sve.earray, dimension(15));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(15));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {2.23f, 2.81f, 3.67f,  4.0f,  4.95f,
                                     5.52f, 5.97f, 6.04f,  6.6f,  6.9f,
                                     7.87f, 8.11f, 10.01f, 16.0f, 19.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {1.22f, 2.51f, 2.67f, 2.95f, 2.96f,
                                     2.84f, 2.8f,  3.2f,  2.7f,  3.0f,
                                     2.54f, 2.46f, 2.4f,  1.66f, 1.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  // C  This function contains the experimental
  // C     total pp-pp+pi(+)pi(-) Xsections    *
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton momentum in GeV/c * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye)* C *
  // C*****************************************
  // C      real*4   xarray(15), earray(15)
  // C
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0.000001f;
  if (srt <= 2.2f) {
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 15) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct x3pi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  x3pi_save()
      : earray(dimension(12), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(12), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for pp-->pn+pi(+)pi(+)pi(-)
// C      real*4 function X3pi(srt)
float x3pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x3pi);
  // SAVE
  arr_ref<float> earray(sve.earray, dimension(12));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(12));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {0.02f, 0.4f,  1.15f, 1.60f, 2.19f, 2.85f,
                                     2.30f, 3.10f, 2.47f, 2.60f, 2.40f, 1.70f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {2.23f, 2.81f, 3.67f, 4.00f, 4.95f,  5.52f,
                                     5.97f, 6.04f, 6.60f, 6.90f, 10.01f, 19.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  This function contains the experimental pp->pp+3pi cross sections * C
  // srt    = DSQRT(s) in GeV                                                   *
  // C  xsec   = production cross section in mb * C  earray = EXPerimental table
  // with proton energies in MeV                    * C  xarray = EXPerimental
  // table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  // C      real*4   xarray(12), earray(12)
  // C
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 1.e-06f;
  if (srt <= 2.3f) {
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 12) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct x33pi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  x33pi_save()
      : earray(dimension(12), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(12), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for pp-->pp+pi(+)pi(-)pi(0)
// C      real*4 function X33pi(srt)
float x33pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x33pi);
  // SAVE
  arr_ref<float> earray(sve.earray, dimension(12));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(12));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {0.02f, 0.22f, 0.74f, 1.10f, 1.76f, 1.84f,
                                     2.20f, 2.40f, 2.15f, 2.60f, 2.30f, 1.70f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {2.23f, 2.81f, 3.67f, 4.00f, 4.95f,  5.52f,
                                     5.97f, 6.04f, 6.60f, 6.90f, 10.01f, 19.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  This function contains the experimental pp->pp+3pi cross sections * C
  // srt    = DSQRT(s) in GeV                                                   *
  // C  xsec   = production cross section in mb * C  earray = EXPerimental table
  // with proton energies in MeV                    * C  xarray = EXPerimental
  // table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  // C      real*4   xarray(12), earray(12)
  // C
  pmass = 0.9383f;
  return_value = 1.e-06f;
  if (srt <= 2.3f) {
    return return_value;
  }
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 12) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct pp1_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float plab2;
  float pmass;
  float pmax;
  float pmin;

  pp1_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        plab2(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0) {}
};

// C*****************************************
// C for pp-->inelastic
// C      real*4 function pp1(srt)
float pp1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pp1);
  // SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& plab = sve.plab;
  float& plab2 = sve.plab2;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  //
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  pmass = 0.9383f;
  return_value = 0.f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab2 =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (plab2 <= 0) {
    return return_value;
  }
  plab = fem::sqrt(plab2);
  pmin = 0.968f;
  pmax = 2080;
  if ((plab < pmin) || (plab > pmax)) {
    return_value = 0.f;
    return return_value;
  }
  // C* fit parameters
  a = 30.9f;
  b = -28.9f;
  c = 0.192f;
  sve.d = -0.835f;
  an = -2.46f;
  return_value =
      a + b * (fem::pow(plab, an)) + c * fem::pow2((fem::alog(plab)));
  if (return_value <= 0) {
    return_value = 0.0f;
  }
  return return_value;
}

struct s1535_save {
  float s0;

  s1535_save() : s0(fem::float0) {}
};

// C
// C************************
// C cross section for N*(1535) production in PP collisions
// C VARIABLES:
// C LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
// C SRT IS THE CMS ENERGY
// C X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
// C NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA
// C PRODUCTION CROSS SECTION
// C DATE: Aug. 1 , 1994
// C ********************************
float s1535(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(s1535);
  // SAVE
  float& s0 = sve.s0;
  //
  s0 = 2.424f;
  return_value = 0.f;
  if (srt <= s0) {
    return return_value;
  }
  return_value = 2.f * 0.102f * (srt - s0) / (0.058f + fem::pow2((srt - s0)));
  return return_value;
}

struct pplpk_save {
  float a;
  float an;
  float b;
  float c;
  float plab;
  float pmass;
  float pmax;
  float pmin;
  float scheck;

  pplpk_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0),
        scheck(fem::float0) {}
};

// C*********************************
// C elementary kaon production cross sections
// C  from the CERN data book
// C  date: Sept.2, 1994
// C  for pp-->pLK+
// C      real*4 function pplpk(srt)
float pplpk(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pplpk);
  common_write write(cmn);
  // SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  float& scheck = sve.scheck;
  //
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C   find the center of mass energy corresponding to the given pm as
  // C   if Lambda+N+K are produced
  return_value = 0.f;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (scheck < 0) {
    write(99, star), "scheck35: ", scheck;
    scheck = 0.f;
  }
  plab = fem::sqrt(scheck);
  // C        plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
  // C
  pmin = 2.82f;
  pmax = 25.0f;
  if (plab > pmax) {
    return_value = 0.036f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 0.f;
    return return_value;
  }
  // C* fit parameters
  a = 0.0654f;
  b = -3.16f;
  c = -0.0029f;
  an = -4.14f;
  return_value =
      a + b * (fem::pow(plab, an)) + c * fem::pow2((fem::alog(plab)));
  if (return_value <= 0) {
    return_value = 0;
  }
  return return_value;
}

struct ppk0_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  ppk0_save()
      : earray(dimension(7), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(7), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C
// C*****************************************
// C for pp-->pSigma+K0
// C      real*4 function ppk0(srt)
float ppk0(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppk0);
  arr_ref<float> earray(sve.earray, dimension(7));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(7));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {0.030f, 0.025f, 0.025f, 0.026f,
                                     0.02f,  0.014f, 0.06f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {3.67f, 4.95f, 5.52f, 6.05f,
                                     6.92f, 7.87f, 10.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C * C***************************************** C      real*4   xarray(7),
  // earray(7)
  // C
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0;
  if (srt <= 2.63f) {
    return return_value;
  }
  if (srt > 4.54f) {
    return_value = 0.037f;
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 7) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      goto statement_10;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      goto statement_10;
    }
  }
statement_10:
  return return_value;
}

struct ppk1_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  ppk1_save()
      : earray(dimension(7), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(7), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for pp-->pSigma0K+
// C      real*4 function ppk1(srt)
float ppk1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppk1);
  arr_ref<float> earray(sve.earray, dimension(7));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(7));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {0.013f, 0.025f, 0.016f, 0.012f,
                                     0.017f, 0.029f, 0.025f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {3.67f, 4.95f, 5.52f, 5.97f,
                                     6.05f, 6.92f, 7.87f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C * C***************************************** C      real*4   xarray(7),
  // earray(7)
  // C
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0.f;
  if (srt <= 2.63f) {
    return return_value;
  }
  if (srt > 4.08f) {
    return_value = 0.025f;
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 7) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      goto statement_10;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      goto statement_10;
    }
  }
statement_10:
  return return_value;
}

struct x4pi_save {
  float ada;
  float ak0;
  float akp;
  float al;
  float ana;
  float as;
  float es;
  float pmass;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnlk;
  float pmnlk2;
  float pmnsk;
  float pmnsk2;
  float pps1;
  float pps2;
  float ppsngl;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2dlk;
  float t2dsk;
  float t2nlk;
  float t2nsk;
  float xk1;
  float xk2;
  float xk3;
  float xk4;
  float xkaon;
  float xpp2pi;
  float xpp3pi;

  x4pi_save()
      : ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        es(fem::float0),
        pmass(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnlk(fem::float0),
        pmnlk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        pps1(fem::float0),
        pps2(fem::float0),
        ppsngl(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nlk(fem::float0),
        t2nsk(fem::float0),
        xk1(fem::float0),
        xk2(fem::float0),
        xk3(fem::float0),
        xk4(fem::float0),
        xkaon(fem::float0),
        xpp2pi(fem::float0),
        xpp3pi(fem::float0) {}
};

// C*****************************************
// C       REAL*4 FUNCTION X4pi(SRT)
float x4pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x4pi);
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& es = sve.es;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnlk2 = sve.pmnlk2;
  float& pmnsk2 = sve.pmnsk2;
  float& pps1 = sve.pps1;
  float& pps2 = sve.pps2;
  float& ppsngl = sve.ppsngl;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nlk = sve.t2nlk;
  float& t2nsk = sve.t2nsk;
  float& xk1 = sve.xk1;
  float& xk2 = sve.xk2;
  float& xk3 = sve.xk3;
  float& xk4 = sve.xk4;
  float& xkaon = sve.xkaon;
  float& xpp2pi = sve.xpp2pi;
  float& xpp3pi = sve.xpp3pi;
  // C       CROSS SECTION FOR NN-->DD+rho PROCESS
  // C *****************************
  akp = 0.498f;
  sve.ak0 = 0.498f;
  ana = 0.94f;
  ada = 1.232f;
  al = 1.1157f;
  as = 1.1197f;
  sve.pmass = 0.9383f;
  es = srt;
  if (es <= 4) {
    return_value = 0.f;
  } else {
    // C cross section for two resonance pp-->DD+DN*+N*N*
    xpp2pi = 4.f * x2pi(cmn, es);
    // C cross section for pp-->pp+spi
    xpp3pi = 3.f * (x3pi(cmn, es) + x33pi(cmn, es));
    // C cross section for pp-->pD+ and nD++
    pps1 = sigma(cmn, es, 1, 1, 0) + 0.5f * sigma(cmn, es, 1, 1, 1);
    pps2 = 1.5f * sigma(cmn, es, 1, 1, 1);
    ppsngl = pps1 + pps2 + s1535(cmn, es);
    // C CROSS SECTION FOR KAON PRODUCTION from the four channels
    // C for NLK channel
    xk1 = 0;
    xk2 = 0;
    xk3 = 0;
    xk4 = 0;
    t1nlk = ana + al + akp;
    t2nlk = ana + al - akp;
    if (es <= t1nlk) {
      goto statement_333;
    }
    pmnlk2 = (fem::pow2(es) - fem::pow2(t1nlk)) *
             (fem::pow2(es) - fem::pow2(t2nlk)) / (4.f * fem::pow2(es));
    sve.pmnlk = fem::sqrt(pmnlk2);
    xk1 = pplpk(cmn, es);
    // C for DLK channel
    t1dlk = ada + al + akp;
    t2dlk = ada + al - akp;
    if (es <= t1dlk) {
      goto statement_333;
    }
    pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
             (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
    sve.pmdlk = fem::sqrt(pmdlk2);
    xk3 = pplpk(cmn, es);
    // C for NSK channel
    t1nsk = ana + as + akp;
    t2nsk = ana + as - akp;
    if (es <= t1nsk) {
      goto statement_333;
    }
    pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
             (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
    sve.pmnsk = fem::sqrt(pmnsk2);
    xk2 = ppk1(cmn, es) + ppk0(cmn, es);
    // C for DSK channel
    t1dsk = ada + as + akp;
    t2dsk = ada + as - akp;
    if (es <= t1dsk) {
      goto statement_333;
    }
    pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
             (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
    sve.pmdsk = fem::sqrt(pmdsk2);
    xk4 = ppk1(cmn, es) + ppk0(cmn, es);
  // C THE TOTAL KAON+ AND KAON0 PRODUCTION CROSS SECTION IS THEN
  statement_333:
    xkaon = 3.f * (xk1 + xk2 + xk3 + xk4);
    // C cross section for pp-->DD+rho
    return_value = pp1(cmn, es) - ppsngl - xpp2pi - xpp3pi - xkaon;
    if (return_value <= 0) {
      return_value = 1.e-06f;
    }
  }
  return return_value;
}

struct fkaon_save {
  float fmax;

  fkaon_save() : fmax(fem::float0) {}
};

// C
// C*******************************
// C
// C       Kaon momentum distribution in baryon-baryon-->N lamda K process
// C
// C       NOTE: dsima/dp is prototional to (1-p/p_max)(p/p_max)^2
// C              we use rejection method to generate kaon momentum
// C
// C       Variables: Fkaon = F(p)/F_max
// C                 srt   = cms energy of the colliding pair,
// C                          used to calculate the P_max
// C       Date: Feb. 8, 1994
// C
// C       Reference: C. M. Ko et al.
// C*******************************
float fkaon(common& cmn, float const& p, float& pmax) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fkaon);
  // SAVE
  float& fmax = sve.fmax;
  //
  fmax = 0.148f;
  if (pmax == 0.f) {
    pmax = 0.000001f;
  }
  return_value = (1.f - p / pmax) * fem::pow2((p / pmax));
  if (return_value > fmax) {
    return_value = fmax;
  }
  return_value = return_value / fmax;
  return return_value;
}

struct fdelta_save {
  float am0;
  float amn;
  float avpi;
  float fd;

  fdelta_save()
      : am0(fem::float0),
        amn(fem::float0),
        avpi(fem::float0),
        fd(fem::float0) {}
};

// C**************************8
// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
// CKITAZOE'S FORMULA
float fdelta(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fdelta);
  // SAVE
  float& fd = sve.fd;
  //
  sve.amn = 0.938869f;
  sve.avpi = 0.13803333f;
  sve.am0 = 1.232f;
  fd = 0.25f * fem::pow2(width(cmn, dmass)) /
       (fem::pow2((dmass - 1.232f)) + 0.25f * fem::pow2(width(cmn, dmass)));
  return_value = fd;
  return return_value;
}

struct rmass_save {
  float dm;
  float dmin;
  float fm;
  int ntry1;

  rmass_save()
      : dm(fem::float0), dmin(fem::float0), fm(fem::float0), ntry1(fem::int0) {}
};

// C**************************8
// C   DELTA MASS GENERATOR
float rmass(common& cmn, float const& dmax, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rmass);
  int& nseed = cmn.nseed;
  //
  float& dm = sve.dm;
  float& dmin = sve.dmin;
  float& fm = sve.fm;
  int& ntry1 = sve.ntry1;
  // Cc      SAVE /RNDF77/
  // C THE MINIMUM MASS FOR DELTA
  dmin = 1.078f;
  // C Delta(1232) production
  if (dmax < 1.232f) {
    fm = fdelta(cmn, dmax);
  } else {
    fm = 1.f;
  }
  if (fm == 0.f) {
    fm = 1.e-06f;
  }
  ntry1 = 0;
statement_10:
  dm = ranart(nseed) * (dmax - dmin) + dmin;
  ntry1++;
  if ((ranart(nseed) > fdelta(cmn, dm) / fm) && (ntry1 <= 10)) {
    goto statement_10;
  }
  // Clin-2/26/03 sometimes Delta mass can reach very high values (e.g. 15.GeV),
  // C     thus violating the thresh of the collision which produces it
  // C     and leads to large violation of energy conservation.
  // C     To limit the above, limit the Delta mass below a certain value
  // C     (here taken as its central value + 2* B-W fullwidth):
  if (dm > 1.47f) {
    goto statement_10;
  }
  // C
  return_value = dm;
  return return_value;
}

struct bbkaon_save {
  float aka;
  float bx;
  float by;
  float bz;
  float cs;
  float csn;
  float dm1;
  float dmax;
  float ek;
  float el;
  float eln;
  float elnc;
  float en;
  float fai;
  float fain;
  float ga;
  int ntry;
  float pbeta;
  float pi;
  float pk;
  float pmax;
  float pn;
  float pn2;
  float prob;
  float scheck;
  float ss;
  float ssn;
  float t1;
  float t2;
  float trans0;

  bbkaon_save()
      : aka(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        cs(fem::float0),
        csn(fem::float0),
        dm1(fem::float0),
        dmax(fem::float0),
        ek(fem::float0),
        el(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        ga(fem::float0),
        ntry(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pk(fem::float0),
        pmax(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        prob(fem::float0),
        scheck(fem::float0),
        ss(fem::float0),
        ssn(fem::float0),
        t1(fem::float0),
        t2(fem::float0),
        trans0(fem::float0) {}
};

// Csp11/21/01 end
// C*********************************
void bbkaon(common& cmn, int const& ic, float const& srt, float& px, float& py,
            float& pz, float& ana, float& plx, float& ply, float& plz,
            float& ala, float& pkx, float& pky, float& pkz, int& icou1) {
  FEM_CMN_SVE(bbkaon);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  //
  float& aka = sve.aka;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& cs = sve.cs;
  float& csn = sve.csn;
  float& dm1 = sve.dm1;
  float& dmax = sve.dmax;
  float& ek = sve.ek;
  float& el = sve.el;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& ga = sve.ga;
  int& ntry = sve.ntry;
  float& pbeta = sve.pbeta;
  float& pk = sve.pk;
  float& pmax = sve.pmax;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& prob = sve.prob;
  float& scheck = sve.scheck;
  float& ss = sve.ss;
  float& ssn = sve.ssn;
  float& t1 = sve.t1;
  float& t2 = sve.t2;
  float& trans0 = sve.trans0;
  // C purpose: generate the momenta for kaon,lambda/sigma and nucleon/delta
  // C          in the BB-->nlk process
  // C date: Sept. 9, 1994
  // C
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  sve.pi = 3.1415962f;
  icou1 = 0;
  aka = 0.498f;
  ala = 1.116f;
  if (ic == 2 || ic == 4) {
    ala = 1.197f;
  }
  ana = 0.939f;
  // C generate the mass of the delta
  if (ic > 2) {
    dmax = srt - aka - ala - 0.02f;
    dm1 = rmass(cmn, dmax, cmn.iseed);
    ana = dm1;
  }
  t1 = aka + ana + ala;
  t2 = ana + ala - aka;
  if (srt <= t1) {
    icou1 = -1;
    return;
  }
  pmax = fem::sqrt((fem::pow2(srt) - fem::pow2(t1)) *
                   (fem::pow2(srt) - fem::pow2(t2))) /
         (2.f * srt);
  if (pmax == 0.f) {
    pmax = 1.e-09f;
  }
  // C (1) Generate the momentum of the kaon according to the distribution Fkaon
  // C     and assume that the angular distribution is isotropic
  // C     in the cms of the colliding pair
  ntry = 0;
statement_1:
  pk = pmax * ranart(nseed);
  ntry++;
  prob = fkaon(cmn, pk, pmax);
  if ((prob < ranart(nseed)) && (ntry <= 40)) {
    goto statement_1;
  }
  cs = 1.f - 2.f * ranart(nseed);
  ss = fem::sqrt(1.f - fem::pow2(cs));
  fai = 2.f * 3.14f * ranart(nseed);
  pkx = pk * ss * fem::cos(fai);
  pky = pk * ss * fem::sin(fai);
  pkz = pk * cs;
  // C the energy of the kaon
  ek = fem::sqrt(fem::pow2(aka) + fem::pow2(pk));
  // C (2) Generate the momentum of the nucleon/delta in the cms of N/delta
  // C     and lamda/sigma
  // C  the energy of the cms of NL
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  // C beta and gamma of the cms of L/S+N
  bx = -pkx / eln;
  by = -pky / eln;
  bz = -pkz / eln;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck44: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  // C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  // C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(ana) - fem::pow2(ala)) /
                   (2.f * elnc))) -
        fem::pow2(ana);
  if (pn2 <= 0.f) {
    pn2 = 1.e-09f;
  }
  pn = fem::sqrt(pn2);
  csn = 1.f - 2.f * ranart(nseed);
  ssn = fem::sqrt(1.f - fem::pow2(csn));
  fain = 2.f * 3.14f * ranart(nseed);
  px = pn * ssn * fem::cos(fain);
  py = pn * ssn * fem::sin(fain);
  pz = pn * csn;
  en = fem::sqrt(fem::pow2(ana) + pn2);
  // C the momentum of the lambda/sigma in the n-l cms frame is
  plx = -px;
  ply = -py;
  plz = -pz;
  // C (3) LORENTZ-TRANSFORMATION INTO nn cms FRAME for the neutron/delta
  pbeta = px * bx + py * by + pz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  px += bx * trans0;
  py += by * trans0;
  pz += bz * trans0;
  // C (4) Lorentz-transformation for the lambda/sigma
  el = fem::sqrt(fem::pow2(ala) + fem::pow2(plx) + fem::pow2(ply) +
                 fem::pow2(plz));
  pbeta = plx * bx + ply * by + plz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + el);
  plx += bx * trans0;
  ply += by * trans0;
  plz += bz * trans0;
}

struct xrho_save {
  float es;
  float esmin;
  float pmass;
  float rmass;
  float trho;
  float xrho0;

  xrho_save()
      : es(fem::float0),
        esmin(fem::float0),
        pmass(fem::float0),
        rmass(fem::float0),
        trho(fem::float0),
        xrho0(fem::float0) {}
};

// C *****************************
// C       real*4 function xrho(srt)
float xrho(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xrho);
  // SAVE
  float& es = sve.es;
  float& esmin = sve.esmin;
  float& rmass = sve.rmass;
  float& trho = sve.trho;
  float& xrho0 = sve.xrho0;
  //
  // C       xsection for pp-->pp+rho
  // C *****************************
  sve.pmass = 0.9383f;
  rmass = 0.77f;
  trho = 0.151f;
  return_value = 0.000000001f;
  if (srt <= 2.67f) {
    return return_value;
  }
  esmin = 2.f * 0.9383f + rmass - trho / 2.f;
  es = srt;
  // C the cross section for tho0 production is
  xrho0 = 0.24f * (es - esmin) / (1.4f + fem::pow2((es - esmin)));
  return_value = 3.f * xrho0;
  return return_value;
}

struct omega_save {
  float es;
  float esmin;
  float omass;
  float pmass;
  float tomega;

  omega_save()
      : es(fem::float0),
        esmin(fem::float0),
        omass(fem::float0),
        pmass(fem::float0),
        tomega(fem::float0) {}
};

// C *****************************
// C       real*4 function omega(srt)
float omega(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(omega);
  // SAVE
  float& es = sve.es;
  float& esmin = sve.esmin;
  float& omass = sve.omass;
  float& tomega = sve.tomega;
  //
  // C       xsection for pp-->pp+omega
  // C *****************************
  sve.pmass = 0.9383f;
  omass = 0.782f;
  tomega = 0.0084f;
  return_value = 0.00000001f;
  if (srt <= 2.68f) {
    return return_value;
  }
  esmin = 2.f * 0.9383f + omass - tomega / 2.f;
  es = srt;
  return_value = 0.36f * (es - esmin) / (1.25f + fem::pow2((es - esmin)));
  return return_value;
}

struct rotate_save {
  float c1;
  float c2;
  float ct1;
  float ct2;
  float pr;
  float pr0;
  float s1;
  float s2;
  float scheck;
  float ss;
  float st1;
  float st2;
  float t1;
  float t2;

  rotate_save()
      : c1(fem::float0),
        c2(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        pr(fem::float0),
        pr0(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        scheck(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t2(fem::float0) {}
};

// C**************************************
void rotate(common& cmn, float const& px0, float const& py0, float const& pz0,
            float& px, float& py, float& pz) {
  FEM_CMN_SVE(rotate);
  common_write write(cmn);
  // SAVE
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& pr = sve.pr;
  float& pr0 = sve.pr0;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& scheck = sve.scheck;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t2 = sve.t2;
  //
  // C purpose: rotate the momentum of a particle in the CMS of p1+p2 such that
  // C the x' y' and z' in the cms of p1+p2 is the same as the fixed x y and z
  // C quantities:
  // C            px0,py0 and pz0 are the cms momentum of the incoming colliding
  // C            particles
  // C            px, py and pz are the cms momentum of any one of the particles
  // C            after the collision to be rotated
  // C**************************************
  // C the momentum, polar and azimuthal angles of the incoming momentm
  pr0 = fem::sqrt(fem::pow2(px0) + fem::pow2(py0) + fem::pow2(pz0));
  if (pr0 == 0) {
    pr0 = 0.00000001f;
  }
  c2 = pz0 / pr0;
  if (px0 == 0.0f && py0 == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py0, px0);
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck45: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  // C      S2  =  SQRT( 1.0 - C2**2 )
  // C
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  // C the momentum, polar and azimuthal angles of the momentum to be rotated
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  if (pr == 0) {
    pr = 0.0000001f;
  }
  c1 = pz / pr;
  if (px == 0 && py == 0) {
    t1 = 0.f;
  } else {
    t1 = fem::atan2(py, px);
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c1);
  if (scheck < 0) {
    write(99, star), "scheck46: ", scheck;
    scheck = 0.f;
  }
  s1 = fem::sqrt(scheck);
  // C      S1   = SQRT( 1.0 - C1**2 )
  // C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ss = c2 * s1 * ct1 + s2 * c1;
  // C THE MOMENTUM AFTER ROTATION
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
}

// C
// C     Part of the cross section function of NN->Deuteron+Pi (in mb):
float fnndpi(float const& s) {
  float return_value = fem::float0;
  const float srt0 = 2.012f;
  if (s <= fem::pow2(srt0)) {
    return_value = 0.f;
  } else {
    return_value = 26.f * fem::exp(-fem::pow2((s - 4.65f)) / 0.1f) +
                   4.f * fem::exp(-fem::pow2((s - 4.65f)) / 2.f) +
                   0.28f * fem::exp(-fem::pow2((s - 6.f)) / 10.f);
  }
  return return_value;
}

struct sbbdm_save {
  float fs;
  int ilb1;
  int ilb2;
  float pifactor;
  float pinitial;
  float s;
  float sbbdeta;
  float sbbdomega;
  float sbbdpi;
  float sbbdrho;
  float scheck;
  float snew;
  float threshold;
  float x1;

  sbbdm_save()
      : fs(fem::float0),
        ilb1(fem::int0),
        ilb2(fem::int0),
        pifactor(fem::float0),
        pinitial(fem::float0),
        s(fem::float0),
        sbbdeta(fem::float0),
        sbbdomega(fem::float0),
        sbbdpi(fem::float0),
        sbbdrho(fem::float0),
        scheck(fem::float0),
        snew(fem::float0),
        threshold(fem::float0),
        x1(fem::float0) {}
};

// C---------------------------------------------------------------------------
// C
// Clin-8/2008 B+B->Deuteron+Meson cross section in mb:
void sbbdm(common& cmn, float const& srt, float& sdprod, int const& ianti,
           int& lbm, float& xmm, float& pfinal) {
  FEM_CMN_SVE(sbbdm);
  common_write write(cmn);
  // COMMON leadng
  float& em1 = cmn.em1;
  // COMMON dpi
  float& em2 = cmn.em2;
  // COMMON para8
  int& idxsec = cmn.idxsec;
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& fs = sve.fs;
  int& ilb1 = sve.ilb1;
  int& ilb2 = sve.ilb2;
  float& pifactor = sve.pifactor;
  float& pinitial = sve.pinitial;
  float& s = sve.s;
  float& sbbdeta = sve.sbbdeta;
  float& sbbdomega = sve.sbbdomega;
  float& sbbdpi = sve.sbbdpi;
  float& sbbdrho = sve.sbbdrho;
  float& scheck = sve.scheck;
  float& snew = sve.snew;
  float& threshold = sve.threshold;
  float& x1 = sve.x1;
  //
  // C
  sdprod = 0.f;
  sbbdpi = 0.f;
  sbbdrho = 0.f;
  sbbdomega = 0.f;
  sbbdeta = 0.f;
  if (srt <= (em1 + em2)) {
    return;
  }
  // C
  ilb1 = fem::iabs(cmn.lb1);
  ilb2 = fem::iabs(cmn.lb2);
  // Ctest off check Xsec using fixed mass for resonances:
  // C      if(ilb1.ge.6.and.ilb1.le.9) then
  // C         em1=1.232
  // C      elseif(ilb1.ge.10.and.ilb1.le.11) then
  // C         em1=1.44
  // C      elseif(ilb1.ge.12.and.ilb1.le.13) then
  // C         em1=1.535
  // C      endif
  // C      if(ilb2.ge.6.and.ilb2.le.9) then
  // C         em2=1.232
  // C      elseif(ilb2.ge.10.and.ilb2.le.11) then
  // C         em2=1.44
  // C      elseif(ilb2.ge.12.and.ilb2.le.13) then
  // C         em2=1.535
  // C      endif
  // C
  s = fem::pow2(srt);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
  if (scheck <= 0) {
    write(99, star), "scheck50: ", scheck;
    FEM_STOP(0);
  }
  pinitial = fem::sqrt(scheck) / 2.f / srt;
  // C      pinitial=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
  // C
  fs = fnndpi(s);
  // C     Determine isospin and spin factors for the ratio between
  // C     BB->Deuteron+Meson and Deuteron+Meson->BB cross sections:
  if (idxsec == 1 || idxsec == 2) {
    // C     Assume B+B -> d+Meson has the same cross sections as N+N -> d+pi:
  } else {
    // C     Assume d+Meson -> B+B has the same cross sections as d+pi -> N+N,
    // C     then determine B+B -> d+Meson cross sections:
    if (ilb1 >= 1 && ilb1 <= 2 && ilb2 >= 1 && ilb2 <= 2) {
      pifactor = 9.f / 8.f;
    } else if ((ilb1 >= 1 && ilb1 <= 2 && ilb2 >= 6 && ilb2 <= 9) ||
               (ilb2 >= 1 && ilb2 <= 2 && ilb1 >= 6 && ilb1 <= 9)) {
      pifactor = 9.f / 64.f;
    } else if ((ilb1 >= 1 && ilb1 <= 2 && ilb2 >= 10 && ilb2 <= 13) ||
               (ilb2 >= 1 && ilb2 <= 2 && ilb1 >= 10 && ilb1 <= 13)) {
      pifactor = 9.f / 16.f;
    } else if (ilb1 >= 6 && ilb1 <= 9 && ilb2 >= 6 && ilb2 <= 9) {
      pifactor = 9.f / 128.f;
    } else if ((ilb1 >= 6 && ilb1 <= 9 && ilb2 >= 10 && ilb2 <= 13) ||
               (ilb2 >= 6 && ilb2 <= 9 && ilb1 >= 10 && ilb1 <= 13)) {
      pifactor = 9.f / 64.f;
    } else if ((ilb1 >= 10 && ilb1 <= 11 && ilb2 >= 10 && ilb2 <= 11) ||
               (ilb2 >= 12 && ilb2 <= 13 && ilb1 >= 12 && ilb1 <= 13)) {
      pifactor = 9.f / 8.f;
    } else if ((ilb1 >= 10 && ilb1 <= 11 && ilb2 >= 12 && ilb2 <= 13) ||
               (ilb2 >= 10 && ilb2 <= 11 && ilb1 >= 12 && ilb1 <= 13)) {
      pifactor = 9.f / 16.f;
    }
  }
  // C     d pi: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  // C     (1) FOR P+P->Deuteron+pi+:
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((ilb1 * ilb2) == 1) {
    lbm = 5;
    if (ianti == 1) {
      lbm = 3;
    }
    xmm = ap2;
    // C     (2)FOR N+N->Deuteron+pi-:
  } else if (ilb1 == 2 && ilb2 == 2) {
    lbm = 3;
    if (ianti == 1) {
      lbm = 5;
    }
    xmm = ap2;
    // C     (3)FOR N+P->Deuteron+pi0:
  } else if ((ilb1 * ilb2) == 2) {
    lbm = 4;
    xmm = ap1;
  } else {
    // C     For baryon resonances, use isospin-averaged cross sections:
    lbm = 3 + fem::fint(3 * ranart(nseed));
    if (lbm == 4) {
      xmm = ap1;
    } else {
      xmm = ap2;
    }
  }
  // C
  const float xmd = 1.8756f;
  const float srt0 = 2.012f;
  if (srt >= (xmd + xmm)) {
    pfinal =
        fem::sqrt((s - fem::pow2((xmd + xmm))) * (s - fem::pow2((xmd - xmm)))) /
        2.f / srt;
    if ((ilb1 == 1 && ilb2 == 1) || (ilb1 == 2 && ilb2 == 2)) {
      // C     for pp or nn initial states:
      sbbdpi = fs * pfinal / pinitial / 4.f;
    } else if ((ilb1 == 1 && ilb2 == 2) || (ilb1 == 2 && ilb2 == 1)) {
      // C     factor of 1/2 for pn or np initial states:
      sbbdpi = fs * pfinal / pinitial / 4.f / 2.f;
    } else {
      // C     for other BB initial states (spin- and isospin averaged):
      if (idxsec == 1) {
        // C     1: assume the same |matrix element|**2/s (after averaging over
        // initial C     spins and isospins) for B+B -> deuteron+meson at the
        // same sqrt(s);
        sbbdpi = fs * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 2 || idxsec == 4) {
        threshold = fem::amax1(xmd + xmm, em1 + em2);
        snew = fem::pow2((srt - threshold + srt0));
        if (idxsec == 2) {
          // C     2: assume the same |matrix element|**2/s for B+B ->
          // deuteron+meson C     at the same sqrt(s)-threshold:
          sbbdpi = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
        } else if (idxsec == 4) {
          // C     4: assume the same |matrix element|**2/s for B+B <-
          // deuteron+meson C     at the same sqrt(s)-threshold:
          sbbdpi = fnndpi(snew) * pfinal / pinitial / 6.f * pifactor;
        }
      } else if (idxsec == 3) {
        // C     3: assume the same |matrix element|**2/s for B+B <-
        // deuteron+meson C     at the same sqrt(s):
        sbbdpi = fs * pfinal / pinitial / 6.f * pifactor;
      }
      // C
    }
  }
  // C
  // C     d rho: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
  const float xmrho = 0.770f;
  if (srt > (xmd + xmrho)) {
    pfinal = fem::sqrt((s - fem::pow2((xmd + xmrho))) *
                       (s - fem::pow2((xmd - xmrho)))) /
             2.f / srt;
    if (idxsec == 1) {
      sbbdrho = fs * pfinal / pinitial * 3.f / 16.f;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmd + xmrho, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sbbdrho = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 4) {
        // C     The spin- and isospin-averaged factor is 3-times larger for
        // rho:
        sbbdrho = fnndpi(snew) * pfinal / pinitial / 6.f * (pifactor * 3.f);
      }
    } else if (idxsec == 3) {
      sbbdrho = fs * pfinal / pinitial / 6.f * (pifactor * 3.f);
    }
  }
  // C
  // C     d omega: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
  const float xmomega = 0.782f;
  if (srt > (xmd + xmomega)) {
    pfinal = fem::sqrt((s - fem::pow2((xmd + xmomega))) *
                       (s - fem::pow2((xmd - xmomega)))) /
             2.f / srt;
    if (idxsec == 1) {
      sbbdomega = fs * pfinal / pinitial * 3.f / 16.f;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmd + xmomega, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sbbdomega = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 4) {
        sbbdomega = fnndpi(snew) * pfinal / pinitial / 6.f * pifactor;
      }
    } else if (idxsec == 3) {
      sbbdomega = fs * pfinal / pinitial / 6.f * pifactor;
    }
  }
  // C
  // C     d eta: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
  const float xmeta = 0.548f;
  if (srt > (xmd + xmeta)) {
    pfinal = fem::sqrt((s - fem::pow2((xmd + xmeta))) *
                       (s - fem::pow2((xmd - xmeta)))) /
             2.f / srt;
    if (idxsec == 1) {
      sbbdeta = fs * pfinal / pinitial * 3.f / 16.f;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmd + xmeta, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sbbdeta = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 4) {
        sbbdeta = fnndpi(snew) * pfinal / pinitial / 6.f * (pifactor / 3.f);
      }
    } else if (idxsec == 3) {
      sbbdeta = fs * pfinal / pinitial / 6.f * (pifactor / 3.f);
    }
  }
  // C
  sdprod = sbbdpi + sbbdrho + sbbdomega + sbbdeta;
  // Ctest off
  // C      write(99,111) srt,sbbdpi,sbbdrho,sbbdomega,sbbdeta,sdprod
  // C 111  format(6(f8.2,1x))
  // C
  if (sdprod <= 0) {
    return;
  }
  // C
  // C     choose final state and assign masses here:
  x1 = ranart(nseed);
  if (x1 <= sbbdpi / sdprod) {
    // C     use the above-determined lbm and xmm.
  } else if (x1 <= (sbbdpi + sbbdrho) / sdprod) {
    lbm = 25 + fem::fint(3 * ranart(nseed));
    xmm = xmrho;
  } else if (x1 <= (sbbdpi + sbbdrho + sbbdomega) / sdprod) {
    lbm = 28;
    xmm = xmomega;
  } else {
    lbm = 0;
    xmm = xmeta;
  }
  // C
}

struct bbdangle_save {
  float c1;
  float ct1;
  float dprob;
  float s1;
  float st1;
  float t1;

  bbdangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dprob(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C
// C     Generate angular distribution of Deuteron in the CMS frame:
void bbdangle(common& cmn, float& pxd, float& pyd, float& pzd, int const& nt,
              int const& ipert1, int const& ianti, int const& idloop,
              float const& pfinal, float const& dprob1, int const& lbm) {
  FEM_CMN_SVE(bbdangle);
  common_write write(cmn);
  // COMMON leadng
  int& lb1 = cmn.lb1;
  // COMMON dpi
  int& lb2 = cmn.lb2;
  // COMMON rndf77
  int& nseed = cmn.nseed;
  // COMMON para8
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  // COMMON arevt
  int& iaevt = cmn.iaevt;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dprob = sve.dprob;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzd = pfinal * c1;
  pxd = pfinal * s1 * ct1;
  pyd = pfinal * s1 * st1;
  // Clin-5/2008 track the number of produced deuterons:
  if (idpert == 1 && npertd >= 1) {
    dprob = dprob1;
  } else if (idpert == 2 && npertd >= 1) {
    dprob = 1.f / fem::ffloat(npertd);
  }
  if (ianti == 0) {
    if (idpert == 0 || (idpert == 1 && ipert1 == 0) ||
        (idpert == 2 && idloop == (npertd + 1))) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm,
          " (regular d prodn)  @evt#", iaevt, " @nt=", nt;
    } else if ((idpert == 1 || idpert == 2) && idloop == npertd) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm, " (pert d prodn)  @evt#",
          iaevt, " @nt=", nt, " @prob=", dprob;
    }
  } else {
    if (idpert == 0 || (idpert == 1 && ipert1 == 0) ||
        (idpert == 2 && idloop == (npertd + 1))) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm,
          " (regular dbar prodn) @evt#", iaevt, " @nt=", nt;
    } else if ((idpert == 1 || idpert == 2) && idloop == npertd) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm,
          " (pert dbar prodn)  @evt#", iaevt, " @nt=", nt, " @prob=", dprob;
    }
  }
  // C
}

struct crnn_save {
  static const int npdmax = 10000;

  float a;
  float ada;
  float ak0;
  float akp;
  float al;
  float amrho;
  float ana;
  float aomega;
  float arho;
  float as;
  float c1;
  float c2;
  float cc1;
  float ct1;
  float ct2;
  float dm;
  float dm1;
  float dm1n;
  float dm2;
  float dm2n;
  float dm3;
  float dm4;
  float dmax;
  float dmin;
  float dprob1;
  float e1cm;
  float e1dcm;
  float e2cm;
  float e2picm;
  float epcm;
  float es;
  float eti1;
  float eti2;
  float fm;
  int ianti;
  int ic;
  int icou1;
  int id1;
  int idloop;
  int ipertd;
  int lbd;
  int lbi1;
  int lbi2;
  int lbm;
  arr<int> lbpd;
  int m12;
  int n12;
  int ndloop;
  int ntry1;
  int ntry2;
  float p1beta;
  float p1dbeta;
  float p2beta;
  float p2pibeta;
  float pfinal;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float ppbeta;
  arr<float, 2> ppd;
  float ppx;
  float ppy;
  float ppz;
  float pr;
  float pr2;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px3;
  float px4;
  float pxd;
  float pxi1;
  float pxi2;
  float py3;
  float py4;
  float pyd;
  float pyi1;
  float pyi2;
  float pz2;
  float pz3;
  float pz4;
  float pzd;
  float pzi1;
  float pzi2;
  float s1;
  float s2;
  float s4pi;
  float scheck;
  float sdprod;
  float sig1;
  float sig2;
  float sig3;
  float sig4;
  float sigk;
  float signd;
  float somega;
  float srho;
  float ss;
  float st1;
  float st2;
  float t1;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float ta;
  float transf;
  float x;
  float x1;
  float x1535;
  float xdir;
  float xdmass;
  float xfinal;
  float xmass;
  float xmm;
  float xptr;
  float xsk1;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;

  crnn_save()
      : a(fem::float0),
        ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        amrho(fem::float0),
        ana(fem::float0),
        aomega(fem::float0),
        arho(fem::float0),
        as(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        dm(fem::float0),
        dm1(fem::float0),
        dm1n(fem::float0),
        dm2(fem::float0),
        dm2n(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        dprob1(fem::float0),
        e1cm(fem::float0),
        e1dcm(fem::float0),
        e2cm(fem::float0),
        e2picm(fem::float0),
        epcm(fem::float0),
        es(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fm(fem::float0),
        ianti(fem::int0),
        ic(fem::int0),
        icou1(fem::int0),
        id1(fem::int0),
        idloop(fem::int0),
        ipertd(fem::int0),
        lbd(fem::int0),
        lbi1(fem::int0),
        lbi2(fem::int0),
        lbm(fem::int0),
        lbpd(dimension(npdmax), fem::fill0),
        m12(fem::int0),
        n12(fem::int0),
        ndloop(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        p1beta(fem::float0),
        p1dbeta(fem::float0),
        p2beta(fem::float0),
        p2pibeta(fem::float0),
        pfinal(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        ppbeta(fem::float0),
        ppd(dimension(3, npdmax), fem::fill0),
        ppx(fem::float0),
        ppy(fem::float0),
        ppz(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px3(fem::float0),
        px4(fem::float0),
        pxd(fem::float0),
        pxi1(fem::float0),
        pxi2(fem::float0),
        py3(fem::float0),
        py4(fem::float0),
        pyd(fem::float0),
        pyi1(fem::float0),
        pyi2(fem::float0),
        pz2(fem::float0),
        pz3(fem::float0),
        pz4(fem::float0),
        pzd(fem::float0),
        pzi1(fem::float0),
        pzi2(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        s4pi(fem::float0),
        scheck(fem::float0),
        sdprod(fem::float0),
        sig1(fem::float0),
        sig2(fem::float0),
        sig3(fem::float0),
        sig4(fem::float0),
        sigk(fem::float0),
        signd(fem::float0),
        somega(fem::float0),
        srho(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        ta(fem::float0),
        transf(fem::float0),
        x(fem::float0),
        x1(fem::float0),
        x1535(fem::float0),
        xdir(fem::float0),
        xdmass(fem::float0),
        xfinal(fem::float0),
        xmass(fem::float0),
        xmm(fem::float0),
        xptr(fem::float0),
        xsk1(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0) {}
};

const int crnn_save::npdmax;

// C***************************************
// C                                                                      *
void crnn(common& cmn, int const& irun, float& px, float& py, float& pz,
          float const& srt, int const& i1, int const& i2, int& iblock,
          int& ntag, float const& signn, float const& sig, int const& nt,
          int const& ipert1) {
  FEM_CMN_SVE(crnn);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  float& dir = cmn.dir;
  int& nnn = cmn.nnn;
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& iseed = cmn.iseed;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  int& nseed = cmn.nseed;
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  //
  float& a = sve.a;
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& amrho = sve.amrho;
  float& ana = sve.ana;
  float& aomega = sve.aomega;
  float& arho = sve.arho;
  float& as = sve.as;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& dm = sve.dm;
  float& dm1 = sve.dm1;
  float& dm1n = sve.dm1n;
  float& dm2 = sve.dm2;
  float& dm2n = sve.dm2n;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& dprob1 = sve.dprob1;
  float& e1cm = sve.e1cm;
  float& e1dcm = sve.e1dcm;
  float& e2cm = sve.e2cm;
  float& e2picm = sve.e2picm;
  float& epcm = sve.epcm;
  float& es = sve.es;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fm = sve.fm;
  int& ianti = sve.ianti;
  int& ic = sve.ic;
  int& icou1 = sve.icou1;
  int& id1 = sve.id1;
  int& idloop = sve.idloop;
  int& ipertd = sve.ipertd;
  int& lbd = sve.lbd;
  int& lbi1 = sve.lbi1;
  int& lbi2 = sve.lbi2;
  int& lbm = sve.lbm;
  const int npdmax = 10000;
  arr_ref<int> lbpd(sve.lbpd, dimension(npdmax));
  int& n12 = sve.n12;
  int& ndloop = sve.ndloop;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& p1beta = sve.p1beta;
  float& p1dbeta = sve.p1dbeta;
  float& p2beta = sve.p2beta;
  float& p2pibeta = sve.p2pibeta;
  float& pfinal = sve.pfinal;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& ppbeta = sve.ppbeta;
  arr_ref<float, 2> ppd(sve.ppd, dimension(3, npdmax));
  float& ppx = sve.ppx;
  float& ppy = sve.ppy;
  float& ppz = sve.ppz;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px3 = sve.px3;
  float& px4 = sve.px4;
  float& pxd = sve.pxd;
  float& pxi1 = sve.pxi1;
  float& pxi2 = sve.pxi2;
  float& py3 = sve.py3;
  float& py4 = sve.py4;
  float& pyd = sve.pyd;
  float& pyi1 = sve.pyi1;
  float& pyi2 = sve.pyi2;
  float& pz2 = sve.pz2;
  float& pz3 = sve.pz3;
  float& pz4 = sve.pz4;
  float& pzd = sve.pzd;
  float& pzi1 = sve.pzi1;
  float& pzi2 = sve.pzi2;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& s4pi = sve.s4pi;
  float& scheck = sve.scheck;
  float& sdprod = sve.sdprod;
  float& sig1 = sve.sig1;
  float& sig2 = sve.sig2;
  float& sig3 = sve.sig3;
  float& sig4 = sve.sig4;
  float& sigk = sve.sigk;
  float& signd = sve.signd;
  float& somega = sve.somega;
  float& srho = sve.srho;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2 = sve.t2;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& ta = sve.ta;
  float& transf = sve.transf;
  float& x = sve.x;
  float& x1 = sve.x1;
  float& x1535 = sve.x1535;
  float& xdir = sve.xdir;
  float& xdmass = sve.xdmass;
  float& xfinal = sve.xfinal;
  float& xmass = sve.xmass;
  float& xmm = sve.xmm;
  float& xptr = sve.xptr;
  float& xsk1 = sve.xsk1;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  const float pi = 3.1415926f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  const float avmass = 0.9383f;
  const float amp = 0.93828f;
  const float ap1 = 0.13496f;
  const float ap2 = 0.13957f;
  const float xmd = 1.8756f;
  const float aka = 0.498f;
  // C     PURPOSE:                                                         *
  // C             DEALING WITH NUCLEON-NUCLEON COLLISIONS                    *
  // C     NOTE   :                                                         *
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  // C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      0-> COLLISION CANNOT HAPPEN                     *
  // C                      1-> N-N ELASTIC COLLISION                       *
  // C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  // C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  // C                      4-> N+N->D+D+pion reaction
  // C                     43->N+N->D(N*)+D(N*) reaction
  // C                     44->N+N->D+D+rho reaction
  // C                     45->N+N->N+N+rho
  // C                     46->N+N->N+N+omega
  // C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  // C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  // C                      N12,                                            *
  // C                      M12=1 FOR p+n-->delta(+)+ n                     *
  // C                          2     p+n-->delta(0)+ p                     *
  // C                          3     p+p-->delta(++)+n                     *
  // C                          4     p+p-->delta(+)+p                      *
  // C                          5     n+n-->delta(0)+n                      *
  // C                          6     n+n-->delta(-)+p                      *
  // C                          7     n+p-->N*(0)(1440)+p                   *
  // C                          8     n+p-->N*(+)(1440)+n                   *
  // C                        9     p+p-->N*(+)(1535)+p                     *
  // C                        10    n+n-->N*(0)(1535)+n                     *
  // C                         11    n+p-->N*(+)(1535)+n                     *
  // C                        12    n+p-->N*(0)(1535)+p
  // C                        13    D(++)+D(-)-->N*(+)(1440)+n
  // C                         14    D(++)+D(-)-->N*(0)(1440)+p
  // C                        15    D(+)+D(0)--->N*(+)(1440)+n
  // C                        16    D(+)+D(0)--->N*(0)(1440)+p
  // C                        17    D(++)+D(0)-->N*(+)(1535)+p
  // C                        18    D(++)+D(-)-->N*(0)(1535)+p
  // C                        19    D(++)+D(-)-->N*(+)(1535)+n
  // C                        20    D(+)+D(+)-->N*(+)(1535)+p
  // C                        21    D(+)+D(0)-->N*(+)(1535)+n
  // C                        22    D(+)+D(0)-->N*(0)(1535)+p
  // C                        23    D(+)+D(-)-->N*(0)(1535)+n
  // C                        24    D(0)+D(0)-->N*(0)(1535)+n
  // C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  // C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  // C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  // C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  // C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  // C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  // C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  // C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  // C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  // C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  // C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  // C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  // C                        ++    see the note book for more listing
  // C
  // C     NOTE ABOUT N*(1440) RESORANCE IN Nucleon+NUCLEON COLLISION:      *
  // C     As it has been discussed in VerWest's paper,I= 1(initial isospin)*
  // C     channel can all be attributed to delta resorance while I= 0      *
  // C     channel can all be  attribured to N* resorance.Only in n+p       *
  // C     one can have I=0 channel so is the N*(1440) resonance            *
  // C                                                                      *
  // C                             REFERENCES:                            *
  // C                    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)    *
  // C                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
  // C                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
  // C                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615;       *
  // C                                     Nucl phys A552 (1993) 349.       *
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /BG/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /TABLE/
  // Cc      SAVE /input1/
  // Cc      SAVE /leadng/
  // Cc      SAVE /RNDF77/
  // C-----------------------------------------------------------------------
  n12 = 0;
  sve.m12 = 0;
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  c2 = pz / pr;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 && lb(i2) < 0) {
    ianti = 1;
  }
  sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
  // Clin-5/2008 Production of perturbative deuterons for idpert=1:
  if (idpert == 1 && ipert1 == 1) {
    if (srt < 2.012f) {
      return;
    }
    if ((fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i1)) == 2) &&
        (fem::iabs(lb(i2)) == 1 || fem::iabs(lb(i2)) == 2)) {
      goto statement_108;
    } else {
      return;
    }
  }
  // C
  // C-----------------------------------------------------------------------
  // CCOM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
  // C      N-DELTA OR N*-N* or N*-Delta)
  // C      IF (X1 .LE. SIGNN/SIG) THEN
  if (x1 <= (signn / sig)) {
    // CCOM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
    as = fem::pow((3.65f * (srt - 1.8766f)), 6);
    a = 6.0f * as / (1.0f + as);
    ta = -2.0f * fem::pow2(pr);
    x = ranart(nseed);
    // Clin-10/24/02        T1  = DLOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /
    // A
    t1 = fem::sngl(fem::dlog(fem::dble(1.f - x) *
                                 fem::dexp(fem::dble(a) * fem::dble(ta)) +
                             fem::dble(x))) /
         a;
    c1 = 1.0f - t1 / ta;
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 1;
    goto statement_107;
  } else {
    // CCOM: TEST FOR INELASTIC SCATTERING
    // C     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
    // C     CAN HAPPEN ANY MORE ==> RETURN (2.012 = 2*AVMASS + PI-MASS)
    // Clin-5/2008: Mdeuteron+Mpi=2.0106 to 2.0152 GeV/c2, so we can still use
    // this:
    if (srt < 2.012f) {
      return;
    }
    // C     calculate the N*(1535) production cross section in N+N collisions
    // C     note that the cross sections in this subroutine are in units of mb
    // C     as only ratios of the cross sections are used to determine the
    // C     reaction channels
    n1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
    // CCOM: HERE WE HAVE A PROCESS N+N ==> N+DELTA,OR N+N==>N+N*(144) or
    // N*(1535) C     OR C 3 pi channel : N+N==>d1+d2+PION
    sig3 = 3.f * (x3pi(cmn, srt) + x33pi(cmn, srt));
    // C 2 pi channel : N+N==>d1+d2+d1*n*+n*n*
    sig4 = 4.f * x2pi(cmn, srt);
    // C 4 pi channel : N+N==>d1+d2+rho
    s4pi = x4pi(cmn, srt);
    // C N+N-->NN+rho channel
    srho = xrho(cmn, srt);
    // C N+N-->NN+omega
    somega = omega(cmn, srt);
    // C CROSS SECTION FOR KAON PRODUCTION from the four channels
    // C for NLK channel
    akp = 0.498f;
    sve.ak0 = 0.498f;
    ana = 0.94f;
    ada = 1.232f;
    al = 1.1157f;
    as = 1.1197f;
    xsk1 = 0;
    xsk2 = 0;
    xsk3 = 0;
    xsk4 = 0;
    xsk5 = 0;
    t1nlk = ana + al + akp;
    if (srt <= t1nlk) {
      goto statement_222;
    }
    xsk1 = 1.5f * pplpk(cmn, srt);
    // C for DLK channel
    t1dlk = ada + al + akp;
    t2dlk = ada + al - akp;
    if (srt <= t1dlk) {
      goto statement_222;
    }
    es = srt;
    pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
             (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
    sve.pmdlk = fem::sqrt(pmdlk2);
    xsk3 = 1.5f * pplpk(cmn, srt);
    // C for NSK channel
    t1nsk = ana + as + akp;
    t2nsk = ana + as - akp;
    if (srt <= t1nsk) {
      goto statement_222;
    }
    pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
             (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
    sve.pmnsk = fem::sqrt(pmnsk2);
    xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    // C for DSK channel
    t1dsk = ada + as + akp;
    t2dsk = ada + as - akp;
    if (srt <= t1dsk) {
      goto statement_222;
    }
    pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
             (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
    sve.pmdsk = fem::sqrt(pmdsk2);
    xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    // Csp11/21/01
    // C phi production
    if (srt <= (2.f * amn + aphi)) {
      goto statement_222;
    }
    // C  !! mb put the correct form
    xsk5 = 0.0001f;
  // Csp11/21/01 end
  // C
  // C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
  statement_222:
    sigk = xsk1 + xsk2 + xsk3 + xsk4;
    // C
    // Cbz3/7/99 neutralk
    xsk1 = 2.0f * xsk1;
    xsk2 = 2.0f * xsk2;
    xsk3 = 2.0f * xsk3;
    xsk4 = 2.0f * xsk4;
    sigk = 2.0f * sigk + xsk5;
    // Cbz3/7/99 neutralk end
    // C
    // C* FOR P+P or L/S+L/S COLLISION:
    // C       lb1=lb(i1)
    // C       lb2=lb(i2)
    lb1 = fem::iabs(lb(i1));
    lb2 = fem::iabs(lb(i2));
    if ((lb(i1) * lb(i2) == 1) ||
        ((lb1 <= 17 && lb1 >= 14) && (lb2 <= 17 && lb2 >= 14)) ||
        ((lb1 <= 2) && (lb2 <= 17 && lb2 >= 14)) ||
        ((lb2 <= 2) && (lb1 <= 17 && lb1 >= 14))) {
      // Clin-8/2008 PP->d+meson here:
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      sig1 = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sig2 = 1.5f * sigma(cmn, srt, 1, 1, 1);
      signd = sig1 + sig2 + sig3 + sig4 + x1535 + sigk + s4pi + srho + somega;
      // Clin-5/2008:
      // C           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      dir = sig3 / signd;
      if (ranart(nseed) <= dir) {
        goto statement_106;
      }
      if (ranart(nseed) <=
          sigk / (sigk + x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_306;
      }
      if (ranart(nseed) <=
          s4pi / (x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_307;
      }
      if (ranart(nseed) <=
          srho / (x1535 + sig4 + sig2 + sig1 + srho + somega)) {
        goto statement_308;
      }
      if (ranart(nseed) <= somega / (x1535 + sig4 + sig2 + sig1 + somega)) {
        goto statement_309;
      }
      if (ranart(nseed) <= x1535 / (sig1 + sig2 + sig4 + x1535)) {
        // C N*(1535) production
        n12 = 9;
      } else {
        if (ranart(nseed) <= sig4 / (sig1 + sig2 + sig4)) {
          // C DOUBLE DELTA PRODUCTION
          n12 = 66;
          goto statement_1012;
        } else {
          // CDELTA PRODUCTION
          n12 = 3;
          if (ranart(nseed) > sig1 / (sig1 + sig2)) {
            n12 = 4;
          }
        }
      }
      goto statement_1011;
    }
    // C* FOR N+N COLLISION:
    if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
      // Clin-8/2008 NN->d+meson here:
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      sig1 = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sig2 = 1.5f * sigma(cmn, srt, 1, 1, 1);
      signd = sig1 + sig2 + x1535 + sig3 + sig4 + sigk + s4pi + srho + somega;
      // Clin-5/2008:
      // C           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      dir = sig3 / signd;
      if (ranart(nseed) <= dir) {
        goto statement_106;
      }
      if (ranart(nseed) <=
          sigk / (sigk + x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_306;
      }
      if (ranart(nseed) <=
          s4pi / (x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_307;
      }
      if (ranart(nseed) <=
          srho / (x1535 + sig4 + sig2 + sig1 + srho + somega)) {
        goto statement_308;
      }
      if (ranart(nseed) <= somega / (x1535 + sig4 + sig2 + sig1 + somega)) {
        goto statement_309;
      }
      if (ranart(nseed) <= x1535 / (x1535 + sig1 + sig2 + sig4)) {
        // C N*(1535) PRODUCTION
        n12 = 10;
      } else {
        if (ranart(nseed) <= sig4 / (sig1 + sig2 + sig4)) {
          // C double delta production
          n12 = 67;
          goto statement_1013;
        } else {
          // C DELTA PRODUCTION
          n12 = 6;
          if (ranart(nseed) > sig1 / (sig1 + sig2)) {
            n12 = 5;
          }
        }
      }
      goto statement_1011;
    }
    // C* FOR N+P COLLISION
    if (lb(i1) * lb(i2) == 2) {
      // Clin-5/2008 NP->d+meson here:
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      sig1 = 0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
      if (cmn.nstar == 1) {
        sig2 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      } else {
        sig2 = 0.f;
      }
      signd = 2.f * (sig1 + sig2 + x1535) + sig3 + sig4 + sigk + s4pi + srho +
              somega;
      // Clin-5/2008:
      // C           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      dir = sig3 / signd;
      if (ranart(nseed) <= dir) {
        goto statement_106;
      }
      if (ranart(nseed) <= sigk / (signd - sig3)) {
        goto statement_306;
      }
      if (ranart(nseed) <= s4pi / (signd - sig3 - sigk)) {
        goto statement_307;
      }
      if (ranart(nseed) <= srho / (signd - sig3 - sigk - s4pi)) {
        goto statement_308;
      }
      if (ranart(nseed) <= somega / (signd - sig3 - sigk - s4pi - srho)) {
        goto statement_309;
      }
      if (ranart(nseed) < x1535 / (sig1 + sig2 + x1535 + 0.5f * sig4)) {
        // C N*(1535) PRODUCTION
        n12 = 11;
        if (ranart(nseed) <= 0.5f) {
          n12 = 12;
        }
      } else {
        if (ranart(nseed) <= sig4 / (sig4 + 2.f * (sig1 + sig2))) {
          // C double resonance production
          n12 = 68;
          goto statement_1014;
        } else {
          if (ranart(nseed) <= sig1 / (sig1 + sig2)) {
            // C DELTA PRODUCTION
            n12 = 2;
            if (ranart(nseed) >= 0.5f) {
              n12 = 1;
            }
          } else {
            // C N*(1440) PRODUCTION
            n12 = 8;
            if (ranart(nseed) >= 0.5f) {
              n12 = 7;
            }
          }
        }
      }
    }
  statement_1011:
    iblock = 2;
    // CPARAMETRIZATION OF THE SHAPE OF THE DELTA RESONANCE ACCORDING
    // C     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
    // C     FORMULA FOR N* RESORANCE
    // C     DETERMINE DELTA MASS VIA REJECTION METHOD.
    dmax = srt - avmass - 0.005f;
    dmax = srt - avmass - 0.005f;
    dmin = 1.078f;
    if (n12 < 7) {
      // C Delta(1232) production
      if (dmax < 1.232f) {
        fm = fde(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FDE():
        xdmass = 1.232f;
        // C          FM=FDE(1.232,SRT,1.)
        fm = fde(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_10:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fde(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 30)) {
        goto statement_10;
      }
      // C
      // Clin-2/26/03 limit the Delta mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.47f) {
        goto statement_10;
      }
      // C
      goto statement_13;
    }
    if ((n12 == 7) || (n12 == 8)) {
      // C N*(1440) production
      if (dmax < 1.44f) {
        fm = fns(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.44f;
        // C          FM=FNS(1.44,SRT,1.)
        fm = fns(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry2 = 0;
    statement_11:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry2++;
      if ((ranart(nseed) > fns(cmn, dm, srt, 1.f) / fm) && (ntry2 <= 10)) {
        goto statement_11;
      }
      // C
      // Clin-2/26/03 limit the N* mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 2.14f) {
        goto statement_11;
      }
      // C
      goto statement_13;
    }
    if (n12 >= 17) {
      // C N*(1535) production
      if (dmax < 1.535f) {
        fm = fd5(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.535f;
        // C          FM=FD5(1.535,SRT,1.)
        fm = fd5(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_12:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fd5(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 10)) {
        goto statement_12;
      }
      // C
      // Clin-2/26/03 limit the N* mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.84f) {
        goto statement_12;
      }
      // C
      goto statement_13;
    }
  // C CALCULATE THE MASSES OF BARYON RESONANCES IN THE DOUBLE RESONANCE
  // C PRODUCTION PROCESS AND RELABLE THE PARTICLES
  statement_1012:
    iblock = 43;
    rmasdd(cmn, srt, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
    rmasdd(cmn, srt, 1.232f, 1.44f, 1.08f, 1.08f, iseed, 3, dm1n, dm2n);
    if (n12 == 66) {
      // C(1) PP-->DOUBLE RESONANCES
      // C DETERMINE THE FINAL STATE
      xfinal = ranart(nseed);
      if (xfinal <= 0.25f) {
        // C (1.1) D+++D0
        lb(i1) = 9;
        lb(i2) = 7;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if ((xfinal > 0.25f) && (xfinal <= 0.5f)) {
        // C (1.2) D++D+
        lb(i1) = 8;
        lb(i2) = 8;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if ((xfinal > 0.5f) && (xfinal <= 0.75f)) {
        // C (1.3) D+++N*0
        lb(i1) = 9;
        lb(i2) = 10;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if (xfinal > 0.75f) {
        // C (1.4) D++N*+
        lb(i1) = 8;
        lb(i2) = 11;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
    }
  statement_1013:
    iblock = 43;
    rmasdd(cmn, srt, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
    rmasdd(cmn, srt, 1.232f, 1.44f, 1.08f, 1.08f, iseed, 3, dm1n, dm2n);
    if (n12 == 67) {
      // C(2) NN-->DOUBLE RESONANCES
      // C DETERMINE THE FINAL STATE
      xfinal = ranart(nseed);
      if (xfinal <= 0.25f) {
        // C (2.1) D0+D0
        lb(i1) = 7;
        lb(i2) = 7;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if ((xfinal > 0.25f) && (xfinal <= 0.5f)) {
        // C (2.2) D++D+
        lb(i1) = 6;
        lb(i2) = 8;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if ((xfinal > 0.5f) && (xfinal <= 0.75f)) {
        // C (2.3) D0+N*0
        lb(i1) = 7;
        lb(i2) = 10;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if (xfinal > 0.75f) {
        // C (2.4) D++N*+
        lb(i1) = 8;
        lb(i2) = 11;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
    }
  statement_1014:
    iblock = 43;
    rmasdd(cmn, srt, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
    rmasdd(cmn, srt, 1.232f, 1.44f, 1.08f, 1.08f, iseed, 3, dm1n, dm2n);
    if (n12 == 68) {
      // C(3) NP-->DOUBLE RESONANCES
      // C DETERMINE THE FINAL STATE
      xfinal = ranart(nseed);
      if (xfinal <= 0.25f) {
        // C (3.1) D0+D+
        lb(i1) = 7;
        lb(i2) = 8;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if ((xfinal > 0.25f) && (xfinal <= 0.5f)) {
        // C (3.2) D+++D-
        lb(i1) = 9;
        lb(i2) = 6;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if ((xfinal > 0.5f) && (xfinal <= 0.75f)) {
        // C (3.3) D0+N*+
        lb(i1) = 7;
        lb(i2) = 11;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
      if (xfinal > 0.75f) {
        // C (3.4) D++N*0
        lb(i1) = 8;
        lb(i2) = 10;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        // C go to 200 to set the new momentum
      }
    }
  statement_13:
    // C-------------------------------------------------------
    // C RELABLE BARYON I1 AND I2
    // C1. p+n-->delta(+)+n
    if (n12 == 1) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i2) = 2;
        lb(i1) = 8;
        e(i1) = dm;
      } else {
        lb(i1) = 2;
        lb(i2) = 8;
        e(i2) = dm;
      }
      goto statement_200;
    }
    // C2 p+n-->delta(0)+p
    if (n12 == 2) {
      if (fem::iabs(lb(i1)) == 2) {
        lb(i2) = 1;
        lb(i1) = 7;
        e(i1) = dm;
      } else {
        lb(i1) = 1;
        lb(i2) = 7;
        e(i2) = dm;
      }
      goto statement_200;
    }
    // C3 p+p-->delta(++)+n
    if (n12 == 3) {
      lb(i1) = 9;
      e(i1) = dm;
      lb(i2) = 2;
      e(i2) = amn;
      goto statement_200;
    }
    // C4 p+p-->delta(+)+p
    if (n12 == 4) {
      lb(i2) = 1;
      lb(i1) = 8;
      e(i1) = dm;
      goto statement_200;
    }
    // C5 n+n--> delta(0)+n
    if (n12 == 5) {
      lb(i2) = 2;
      lb(i1) = 7;
      e(i1) = dm;
      goto statement_200;
    }
    // C6 n+n--> delta(-)+p
    if (n12 == 6) {
      lb(i1) = 6;
      e(i1) = dm;
      lb(i2) = 1;
      e(i2) = amp;
      goto statement_200;
    }
    // C7 n+p--> N*(0)+p
    if (n12 == 7) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i1) = 1;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_200;
    }
    // C8 n+p--> N*(+)+n
    if (n12 == 8) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i2) = 2;
        lb(i1) = 11;
        e(i1) = dm;
      } else {
        lb(i1) = 2;
        lb(i2) = 11;
        e(i2) = dm;
      }
      goto statement_200;
    }
    // C9 p+p--> N*(+)(1535)+p
    if (n12 == 9) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        lb(i1) = 13;
        e(i1) = dm;
      } else {
        lb(i1) = 1;
        lb(i2) = 13;
        e(i2) = dm;
      }
      goto statement_200;
    }
    // C10 n+n--> N*(0)(1535)+n
    if (n12 == 10) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 2;
        lb(i1) = 12;
        e(i1) = dm;
      } else {
        lb(i1) = 2;
        lb(i2) = 12;
        e(i2) = dm;
      }
      goto statement_200;
    }
    // C11 n+p--> N*(+)(1535)+n
    if (n12 == 11) {
      if (fem::iabs(lb(i1)) == 2) {
        lb(i1) = 2;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_200;
    }
    // C12 n+p--> N*(0)(1535)+p
    if (n12 == 12) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i1) = 1;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        lb(i1) = 12;
        e(i1) = dm;
      }
    }
  }
// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
// C ENERGY CONSERVATION
statement_200:
  em1 = e(i1);
  em2 = e(i2);
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  if (srt <= 2.14f) {
    c1 = 1.0f - 2.0f * ranart(nseed);
  }
  if (srt > 2.14f && srt <= 2.4f) {
    c1 = ang(cmn, srt, iseed);
  }
  if (srt > 2.4f) {
    // C
    // Clin-10/25/02 get rid of argument usage mismatch in PTR():
    xptr = 0.33f * pr;
    // C         cc1=ptr(0.33*pr,iseed)
    cc1 = ptr(cmn, xptr, iseed);
    // Clin-10/25/02-end
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2(pr) - fem::pow2(cc1);
    if (scheck < 0) {
      write(99, star), "scheck2: ", scheck;
      scheck = 0.f;
    }
    c1 = fem::sqrt(scheck) / pr;
    // C             c1=sqrt(pr**2-cc1**2)/pr
    // C
  }
  t1 = 2.0f * pi * ranart(nseed);
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
  }
  goto statement_107;
// CFOR THE NN-->D1+D2+PI PROCESS, FIND MOMENTUM OF THE FINAL TWO
// CDELTAS AND PION IN THE NUCLEUS-NUCLEUS CMS.
statement_106:
  ntry1 = 0;
statement_123:
  ddp2(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
       icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 40)) {
    goto statement_123;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  // C (1) FOR P+P
  xdir = ranart(nseed);
  if (lb(i1) * lb(i2) == 1) {
    if (xdir <= 0.2f) {
      // C (1.1)P+P-->D+++D0+PION(0)
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 9;
      lb(i2) = 7;
      goto statement_205;
    }
    // C (1.2)P+P -->D++D+PION(0)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_205;
    }
    // C (1.3)P+P-->D+++D+PION(-)
    if ((xdir <= 0.6f) && (xdir > 0.4f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_205;
    }
    if ((xdir <= 0.8f) && (xdir > 0.6f)) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 9;
      lb(i2) = 6;
      goto statement_205;
    }
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
  }
  // C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    if (xdir <= 0.2f) {
      // C (2.1)N+N-->D++D-+PION(0)
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 6;
      lb(i2) = 7;
      goto statement_205;
    }
    // C (2.2)N+N -->D+++D-+PION(-)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_205;
    }
    // C (2.3)P+P-->D0+D-+PION(+)
    if ((xdir > 0.4f) && (xdir <= 0.6f)) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_205;
    }
    // C (2.4)P+P-->D0+D0+PION(0)
    if ((xdir > 0.6f) && (xdir <= 0.8f)) {
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 7;
      lb(i2) = 7;
      goto statement_205;
    }
    // C (2.5)P+P-->D0+D++PION(-)
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
  }
  // C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    if (xdir <= 0.17f) {
      // C (3.1)N+P-->D+++D-+PION(0)
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_205;
    }
    // C (3.2)N+P -->D+++D0+PION(-)
    if ((xdir <= 0.34f) && (xdir > 0.17f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 9;
      goto statement_205;
    }
    // C (3.3)N+P-->D++D-+PION(+)
    if ((xdir > 0.34f) && (xdir <= 0.51f)) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
    // C (3.4)N+P-->D++D++PION(-)
    if ((xdir > 0.51f) && (xdir <= 0.68f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_205;
    }
    // C (3.5)N+P-->D0+D++PION(0)
    if ((xdir > 0.68f) && (xdir <= 0.85f)) {
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
    // C (3.6)N+P-->D0+D0+PION(+)
    if (xdir > 0.85f) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 7;
    }
  }
// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
// C NUCLEUS CMS. FRAME
// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_205:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  // C
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 3) {
      lpion(nnn, irun) = 5;
    } else if (lpion(nnn, irun) == 5) {
      lpion(nnn, irun) = 3;
    }
  }
  // C
  lb1 = lb(i1);
  // C FOR DELTA2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  // C assign delta1 and delta2 to i1 or i2 to keep the leadng particle
  // C behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 4;
  // C GET PION'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008 do not allow smearing in position of produced particles
  // C     to avoid immediate reinteraction with the particle I1, I2 or
  // themselves: C2002        X01 = 1.0 - 2.0 * RANART(NSEED) C            Y01
  // = 1.0 - 2.0 * RANART(NSEED) C            Z01 = 1.0 - 2.0 * RANART(NSEED) C
  // IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2002 C
  // RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01 C RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01 C
  // RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  goto statement_90005;
// Clin-5/2008 N+N->Deuteron+pi:
// C     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_108:
  if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
    // C     For idpert=1: we produce npertd pert deuterons:
    ndloop = npertd;
  } else if (idpert == 2 && npertd >= 1) {
    // C     For idpert=2: we first save information for npertd pert deuterons;
    // C     at the last ndloop we create the regular deuteron+pi
    // C     and those pert deuterons:
    ndloop = npertd + 1;
  } else {
    // C     Just create the regular deuteron+pi:
    ndloop = 1;
  }
  // C
  dprob1 = sdprod / sig / fem::ffloat(npertd);
  FEM_DO_SAFE(idloop, 1, ndloop) {
    bbdangle(cmn, pxd, pyd, pzd, nt, ipert1, ianti, idloop, pfinal, dprob1,
             lbm);
    rotate(cmn, px, py, pz, pxd, pyd, pzd);
    // C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
    // STATE C     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME: C     For the
    // Deuteron:
    xmass = xmd;
    e1dcm = fem::sqrt(fem::pow2(xmass) + fem::pow2(pxd) + fem::pow2(pyd) +
                      fem::pow2(pzd));
    p1dbeta = pxd * betax + pyd * betay + pzd * betaz;
    transf = gamma * (gamma * p1dbeta / (gamma + 1.f) + e1dcm);
    pxi1 = betax * transf + pxd;
    pyi1 = betay * transf + pyd;
    pzi1 = betaz * transf + pzd;
    if (ianti == 0) {
      lbd = 42;
    } else {
      lbd = -42;
    }
    if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
      // Cccc  Perturbative production for idpert=1:
      nnn++;
      ppion(1, nnn, irun) = pxi1;
      ppion(2, nnn, irun) = pyi1;
      ppion(3, nnn, irun) = pzi1;
      epion(nnn, irun) = xmd;
      lpion(nnn, irun) = lbd;
      rpion(1, nnn, irun) = r(1, i1);
      rpion(2, nnn, irun) = r(2, i1);
      rpion(3, nnn, irun) = r(3, i1);
      // Clin-5/2008 assign the perturbative probability:
      dppion(nnn, irun) = sdprod / sig / fem::ffloat(npertd);
    } else if (idpert == 2 && idloop <= npertd) {
      // Clin-5/2008 For idpert=2, we produce NPERTD perturbative
      // (anti)deuterons C     only when a regular (anti)deuteron+pi is produced
      // in NN collisions. C     First save the info for the perturbative
      // deuterons:
      ppd(1, idloop) = pxi1;
      ppd(2, idloop) = pyi1;
      ppd(3, idloop) = pzi1;
      lbpd(idloop) = lbd;
    } else {
      // Cccc  Regular production:
      // C     For the regular pion: do LORENTZ-TRANSFORMATION:
      e(i1) = xmm;
      e2picm = fem::sqrt(fem::pow2(xmm) + fem::pow2(pxd) + fem::pow2(pyd) +
                         fem::pow2(pzd));
      p2pibeta = -pxd * betax - pyd * betay - pzd * betaz;
      transf = gamma * (gamma * p2pibeta / (gamma + 1.f) + e2picm);
      pxi2 = betax * transf - pxd;
      pyi2 = betay * transf - pyd;
      pzi2 = betaz * transf - pzd;
      p(1, i1) = pxi2;
      p(2, i1) = pyi2;
      p(3, i1) = pzi2;
      // C     Remove regular pion to check the equivalence
      // C     between the perturbative and regular deuteron results:
      // C                 E(i1)=0.
      // C
      lb(i1) = lbm;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      id(i1) = 2;
      id1 = id(i1);
      cmn.e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                         fem::pow2(pz1));
      lb1 = lb(i1);
      // C     For the regular deuteron:
      p(1, i2) = pxi1;
      p(2, i2) = pyi1;
      p(3, i2) = pzi1;
      lb(i2) = lbd;
      lb2 = lb(i2);
      e(i2) = xmd;
      eti2 = e(i2);
      id(i2) = 2;
      // C     For idpert=2: create the perturbative deuterons:
      if (idpert == 2 && idloop == ndloop) {
        FEM_DO_SAFE(ipertd, 1, npertd) {
          nnn++;
          ppion(1, nnn, irun) = ppd(1, ipertd);
          ppion(2, nnn, irun) = ppd(2, ipertd);
          ppion(3, nnn, irun) = ppd(3, ipertd);
          epion(nnn, irun) = xmd;
          lpion(nnn, irun) = lbpd(ipertd);
          rpion(1, nnn, irun) = r(1, i1);
          rpion(2, nnn, irun) = r(2, i1);
          rpion(3, nnn, irun) = r(3, i1);
          // Clin-5/2008 assign the perturbative probability:
          dppion(nnn, irun) = 1.f / fem::ffloat(npertd);
        }
      }
    }
  }
  iblock = 501;
  goto statement_90005;
// Clin-5/2008 N+N->Deuteron+pi over
// C FOR THE NN-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN
// C THE NUCLEUS-NUCLEUS CMS.
statement_306:
  // Csp11/21/01 phi production
  if (xsk5 / sigk > ranart(nseed)) {
    pz1 = p(3, i1);
    pz2 = p(3, i2);
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    nnn++;
    lpion(nnn, irun) = 29;
    epion(nnn, irun) = aphi;
    iblock = 222;
    goto statement_208;
  }
  // C
  iblock = 9;
  if (ianti == 1) {
    iblock = -9;
  }
  // C
  pz1 = p(3, i1);
  pz2 = p(3, i2);
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  nnn++;
  lpion(nnn, irun) = 23;
  epion(nnn, irun) = aka;
  if (srt <= 2.63f) {
    // C only lambda production is possible
    // C (1.1)P+P-->p+L+kaon+
    ic = 1;
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 14;
    goto statement_208;
  }
  if (srt <= 2.74f && srt > 2.63f) {
    // C both Lambda and sigma production are possible
    if (xsk1 / (xsk1 + xsk2) > ranart(nseed)) {
      // C lambda production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
    } else {
      // C sigma production
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      ic = 2;
    }
    goto statement_208;
  }
  if (srt <= 2.77f && srt > 2.74f) {
    // C then pp-->Delta lamda kaon can happen
    if (xsk1 / (xsk1 + xsk2 + xsk3) > ranart(nseed)) {
      // C * (1.1)P+P-->p+L+kaon+
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk2 / (xsk2 + xsk3) > ranart(nseed)) {
        // C pp-->psk
        ic = 2;
        lb(i1) = 1 + fem::fint(2 * ranart(nseed));
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      } else {
        // C pp-->D+l+k
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
      }
      goto statement_208;
    }
  }
  if (srt > 2.77f) {
    // C all four channels are possible
    if (xsk1 / (xsk1 + xsk2 + xsk3 + xsk4) > ranart(nseed)) {
      // C p lambda k production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk3 / (xsk2 + xsk3 + xsk4) > ranart(nseed)) {
        // C delta l K production
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
        goto statement_208;
      } else {
        if (xsk2 / (xsk2 + xsk4) > ranart(nseed)) {
          // C n sigma k production
          lb(i1) = 1 + fem::fint(2 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          ic = 2;
        } else {
          ic = 4;
          lb(i1) = 6 + fem::fint(4 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        }
        goto statement_208;
      }
    }
  }
statement_208:
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 23) {
      lpion(nnn, irun) = 21;
    }
  }
  // C KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
  ntry1 = 0;
statement_127:
  bbkaon(cmn, ic, srt, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_127;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  // C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
  // C NUCLEUS CMS. FRAME
  // C (1) for the necleon/delta
  // C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  lbi1 = lb(i1);
  // C (2) for the lambda/sigma
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lbi2 = lb(i2);
  // C GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(aka) + fem::pow2(ppx) + fem::pow2(ppy) +
                   fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008
  // C2003        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2003
  // C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  // C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  // C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  // C assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the
  // C leadng particle behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lbi1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lbi2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  goto statement_90005;
// C FOR THE NN-->Delta+Delta+rho PROCESS, FIND MOMENTUM OF THE FINAL
// C PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_307:
  ntry1 = 0;
statement_125:
  ddrho(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
        amrho, icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_125;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  arho = amrho;
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  // C (1) FOR P+P
  xdir = ranart(nseed);
  if (lb(i1) * lb(i2) == 1) {
    if (xdir <= 0.2f) {
      // C (1.1)P+P-->D+++D0+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 7;
      goto statement_2051;
    }
    // C (1.2)P+P -->D++D+rho(0)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_2051;
    }
    // C (1.3)P+P-->D+++D+arho(-)
    if ((xdir <= 0.6f) && (xdir > 0.4f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_2051;
    }
    if ((xdir <= 0.8f) && (xdir > 0.6f)) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 6;
      goto statement_2051;
    }
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
  }
  // C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    if (xdir <= 0.2f) {
      // C (2.1)N+N-->D++D-+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 6;
      lb(i2) = 7;
      goto statement_2051;
    }
    // C (2.2)N+N -->D+++D-+rho(-)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_2051;
    }
    // C (2.3)P+P-->D0+D-+rho(+)
    if ((xdir > 0.4f) && (xdir <= 0.6f)) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_2051;
    }
    // C (2.4)P+P-->D0+D0+rho(0)
    if ((xdir > 0.6f) && (xdir <= 0.8f)) {
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 7;
      goto statement_2051;
    }
    // C (2.5)P+P-->D0+D++rho(-)
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
  }
  // C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    if (xdir <= 0.17f) {
      // C (3.1)N+P-->D+++D-+rho(0)
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_2051;
    }
    // C (3.2)N+P -->D+++D0+rho(-)
    if ((xdir <= 0.34f) && (xdir > 0.17f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 9;
      goto statement_2051;
    }
    // C (3.3)N+P-->D++D-+rho(+)
    if ((xdir > 0.34f) && (xdir <= 0.51f)) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
    // C (3.4)N+P-->D++D++rho(-)
    if ((xdir > 0.51f) && (xdir <= 0.68f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_2051;
    }
    // C (3.5)N+P-->D0+D++rho(0)
    if ((xdir > 0.68f) && (xdir <= 0.85f)) {
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
    // C (3.6)N+P-->D0+D0+rho(+)
    if (xdir > 0.85f) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 7;
    }
  }
// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
// C NUCLEUS CMS. FRAME
// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_2051:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  // C
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 25) {
      lpion(nnn, irun) = 27;
    } else if (lpion(nnn, irun) == 27) {
      lpion(nnn, irun) = 25;
    }
  }
  // C
  lb1 = lb(i1);
  // C FOR DELTA2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  // C assign delta1 and delta2 to i1 or i2 to keep the leadng particle
  // C behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 44;
  // C GET rho'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008:
  // C2004        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2004
  // C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  // C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  // C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  goto statement_90005;
// C FOR THE NN-->N+N+rho PROCESS, FIND MOMENTUM OF THE FINAL
// C PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_308:
  ntry1 = 0;
statement_126:
  pprho(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
        amrho, icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_126;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  arho = amrho;
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  // C (1) FOR P+P
  xdir = ranart(nseed);
  if (lb(i1) * lb(i2) == 1) {
    if (xdir <= 0.5f) {
      // C (1.1)P+P-->P+P+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 1;
      goto statement_2052;
    } else {
      // C (1.2)P+P -->p+n+rho(+)
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 2;
      goto statement_2052;
    }
  }
  // C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    if (xdir <= 0.5f) {
      // C (2.1)N+N-->N+N+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 2;
      lb(i2) = 2;
      goto statement_2052;
    } else {
      // C (2.2)N+N -->N+P+rho(-)
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 2;
      goto statement_2052;
    }
  }
  // C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    if (xdir <= 0.33f) {
      // C (3.1)N+P-->N+P+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 2;
      goto statement_2052;
      // C (3.2)N+P -->P+P+rho(-)
    } else if ((xdir <= 0.67f) && (xdir > 0.34f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 1;
      goto statement_2052;
    } else {
      // C (3.3)N+P-->N+N+rho(+)
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 2;
      lb(i2) = 2;
      goto statement_2052;
    }
  }
// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
// C NUCLEUS CMS. FRAME
// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_2052:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  // C
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 25) {
      lpion(nnn, irun) = 27;
    } else if (lpion(nnn, irun) == 27) {
      lpion(nnn, irun) = 25;
    }
  }
  // C
  lb1 = lb(i1);
  // C FOR p2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  // C assign p1 and p2 to i1 or i2 to keep the leadng particle
  // C behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 45;
  // C GET rho'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008:
  // C2005        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2005
  // C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  // C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  // C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  goto statement_90005;
// C FOR THE NN-->p+p+omega PROCESS, FIND MOMENTUM OF THE FINAL
// C PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_309:
  ntry1 = 0;
statement_138:
  ppomga(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_138;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  aomega = 0.782f;
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  // C (1) FOR P+P
  if (lb(i1) * lb(i2) == 1) {
    // C (1.1)P+P-->P+P+omega(0)
    lpion(nnn, irun) = 28;
    epion(nnn, irun) = aomega;
    lb(i1) = 1;
    lb(i2) = 1;
    goto statement_2053;
  }
  // C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    // C (2.1)N+N-->N+N+omega(0)
    lpion(nnn, irun) = 28;
    epion(nnn, irun) = aomega;
    lb(i1) = 2;
    lb(i2) = 2;
    goto statement_2053;
  }
  // C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    // C (3.1)N+P-->N+P+omega(0)
    lpion(nnn, irun) = 28;
    epion(nnn, irun) = aomega;
    lb(i1) = 1;
    lb(i2) = 2;
    goto statement_2053;
  }
// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
// C NUCLEUS CMS. FRAME
// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_2053:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
  }
  lb1 = lb(i1);
  // C FOR DELTA2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  // C assign delta1 and delta2 to i1 or i2 to keep the leadng particle
  // C behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 46;
  // C GET omega'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008:
  // C2006        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2006
  // C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  // C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  // C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  goto statement_90005;
// C change phase space density FOR NUCLEONS AFTER THE PROCESS
// C
// Clin-10/25/02-comment out following, since there is no path to it:
// Clin-8/16/02 used before set
// C     IX1,IY1,IZ1,IPX1,IPY1,IPZ1, IX2,IY2,IZ2,IPX2,IPY2,IPZ2:
// C                if ((abs(ix1).le.mx) .and. (abs(iy1).le.my) .and.
// C     &              (abs(iz1).le.mz)) then
// C                  ipx1p = nint(p(1,i1)/dpx)
// C                  ipy1p = nint(p(2,i1)/dpy)
// C                  ipz1p = nint(p(3,i1)/dpz)
// C                  if ((ipx1p.ne.ipx1) .or. (ipy1p.ne.ipy1) .or.
// C     &                (ipz1p.ne.ipz1)) then
// C                    if ((abs(ipx1).le.mpx) .and. (abs(ipy1).le.my)
// C     &                .and. (ipz1.ge.-mpz) .and. (ipz1.le.mpzp))
// C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) =
// C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) - 1.
// C                    if ((abs(ipx1p).le.mpx) .and. (abs(ipy1p).le.my)
// C     &                .and. (ipz1p.ge.-mpz).and. (ipz1p.le.mpzp))
// C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) =
// C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) + 1.
// C                  end if
// C                end if
// C                if ((abs(ix2).le.mx) .and. (abs(iy2).le.my) .and.
// C     &              (abs(iz2).le.mz)) then
// C                  ipx2p = nint(p(1,i2)/dpx)
// C                  ipy2p = nint(p(2,i2)/dpy)
// C                  ipz2p = nint(p(3,i2)/dpz)
// C                  if ((ipx2p.ne.ipx2) .or. (ipy2p.ne.ipy2) .or.
// C     &                (ipz2p.ne.ipz2)) then
// C                    if ((abs(ipx2).le.mpx) .and. (abs(ipy2).le.my)
// C     &                .and. (ipz2.ge.-mpz) .and. (ipz2.le.mpzp))
// C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) =
// C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) - 1.
// C                    if ((abs(ipx2p).le.mpx) .and. (abs(ipy2p).le.my)
// C     &                .and. (ipz2p.ge.-mpz) .and. (ipz2p.le.mpzp))
// C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) =
// C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) + 1.
// C                  end if
// C                end if
// Clin-10/25/02-end
// C
statement_90005:
  return;
// C-----------------------------------------------------------------------
// CCOM: SET THE NEW MOMENTUM COORDINATES
statement_107:
  if (px == 0.0f && py == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py, px);
  }
  s1 = 1.0f - fem::pow2(c1);
  if (s1 <= 0) {
    s1 = 0;
  }
  s1 = fem::sqrt(s1);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck3: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  // C       S2  =  SQRT( 1.0 - C2**2 )
  // C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
  ss = c2 * s1 * ct1 + s2 * c1;
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
}

struct rhores_save {
  float dm;
  double e10;
  double e20;
  double p1;
  double p2;
  double p3;
  double scheck;

  rhores_save()
      : dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0) {}
};

// C---------------------------------------------------------------------------
// C PURPOSE : CALCULATE THE MASS AND MOMENTUM OF RHO RESONANCE
// C           AFTER PION + PION COLLISION
// C DATE    : NOV. 30,1994
void rhores(common& cmn, int const& i1, int const& i2) {
  FEM_CMN_SVE(rhores);
  common_write write(cmn);
  // COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON cc
  arr_ref<float> e(cmn.e, dimension(maxstr));
  //
  // SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  //
  // Clin-9/2012: improve precision for argument in sqrt():
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // C 1. DETERMINE THE MOMENTUM COMPONENT OF THE RHO IN THE CMS OF NN FRAME
  // C    WE LET I1 TO BE THE RHO AND ABSORB I2
  // Clin-9/2012: improve precision for argument in sqrt():
  // C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  // C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  // C
  p(1, i1) += p(1, i2);
  p(2, i1) += p(2, i2);
  p(3, i1) += p(3, i2);
  // C 2. DETERMINE THE MASS OF THE RHO BY USING THE REACTION KINEMATICS
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck18: ", scheck;
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  // C        DM=SQRT((E10+E20)**2-P(1,I1)**2-P(2,I1)**2-P(3,I1)**2)
  // C
  e(i1) = dm;
  e(i2) = 0;
}

struct bbarfs_save {
  int i;
  int ifs;
  float rd;
  float rd1;
  float rd2;
  float wsum;

  bbarfs_save()
      : i(fem::int0),
        ifs(fem::int0),
        rd(fem::float0),
        rd1(fem::float0),
        rd2(fem::float0),
        wsum(fem::float0) {}
};

// C
// C****************************************
// C Generate final states for mm-->Bbar B *
void bbarfs(common& cmn, int& lbb1, int& lbb2, float& ei1, float& ei2,
            int& iblock, int const& /* iseed */) {
  FEM_CMN_SVE(bbarfs);
  arr_cref<float, 2> ppbm(cmn.ppbm, dimension(15, 2));
  arr_cref<float> weight(cmn.weight, dimension(15));
  int& nseed = cmn.nseed;
  //
  int& i = sve.i;
  int& ifs = sve.ifs;
  float& rd = sve.rd;
  float& rd1 = sve.rd1;
  float& rd2 = sve.rd2;
  float& wsum = sve.wsum;
  // C****************************************
  // Cc      SAVE /ppbmas/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  // C     determine which final BbarB channel occurs:
  rd = ranart(nseed);
  wsum = 0.f;
  FEM_DO_SAFE(i, 1, cmn.nstate) {
    wsum += weight(i);
    if (rd <= (wsum / cmn.wtot)) {
      ifs = i;
      ei1 = ppbm(i, 1);
      ei2 = ppbm(i, 2);
      goto statement_10;
    }
  }
statement_10:
  // C
  // C1    pbar p
  if (ifs == 1) {
    iblock = 1801;
    lbb1 = -1;
    lbb2 = 1;
  } else if (ifs == 2) {
    // C2    pbar n
    if (ranart(nseed) <= 0.5f) {
      iblock = 18021;
      lbb1 = -1;
      lbb2 = 2;
      // C2    nbar p
    } else {
      iblock = 18022;
      lbb1 = 1;
      lbb2 = -2;
    }
    // C3    nbar n
  } else if (ifs == 3) {
    iblock = 1803;
    lbb1 = -2;
    lbb2 = 2;
    // C4&5  (pbar nbar) Delta, (p n) anti-Delta
  } else if (ifs == 4 || ifs == 5) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      // C     (pbar nbar) Delta
      if (ifs == 4) {
        iblock = 18041;
        lbb1 = -1;
      } else {
        iblock = 18051;
        lbb1 = -2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.25f) {
        lbb2 = 6;
      } else if (rd2 <= 0.5f) {
        lbb2 = 7;
      } else if (rd2 <= 0.75f) {
        lbb2 = 8;
      } else {
        lbb2 = 9;
      }
    } else {
      // C     (p n) anti-Delta
      if (ifs == 4) {
        iblock = 18042;
        lbb1 = 1;
      } else {
        iblock = 18052;
        lbb1 = 2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.25f) {
        lbb2 = -6;
      } else if (rd2 <= 0.5f) {
        lbb2 = -7;
      } else if (rd2 <= 0.75f) {
        lbb2 = -8;
      } else {
        lbb2 = -9;
      }
    }
    // C6&7  (pbar nbar) N*(1440), (p n) anti-N*(1440)
  } else if (ifs == 6 || ifs == 7) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      // C     (pbar nbar) N*(1440)
      if (ifs == 6) {
        iblock = 18061;
        lbb1 = -1;
      } else {
        iblock = 18071;
        lbb1 = -2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = 10;
      } else {
        lbb2 = 11;
      }
    } else {
      // C     (p n) anti-N*(1440)
      if (ifs == 6) {
        iblock = 18062;
        lbb1 = 1;
      } else {
        iblock = 18072;
        lbb1 = 2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = -10;
      } else {
        lbb2 = -11;
      }
    }
    // C8    Delta anti-Delta
  } else if (ifs == 8) {
    iblock = 1808;
    rd1 = ranart(nseed);
    if (rd1 <= 0.25f) {
      lbb1 = 6;
    } else if (rd1 <= 0.5f) {
      lbb1 = 7;
    } else if (rd1 <= 0.75f) {
      lbb1 = 8;
    } else {
      lbb1 = 9;
    }
    rd2 = ranart(nseed);
    if (rd2 <= 0.25f) {
      lbb2 = -6;
    } else if (rd2 <= 0.5f) {
      lbb2 = -7;
    } else if (rd2 <= 0.75f) {
      lbb2 = -8;
    } else {
      lbb2 = -9;
    }
    // C9&10 (pbar nbar) N*(1535), (p n) anti-N*(1535)
  } else if (ifs == 9 || ifs == 10) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      // C     (pbar nbar) N*(1440)
      if (ifs == 9) {
        iblock = 18091;
        lbb1 = -1;
      } else {
        iblock = 18101;
        lbb1 = -2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = 12;
      } else {
        lbb2 = 13;
      }
    } else {
      // C     (p n) anti-N*(1535)
      if (ifs == 9) {
        iblock = 18092;
        lbb1 = 1;
      } else {
        iblock = 18102;
        lbb1 = 2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = -12;
      } else {
        lbb2 = -13;
      }
    }
    // C11&12 anti-Delta N*, Delta anti-N*
  } else if (ifs == 11 || ifs == 12) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      // C     anti-Delta N*
      rd1 = ranart(nseed);
      if (rd1 <= 0.25f) {
        lbb1 = -6;
      } else if (rd1 <= 0.5f) {
        lbb1 = -7;
      } else if (rd1 <= 0.75f) {
        lbb1 = -8;
      } else {
        lbb1 = -9;
      }
      if (ifs == 11) {
        iblock = 18111;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = 10;
        } else {
          lbb2 = 11;
        }
      } else {
        iblock = 18121;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = 12;
        } else {
          lbb2 = 13;
        }
      }
    } else {
      // C     Delta anti-N*
      rd1 = ranart(nseed);
      if (rd1 <= 0.25f) {
        lbb1 = 6;
      } else if (rd1 <= 0.5f) {
        lbb1 = 7;
      } else if (rd1 <= 0.75f) {
        lbb1 = 8;
      } else {
        lbb1 = 9;
      }
      if (ifs == 11) {
        iblock = 18112;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = -10;
        } else {
          lbb2 = -11;
        }
      } else {
        iblock = 18122;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = -12;
        } else {
          lbb2 = -13;
        }
      }
    }
    // C13   N*(1440) anti-N*(1440)
  } else if (ifs == 13) {
    iblock = 1813;
    rd1 = ranart(nseed);
    if (rd1 <= 0.5f) {
      lbb1 = 10;
    } else {
      lbb1 = 11;
    }
    rd2 = ranart(nseed);
    if (rd2 <= 0.5f) {
      lbb2 = -10;
    } else {
      lbb2 = -11;
    }
    // C14   anti-N*(1440) N*(1535), N*(1440) anti-N*(1535)
  } else if (ifs == 14) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      // C     anti-N*(1440) N*(1535)
      iblock = 18141;
      rd1 = ranart(nseed);
      if (rd1 <= 0.5f) {
        lbb1 = -10;
      } else {
        lbb1 = -11;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = 12;
      } else {
        lbb2 = 13;
      }
    } else {
      // C     N*(1440) anti-N*(1535)
      iblock = 18142;
      rd1 = ranart(nseed);
      if (rd1 <= 0.5f) {
        lbb1 = 10;
      } else {
        lbb1 = 11;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = -12;
      } else {
        lbb2 = -13;
      }
    }
    // C15   N*(1535) anti-N*(1535)
  } else if (ifs == 15) {
    iblock = 1815;
    rd1 = ranart(nseed);
    if (rd1 <= 0.5f) {
      lbb1 = 12;
    } else {
      lbb1 = 13;
    }
    rd2 = ranart(nseed);
    if (rd2 <= 0.5f) {
      lbb2 = -12;
    } else {
      lbb2 = -13;
    }
  } else {
  }
  // C
}

// C
// C****************************************
// C for pi pi <-> rho rho final states
void pi2ro2(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // Cc      SAVE /EE/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5) && (lb(i2) >= 3 && lb(i2) <= 5)) {
    iblock = 1850;
    ei1 = 0.77f;
    ei2 = 0.77f;
    // C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    // 2rho) C     thus the cross sections used are considered as the
    // isospin-averaged ones.
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 25 + fem::fint(3 * ranart(nseed));
  } else if ((lb(i1) >= 25 && lb(i1) <= 27) && (lb(i2) >= 25 && lb(i2) <= 27)) {
    iblock = 1851;
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = ap2;
    ei2 = ap2;
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  // C
}

// C
// C****************************************
// C for pi pi <-> eta eta final states
void pi2et2(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // Cc      SAVE /EE/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  const float etam = 0.5475f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5) && (lb(i2) >= 3 && lb(i2) <= 5)) {
    iblock = 1860;
    ei1 = etam;
    ei2 = etam;
    // C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    // 2rho) C     thus the cross sections used are considered as the
    // isospin-averaged ones.
    lbb1 = 0;
    lbb2 = 0;
  } else if (lb(i1) == 0 && lb(i2) == 0) {
    iblock = 1861;
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = ap2;
    ei2 = ap2;
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  // C
}

// C
// C****************************************
// C for pi pi <-> pi eta final states
void pi3eta(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // Cc      SAVE /EE/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  const float ap2 = 0.13957f;
  const float etam = 0.5475f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5) && (lb(i2) >= 3 && lb(i2) <= 5)) {
    iblock = 1870;
    ei1 = ap2;
    ei2 = etam;
    // C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    // 2rho) C     thus the cross sections used are considered as the
    // isospin-averaged ones.
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    lbb2 = 0;
  } else if ((lb(i1) >= 3 && lb(i1) <= 5 && lb(i2) == 0) ||
             (lb(i2) >= 3 && lb(i2) <= 5 && lb(i1) == 0)) {
    iblock = 1871;
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = ap2;
    ei2 = ap2;
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  // C
}

// C
// C****************************************
// C for rho pi <-> rho eta final states
void rpiret(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // Cc      SAVE /EE/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  const float arho = 0.77f;
  const float etam = 0.5475f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 25 && lb(i1) <= 27 && lb(i2) >= 3 && lb(i2) <= 5) ||
      (lb(i1) >= 3 && lb(i1) <= 5 && lb(i2) >= 25 && lb(i2) <= 27)) {
    iblock = 1880;
    ei1 = arho;
    ei2 = etam;
    // C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    // 2rho) C     thus the cross sections used are considered as the
    // isospin-averaged ones.
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 0;
  } else if ((lb(i1) >= 25 && lb(i1) <= 27 && lb(i2) == 0) ||
             (lb(i2) >= 25 && lb(i2) <= 27 && lb(i1) == 0)) {
    iblock = 1881;
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = arho;
    ei2 = ap2;
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  // C
}

// C
// C****************************************
// C for omega pi <-> omega eta final states
void opioet(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // Cc      SAVE /EE/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  const float aomega = 0.782f;
  const float etam = 0.5475f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5 && lb(i2) == 28) ||
      (lb(i2) >= 3 && lb(i2) <= 5 && lb(i1) == 28)) {
    iblock = 1890;
    ei1 = aomega;
    ei2 = etam;
    // C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    // 2rho) C     thus the cross sections used are considered as the
    // isospin-averaged ones.
    lbb1 = 28;
    lbb2 = 0;
  } else if ((lb(i1) == 28 && lb(i2) == 0) || (lb(i1) == 0 && lb(i2) == 28)) {
    iblock = 1891;
    lbb1 = 28;
    lbb2 = 3 + fem::fint(3 * ranart(cmn.nseed));
    ei1 = aomega;
    ei2 = ap2;
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  // C
}

// C
// C****************************************
// C for rho rho <-> eta eta final states
void ro2et2(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // Cc      SAVE /EE/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  const float etam = 0.5475f;
  const float arho = 0.77f;
  if (lb(i1) >= 25 && lb(i1) <= 27 && lb(i2) >= 25 && lb(i2) <= 27) {
    iblock = 1895;
    ei1 = etam;
    ei2 = etam;
    // C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    // 2rho) C     thus the cross sections used are considered as the
    // isospin-averaged ones.
    lbb1 = 0;
    lbb2 = 0;
  } else if (lb(i1) == 0 && lb(i2) == 0) {
    iblock = 1896;
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 25 + fem::fint(3 * ranart(nseed));
    ei1 = arho;
    ei2 = arho;
  }
  // C
}

struct crpp_save {
  float c1;
  float ct1;
  float ei1;
  float ei2;
  float em1;
  float em2;
  int lb1;
  int lb1i;
  int lb2;
  int lb2i;
  int lbb1;
  int lbb2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float ranpi;
  float s1;
  float st1;
  float t1;

  crpp_save()
      : c1(fem::float0),
        ct1(fem::float0),
        ei1(fem::float0),
        ei2(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        lb1(fem::int0),
        lb1i(fem::int0),
        lb2(fem::int0),
        lb2i(fem::int0),
        lbb1(fem::int0),
        lbb2(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        ranpi(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// Clin-5/2008 CRNN over
// C
// C*********************************
// C                                                                      *
// C
void crpp(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& ppel,
          float const& ppin, float const& spprho, int const& ipp) {
  FEM_CMN_SVE(crpp);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& iseed = cmn.iseed;
  float& pprr = cmn.pprr;
  float& ppee = cmn.ppee;
  float& pppe = cmn.pppe;
  float& rpre = cmn.rpre;
  float& xopoe = cmn.xopoe;
  float& rree = cmn.rree;
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& ei1 = sve.ei1;
  float& ei2 = sve.ei2;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  int& lbb1 = sve.lbb1;
  int& lbb2 = sve.lbb2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& ranpi = sve.ranpi;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  const float aka = 0.498f;
  const float aks = 0.895f;
  const float pi = 3.1415926f;
  // C     PURPOSE:                                                         *
  // C             DEALING WITH PION-PION COLLISIONS                        *
  // C     NOTE   :                                                         *
  // C           VALID ONLY FOR PION-PION-DISTANCES LESS THAN 2.5 FM        *
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     6-> Meson+Meson elastic
  // C                     66-> Meson+meson-->K+K-
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /RNDF77/
  // C
  sve.lb1i = lb(i1);
  sve.lb2i = lb(i2);
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  // C-----------------------------------------------------------------------
  // C check Meson+Meson inelastic collisions
  // Clin-9/28/00
  // C        if((srt.gt.1.).and.(ppin/(ppin+ppel).gt.RANART(NSEED)))then
  // C        iblock=66
  // C        e(i1)=0.498
  // C        e(i2)=0.498
  // C        lb(i1)=21
  // C        lb(i2)=23
  // C        go to 10
  // Clin-11/07/00
  // C        if(srt.gt.1.and.(ppin/(ppin+ppel)).gt.RANART(NSEED)) then
  // Clin-4/03/02
  if (srt > (2 * aka) && (ppin / (ppin + ppel)) > ranart(nseed)) {
    // C        if(ppin/(ppin+ppel).gt.RANART(NSEED)) then
    // Clin-10/08/00
    // C
    ranpi = ranart(nseed);
    if ((pprr / ppin) >= ranpi) {
      // C
      // C     1) pi pi <-> rho rho:
      pi2ro2(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
      // C
      // Clin-4/03/02 eta equilibration:
    } else if ((pprr + ppee) / ppin >= ranpi) {
      // C     4) pi pi <-> eta eta:
      pi2et2(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe) / ppin) >= ranpi) {
      // C     5) pi pi <-> pi eta:
      pi3eta(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe + rpre) / ppin) >= ranpi) {
      // C     6) rho pi <-> pi eta:
      rpiret(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe + rpre + xopoe) / ppin) >= ranpi) {
      // C     7) omega pi <-> omega eta:
      opioet(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe + rpre + xopoe + rree) / ppin) >= ranpi) {
      // C     8) rho rho <-> eta eta:
      ro2et2(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
      // Clin-4/03/02-end
      // C
      // C     2) BBbar production:
    } else if (((pprr + ppee + pppe + rpre + xopoe + rree + cmn.ppinnb) /
                ppin) >= ranpi) {
      // C
      bbarfs(cmn, lbb1, lbb2, ei1, ei2, iblock, iseed);
      // C     3) KKbar production:
    } else {
      iblock = 66;
      ei1 = aka;
      ei2 = aka;
      lbb1 = 21;
      lbb2 = 23;
      // Clin-11/07/00 pi rho -> K* Kbar and K*bar K productions:
      lb1 = lb(i1);
      lb2 = lb(i2);
      // Clin-2/13/03 include omega the same as rho, eta the same as pi:
      // C        if(((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.25.and.lb2.le.27))
      // C     1  .or.((lb2.ge.3.and.lb2.le.5).and.(lb1.ge.25.and.lb1.le.27)))
      if (((lb1 == 0 || (lb1 >= 3 && lb1 <= 5)) && (lb2 >= 25 && lb2 <= 28)) ||
          ((lb2 == 0 || (lb2 >= 3 && lb2 <= 5)) && (lb1 >= 25 && lb1 <= 28))) {
        ei1 = aks;
        ei2 = aka;
        if (ranart(nseed) >= 0.5f) {
          iblock = 366;
          lbb1 = 30;
          lbb2 = 21;
        } else {
          iblock = 367;
          lbb1 = -30;
          lbb2 = 23;
        }
      }
      // Clin-11/07/00-end
    }
    // Clin-ppbar-8/25/00
    e(i1) = ei1;
    e(i2) = ei2;
    lb(i1) = lbb1;
    lb(i2) = lbb2;
    // Clin-10/08/00-end
    // C
  } else {
    // Cbzdbg10/15/99
    // C.....for meson+meson elastic srt.le.2Mk, if not pi+pi collision return
    if ((lb(i1) < 3 || lb(i1) > 5) && (lb(i2) < 3 || lb(i2) > 5)) {
      return;
    }
    // Cbzdbg10/15/99 end
    // C
    // C check Meson+Meson elastic collisions
    iblock = 6;
    // C direct process
    if (ipp == 1 || ipp == 4 || ipp == 6) {
      goto statement_10;
    }
    if (spprho / ppel > ranart(nseed)) {
      goto statement_20;
    }
  }
statement_10:
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  // C
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C for isotropic distribution no need to ROTATE THE MOMENTUM
  // C
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
  // C
  return;
statement_20:
  iblock = 666;
  // C treat rho formation in pion+pion collisions
  // C calculate the mass and momentum of rho in the nucleus-nucleus frame
  rhores(cmn, i1, i2);
  if (ipp == 2) {
    lb(i1) = 27;
  }
  if (ipp == 3) {
    lb(i1) = 26;
  }
  if (ipp == 5) {
    lb(i1) = 25;
  }
}

struct denom_save {
  float a1;
  float am0;
  float amax;
  float amin;
  float amn;
  float amp;
  float avpi;
  float dm;
  float dmass;
  float f;
  int i;
  int nmax;
  float p0;
  float p1;
  float q;
  float q2;
  float s;
  float sum;
  float tq;

  denom_save()
      : a1(fem::float0),
        am0(fem::float0),
        amax(fem::float0),
        amin(fem::float0),
        amn(fem::float0),
        amp(fem::float0),
        avpi(fem::float0),
        dm(fem::float0),
        dmass(fem::float0),
        f(fem::float0),
        i(fem::int0),
        nmax(fem::int0),
        p0(fem::float0),
        p1(fem::float0),
        q(fem::float0),
        q2(fem::float0),
        s(fem::float0),
        sum(fem::float0),
        tq(fem::float0) {}
};

// C
// C****************************
float denom(common& cmn, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(denom);
  // SAVE
  float& a1 = sve.a1;
  float& am0 = sve.am0;
  float& amax = sve.amax;
  float& amin = sve.amin;
  float& amn = sve.amn;
  float& amp = sve.amp;
  float& avpi = sve.avpi;
  float& dm = sve.dm;
  float& dmass = sve.dmass;
  float& f = sve.f;
  int& i = sve.i;
  int& nmax = sve.nmax;
  float& p0 = sve.p0;
  float& p1 = sve.p1;
  float& q = sve.q;
  float& q2 = sve.q2;
  float& s = sve.s;
  float& sum = sve.sum;
  float& tq = sve.tq;
  //
  // C NOTE: CON=1 FOR DELTA RESONANCE, CON=2 FOR N*(1440) RESONANCE
  // C       con=-1 for N*(1535)
  // C PURPOSE : CALCULATE THE INTEGRAL IN THE DETAILED BALANCE
  // C
  // C DATE : NOV. 15, 1991
  // C******************************
  const float ap1 = 0.13496f;
  const float ap2 = 0.13957f;
  avpi = (ap1 + 2.f * ap2) / 3.f;
  am0 = 1.232f;
  const float avmass = 0.9383f;
  amn = avmass;
  amp = avpi;
  amax = srt - avmass;
  amin = avmass + avpi;
  nmax = 200;
  dmass = (amax - amin) / fem::ffloat(nmax);
  sum = 0.f;
  FEM_DO_SAFE(i, 1, nmax + 1) {
    dm = amin + fem::ffloat(i - 1) * dmass;
    if (con == 1.f) {
      q2 = fem::pow2(((fem::pow2(dm) - fem::pow2(amn) + fem::pow2(amp)) /
                      (2.f * dm))) -
           fem::pow2(amp);
      if (q2 > 0.f) {
        q = fem::sqrt(q2);
      } else {
        q = 1.e-06f;
      }
      tq = 0.47f * (fem::pow3(q)) /
           (fem::pow2(amp) * (1.f + 0.6f * fem::pow2((q / amp))));
    } else if (con == 2) {
      tq = 0.2f;
      am0 = 1.44f;
    } else if (con == -1.f) {
      tq = 0.1f;
      am0 = 1.535f;
    }
    a1 = 4.f * tq * fem::pow2(am0) /
         (fem::pow2(am0) * fem::pow2(tq) +
          fem::pow2((fem::pow2(dm) - fem::pow2(am0))));
    s = fem::pow2(srt);
    p0 = fem::pow2((s + fem::pow2(dm) - fem::pow2(amn))) / (4.f * s) -
         fem::pow2(dm);
    if (p0 <= 0.f) {
      p1 = 1.e-06f;
    } else {
      p1 = fem::sqrt(p0);
    }
    f = dm * a1 * p1;
    if ((i == 1) || (i == (nmax + 1))) {
      sum += f * 0.5f;
    } else {
      sum += f;
    }
  }
  const float pi = 3.1415926f;
  return_value = sum * dmass / (2.f * pi);
  return return_value;
}

struct m1535_save {
  float s0;
  float sigma;

  m1535_save() : s0(fem::float0), sigma(fem::float0) {}
};

// C
// C************************
// C cross section for N*(1535) production in ND OR NN* collisions
// C VARIABLES:
// C LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
// C SRT IS THE CMS ENERGY
// C X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
// C NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA
// C PRODUCTION CROSS SECTION
// C DATE: MAY 18, 1994
// C ***********************
void m1535(common& cmn, int const& lb1, int const& lb2, float const& srt,
           float& x1535) {
  FEM_CMN_SVE(m1535);
  // SAVE
  float& s0 = sve.s0;
  float& sigma = sve.sigma;
  //
  s0 = 2.424f;
  x1535 = 0.f;
  if (srt <= s0) {
    return;
  }
  sigma = 2.f * 0.102f * (srt - s0) / (0.058f + fem::pow2((srt - s0)));
  // C I N*(1535) PRODUCTION IN NUCLEON-DELTA COLLISIONS
  // C(1) nD(++)->pN*(+)(1535), pD(-)->nN*(0)(1535),pD(+)-->N*(+)p
  // Cbz11/25/98
  // C       IF((LB1*LB2.EQ.18).OR.(LB1*LB2.EQ.6).
  // C     1  or.(lb1*lb2).eq.8)then
  if ((lb1 * lb2 == 18 && (lb1 == 2 || lb2 == 2)) ||
      (lb1 * lb2 == 6 && (lb1 == 1 || lb2 == 1)) ||
      (lb1 * lb2 == 8 && (lb1 == 1 || lb2 == 1))) {
    // Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  // C(2) pD(0)->pN*(0)(1535),pD(0)->nN*(+)(1535)
  if (lb1 * lb2 == 7) {
    x1535 = 3.f * sigma;
    return;
  }
  // C II N*(1535) PRODUCTION IN N*(1440)+NUCLEON REACTIONS
  // C(3) N*(+)(1440)p->N*(0+)(1535)p, N*(0)(1440)n->N*(0)(1535)
  // Cbz11/25/98
  // C       IF((LB1*LB2.EQ.11).OR.(LB1*LB2.EQ.20))THEN
  if ((lb1 * lb2 == 11) || (lb1 * lb2 == 20 && (lb1 == 2 || lb2 == 2))) {
    // Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  // C(4) N*(0)(1440)p->N*(0+) or N*(+)(1440)n->N*(0+)(1535)
  // Cbz11/25/98
  // C       IF((LB1*LB2.EQ.10).OR.(LB1*LB2.EQ.22))X1535=3.*SIGMA
  if ((lb1 * lb2 == 10 && (lb1 == 1 || lb2 == 1)) ||
      (lb1 * lb2 == 22 && (lb1 == 2 || lb2 == 2))) {
    x1535 = 3.f * sigma;
  }
  // Cbz11/25/98end
}

struct crnd_save {
  static const int npdmax = 10000;

  float a;
  float am1;
  float am2;
  float as;
  float c1;
  float c2;
  float cc1;
  float ct1;
  float ct2;
  float deltam;
  float dm;
  float dm3;
  float dm4;
  float dmax;
  float dmin;
  float dprob1;
  float e1cm;
  float e1dcm;
  float e2cm;
  float e2picm;
  float epcm;
  float eti1;
  float eti2;
  float fm;
  int ianti;
  int ic;
  int icou1;
  int id1;
  int idloop;
  int ipertd;
  int lbd;
  int lbi1;
  int lbi2;
  int lbm;
  arr<int> lbpd;
  int m12;
  int n12;
  int ndloop;
  int ntag;
  int ntry1;
  int ntry2;
  float p1beta;
  float p1dbeta;
  float p2beta;
  float p2pibeta;
  float pf2;
  float pfinal;
  float ppbeta;
  arr<float, 2> ppd;
  float ppx;
  float ppy;
  float ppz;
  float pr;
  float prf;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px3;
  float px4;
  float pxd;
  float pxi1;
  float pxi2;
  float py3;
  float py4;
  float pyd;
  float pyi1;
  float pyi2;
  float pz2;
  float pz3;
  float pz4;
  float pzd;
  float pzi1;
  float pzi2;
  float renom;
  float renom1;
  float renomn;
  float s1;
  float s2;
  float scheck;
  float sdprod;
  float sigdn;
  float signd;
  float ss;
  float st1;
  float st2;
  float t1;
  float t2;
  float ta;
  float transf;
  float x;
  float x1;
  float x1440;
  float x1535;
  float xdmass;
  float xmass;
  float xmm;
  float xptr;

  crnd_save()
      : a(fem::float0),
        am1(fem::float0),
        am2(fem::float0),
        as(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        deltam(fem::float0),
        dm(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        dprob1(fem::float0),
        e1cm(fem::float0),
        e1dcm(fem::float0),
        e2cm(fem::float0),
        e2picm(fem::float0),
        epcm(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fm(fem::float0),
        ianti(fem::int0),
        ic(fem::int0),
        icou1(fem::int0),
        id1(fem::int0),
        idloop(fem::int0),
        ipertd(fem::int0),
        lbd(fem::int0),
        lbi1(fem::int0),
        lbi2(fem::int0),
        lbm(fem::int0),
        lbpd(dimension(npdmax), fem::fill0),
        m12(fem::int0),
        n12(fem::int0),
        ndloop(fem::int0),
        ntag(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        p1beta(fem::float0),
        p1dbeta(fem::float0),
        p2beta(fem::float0),
        p2pibeta(fem::float0),
        pf2(fem::float0),
        pfinal(fem::float0),
        ppbeta(fem::float0),
        ppd(dimension(3, npdmax), fem::fill0),
        ppx(fem::float0),
        ppy(fem::float0),
        ppz(fem::float0),
        pr(fem::float0),
        prf(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px3(fem::float0),
        px4(fem::float0),
        pxd(fem::float0),
        pxi1(fem::float0),
        pxi2(fem::float0),
        py3(fem::float0),
        py4(fem::float0),
        pyd(fem::float0),
        pyi1(fem::float0),
        pyi2(fem::float0),
        pz2(fem::float0),
        pz3(fem::float0),
        pz4(fem::float0),
        pzd(fem::float0),
        pzi1(fem::float0),
        pzi2(fem::float0),
        renom(fem::float0),
        renom1(fem::float0),
        renomn(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        scheck(fem::float0),
        sdprod(fem::float0),
        sigdn(fem::float0),
        signd(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t2(fem::float0),
        ta(fem::float0),
        transf(fem::float0),
        x(fem::float0),
        x1(fem::float0),
        x1440(fem::float0),
        x1535(fem::float0),
        xdmass(fem::float0),
        xmass(fem::float0),
        xmm(fem::float0),
        xptr(fem::float0) {}
};

const int crnd_save::npdmax;

// C*********************************
// C                                                                      *
void crnd(common& cmn, int const& irun, float& px, float& py, float& pz,
          float const& srt, int const& i1, int const& i2, int& iblock,
          float const& signn, float const& sig, float const& sigk,
          float const& xsk1, float const& xsk2, float const& xsk3,
          float const& xsk4, float const& xsk5, int const& nt,
          int const& ipert1) {
  FEM_CMN_SVE(crnd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nnn = cmn.nnn;
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& iseed = cmn.iseed;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  //
  float& a = sve.a;
  float& as = sve.as;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& deltam = sve.deltam;
  float& dm = sve.dm;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& dprob1 = sve.dprob1;
  float& e1cm = sve.e1cm;
  float& e1dcm = sve.e1dcm;
  float& e2cm = sve.e2cm;
  float& e2picm = sve.e2picm;
  float& epcm = sve.epcm;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fm = sve.fm;
  int& ianti = sve.ianti;
  int& ic = sve.ic;
  int& icou1 = sve.icou1;
  int& id1 = sve.id1;
  int& idloop = sve.idloop;
  int& ipertd = sve.ipertd;
  int& lbd = sve.lbd;
  int& lbi1 = sve.lbi1;
  int& lbi2 = sve.lbi2;
  int& lbm = sve.lbm;
  const int npdmax = 10000;
  arr_ref<int> lbpd(sve.lbpd, dimension(npdmax));
  int& m12 = sve.m12;
  int& ndloop = sve.ndloop;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& p1beta = sve.p1beta;
  float& p1dbeta = sve.p1dbeta;
  float& p2beta = sve.p2beta;
  float& p2pibeta = sve.p2pibeta;
  float& pf2 = sve.pf2;
  float& pfinal = sve.pfinal;
  float& ppbeta = sve.ppbeta;
  arr_ref<float, 2> ppd(sve.ppd, dimension(3, npdmax));
  float& ppx = sve.ppx;
  float& ppy = sve.ppy;
  float& ppz = sve.ppz;
  float& pr = sve.pr;
  float& prf = sve.prf;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px3 = sve.px3;
  float& px4 = sve.px4;
  float& pxd = sve.pxd;
  float& pxi1 = sve.pxi1;
  float& pxi2 = sve.pxi2;
  float& py3 = sve.py3;
  float& py4 = sve.py4;
  float& pyd = sve.pyd;
  float& pyi1 = sve.pyi1;
  float& pyi2 = sve.pyi2;
  float& pz2 = sve.pz2;
  float& pz3 = sve.pz3;
  float& pz4 = sve.pz4;
  float& pzd = sve.pzd;
  float& pzi1 = sve.pzi1;
  float& pzi2 = sve.pzi2;
  float& renom = sve.renom;
  float& renom1 = sve.renom1;
  float& renomn = sve.renomn;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& scheck = sve.scheck;
  float& sdprod = sve.sdprod;
  float& sigdn = sve.sigdn;
  float& signd = sve.signd;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t2 = sve.t2;
  float& ta = sve.ta;
  float& transf = sve.transf;
  float& x = sve.x;
  float& x1 = sve.x1;
  float& x1440 = sve.x1440;
  float& x1535 = sve.x1535;
  float& xdmass = sve.xdmass;
  float& xmass = sve.xmass;
  float& xmm = sve.xmm;
  float& xptr = sve.xptr;
  const float pi = 3.1415926f;
  const float avmass = 0.9383f;
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  const float aka = 0.498f;
  const float xmd = 1.8756f;
  // C     PURPOSE:                                                         *
  // C             DEALING WITH NUCLEON-BARYON RESONANCE COLLISIONS         *
  // C     NOTE   :                                                         *
  // C           VALID ONLY FOR BARYON-BARYON-DISTANCES LESS THAN 1.32 FM   *
  // C           (1.32 = 2 * HARD-CORE-RADIUS [HRC] )                       *
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  // C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      0-> COLLISION CANNOT HAPPEN                     *
  // C                      1-> N-N ELASTIC COLLISION                       *
  // C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  // C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  // C                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
  // C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  // C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  // C                      N12,                                            *
  // C                      M12=1 FOR p+n-->delta(+)+ n                     *
  // C                          2     p+n-->delta(0)+ p                     *
  // C                          3     p+p-->delta(++)+n                     *
  // C                          4     p+p-->delta(+)+p                      *
  // C                          5     n+n-->delta(0)+n                      *
  // C                          6     n+n-->delta(-)+p                      *
  // C                          7     n+p-->N*(0)(1440)+p                   *
  // C                          8     n+p-->N*(+)(1440)+n                   *
  // C                        9     p+p-->N*(+)(1535)+p                     *
  // C                        10    n+n-->N*(0)(1535)+n                     *
  // C                         11    n+p-->N*(+)(1535)+n                     *
  // C                        12    n+p-->N*(0)(1535)+p
  // C                        13    D(++)+D(-)-->N*(+)(1440)+n
  // C                         14    D(++)+D(-)-->N*(0)(1440)+p
  // C                        15    D(+)+D(0)--->N*(+)(1440)+n
  // C                        16    D(+)+D(0)--->N*(0)(1440)+p
  // C                        17    D(++)+D(0)-->N*(+)(1535)+p
  // C                        18    D(++)+D(-)-->N*(0)(1535)+p
  // C                        19    D(++)+D(-)-->N*(+)(1535)+n
  // C                        20    D(+)+D(+)-->N*(+)(1535)+p
  // C                        21    D(+)+D(0)-->N*(+)(1535)+n
  // C                        22    D(+)+D(0)-->N*(0)(1535)+p
  // C                        23    D(+)+D(-)-->N*(0)(1535)+n
  // C                        24    D(0)+D(0)-->N*(0)(1535)+n
  // C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  // C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  // C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  // C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  // C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  // C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  // C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  // C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  // C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  // C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  // C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  // C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  // C                        ++    see the note book for more listing
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /BG/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /input1/
  // Cc      SAVE /leadng/
  // Cc      SAVE /RNDF77/
  // C-----------------------------------------------------------------------
  sve.n12 = 0;
  m12 = 0;
  iblock = 0;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  c2 = pz / pr;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 && lb(i2) < 0) {
    ianti = 1;
  }
  // C
  // Clin-6/2008 Production of perturbative deuterons for idpert=1:
  sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
  if (idpert == 1 && ipert1 == 1) {
    if (srt < 2.012f) {
      return;
    }
    if ((fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i1)) == 2) &&
        (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
      goto statement_108;
    } else if ((fem::iabs(lb(i2)) == 1 || fem::iabs(lb(i2)) == 2) &&
               (fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13)) {
      goto statement_108;
    } else {
      return;
    }
  }
  // C-----------------------------------------------------------------------
  // CCOM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
  // C      N-DELTA OR N*-N* or N*-Delta)
  if (x1 <= signn / sig) {
    // CCOM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
    as = fem::pow((3.65f * (srt - 1.8766f)), 6);
    a = 6.0f * as / (1.0f + as);
    ta = -2.0f * fem::pow2(pr);
    x = ranart(nseed);
    // Clin-10/24/02        T1  = ALOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /
    // A
    t1 = fem::sngl(fem::dlog(fem::dble(1.f - x) *
                                 fem::dexp(fem::dble(a) * fem::dble(ta)) +
                             fem::dble(x))) /
         a;
    c1 = 1.0f - t1 / ta;
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 1;
    goto statement_107;
  } else {
    // CCOM: TEST FOR INELASTIC SCATTERING
    // C     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
    // C     CAN HAPPEN ANY MORE ==> RETURN (2.04 = 2*AVMASS + PI-MASS+0.02)
    if (srt < 2.04f) {
      return;
    }
    // Clin-6/2008 add d+meson production for n*N*(0)(1440) and p*N*(+)(1440)
    // channels C     (they did not have any inelastic reactions before):
    if (((fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2) &&
         (lb(i1) * lb(i2)) == 20) ||
        (lb(i1) * lb(i2)) == 13) {
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
    }
    // C
    // C Resonance absorption or Delta + N-->N*(1440), N*(1535)
    // C COM: TEST FOR DELTA OR N* ABSORPTION
    // C      IN THE PROCESS DELTA+N-->NN, N*+N-->NN
    prf = fem::sqrt(0.25f * fem::pow2(srt) - fem::pow2(avmass));
    if (em1 > 1.f) {
      deltam = em1;
    } else {
      deltam = em2;
    }
    renom = deltam * fem::pow2(prf) / denom(cmn, srt, 1.f) / pr;
    renomn = deltam * fem::pow2(prf) / denom(cmn, srt, 2.f) / pr;
    renom1 = deltam * fem::pow2(prf) / denom(cmn, srt, -1.f) / pr;
    // C avoid the inelastic collisions between n+delta- -->N+N
    // C       and p+delta++ -->N+N due to charge conservation,
    // C       but they can scatter to produce kaons
    if ((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) {
      renom = 0.f;
    }
    if ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) {
      renom = 0.f;
    }
    if ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) {
      renom = 0.f;
    }
    if ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9)) {
      renom = 0.f;
    }
    m1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
    x1440 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    // C CROSS SECTION FOR KAON PRODUCTION from the four channels
    // C for NLK channel
    // C avoid the inelastic collisions between n+delta- -->N+N
    // C       and p+delta++ -->N+N due to charge conservation,
    // C       but they can scatter to produce kaons
    if (((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) ||
        ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) ||
        ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) ||
        ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9))) {
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C          IF((SIGK+SIGNN)/SIG.GE.X1)GO TO 306
      if ((sigk + signn + sdprod) / sig >= x1) {
        goto statement_306;
      }
      // C
    }
    // C WE DETERMINE THE REACTION CHANNELS IN THE FOLLOWING
    // C FOR n+delta(++)-->p+p or n+delta(++)-->n+N*(+)(1440),n+N*(+)(1535)
    // C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
    if (lb(i1) * lb(i2) == 18 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      // C REABSORPTION:
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 3;
        goto statement_206;
      } else {
        // C N* PRODUCTION
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          // C N*(1440)
          m12 = 37;
        } else {
          // C N*(1535)       M12=38
          // Clin-2/26/03 why is the above commented out? leads to M12=0 but
          // C     particle mass is changed after 204 (causes energy violation).
          // C     replace by elastic process (return):
          return;
          // C
        }
        goto statement_204;
      }
    }
    // C FOR p+delta(-)-->n+n or p+delta(-)-->n+N*(0)(1440),n+N*(0)(1535)
    // C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
    if (lb(i1) * lb(i2) == 6 &&
        ((fem::iabs(lb(i1)) == 1) || (fem::iabs(lb(i2)) == 1))) {
      signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF (X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      // C REABSORPTION:
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 6;
        goto statement_206;
      } else {
        // C N* PRODUCTION
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          // C N*(1440)
          m12 = 47;
        } else {
          // C N*(1535)       M12=48
          // Clin-2/26/03 causes energy violation, replace by elastic process
          // (return):
          return;
          // C
        }
        goto statement_204;
      }
    }
    // C FOR p+delta(+)-->p+p, N*(+)(144)+p, N*(+)(1535)+p
    if (lb(i1) * lb(i2) == 8 &&
        (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
      signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 4;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          // C N*(144)
          m12 = 39;
        } else {
          m12 = 40;
        }
        goto statement_204;
      }
    }
    // C FOR n+delta(0)-->n+n, N*(0)(144)+n, N*(0)(1535)+n
    if (lb(i1) * lb(i2) == 14 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 5;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          // C N*(144)
          m12 = 48;
        } else {
          m12 = 49;
        }
        goto statement_204;
      }
    }
    // C FOR n+delta(+)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
    // C                       N*(+)(1535)+n,N*(0)(1535)+p
    if (lb(i1) * lb(i2) == 16 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd =
          0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
      sigdn = 0.5f * signd * renom;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK)/SIG)RETURN
      if (x1 >
          (signn + sigdn + 2.f * x1440 + 2.f * x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + 2 * x1440 + 2 * x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + 2.f * x1440 + 2.f * x1535)) {
        m12 = 1;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          m12 = 41;
          if (ranart(nseed) <= 0.5f) {
            m12 = 43;
          }
        } else {
          m12 = 42;
          if (ranart(nseed) <= 0.5f) {
            m12 = 44;
          }
        }
        goto statement_204;
      }
    }
    // C FOR p+delta(0)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
    // C                       N*(+)(1535)+n,N*(0)(1535)+p
    if (lb(i1) * lb(i2) == 7) {
      signd =
          0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
      sigdn = 0.5f * signd * renom;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK)/SIG)RETURN
      if (x1 >
          (signn + sigdn + 2.f * x1440 + 2.f * x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + 2 * x1440 + 2 * x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + 2.f * x1440 + 2.f * x1535)) {
        m12 = 2;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          m12 = 50;
          if (ranart(nseed) <= 0.5f) {
            m12 = 51;
          }
        } else {
          m12 = 52;
          if (ranart(nseed) <= 0.5f) {
            m12 = 53;
          }
        }
        goto statement_204;
      }
    }
    // C FOR p+N*(0)(14)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
    // C OR  P+N*(0)(14)-->D(+)+N, D(0)+P,
    if (lb(i1) * lb(i2) == 10 &&
        (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
      signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      sigdn = signd * renomn;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1535)) {
        m12 = 7;
        goto statement_206;
      } else {
        m12 = 54;
        if (ranart(nseed) <= 0.5f) {
          m12 = 55;
        }
      }
      goto statement_204;
    }
    // C FOR n+N*(+)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
    if (lb(i1) * lb(i2) == 22 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      sigdn = signd * renomn;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1535 + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1535)) {
        m12 = 8;
        goto statement_206;
      } else {
        m12 = 56;
        if (ranart(nseed) <= 0.5f) {
          m12 = 57;
        }
      }
      goto statement_204;
    }
    // C FOR N*(1535)+N-->N+N COLLISIONS
    if ((fem::iabs(lb(i1)) == 12) || (fem::iabs(lb(i1)) == 13) ||
        (fem::iabs(lb(i2)) == 12) || (fem::iabs(lb(i2)) == 13)) {
      signd = x1535;
      sigdn = signd * renom1;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGDN+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + sigk + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (sigk + sigdn) > ranart(nseed)) {
        goto statement_306;
      }
      if (lb(i1) * lb(i2) == 24) {
        m12 = 10;
      }
      if (lb(i1) * lb(i2) == 12) {
        m12 = 12;
      }
      if (lb(i1) * lb(i2) == 26) {
        m12 = 11;
      }
      if (lb(i1) * lb(i2) == 13) {
        m12 = 9;
      }
      goto statement_206;
    }
  statement_204:
    // C (1) GENERATE THE MASS FOR THE N*(1440) AND N*(1535)
    // C (2) CALCULATE THE FINAL MOMENTUM OF THE n+N* SYSTEM
    // C (3) RELABLE THE FINAL STATE PARTICLES
    // CPARAMETRIZATION OF THE SHAPE OF THE N* RESONANCE ACCORDING
    // C     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
    // C     FORMULA FOR N* RESORANCE
    // C     DETERMINE DELTA MASS VIA REJECTION METHOD.
    dmax = srt - avmass - 0.005f;
    dmin = 1.078f;
    if ((m12 == 37) || (m12 == 39) || (m12 == 41) || (m12 == 43) ||
        (m12 == 46) || (m12 == 48) || (m12 == 50) || (m12 == 51)) {
      // C N*(1440) production
      if (dmax < 1.44f) {
        fm = fns(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.44f;
        // C          FM=FNS(1.44,SRT,1.)
        fm = fns(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry2 = 0;
    statement_11:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry2++;
      if ((ranart(nseed) > fns(cmn, dm, srt, 1.f) / fm) && (ntry2 <= 10)) {
        goto statement_11;
      }
      // C
      // Clin-2/26/03 limit the N* mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 2.14f) {
        goto statement_11;
      }
      // C
      goto statement_13;
    } else {
      // C N*(1535) production
      if (dmax < 1.535f) {
        fm = fd5(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.535f;
        // C          FM=FD5(1.535,SRT,1.)
        fm = fd5(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_12:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fd5(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 10)) {
        goto statement_12;
      }
      // C
      // Clin-2/26/03 limit the N* mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.84f) {
        goto statement_12;
      }
      // C
    }
  statement_13:
    // C (2) DETERMINE THE FINAL MOMENTUM
    prf = 0.f;
    pf2 = fem::pow2(((fem::pow2(srt) - fem::pow2(dm) + fem::pow2(avmass)) /
                     (2.f * srt))) -
          fem::pow2(avmass);
    if (pf2 > 0.f) {
      prf = fem::sqrt(pf2);
    }
    // C (3) RELABLE FINAL STATE PARTICLES
    // C 37 D(++)+n-->N*(+)(14)+p
    if (m12 == 37) {
      if (fem::iabs(lb(i1)) == 9) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 38 D(++)+n-->N*(+)(15)+p
    if (m12 == 38) {
      if (fem::iabs(lb(i1)) == 9) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 39 D(+)+P-->N*(+)(14)+p
    if (m12 == 39) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 40 D(+)+P-->N*(+)(15)+p
    if (m12 == 40) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 41 D(+)+N-->N*(+)(14)+N
    if (m12 == 41) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 42 D(+)+N-->N*(+)(15)+N
    if (m12 == 42) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 43 D(+)+N-->N*(0)(14)+P
    if (m12 == 43) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 44 D(+)+N-->N*(0)(15)+P
    if (m12 == 44) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 46 D(-)+P-->N*(0)(14)+N
    if (m12 == 46) {
      if (fem::iabs(lb(i1)) == 6) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 47 D(-)+P-->N*(0)(15)+N
    if (m12 == 47) {
      if (fem::iabs(lb(i1)) == 6) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 48 D(0)+N-->N*(0)(14)+N
    if (m12 == 48) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 49 D(0)+N-->N*(0)(15)+N
    if (m12 == 49) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 50 D(0)+P-->N*(0)(14)+P
    if (m12 == 50) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 51 D(0)+P-->N*(+)(14)+N
    if (m12 == 51) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 52 D(0)+P-->N*(0)(15)+P
    if (m12 == 52) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 53 D(0)+P-->N*(+)(15)+N
    if (m12 == 53) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 54 N*(0)(14)+P-->N*(+)(15)+N
    if (m12 == 54) {
      if (fem::iabs(lb(i1)) == 10) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 55 N*(0)(14)+P-->N*(0)(15)+P
    if (m12 == 55) {
      if (fem::iabs(lb(i1)) == 10) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 56 N*(+)(14)+N-->N*(+)(15)+N
    if (m12 == 56) {
      if (fem::iabs(lb(i1)) == 11) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    // C 57 N*(+)(14)+N-->N*(0)(15)+P
    if (m12 == 57) {
      if (fem::iabs(lb(i1)) == 11) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
    }
    goto statement_207;
  // C------------------------------------------------
  // C RELABLE NUCLEONS AFTER DELTA OR N* BEING ABSORBED
  // C(1) n+delta(+)-->n+p
  statement_206:
    if (m12 == 1) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i2) = 2;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 2;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_207;
    }
    // C(2) p+delta(0)-->p+n
    if (m12 == 2) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i2) = 1;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_207;
    }
    // C(3) n+delta(++)-->p+p
    if (m12 == 3) {
      lb(i1) = 1;
      lb(i2) = 1;
      e(i1) = amp;
      e(i2) = amp;
      goto statement_207;
    }
    // C(4) p+delta(+)-->p+p
    if (m12 == 4) {
      lb(i1) = 1;
      lb(i2) = 1;
      e(i1) = amp;
      e(i2) = amp;
      goto statement_207;
    }
    // C(5) n+delta(0)-->n+n
    if (m12 == 5) {
      lb(i1) = 2;
      lb(i2) = 2;
      e(i1) = amn;
      e(i2) = amn;
      goto statement_207;
    }
    // C(6) p+delta(-)-->n+n
    if (m12 == 6) {
      lb(i1) = 2;
      lb(i2) = 2;
      e(i1) = amn;
      e(i2) = amn;
      goto statement_207;
    }
    // C(7) p+N*(0)-->n+p
    if (m12 == 7) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i1) = 1;
        lb(i2) = 2;
        e(i1) = amp;
        e(i2) = amn;
      } else {
        lb(i1) = 2;
        lb(i2) = 1;
        e(i1) = amn;
        e(i2) = amp;
      }
      goto statement_207;
    }
    // C(8) n+N*(+)-->n+p
    if (m12 == 8) {
      if (fem::iabs(lb(i1)) == 2) {
        lb(i1) = 2;
        lb(i2) = 1;
        e(i1) = amn;
        e(i2) = amp;
      } else {
        lb(i1) = 1;
        lb(i2) = 2;
        e(i1) = amp;
        e(i2) = amn;
      }
      goto statement_207;
    }
    // Clin-6/2008
    // C*(9) N*(+)p-->pp
    // C(9) N*(+)(1535) p-->pp
    if (m12 == 9) {
      lb(i1) = 1;
      lb(i2) = 1;
      e(i1) = amp;
      e(i2) = amp;
      goto statement_207;
    }
    // C(12) N*(0)P-->nP
    if (m12 == 12) {
      lb(i1) = 2;
      lb(i2) = 1;
      e(i1) = amn;
      e(i2) = amp;
      goto statement_207;
    }
    // C(11) N*(+)n-->nP
    if (m12 == 11) {
      lb(i1) = 2;
      lb(i2) = 1;
      e(i1) = amn;
      e(i2) = amp;
      goto statement_207;
    }
    // Clin-6/2008
    // C*(12) N*(0)p-->Np
    // C(12) N*(0)(1535) p-->Np
    if (m12 == 12) {
      lb(i1) = 1;
      lb(i2) = 2;
      e(i1) = amp;
      e(i2) = amn;
    }
  // C----------------------------------------------
  statement_207:
    pr = prf;
    c1 = 1.0f - 2.0f * ranart(nseed);
    if (srt <= 2.14f) {
      c1 = 1.0f - 2.0f * ranart(nseed);
    }
    if (srt > 2.14f && srt <= 2.4f) {
      c1 = ang(cmn, srt, iseed);
    }
    if (srt > 2.4f) {
      // C
      // Clin-10/25/02 get rid of argument usage mismatch in PTR():
      xptr = 0.33f * pr;
      // C         cc1=ptr(0.33*pr,iseed)
      cc1 = ptr(cmn, xptr, iseed);
      // Clin-10/25/02-end
      // C
      // Clin-9/2012: check argument in sqrt():
      scheck = fem::pow2(pr) - fem::pow2(cc1);
      if (scheck < 0) {
        write(99, star), "scheck4: ", scheck;
        scheck = 0.f;
      }
      c1 = fem::sqrt(scheck) / pr;
      // C         c1=sqrt(pr**2-cc1**2)/pr
      // C
    }
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 3;
  }
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
  }
// C
// C-----------------------------------------------------------------------
// CCOM: SET THE NEW MOMENTUM COORDINATES
statement_107:
  if (px == 0.0f && py == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py, px);
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c1);
  if (scheck < 0) {
    write(99, star), "scheck5: ", scheck;
    scheck = 0.f;
  }
  s1 = fem::sqrt(scheck);
  // C      S1   = SQRT( 1.0 - C1**2 )
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck6: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  // C      S2  =  SQRT( 1.0 - C2**2 )
  // C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
  ss = c2 * s1 * ct1 + s2 * c1;
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
  return;
// C FOR THE NN-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN
// C THE NUCLEUS-NUCLEUS CMS.
statement_306:
  // Csp11/21/01 phi production
  if (xsk5 / sigk > ranart(nseed)) {
    pz1 = p(3, i1);
    pz2 = p(3, i2);
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    nnn++;
    lpion(nnn, irun) = 29;
    epion(nnn, irun) = aphi;
    iblock = 222;
    goto statement_208;
  }
  // Csp11/21/01 end
  iblock = 11;
  if (ianti == 1) {
    iblock = -11;
  }
  // C
  pz1 = p(3, i1);
  pz2 = p(3, i2);
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  nnn++;
  lpion(nnn, irun) = 23;
  epion(nnn, irun) = aka;
  if (srt <= 2.63f) {
    // C only lambda production is possible
    // C (1.1)P+P-->p+L+kaon+
    ic = 1;
    // C
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 14;
    goto statement_208;
  }
  if (srt <= 2.74f && srt > 2.63f) {
    // C both Lambda and sigma production are possible
    if (xsk1 / (xsk1 + xsk2) > ranart(nseed)) {
      // C lambda production
      ic = 1;
      // C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
    } else {
      // C sigma production
      // C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      ic = 2;
    }
    goto statement_208;
  }
  if (srt <= 2.77f && srt > 2.74f) {
    // C then pp-->Delta lamda kaon can happen
    if (xsk1 / (xsk1 + xsk2 + xsk3) > ranart(nseed)) {
      // C * (1.1)P+P-->p+L+kaon+
      ic = 1;
      // C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk2 / (xsk2 + xsk3) > ranart(nseed)) {
        // C pp-->psk
        ic = 2;
        // C
        lb(i1) = 1 + fem::fint(2 * ranart(nseed));
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        // C
      } else {
        // C pp-->D+l+k
        ic = 3;
        // C
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
      }
      goto statement_208;
    }
  }
  if (srt > 2.77f) {
    // C all four channels are possible
    if (xsk1 / (xsk1 + xsk2 + xsk3 + xsk4) > ranart(nseed)) {
      // C p lambda k production
      ic = 1;
      // C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk3 / (xsk2 + xsk3 + xsk4) > ranart(nseed)) {
        // C delta l K production
        ic = 3;
        // C
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
        goto statement_208;
      } else {
        if (xsk2 / (xsk2 + xsk4) > ranart(nseed)) {
          // C n sigma k production
          // C
          lb(i1) = 1 + fem::fint(2 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          // C
          ic = 2;
        } else {
          ic = 4;
          // C
          lb(i1) = 6 + fem::fint(4 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          // C
        }
        goto statement_208;
      }
    }
  }
statement_208:
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 23) {
      lpion(nnn, irun) = 21;
    }
  }
  lbi1 = lb(i1);
  lbi2 = lb(i2);
  // C KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
  ntry1 = 0;
statement_128:
  bbkaon(cmn, ic, srt, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_128;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  // C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
  // C NUCLEUS CMS. FRAME
  // C (1) for the necleon/delta
  // C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  // C (2) for the lambda/sigma
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  // C GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(aka) + fem::pow2(ppx) + fem::pow2(ppy) +
                   fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008:
  // C2008        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2008
  // C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  // C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  // C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  // C assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the
  // C leadng particle behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lbi1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lbi2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  if (lpion(nnn, irun) != 29) {
    iblock = 11;
  }
  lb1 = lb(i1);
  lb2 = lb(i2);
  sve.am1 = em1;
  sve.am2 = em2;
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  return;
// C
// Clin-6/2008 N+D->Deuteron+pi:
// C     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_108:
  if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
    // C     For idpert=1: we produce npertd pert deuterons:
    ndloop = npertd;
  } else if (idpert == 2 && npertd >= 1) {
    // C     For idpert=2: we first save information for npertd pert deuterons;
    // C     at the last ndloop we create the regular deuteron+pi
    // C     and those pert deuterons:
    ndloop = npertd + 1;
  } else {
    // C     Just create the regular deuteron+pi:
    ndloop = 1;
  }
  // C
  dprob1 = sdprod / sig / fem::ffloat(npertd);
  FEM_DO_SAFE(idloop, 1, ndloop) {
    bbdangle(cmn, pxd, pyd, pzd, nt, ipert1, ianti, idloop, pfinal, dprob1,
             lbm);
    rotate(cmn, px, py, pz, pxd, pyd, pzd);
    // C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
    // STATE C     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME: C     For the
    // Deuteron:
    xmass = xmd;
    e1dcm = fem::sqrt(fem::pow2(xmass) + fem::pow2(pxd) + fem::pow2(pyd) +
                      fem::pow2(pzd));
    p1dbeta = pxd * betax + pyd * betay + pzd * betaz;
    transf = gamma * (gamma * p1dbeta / (gamma + 1.f) + e1dcm);
    pxi1 = betax * transf + pxd;
    pyi1 = betay * transf + pyd;
    pzi1 = betaz * transf + pzd;
    if (ianti == 0) {
      lbd = 42;
    } else {
      lbd = -42;
    }
    if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
      // Cccc  Perturbative production for idpert=1:
      nnn++;
      ppion(1, nnn, irun) = pxi1;
      ppion(2, nnn, irun) = pyi1;
      ppion(3, nnn, irun) = pzi1;
      epion(nnn, irun) = xmd;
      lpion(nnn, irun) = lbd;
      rpion(1, nnn, irun) = r(1, i1);
      rpion(2, nnn, irun) = r(2, i1);
      rpion(3, nnn, irun) = r(3, i1);
      // Clin-6/2008 assign the perturbative probability:
      dppion(nnn, irun) = sdprod / sig / fem::ffloat(npertd);
    } else if (idpert == 2 && idloop <= npertd) {
      // Clin-6/2008 For idpert=2, we produce NPERTD perturbative
      // (anti)deuterons C     only when a regular (anti)deuteron+pi is produced
      // in NN collisions. C     First save the info for the perturbative
      // deuterons:
      ppd(1, idloop) = pxi1;
      ppd(2, idloop) = pyi1;
      ppd(3, idloop) = pzi1;
      lbpd(idloop) = lbd;
    } else {
      // Cccc  Regular production:
      // C     For the regular pion: do LORENTZ-TRANSFORMATION:
      e(i1) = xmm;
      e2picm = fem::sqrt(fem::pow2(xmm) + fem::pow2(pxd) + fem::pow2(pyd) +
                         fem::pow2(pzd));
      p2pibeta = -pxd * betax - pyd * betay - pzd * betaz;
      transf = gamma * (gamma * p2pibeta / (gamma + 1.f) + e2picm);
      pxi2 = betax * transf - pxd;
      pyi2 = betay * transf - pyd;
      pzi2 = betaz * transf - pzd;
      p(1, i1) = pxi2;
      p(2, i1) = pyi2;
      p(3, i1) = pzi2;
      // C     Remove regular pion to check the equivalence
      // C     between the perturbative and regular deuteron results:
      // C                 E(i1)=0.
      // C
      lb(i1) = lbm;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      id(i1) = 2;
      id1 = id(i1);
      e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                     fem::pow2(pz1));
      lb1 = lb(i1);
      // C     For the regular deuteron:
      p(1, i2) = pxi1;
      p(2, i2) = pyi1;
      p(3, i2) = pzi1;
      lb(i2) = lbd;
      lb2 = lb(i2);
      e(i2) = xmd;
      eti2 = e(i2);
      id(i2) = 2;
      // C     For idpert=2: create the perturbative deuterons:
      if (idpert == 2 && idloop == ndloop) {
        FEM_DO_SAFE(ipertd, 1, npertd) {
          nnn++;
          ppion(1, nnn, irun) = ppd(1, ipertd);
          ppion(2, nnn, irun) = ppd(2, ipertd);
          ppion(3, nnn, irun) = ppd(3, ipertd);
          epion(nnn, irun) = xmd;
          lpion(nnn, irun) = lbpd(ipertd);
          rpion(1, nnn, irun) = r(1, i1);
          rpion(2, nnn, irun) = r(2, i1);
          rpion(3, nnn, irun) = r(3, i1);
          // Clin-6/2008 assign the perturbative probability:
          dppion(nnn, irun) = 1.f / fem::ffloat(npertd);
        }
      }
    }
  }
  iblock = 501;
  // Clin-6/2008 N+D->Deuteron+pi over
  // C
}

struct reab2d_save {
  float ed1;
  float ed2;
  float factor;
  int lb1;
  int lb2;
  float pin2;
  float pout2;
  float xpro;

  reab2d_save()
      : ed1(fem::float0),
        ed2(fem::float0),
        factor(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pin2(fem::float0),
        pout2(fem::float0),
        xpro(fem::float0) {}
};

// C*****************************************
// C for the reabsorption of two resonances
// C This function calculates the cross section for
// C DD-->NN, N*N*-->NN and DN*-->NN
// C      real*4 function reab2d(i1,i2,srt)
float reab2d(common& cmn, int const& i1, int const& i2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(reab2d);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& ed1 = sve.ed1;
  float& ed2 = sve.ed2;
  float& factor = sve.factor;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pin2 = sve.pin2;
  float& pout2 = sve.pout2;
  float& xpro = sve.xpro;
  //
  // C  srt    = DSQRT(s) in GeV * C  reab   = cross section in mb
  // C***************************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /EE/
  return_value = 0;
  lb1 = fem::iabs(lb(i1));
  lb2 = fem::iabs(lb(i2));
  ed1 = e(i1);
  ed2 = e(i2);
  const float amn = 0.938f;
  pin2 = fem::pow2((srt / 2.f)) - fem::pow2(amn);
  pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(ed1) - fem::pow2(ed2)) /
                     (2.f * srt))) -
          fem::pow2(ed1);
  if (pout2 <= 0) {
    return return_value;
  }
  xpro = x2pi(cmn, srt);
  factor = 1 / 4.f;
  if ((lb1 >= 10 && lb1 <= 13) && (lb2 >= 10 && lb2 <= 13)) {
    factor = 1.f;
  }
  if ((lb1 >= 6 && lb1 <= 9) && (lb2 > 10 && lb2 <= 13)) {
    factor = 1 / 2.f;
  }
  if ((lb2 >= 6 && lb2 <= 9) && (lb1 > 10 && lb1 <= 13)) {
    factor = 1 / 2.f;
  }
  return_value = factor * pin2 / pout2 * xpro;
  return return_value;
}

struct crdd_save {
  static const int npdmax = 10000;

  float a;
  float ada;
  float ak0;
  float akp;
  float al;
  float am1;
  float am2;
  float ana;
  float as;
  float c1;
  float c2;
  float cc1;
  float ct1;
  float ct2;
  float dm;
  float dm3;
  float dm4;
  float dmax;
  float dmin;
  float dprob1;
  float e1cm;
  float e1dcm;
  float e2cm;
  float e2picm;
  float epcm;
  float es;
  float eti1;
  float eti2;
  float fm;
  int ianti;
  int ic;
  int ich;
  int icou1;
  int id1;
  int idd;
  int idloop;
  int ipertd;
  int lbd;
  int lbi1;
  int lbi2;
  int lbm;
  arr<int> lbpd;
  int m12;
  int n12;
  int ndloop;
  int ntry1;
  int ntry2;
  float p1beta;
  float p1dbeta;
  float p2beta;
  float p2pibeta;
  float pfinal;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float ppbeta;
  arr<float, 2> ppd;
  float ppx;
  float ppy;
  float ppz;
  float pr;
  float pr2;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px3;
  float px4;
  float pxd;
  float pxi1;
  float pxi2;
  float py3;
  float py4;
  float pyd;
  float pyi1;
  float pyi2;
  float pz2;
  float pz3;
  float pz4;
  float pzd;
  float pzi1;
  float pzi2;
  float s1;
  float s2;
  float s2d;
  float scheck;
  float sdprod;
  float sig2;
  float sigk;
  float signd;
  float ss;
  float st1;
  float st2;
  float t1;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float ta;
  float transf;
  float x;
  float x1;
  float x1535;
  float xdmass;
  float xmass;
  float xmm;
  float xptr;
  float xsk1;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;

  crdd_save()
      : a(fem::float0),
        ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        am1(fem::float0),
        am2(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        dm(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        dprob1(fem::float0),
        e1cm(fem::float0),
        e1dcm(fem::float0),
        e2cm(fem::float0),
        e2picm(fem::float0),
        epcm(fem::float0),
        es(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fm(fem::float0),
        ianti(fem::int0),
        ic(fem::int0),
        ich(fem::int0),
        icou1(fem::int0),
        id1(fem::int0),
        idd(fem::int0),
        idloop(fem::int0),
        ipertd(fem::int0),
        lbd(fem::int0),
        lbi1(fem::int0),
        lbi2(fem::int0),
        lbm(fem::int0),
        lbpd(dimension(npdmax), fem::fill0),
        m12(fem::int0),
        n12(fem::int0),
        ndloop(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        p1beta(fem::float0),
        p1dbeta(fem::float0),
        p2beta(fem::float0),
        p2pibeta(fem::float0),
        pfinal(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        ppbeta(fem::float0),
        ppd(dimension(3, npdmax), fem::fill0),
        ppx(fem::float0),
        ppy(fem::float0),
        ppz(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px3(fem::float0),
        px4(fem::float0),
        pxd(fem::float0),
        pxi1(fem::float0),
        pxi2(fem::float0),
        py3(fem::float0),
        py4(fem::float0),
        pyd(fem::float0),
        pyi1(fem::float0),
        pyi2(fem::float0),
        pz2(fem::float0),
        pz3(fem::float0),
        pz4(fem::float0),
        pzd(fem::float0),
        pzi1(fem::float0),
        pzi2(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        s2d(fem::float0),
        scheck(fem::float0),
        sdprod(fem::float0),
        sig2(fem::float0),
        sigk(fem::float0),
        signd(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        ta(fem::float0),
        transf(fem::float0),
        x(fem::float0),
        x1(fem::float0),
        x1535(fem::float0),
        xdmass(fem::float0),
        xmass(fem::float0),
        xmm(fem::float0),
        xptr(fem::float0),
        xsk1(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0) {}
};

const int crdd_save::npdmax;

// C*********************************
// C                                                                      *
void crdd(common& cmn, int const& irun, float& px, float& py, float& pz,
          float const& srt, int const& i1, int const& i2, int& iblock,
          int& ntag, float const& signn, float const& sig, int const& nt,
          int const& ipert1) {
  FEM_CMN_SVE(crdd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nnn = cmn.nnn;
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& iseed = cmn.iseed;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  //
  float& a = sve.a;
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& dm = sve.dm;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& dprob1 = sve.dprob1;
  float& e1cm = sve.e1cm;
  float& e1dcm = sve.e1dcm;
  float& e2cm = sve.e2cm;
  float& e2picm = sve.e2picm;
  float& epcm = sve.epcm;
  float& es = sve.es;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fm = sve.fm;
  int& ianti = sve.ianti;
  int& ic = sve.ic;
  int& ich = sve.ich;
  int& icou1 = sve.icou1;
  int& id1 = sve.id1;
  int& idd = sve.idd;
  int& idloop = sve.idloop;
  int& ipertd = sve.ipertd;
  int& lbd = sve.lbd;
  int& lbi1 = sve.lbi1;
  int& lbi2 = sve.lbi2;
  int& lbm = sve.lbm;
  const int npdmax = 10000;
  arr_ref<int> lbpd(sve.lbpd, dimension(npdmax));
  int& n12 = sve.n12;
  int& ndloop = sve.ndloop;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& p1beta = sve.p1beta;
  float& p1dbeta = sve.p1dbeta;
  float& p2beta = sve.p2beta;
  float& p2pibeta = sve.p2pibeta;
  float& pfinal = sve.pfinal;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& ppbeta = sve.ppbeta;
  arr_ref<float, 2> ppd(sve.ppd, dimension(3, npdmax));
  float& ppx = sve.ppx;
  float& ppy = sve.ppy;
  float& ppz = sve.ppz;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px3 = sve.px3;
  float& px4 = sve.px4;
  float& pxd = sve.pxd;
  float& pxi1 = sve.pxi1;
  float& pxi2 = sve.pxi2;
  float& py3 = sve.py3;
  float& py4 = sve.py4;
  float& pyd = sve.pyd;
  float& pyi1 = sve.pyi1;
  float& pyi2 = sve.pyi2;
  float& pz2 = sve.pz2;
  float& pz3 = sve.pz3;
  float& pz4 = sve.pz4;
  float& pzd = sve.pzd;
  float& pzi1 = sve.pzi1;
  float& pzi2 = sve.pzi2;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& s2d = sve.s2d;
  float& scheck = sve.scheck;
  float& sdprod = sve.sdprod;
  float& sig2 = sve.sig2;
  float& sigk = sve.sigk;
  float& signd = sve.signd;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2 = sve.t2;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& ta = sve.ta;
  float& transf = sve.transf;
  float& x = sve.x;
  float& x1 = sve.x1;
  float& x1535 = sve.x1535;
  float& xdmass = sve.xdmass;
  float& xmass = sve.xmass;
  float& xmm = sve.xmm;
  float& xptr = sve.xptr;
  float& xsk1 = sve.xsk1;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  const float pi = 3.1415926f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  const float avmass = 0.9383f;
  const float amp = 0.93828f;
  const float aka = 0.498f;
  const float xmd = 1.8756f;
  // C     1NTAG,SIGNN,SIG)
  // C     PURPOSE:                                                         *
  // C             DEALING WITH BARYON RESONANCE-BARYON RESONANCE COLLISIONS*
  // C     NOTE   :                                                         *
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  // C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      0-> COLLISION CANNOT HAPPEN                     *
  // C                      1-> N-N ELASTIC COLLISION                       *
  // C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  // C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  // C                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
  // C                     5-> DELTA(N*)+DELTA(N*)   TOTAL   COLLISIONS    *
  // C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  // C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  // C                      N12,                                            *
  // C                      M12=1 FOR p+n-->delta(+)+ n                     *
  // C                          2     p+n-->delta(0)+ p                     *
  // C                          3     p+p-->delta(++)+n                     *
  // C                          4     p+p-->delta(+)+p                      *
  // C                          5     n+n-->delta(0)+n                      *
  // C                          6     n+n-->delta(-)+p                      *
  // C                          7     n+p-->N*(0)(1440)+p                   *
  // C                          8     n+p-->N*(+)(1440)+n                   *
  // C                        9     p+p-->N*(+)(1535)+p                     *
  // C                        10    n+n-->N*(0)(1535)+n                     *
  // C                         11    n+p-->N*(+)(1535)+n                     *
  // C                        12    n+p-->N*(0)(1535)+p
  // C                        13    D(++)+D(-)-->N*(+)(1440)+n
  // C                         14    D(++)+D(-)-->N*(0)(1440)+p
  // C                        15    D(+)+D(0)--->N*(+)(1440)+n
  // C                        16    D(+)+D(0)--->N*(0)(1440)+p
  // C                        17    D(++)+D(0)-->N*(+)(1535)+p
  // C                        18    D(++)+D(-)-->N*(0)(1535)+p
  // C                        19    D(++)+D(-)-->N*(+)(1535)+n
  // C                        20    D(+)+D(+)-->N*(+)(1535)+p
  // C                        21    D(+)+D(0)-->N*(+)(1535)+n
  // C                        22    D(+)+D(0)-->N*(0)(1535)+p
  // C                        23    D(+)+D(-)-->N*(0)(1535)+n
  // C                        24    D(0)+D(0)-->N*(0)(1535)+n
  // C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  // C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  // C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  // C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  // C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  // C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  // C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  // C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  // C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  // C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  // C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  // C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  // C                        +++
  // C               AND MORE CHANNELS AS LISTED IN THE NOTE BOOK
  // C
  // C NOTE ABOUT N*(1440) RESORANCE:                                       *
  // C     As it has been discussed in VerWest's paper,I= 1 (initial isospin)
  // C     channel can all be attributed to delta resorance while I= 0      *
  // C     channel can all be  attribured to N* resorance.Only in n+p       *
  // C     one can have I=0 channel so is the N*(1440) resorance            *
  // C REFERENCES:    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)        *
  // C                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
  // C                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
  // C                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615        *
  // C                    CUTOFF = 2 * AVMASS + 20 MEV                      *
  // C                                                                      *
  // C       for N*(1535) we use the parameterization by Gy. Wolf et al     *
  // C       Nucl phys A552 (1993) 349, added May 18, 1994                  *
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /BG/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /input1/
  // Cc      SAVE /leadng/
  // Cc      SAVE /RNDF77/
  // C-----------------------------------------------------------------------
  n12 = 0;
  sve.m12 = 0;
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  c2 = pz / pr;
  if (px == 0.0f && py == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py, px);
  }
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 && lb(i2) < 0) {
    ianti = 1;
  }
  // C
  // Clin-6/2008 Production of perturbative deuterons for idpert=1:
  sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
  if (idpert == 1 && ipert1 == 1) {
    if (srt < 2.012f) {
      return;
    }
    if ((fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13) &&
        (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
      goto statement_108;
    } else {
      return;
    }
  }
  // C
  // C-----------------------------------------------------------------------
  // CCOM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
  // C      N-DELTA OR N*-N* or N*-Delta)
  if (x1 <= signn / sig) {
    // CCOM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
    as = fem::pow((3.65f * (srt - 1.8766f)), 6);
    a = 6.0f * as / (1.0f + as);
    ta = -2.0f * fem::pow2(pr);
    x = ranart(nseed);
    // Clin-10/24/02        T1  = DLOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /
    // A
    t1 = fem::sngl(fem::dlog(fem::dble(1.f - x) *
                                 fem::dexp(fem::dble(a) * fem::dble(ta)) +
                             fem::dble(x))) /
         a;
    c1 = 1.0f - t1 / ta;
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 20;
    goto statement_107;
  } else {
    // CCOM: TEST FOR INELASTIC SCATTERING
    // C     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
    // C     CAN HAPPEN ANY MORE ==> RETURN (2.15 = 2*AVMASS +2*PI-MASS)
    if (srt < 2.15f) {
      return;
    }
    // C     IF THERE WERE 2 N*(1535) AND THEY DIDN'T SCATT. ELAST.,
    // C     ALLOW THEM TO PRODUCE KAONS. NO OTHER INELASTIC CHANNELS
    // C     ARE KNOWN
    // C       if((lb(i1).ge.12).and.(lb(i2).ge.12))return
    // C     ALL the inelastic collisions between N*(1535) and Delta as well
    // C     as N*(1440) TO PRODUCE KAONS, NO OTHER CHANNELS ARE KNOWN
    // C       if((lb(i1).ge.12).and.(lb(i2).ge.3))return
    // C       if((lb(i2).ge.12).and.(lb(i1).ge.3))return
    // C     calculate the N*(1535) production cross section in I1+I2 collisions
    n1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
    // C
    // C for Delta+Delta-->N*(1440 OR 1535)+N AND N*(1440)+N*(1440)-->N*(1535)+X
    // C     AND DELTA+N*(1440)-->N*(1535)+X
    // C WE ASSUME THEY HAVE THE SAME CROSS SECTIONS as CORRESPONDING N+N
    // COLLISION): C FOR D++D0,
    // D+D+,D+D-,D0D0,N*+N*+,N*0N*0,N*(+)D+,N*(+)D(-),N*(0)D(0) C N*(1535)
    // production, kaon production and reabsorption through C D(N*)+D(N*)-->NN
    // are ALLOWED. C CROSS SECTION FOR KAON PRODUCTION from the four channels
    // are C for NLK channel
    akp = 0.498f;
    sve.ak0 = 0.498f;
    ana = 0.938f;
    ada = 1.232f;
    al = 1.1157f;
    as = 1.1197f;
    xsk1 = 0;
    xsk2 = 0;
    xsk3 = 0;
    xsk4 = 0;
    xsk5 = 0;
    t1nlk = ana + al + akp;
    if (srt <= t1nlk) {
      goto statement_222;
    }
    xsk1 = 1.5f * pplpk(cmn, srt);
    // C for DLK channel
    t1dlk = ada + al + akp;
    t2dlk = ada + al - akp;
    if (srt <= t1dlk) {
      goto statement_222;
    }
    es = srt;
    pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
             (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
    sve.pmdlk = fem::sqrt(pmdlk2);
    xsk3 = 1.5f * pplpk(cmn, srt);
    // C for NSK channel
    t1nsk = ana + as + akp;
    t2nsk = ana + as - akp;
    if (srt <= t1nsk) {
      goto statement_222;
    }
    pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
             (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
    sve.pmnsk = fem::sqrt(pmnsk2);
    xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    // C for DSK channel
    t1dsk = ada + as + akp;
    t2dsk = ada + as - akp;
    if (srt <= t1dsk) {
      goto statement_222;
    }
    pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
             (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
    sve.pmdsk = fem::sqrt(pmdsk2);
    xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    // Csp11/21/01
    // C phi production
    if (srt <= (2.f * amn + aphi)) {
      goto statement_222;
    }
    // C  !! mb put the correct form
    xsk5 = 0.0001f;
  // Csp11/21/01 end
  // C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
  statement_222:
    sigk = xsk1 + xsk2 + xsk3 + xsk4;
    // C
    // Cbz3/7/99 neutralk
    xsk1 = 2.0f * xsk1;
    xsk2 = 2.0f * xsk2;
    xsk3 = 2.0f * xsk3;
    xsk4 = 2.0f * xsk4;
    sigk = 2.0f * sigk + xsk5;
    // Cbz3/7/99 neutralk end
    // C
    // C The reabsorption cross section for the process
    // C D(N*)D(N*)-->NN is
    s2d = reab2d(cmn, i1, i2, srt);
    // C
    // Cbz3/16/99 pion
    s2d = 0.f;
    // Cbz3/16/99 pion end
    // C
    // C(1) N*(1535)+D(N*(1440)) reactions
    // C    we allow kaon production and reabsorption only
    if (((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 12)) ||
        ((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 6)) ||
        ((fem::iabs(lb(i2)) >= 12) && (fem::iabs(lb(i1)) >= 6))) {
      signd = sigk + s2d;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C       if(x1.gt.(signd+signn)/sig)return
      if (x1 > (signd + signn + sdprod) / sig) {
        return;
      }
      // C
      // C if kaon production
      // Clin-6/2008
      // C       IF(SIGK/SIG.GE.RANART(NSEED))GO TO 306
      if ((sigk + sdprod) / sig >= ranart(nseed)) {
        goto statement_306;
      }
      // C
      // C if reabsorption
      goto statement_1012;
    }
    idd = fem::iabs(lb(i1) * lb(i2));
    // C channels have the same charge as pp
    if ((idd == 63) || (idd == 64) || (idd == 48) || (idd == 49) ||
        (idd == 11 * 11) || (idd == 10 * 10) || (idd == 88) || (idd == 66) ||
        (idd == 90) || (idd == 70)) {
      signd = x1535 + sigk + s2d;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      // C
      // C if kaon production
      if (sigk / signd > ranart(nseed)) {
        goto statement_306;
      }
      // C if reabsorption
      if (s2d / (x1535 + s2d) > ranart(nseed)) {
        goto statement_1012;
      }
      // C if N*(1535) production
      if (idd == 63) {
        n12 = 17;
      }
      if (idd == 64) {
        n12 = 20;
      }
      if (idd == 48) {
        n12 = 23;
      }
      if (idd == 49) {
        n12 = 24;
      }
      if (idd == 121) {
        n12 = 25;
      }
      if (idd == 100) {
        n12 = 26;
      }
      if (idd == 88) {
        n12 = 29;
      }
      if (idd == 66) {
        n12 = 31;
      }
      if (idd == 90) {
        n12 = 32;
      }
      if (idd == 70) {
        n12 = 35;
      }
      goto statement_1011;
    }
    // C IN DELTA+N*(1440) and N*(1440)+N*(1440) COLLISIONS,
    // C N*(1535), kaon production and reabsorption are ALLOWED
    // C IN N*(1440)+N*(1440) COLLISIONS, ONLY N*(1535) IS ALLOWED
    if ((idd == 110) || (idd == 77) || (idd == 80)) {
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C       IF(X1.GT.(SIGNN+X1535+SIGK+s2d)/SIG)RETURN
      if (x1 > (signn + x1535 + sigk + s2d + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / (x1535 + sigk + s2d) > ranart(nseed)) {
        goto statement_306;
      }
      if (s2d / (x1535 + s2d) > ranart(nseed)) {
        goto statement_1012;
      }
      if (idd == 77) {
        n12 = 30;
      }
      if ((idd == 77) && (ranart(nseed) <= 0.5f)) {
        n12 = 36;
      }
      if (idd == 80) {
        n12 = 34;
      }
      if ((idd == 80) && (ranart(nseed) <= 0.5f)) {
        n12 = 35;
      }
      if (idd == 110) {
        n12 = 27;
      }
      if ((idd == 110) && (ranart(nseed) <= 0.5f)) {
        n12 = 28;
      }
      goto statement_1011;
    }
    if ((idd == 54) || (idd == 56)) {
      // C LIKE FOR N+P COLLISION,
      // C IN DELTA+DELTA COLLISIONS BOTH N*(1440) AND N*(1535) CAN BE PRODUCED
      sig2 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      signd = 2.f * (sig2 + x1535) + sigk + s2d;
      // Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      // C        IF(X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      // C
      if (sigk / signd > ranart(nseed)) {
        goto statement_306;
      }
      if (s2d / (2.f * (sig2 + x1535) + s2d) > ranart(nseed)) {
        goto statement_1012;
      }
      if (ranart(nseed) < x1535 / (sig2 + x1535)) {
        // C N*(1535) PRODUCTION
        if (idd == 54) {
          n12 = 18;
        }
        if ((idd == 54) && (ranart(nseed) <= 0.5f)) {
          n12 = 19;
        }
        if (idd == 56) {
          n12 = 21;
        }
        if ((idd == 56) && (ranart(nseed) <= 0.5f)) {
          n12 = 22;
        }
      } else {
        // C N*(144) PRODUCTION
        if (idd == 54) {
          n12 = 13;
        }
        if ((idd == 54) && (ranart(nseed) <= 0.5f)) {
          n12 = 14;
        }
        if (idd == 56) {
          n12 = 15;
        }
        if ((idd == 56) && (ranart(nseed) <= 0.5f)) {
          n12 = 16;
        }
      }
    }
  statement_1011:
    iblock = 5;
    // CPARAMETRIZATION OF THE SHAPE OF THE N*(1440) AND N*(1535)
    // C RESONANCE ACCORDING
    // C     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
    // C     FORMULA FOR N* RESORANCE
    // C     DETERMINE DELTA MASS VIA REJECTION METHOD.
    dmax = srt - avmass - 0.005f;
    dmin = 1.078f;
    if ((n12 >= 13) && (n12 <= 16)) {
      // C N*(1440) production
      if (dmax < 1.44f) {
        fm = fns(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.44f;
        // C          FM=FNS(1.44,SRT,1.)
        fm = fns(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry2 = 0;
    statement_11:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry2++;
      if ((ranart(nseed) > fns(cmn, dm, srt, 1.f) / fm) && (ntry2 <= 10)) {
        goto statement_11;
      }
      // C
      // Clin-2/26/03 limit the N* mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 2.14f) {
        goto statement_11;
      }
      // C
      goto statement_13;
    }
    if ((n12 >= 17) && (n12 <= 36)) {
      // C N*(1535) production
      if (dmax < 1.535f) {
        fm = fd5(cmn, dmax, srt, 0.f);
      } else {
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.535f;
        // C          FM=FD5(1.535,SRT,1.)
        fm = fd5(cmn, xdmass, srt, 1.f);
        // Clin-10/25/02-end
        // C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_12:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fd5(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 10)) {
        goto statement_12;
      }
      // C
      // Clin-2/26/03 limit the N* mass below a certain value
      // C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.84f) {
        goto statement_12;
      }
      // C
    }
  statement_13:
    // C-------------------------------------------------------
    // C RELABLE BARYON I1 AND I2
    // C13 D(++)+D(-)--> N*(+)(14)+n
    if (n12 == 13) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 11;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 11;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C14 D(++)+D(-)--> N*(0)(14)+P
    if (n12 == 14) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 10;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 10;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C15 D(+)+D(0)--> N*(+)(14)+n
    if (n12 == 15) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 11;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 11;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C16 D(+)+D(0)--> N*(0)(14)+P
    if (n12 == 16) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 10;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 10;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C17 D(++)+D(0)--> N*(+)(14)+P
    if (n12 == 17) {
      lb(i2) = 13;
      e(i2) = dm;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C18 D(++)+D(-)--> N*(0)(15)+P
    if (n12 == 18) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C19 D(++)+D(-)--> N*(+)(15)+N
    if (n12 == 19) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C20 D(+)+D(+)--> N*(+)(15)+P
    if (n12 == 20) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C21 D(+)+D(0)--> N*(+)(15)+N
    if (n12 == 21) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C22 D(+)+D(0)--> N*(0)(15)+P
    if (n12 == 22) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C23 D(+)+D(-)--> N*(0)(15)+N
    if (n12 == 23) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C24 D(0)+D(0)--> N*(0)(15)+N
    if (n12 == 24) {
      lb(i2) = 12;
      e(i2) = dm;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C25 N*(+)+N*(+)--> N*(0)(15)+P
    if (n12 == 25) {
      lb(i2) = 12;
      e(i2) = dm;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C26 N*(0)+N*(0)--> N*(0)(15)+N
    if (n12 == 26) {
      lb(i2) = 12;
      e(i2) = dm;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C27 N*(+)+N*(0)--> N*(+)(15)+N
    if (n12 == 27) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C28 N*(+)+N*(0)--> N*(0)(15)+P
    if (n12 == 28) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C27 N*(+)+N*(0)--> N*(+)(15)+N
    if (n12 == 27) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C29 N*(+)+D(+)--> N*(+)(15)+P
    if (n12 == 29) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C30 N*(+)+D(0)--> N*(+)(15)+N
    if (n12 == 30) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C31 N*(+)+D(-)--> N*(0)(15)+N
    if (n12 == 31) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C32 N*(0)+D(++)--> N*(+)(15)+P
    if (n12 == 32) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C33 N*(0)+D(+)--> N*(+)(15)+N
    if (n12 == 33) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C34 N*(0)+D(+)--> N*(0)(15)+P
    if (n12 == 34) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    // C35 N*(0)+D(0)--> N*(0)(15)+N
    if (n12 == 35) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C36 N*(+)+D(0)--> N*(0)(15)+P
    if (n12 == 36) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
  statement_1012:
    iblock = 55;
    lb1 = lb(i1);
    lb2 = lb(i2);
    ich = fem::iabs(lb1 * lb2);
    // C-------------------------------------------------------
    // C RELABLE BARYON I1 AND I2 in the reabsorption processes
    // C37 D(++)+D(-)--> n+p
    if (ich == 9 * 6) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C38 D(+)+D(0)--> n+p
    if (ich == 8 * 7) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C39 D(++)+D(0)--> p+p
    if (ich == 9 * 7) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C40 D(+)+D(+)--> p+p
    if (ich == 8 * 8) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C41 D(+)+D(-)--> n+n
    if (ich == 8 * 6) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C42 D(0)+D(0)--> n+n
    if (ich == 6 * 6) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C43 N*(+)+N*(+)--> p+p
    if (ich == 11 * 11 || ich == 13 * 13 || ich == 11 * 13) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C44 N*(0)(1440)+N*(0)--> n+n
    if (ich == 10 * 10 || ich == 12 * 12 || ich == 10 * 12) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C45 N*(+)+N*(0)--> n+p
    if (ich == 10 * 11 || ich == 12 * 13 || ich == 10 * 13 || ich == 11 * 12) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C46 N*(+)+D(+)--> p+p
    if (ich == 11 * 8 || ich == 13 * 8) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C47 N*(+)+D(0)--> n+p
    if (ich == 11 * 7 || ich == 13 * 7) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    // C48 N*(+)+D(-)--> n+n
    if (ich == 11 * 6 || ich == 13 * 6) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C49 N*(0)+D(++)--> p+p
    if (ich == 10 * 9 || ich == 12 * 9) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    // C50 N*(0)+D(0)--> n+n
    if (ich == 10 * 7 || ich == 12 * 7) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    // C51 N*(0)+D(+)--> n+p
    if (ich == 10 * 8 || ich == 12 * 8) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    lb(i1) = 1;
    e(i1) = amp;
    lb(i2) = 2;
    e(i2) = amn;
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  // C resonance production or absorption in resonance+resonance collisions is
  // C assumed to have the same pt distribution as pp
  statement_200:
    em1 = e(i1);
    em2 = e(i2);
    pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
          4.0f * fem::pow2((em1 * em2));
    if (pr2 <= 0.f) {
      pr2 = 1.e-09f;
    }
    pr = fem::sqrt(pr2) / (2.f * srt);
    if (srt <= 2.14f) {
      c1 = 1.0f - 2.0f * ranart(nseed);
    }
    if (srt > 2.14f && srt <= 2.4f) {
      c1 = ang(cmn, srt, iseed);
    }
    if (srt > 2.4f) {
      // C
      // Clin-10/25/02 get rid of argument usage mismatch in PTR():
      xptr = 0.33f * pr;
      // C         cc1=ptr(0.33*pr,iseed)
      cc1 = ptr(cmn, xptr, iseed);
      // Clin-10/25/02-end
      // C
      // Clin-9/2012: check argument in sqrt():
      scheck = fem::pow2(pr) - fem::pow2(cc1);
      if (scheck < 0) {
        write(99, star), "scheck7: ", scheck;
        scheck = 0.f;
      }
      c1 = fem::sqrt(scheck) / pr;
      // C         c1=sqrt(pr**2-cc1**2)/pr
      // C
    }
    t1 = 2.0f * pi * ranart(nseed);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(i1) = -lb(i1);
      lb(i2) = -lb(i2);
    }
  }
// CCOM: SET THE NEW MOMENTUM COORDINATES
// C
// Clin-9/2012: check argument in sqrt():
statement_107:
  scheck = 1.0f - fem::pow2(c1);
  if (scheck < 0) {
    write(99, star), "scheck8: ", scheck;
    scheck = 0.f;
  }
  s1 = fem::sqrt(scheck);
  // C107   S1   = SQRT( 1.0 - C1**2 )
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck9: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  // C      S2  =  SQRT( 1.0 - C2**2 )
  // C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
  ss = c2 * s1 * ct1 + s2 * c1;
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
  return;
// C FOR THE DD-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN
// C THE NUCLEUS-NUCLEUS CMS.
statement_306:
  // Csp11/21/01 phi production
  if (xsk5 / sigk > ranart(nseed)) {
    pz1 = p(3, i1);
    pz2 = p(3, i2);
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    nnn++;
    lpion(nnn, irun) = 29;
    epion(nnn, irun) = aphi;
    iblock = 222;
    goto statement_208;
  }
  iblock = 10;
  if (ianti == 1) {
    iblock = -10;
  }
  pz1 = p(3, i1);
  pz2 = p(3, i2);
  // C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  nnn++;
  lpion(nnn, irun) = 23;
  epion(nnn, irun) = aka;
  if (srt <= 2.63f) {
    // C only lambda production is possible
    // C (1.1)P+P-->p+L+kaon+
    ic = 1;
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 14;
    goto statement_208;
  }
  if (srt <= 2.74f && srt > 2.63f) {
    // C both Lambda and sigma production are possible
    if (xsk1 / (xsk1 + xsk2) > ranart(nseed)) {
      // C lambda production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
    } else {
      // C sigma production
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      ic = 2;
    }
    goto statement_208;
  }
  if (srt <= 2.77f && srt > 2.74f) {
    // C then pp-->Delta lamda kaon can happen
    if (xsk1 / (xsk1 + xsk2 + xsk3) > ranart(nseed)) {
      // C * (1.1)P+P-->p+L+kaon+
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk2 / (xsk2 + xsk3) > ranart(nseed)) {
        // C pp-->psk
        ic = 2;
        lb(i1) = 1 + fem::fint(2 * ranart(nseed));
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      } else {
        // C pp-->D+l+k
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
      }
      goto statement_208;
    }
  }
  if (srt > 2.77f) {
    // C all four channels are possible
    if (xsk1 / (xsk1 + xsk2 + xsk3 + xsk4) > ranart(nseed)) {
      // C p lambda k production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk3 / (xsk2 + xsk3 + xsk4) > ranart(nseed)) {
        // C delta l K production
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
        goto statement_208;
      } else {
        if (xsk2 / (xsk2 + xsk4) > ranart(nseed)) {
          // C n sigma k production
          lb(i1) = 1 + fem::fint(2 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          ic = 2;
        } else {
          // C D sigma K
          ic = 4;
          lb(i1) = 6 + fem::fint(4 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        }
        goto statement_208;
      }
    }
  }
statement_208:
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 23) {
      lpion(nnn, irun) = 21;
    }
  }
  lbi1 = lb(i1);
  lbi2 = lb(i2);
  // C KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
  ntry1 = 0;
statement_129:
  bbkaon(cmn, ic, srt, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_129;
  }
  // C       if(icou1.lt.0)return
  // C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  // C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
  // C NUCLEUS CMS. FRAME
  // C (1) for the necleon/delta
  // C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  // C (2) for the lambda/sigma
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  // C GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(aka) + fem::pow2(ppx) + fem::pow2(ppy) +
                   fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  // Clin-5/2008:
  // C2007        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2007
  // C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  // C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  // C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  // C
  // C assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the
  // C leadng particle behaviour
  // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lbi1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lbi2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  lb1 = lb(i1);
  lb2 = lb(i2);
  sve.am1 = em1;
  sve.am2 = em2;
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  return;
// C
// Clin-6/2008 D+D->Deuteron+pi:
// C     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_108:
  if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
    // C     For idpert=1: we produce npertd pert deuterons:
    ndloop = npertd;
  } else if (idpert == 2 && npertd >= 1) {
    // C     For idpert=2: we first save information for npertd pert deuterons;
    // C     at the last ndloop we create the regular deuteron+pi
    // C     and those pert deuterons:
    ndloop = npertd + 1;
  } else {
    // C     Just create the regular deuteron+pi:
    ndloop = 1;
  }
  // C
  dprob1 = sdprod / sig / fem::ffloat(npertd);
  FEM_DO_SAFE(idloop, 1, ndloop) {
    bbdangle(cmn, pxd, pyd, pzd, nt, ipert1, ianti, idloop, pfinal, dprob1,
             lbm);
    rotate(cmn, px, py, pz, pxd, pyd, pzd);
    // C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
    // STATE C     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME: C     For the
    // Deuteron:
    xmass = xmd;
    e1dcm = fem::sqrt(fem::pow2(xmass) + fem::pow2(pxd) + fem::pow2(pyd) +
                      fem::pow2(pzd));
    p1dbeta = pxd * betax + pyd * betay + pzd * betaz;
    transf = gamma * (gamma * p1dbeta / (gamma + 1.f) + e1dcm);
    pxi1 = betax * transf + pxd;
    pyi1 = betay * transf + pyd;
    pzi1 = betaz * transf + pzd;
    if (ianti == 0) {
      lbd = 42;
    } else {
      lbd = -42;
    }
    if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
      // Cccc  Perturbative production for idpert=1:
      nnn++;
      ppion(1, nnn, irun) = pxi1;
      ppion(2, nnn, irun) = pyi1;
      ppion(3, nnn, irun) = pzi1;
      epion(nnn, irun) = xmd;
      lpion(nnn, irun) = lbd;
      rpion(1, nnn, irun) = r(1, i1);
      rpion(2, nnn, irun) = r(2, i1);
      rpion(3, nnn, irun) = r(3, i1);
      // Clin-6/2008 assign the perturbative probability:
      dppion(nnn, irun) = sdprod / sig / fem::ffloat(npertd);
    } else if (idpert == 2 && idloop <= npertd) {
      // Clin-6/2008 For idpert=2, we produce NPERTD perturbative
      // (anti)deuterons C     only when a regular (anti)deuteron+pi is produced
      // in NN collisions. C     First save the info for the perturbative
      // deuterons:
      ppd(1, idloop) = pxi1;
      ppd(2, idloop) = pyi1;
      ppd(3, idloop) = pzi1;
      lbpd(idloop) = lbd;
    } else {
      // Cccc  Regular production:
      // C     For the regular pion: do LORENTZ-TRANSFORMATION:
      e(i1) = xmm;
      e2picm = fem::sqrt(fem::pow2(xmm) + fem::pow2(pxd) + fem::pow2(pyd) +
                         fem::pow2(pzd));
      p2pibeta = -pxd * betax - pyd * betay - pzd * betaz;
      transf = gamma * (gamma * p2pibeta / (gamma + 1.f) + e2picm);
      pxi2 = betax * transf - pxd;
      pyi2 = betay * transf - pyd;
      pzi2 = betaz * transf - pzd;
      p(1, i1) = pxi2;
      p(2, i1) = pyi2;
      p(3, i1) = pzi2;
      // C     Remove regular pion to check the equivalence
      // C     between the perturbative and regular deuteron results:
      // C                 E(i1)=0.
      // C
      lb(i1) = lbm;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      id(i1) = 2;
      id1 = id(i1);
      e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                     fem::pow2(pz1));
      lb1 = lb(i1);
      // C     For the regular deuteron:
      p(1, i2) = pxi1;
      p(2, i2) = pyi1;
      p(3, i2) = pzi1;
      lb(i2) = lbd;
      lb2 = lb(i2);
      e(i2) = xmd;
      eti2 = e(i2);
      id(i2) = 2;
      // C     For idpert=2: create the perturbative deuterons:
      if (idpert == 2 && idloop == ndloop) {
        FEM_DO_SAFE(ipertd, 1, npertd) {
          nnn++;
          ppion(1, nnn, irun) = ppd(1, ipertd);
          ppion(2, nnn, irun) = ppd(2, ipertd);
          ppion(3, nnn, irun) = ppd(3, ipertd);
          epion(nnn, irun) = xmd;
          lpion(nnn, irun) = lbpd(ipertd);
          rpion(1, nnn, irun) = r(1, i1);
          rpion(2, nnn, irun) = r(2, i1);
          rpion(3, nnn, irun) = r(3, i1);
          // Clin-6/2008 assign the perturbative probability:
          dppion(nnn, irun) = 1.f / fem::ffloat(npertd);
        }
      }
    }
  }
  iblock = 501;
  // Clin-6/2008 D+D->Deuteron+pi over
  // C
}

struct dkine_save {
  float am;
  float bdx;
  float bdy;
  float bdz;
  float bpn;
  float bpp;
  float devio;
  float dm;
  float edelta;
  float en;
  float ep;
  float fgd;
  float gd;
  float pm;
  float px;
  float pxn;
  float pxp;
  float py;
  float pyn;
  float pyp;
  float pz;
  float pzn;
  float pzp;
  float q;
  float q2;
  float qs;
  float qx;
  float qy;
  float qz;
  float rx;
  float ry;
  float rz;
  float tau0;
  float taudcy;

  dkine_save()
      : am(fem::float0),
        bdx(fem::float0),
        bdy(fem::float0),
        bdz(fem::float0),
        bpn(fem::float0),
        bpp(fem::float0),
        devio(fem::float0),
        dm(fem::float0),
        edelta(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        fgd(fem::float0),
        gd(fem::float0),
        pm(fem::float0),
        px(fem::float0),
        pxn(fem::float0),
        pxp(fem::float0),
        py(fem::float0),
        pyn(fem::float0),
        pyp(fem::float0),
        pz(fem::float0),
        pzn(fem::float0),
        pzp(fem::float0),
        q(fem::float0),
        q2(fem::float0),
        qs(fem::float0),
        qx(fem::float0),
        qy(fem::float0),
        qz(fem::float0),
        rx(fem::float0),
        ry(fem::float0),
        rz(fem::float0),
        tau0(fem::float0),
        taudcy(fem::float0) {}
};

// C
// C-------------------------------------------------------------------
// C PURPOSE:
// C         CALCULATE THE MOMENTUM OF NUCLEON AND PION (OR ETA)
// C         IN THE LAB. FRAME AFTER DELTA OR N* DECAY
// C DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA PRODUCTION
void dkine(common& cmn, int const& irun, int const& i, int const& nnn,
           int const& nlab, int const& /* iseed */, float const& wid,
           int const& nt) {
  FEM_CMN_SVE(dkine);
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_cref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  //
  float& am = sve.am;
  float& bdx = sve.bdx;
  float& bdy = sve.bdy;
  float& bdz = sve.bdz;
  float& bpn = sve.bpn;
  float& bpp = sve.bpp;
  float& dm = sve.dm;
  float& edelta = sve.edelta;
  float& en = sve.en;
  float& ep = sve.ep;
  float& fgd = sve.fgd;
  float& gd = sve.gd;
  float& pm = sve.pm;
  float& px = sve.px;
  float& pxn = sve.pxn;
  float& pxp = sve.pxp;
  float& py = sve.py;
  float& pyn = sve.pyn;
  float& pyp = sve.pyp;
  float& pz = sve.pz;
  float& pzn = sve.pzn;
  float& pzp = sve.pzp;
  float& q = sve.q;
  float& q2 = sve.q2;
  float& qs = sve.qs;
  float& qx = sve.qx;
  float& qy = sve.qy;
  float& qz = sve.qz;
  float& tau0 = sve.tau0;
  float& taudcy = sve.taudcy;
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  const float hbarc = 0.19733f;
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /leadng/
  // Cc      SAVE /tdecay/
  // Cc      SAVE /INPUT2/
  // Cc      SAVE /RNDF77/
  // C READ IN THE COORDINATES OF DELTA OR N* UNDERGOING DECAY
  px = p(1, i);
  py = p(2, i);
  pz = p(3, i);
  sve.rx = r(1, i);
  sve.ry = r(2, i);
  sve.rz = r(3, i);
  dm = e(i);
  edelta =
      fem::sqrt(fem::pow2(dm) + fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  pm = epion(nnn, irun);
  am = amp;
  if (nlab == 2) {
    am = amn;
  }
  // C FIND OUT THE MOMENTUM AND ENERGY OF PION AND NUCLEON IN DELTA REST FRAME
  // C THE MAGNITUDE OF MOMENTUM IS DETERMINED BY ENERGY CONSERVATION ,THE
  // FORMULA C CAN BE FOUND ON PAGE 716,W BAUER P.R.C40,1989 C THE DIRECTION OF
  // THE MOMENTUM IS ASSUMED ISOTROPIC. NOTE THAT P(PION)=-P(N)
  q2 = fem::pow2(
           ((fem::pow2(dm) - fem::pow2(am) + fem::pow2(pm)) / (2.f * dm))) -
       fem::pow2(pm);
  if (q2 <= 0.f) {
    q2 = 1.e-09f;
  }
  q = fem::sqrt(q2);
statement_11:
  qx = 1.f - 2.f * ranart(nseed);
  qy = 1.f - 2.f * ranart(nseed);
  qz = 1.f - 2.f * ranart(nseed);
  qs = fem::pow2(qx) + fem::pow2(qy) + fem::pow2(qz);
  if (qs > 1.f) {
    goto statement_11;
  }
  pxp = q * qx / fem::sqrt(qs);
  pyp = q * qy / fem::sqrt(qs);
  pzp = q * qz / fem::sqrt(qs);
  ep = fem::sqrt(fem::pow2(q) + fem::pow2(pm));
  pxn = -pxp;
  pyn = -pyp;
  pzn = -pzp;
  en = fem::sqrt(fem::pow2(q) + fem::pow2(am));
  // C TRANSFORM INTO THE LAB. FRAME. THE GENERAL LORENTZ TRANSFORMATION CAN
  // C BE FOUND ON PAGE 34 OF R. HAGEDORN " RELATIVISTIC KINEMATICS"
  gd = edelta / dm;
  fgd = gd / (1.f + gd);
  bdx = px / edelta;
  bdy = py / edelta;
  bdz = pz / edelta;
  bpp = bdx * pxp + bdy * pyp + bdz * pzp;
  bpn = bdx * pxn + bdy * pyn + bdz * pzn;
  p(1, i) = pxn + bdx * gd * (fgd * bpn + en);
  p(2, i) = pyn + bdy * gd * (fgd * bpn + en);
  p(3, i) = pzn + bdz * gd * (fgd * bpn + en);
  e(i) = am;
  // C WE ASSUME THAT THE SPACIAL COORDINATE OF THE NUCLEON
  // C IS THAT OF THE DELTA
  ppion(1, nnn, irun) = pxp + bdx * gd * (fgd * bpp + ep);
  ppion(2, nnn, irun) = pyp + bdy * gd * (fgd * bpp + ep);
  ppion(3, nnn, irun) = pzp + bdz * gd * (fgd * bpp + ep);
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i);
  // C WE ASSUME THE PION OR ETA COMING FROM DELTA DECAY IS LOCATED ON THE
  // SPHERE C OF RADIUS 0.5FM AROUND DELTA, THIS POINT NEED TO BE CHECKED C AND
  // OTHER CRIERTION MAY BE TRIED Clin-2/20/03 no additional smearing for
  // position of decay daughters: C200         X0 = 1.0 - 2.0 * RANART(NSEED) C
  // Y0 = 1.0 - 2.0 * RANART(NSEED) C            Z0 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 200
  // C        RPION(1,NNN,IRUN)=R(1,I)+0.5*x0
  // C        RPION(2,NNN,IRUN)=R(2,I)+0.5*y0
  // C        RPION(3,NNN,IRUN)=R(3,I)+0.5*z0
  rpion(1, nnn, irun) = r(1, i);
  rpion(2, nnn, irun) = r(2, i);
  rpion(3, nnn, irun) = r(3, i);
  // C
  sve.devio =
      fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppion(1, nnn, irun)) +
                fem::pow2(ppion(2, nnn, irun)) +
                fem::pow2(ppion(3, nnn, irun))) +
      fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                fem::pow2(p(3, i))) -
      e1;
  // C        if(abs(devio).gt.0.02) write(93,*) 'decay(): nt=',nt,devio,lb1
  // C
  // C     add decay time to daughter's formation time at the last timestep:
  if (nt == cmn.ntmax) {
    tau0 = hbarc / wid;
    taudcy = tau0 * (-1.f) * fem::alog(1.f - ranart(nseed));
    // C     lorentz boost:
    taudcy = taudcy * e1 / cmn.em1;
    tfnl += taudcy;
    xfnl += px1 / e1 * taudcy;
    yfnl += py1 / e1 * taudcy;
    zfnl += pz1 / e1 * taudcy;
    r(1, i) = xfnl;
    r(2, i) = yfnl;
    r(3, i) = zfnl;
    tfdcy(i) = tfnl;
    rpion(1, nnn, irun) = xfnl;
    rpion(2, nnn, irun) = yfnl;
    rpion(3, nnn, irun) = zfnl;
    tfdpi(nnn, irun) = tfnl;
  }
  // C
}

struct decay_save {
  float ctrl;
  float dm;
  float dpsave;
  int lbanti;
  int lbi;
  int lbm;
  int lbsave;
  int nalb;
  int nlab;
  float pxsave;
  float pysave;
  float pzsave;
  float x3;
  float x4;
  float x5;
  float x6;
  float x8;
  float xmsave;

  decay_save()
      : ctrl(fem::float0),
        dm(fem::float0),
        dpsave(fem::float0),
        lbanti(fem::int0),
        lbi(fem::int0),
        lbm(fem::int0),
        lbsave(fem::int0),
        nalb(fem::int0),
        nlab(fem::int0),
        pxsave(fem::float0),
        pysave(fem::float0),
        pzsave(fem::float0),
        x3(fem::float0),
        x4(fem::float0),
        x5(fem::float0),
        x6(fem::float0),
        x8(fem::float0),
        xmsave(fem::float0) {}
};

// C-----------------------------------------------------------------------------
// C PURPOSE:1. SORT N*(1440) and N*(1535) 2-body DECAY PRODUCTS
// C         2. DETERMINE THE MOMENTUM AND COORDINATES OF NUCLEON AND PION
// C            AFTER THE DELTA OR N* DECAYING
// C DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA
void decay(common& cmn, int const& irun, int const& i, int const& nnn,
           int const& iseed, float const& wid, int const& nt) {
  FEM_CMN_SVE(decay);
  // COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON cc
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON pb
  const int maxr = 1;
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  // COMMON pc
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  // COMMON pd
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  // COMMON dpert
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  //
  // SAVE
  float& ctrl = sve.ctrl;
  float& dm = sve.dm;
  float& dpsave = sve.dpsave;
  int& lbanti = sve.lbanti;
  int& lbi = sve.lbi;
  int& lbm = sve.lbm;
  int& lbsave = sve.lbsave;
  int& nalb = sve.nalb;
  int& nlab = sve.nlab;
  float& pxsave = sve.pxsave;
  float& pysave = sve.pysave;
  float& pzsave = sve.pzsave;
  float& x3 = sve.x3;
  float& x4 = sve.x4;
  float& x5 = sve.x5;
  float& x6 = sve.x6;
  float& x8 = sve.x8;
  float& xmsave = sve.xmsave;
  //
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /INPUT2/
  // Cc      SAVE /RNDF77/
  lbanti = lb(i);
  // C
  dm = e(i);
  // C1. FOR N*+(1440) DECAY
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  const float etam = 0.5475f;
  if (fem::iabs(lb(i)) == 11) {
    x3 = ranart(nseed);
    if (x3 > (1.f / 3.f)) {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
    } else {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
    }
    // C2. FOR N*0(1440) DECAY
  } else if (fem::iabs(lb(i)) == 10) {
    x4 = ranart(nseed);
    if (x4 > (1.f / 3.f)) {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
    } else {
      lb(i) = 2;
      nalb = 2;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
    }
    // C N*(1535) CAN DECAY TO A PION OR AN ETA IF DM > 1.49 GeV
    // C3 N*(0)(1535) DECAY
  } else if (fem::iabs(lb(i)) == 12) {
    ctrl = 0.65f;
    if (dm <= 1.49f) {
      ctrl = -1.f;
    }
    x5 = ranart(nseed);
    if (x5 >= ctrl) {
      // C DECAY TO PION+NUCLEON
      x6 = ranart(nseed);
      if (x6 > (1.f / 3.f)) {
        lb(i) = 1;
        nlab = 1;
        lpion(nnn, irun) = 3;
        epion(nnn, irun) = ap2;
      } else {
        lb(i) = 2;
        nalb = 2;
        lpion(nnn, irun) = 4;
        epion(nnn, irun) = ap1;
      }
    } else {
      // C DECAY TO ETA+NEUTRON
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 0;
      epion(nnn, irun) = etam;
    }
    // C4. FOR N*+(1535) DECAY
  } else if (fem::iabs(lb(i)) == 13) {
    ctrl = 0.65f;
    if (dm <= 1.49f) {
      ctrl = -1.f;
    }
    x5 = ranart(nseed);
    if (x5 >= ctrl) {
      // C DECAY TO PION+NUCLEON
      x8 = ranart(nseed);
      if (x8 > (1.f / 3.f)) {
        lb(i) = 2;
        nlab = 2;
        lpion(nnn, irun) = 5;
        epion(nnn, irun) = ap2;
      } else {
        lb(i) = 1;
        nlab = 1;
        lpion(nnn, irun) = 4;
        epion(nnn, irun) = ap1;
      }
    } else {
      // C DECAY TO ETA+NUCLEON
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 0;
      epion(nnn, irun) = etam;
    }
  }
  // C
  dkine(cmn, irun, i, nnn, nlab, iseed, wid, nt);
  // C
  // C     anti-particle ID for anti-N* decays:
  if (lbanti < 0) {
    lbi = lb(i);
    if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    } else if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    }
    lb(i) = lbi;
    // C
    lbi = lpion(nnn, irun);
    if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    } else if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    }
    lpion(nnn, irun) = lbi;
  }
  // C
  if (nt == cmn.ntmax) {
    // C     at the last timestep, assign rho or eta (decay daughter)
    // C     to lb(i1) only (not to lpion) in order to decay them again:
    lbm = lpion(nnn, irun);
    if (lbm == 0 || lbm == 25 || lbm == 26 || lbm == 27) {
      // C     switch rho or eta with baryon, positions are the same (no change
      // needed):
      lbsave = lbm;
      xmsave = epion(nnn, irun);
      pxsave = ppion(1, nnn, irun);
      pysave = ppion(2, nnn, irun);
      pzsave = ppion(3, nnn, irun);
      // Clin-5/2008:
      dpsave = dppion(nnn, irun);
      lpion(nnn, irun) = lb(i);
      epion(nnn, irun) = e(i);
      ppion(1, nnn, irun) = p(1, i);
      ppion(2, nnn, irun) = p(2, i);
      ppion(3, nnn, irun) = p(3, i);
      // Clin-5/2008:
      dppion(nnn, irun) = dpertp(i);
      lb(i) = lbsave;
      e(i) = xmsave;
      p(1, i) = pxsave;
      p(2, i) = pysave;
      p(3, i) = pzsave;
      // Clin-5/2008:
      dpertp(i) = dpsave;
    }
  }
  // C
}

struct dkine2_save {
  float am;
  float bdx;
  float bdy;
  float bdz;
  float betax;
  float betay;
  float betaz;
  float bp0;
  float bpn;
  float bpn1;
  float bpp;
  float bpp1;
  float css;
  float devio;
  float dm;
  float edelta;
  float en;
  float enucl;
  float ep;
  float ep0;
  float epion1;
  float epion2;
  float epn;
  float epp;
  float fai;
  float fgd;
  float fgd1;
  float gd;
  float gd1;
  float p1m;
  float p1p;
  float p2m;
  float p2p;
  float p3m;
  float p3p;
  float pm1;
  float pm2;
  float pmax;
  float pmax2;
  float px;
  float px0;
  float pxn;
  float pxp;
  float py;
  float py0;
  float pyn;
  float pyp;
  float pz;
  float pz0;
  float pzn;
  float pzp;
  float q;
  float q2;
  float qs;
  float qx;
  float qy;
  float qz;
  float rx;
  float ry;
  float rz;
  float scheck;
  float sss;
  float tau0;
  float taudcy;

  dkine2_save()
      : am(fem::float0),
        bdx(fem::float0),
        bdy(fem::float0),
        bdz(fem::float0),
        betax(fem::float0),
        betay(fem::float0),
        betaz(fem::float0),
        bp0(fem::float0),
        bpn(fem::float0),
        bpn1(fem::float0),
        bpp(fem::float0),
        bpp1(fem::float0),
        css(fem::float0),
        devio(fem::float0),
        dm(fem::float0),
        edelta(fem::float0),
        en(fem::float0),
        enucl(fem::float0),
        ep(fem::float0),
        ep0(fem::float0),
        epion1(fem::float0),
        epion2(fem::float0),
        epn(fem::float0),
        epp(fem::float0),
        fai(fem::float0),
        fgd(fem::float0),
        fgd1(fem::float0),
        gd(fem::float0),
        gd1(fem::float0),
        p1m(fem::float0),
        p1p(fem::float0),
        p2m(fem::float0),
        p2p(fem::float0),
        p3m(fem::float0),
        p3p(fem::float0),
        pm1(fem::float0),
        pm2(fem::float0),
        pmax(fem::float0),
        pmax2(fem::float0),
        px(fem::float0),
        px0(fem::float0),
        pxn(fem::float0),
        pxp(fem::float0),
        py(fem::float0),
        py0(fem::float0),
        pyn(fem::float0),
        pyp(fem::float0),
        pz(fem::float0),
        pz0(fem::float0),
        pzn(fem::float0),
        pzp(fem::float0),
        q(fem::float0),
        q2(fem::float0),
        qs(fem::float0),
        qx(fem::float0),
        qy(fem::float0),
        qz(fem::float0),
        rx(fem::float0),
        ry(fem::float0),
        rz(fem::float0),
        scheck(fem::float0),
        sss(fem::float0),
        tau0(fem::float0),
        taudcy(fem::float0) {}
};

// C-------------------------------------------------------------------
// C--------------------------------------------------------------------------
// C         CALCULATE THE MOMENTUM OF NUCLEON AND PION (OR ETA)
// C         IN THE LAB. FRAME AFTER DELTA OR N* DECAY
// C DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA PRODUCTION
// C--------------------------------------------------------------------------
void dkine2(common& cmn, int const& irun, int const& i, int const& nnn,
            int const& nlab, int const& /* iseed */, float const& wid,
            int const& nt) {
  FEM_CMN_SVE(dkine2);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_cref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  //
  float& am = sve.am;
  float& bdx = sve.bdx;
  float& bdy = sve.bdy;
  float& bdz = sve.bdz;
  float& betax = sve.betax;
  float& betay = sve.betay;
  float& betaz = sve.betaz;
  float& bp0 = sve.bp0;
  float& bpn = sve.bpn;
  float& bpn1 = sve.bpn1;
  float& bpp = sve.bpp;
  float& bpp1 = sve.bpp1;
  float& css = sve.css;
  float& dm = sve.dm;
  float& edelta = sve.edelta;
  float& en = sve.en;
  float& ep = sve.ep;
  float& ep0 = sve.ep0;
  float& epn = sve.epn;
  float& epp = sve.epp;
  float& fai = sve.fai;
  float& fgd = sve.fgd;
  float& fgd1 = sve.fgd1;
  float& gd = sve.gd;
  float& gd1 = sve.gd1;
  float& p1m = sve.p1m;
  float& p1p = sve.p1p;
  float& p2m = sve.p2m;
  float& p2p = sve.p2p;
  float& p3m = sve.p3m;
  float& p3p = sve.p3p;
  float& pm1 = sve.pm1;
  float& pm2 = sve.pm2;
  float& pmax = sve.pmax;
  float& pmax2 = sve.pmax2;
  float& px = sve.px;
  float& px0 = sve.px0;
  float& pxn = sve.pxn;
  float& pxp = sve.pxp;
  float& py = sve.py;
  float& py0 = sve.py0;
  float& pyn = sve.pyn;
  float& pyp = sve.pyp;
  float& pz = sve.pz;
  float& pz0 = sve.pz0;
  float& pzn = sve.pzn;
  float& pzp = sve.pzp;
  float& q = sve.q;
  float& q2 = sve.q2;
  float& qs = sve.qs;
  float& qx = sve.qx;
  float& qy = sve.qy;
  float& qz = sve.qz;
  float& scheck = sve.scheck;
  float& sss = sve.sss;
  float& tau0 = sve.tau0;
  float& taudcy = sve.taudcy;
  const float amn = 0.939457f;
  const float amp = 0.93828f;
  const float pi = 3.1415926f;
  const float hbarc = 0.19733f;
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /leadng/
  // Cc      SAVE /tdecay/
  // Cc      SAVE /INPUT2/
  // Cc      SAVE /RNDF77/
  // C
  // C READ IN THE COORDINATES OF THE N*(1440) UNDERGOING DECAY
  px = p(1, i);
  py = p(2, i);
  pz = p(3, i);
  sve.rx = r(1, i);
  sve.ry = r(2, i);
  sve.rz = r(3, i);
  dm = e(i);
  edelta =
      fem::sqrt(fem::pow2(dm) + fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  pm1 = epion(nnn, irun);
  pm2 = epion(nnn + 1, irun);
  am = amn;
  if (nlab == 1) {
    am = amp;
  }
  // C THE MAXIMUM MOMENTUM OF THE NUCLEON FROM THE DECAY OF A N*
  pmax2 = (fem::pow2(dm) - fem::pow2((am + pm1 + pm2))) *
          (fem::pow2(dm) - fem::pow2((am - pm1 - pm2))) / 4 / fem::pow2(dm);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = pmax2;
  if (scheck < 0) {
    write(99, star), "scheck15: ", scheck;
    scheck = 0.f;
  }
  pmax = fem::sqrt(scheck);
  // C       PMAX=SQRT(PMAX2)
  // C
  // C GENERATE THE MOMENTUM OF THE NUCLEON IN THE N* REST FRAME
  css = 1.f - 2.f * ranart(nseed);
  sss = fem::sqrt(1 - fem::pow2(css));
  fai = 2 * pi * ranart(nseed);
  px0 = pmax * sss * fem::cos(fai);
  py0 = pmax * sss * fem::sin(fai);
  pz0 = pmax * css;
  ep0 = fem::sqrt(fem::pow2(px0) + fem::pow2(py0) + fem::pow2(pz0) +
                  fem::pow2(am));
  // Clin-5/23/01 bug: P0 for pion0 is equal to PMAX, leaving pion+ and pion-
  // C     without no relative momentum, thus producing them with equal momenta,
  // C BETA AND GAMMA OF THE CMS OF PION+-PION-
  betax = -px0 / (dm - ep0);
  betay = -py0 / (dm - ep0);
  betaz = -pz0 / (dm - ep0);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = 1 - fem::pow2(betax) - fem::pow2(betay) - fem::pow2(betaz);
  if (scheck <= 0) {
    write(99, star), "scheck16: ", scheck;
    FEM_STOP(0);
  }
  gd1 = 1.f / fem::sqrt(scheck);
  // C       GD1=1./SQRT(1-BETAX**2-BETAY**2-BETAZ**2)
  // C
  fgd1 = gd1 / (1 + gd1);
  // C GENERATE THE MOMENTA OF PIONS IN THE CMS OF PION+PION-
  q2 = fem::pow2(((dm - ep0) / (2.f * gd1))) - fem::pow2(pm1);
  if (q2 <= 0.f) {
    q2 = 1.e-09f;
  }
  q = fem::sqrt(q2);
statement_11:
  qx = 1.f - 2.f * ranart(nseed);
  qy = 1.f - 2.f * ranart(nseed);
  qz = 1.f - 2.f * ranart(nseed);
  qs = fem::pow2(qx) + fem::pow2(qy) + fem::pow2(qz);
  if (qs > 1.f) {
    goto statement_11;
  }
  pxp = q * qx / fem::sqrt(qs);
  pyp = q * qy / fem::sqrt(qs);
  pzp = q * qz / fem::sqrt(qs);
  ep = fem::sqrt(fem::pow2(q) + fem::pow2(pm1));
  pxn = -pxp;
  pyn = -pyp;
  pzn = -pzp;
  en = fem::sqrt(fem::pow2(q) + fem::pow2(pm2));
  // C TRANSFORM THE MOMENTA OF PION+PION- INTO THE N* REST FRAME
  bpp1 = betax * pxp + betay * pyp + betaz * pzp;
  bpn1 = betax * pxn + betay * pyn + betaz * pzn;
  // C FOR PION-
  p1m = pxn + betax * gd1 * (fgd1 * bpn1 + en);
  p2m = pyn + betay * gd1 * (fgd1 * bpn1 + en);
  p3m = pzn + betaz * gd1 * (fgd1 * bpn1 + en);
  epn = fem::sqrt(fem::pow2(p1m) + fem::pow2(p2m) + fem::pow2(p3m) +
                  fem::pow2(pm2));
  // C FOR PION+
  p1p = pxp + betax * gd1 * (fgd1 * bpp1 + ep);
  p2p = pyp + betay * gd1 * (fgd1 * bpp1 + ep);
  p3p = pzp + betaz * gd1 * (fgd1 * bpp1 + ep);
  epp = fem::sqrt(fem::pow2(p1p) + fem::pow2(p2p) + fem::pow2(p3p) +
                  fem::pow2(pm1));
  // C TRANSFORM MOMENTA OF THE THREE PIONS INTO THE
  // C THE NUCLEUS-NUCLEUS CENTER OF MASS  FRAME.
  // C THE GENERAL LORENTZ TRANSFORMATION CAN
  // C BE FOUND ON PAGE 34 OF R. HAGEDORN " RELATIVISTIC KINEMATICS"
  gd = edelta / dm;
  fgd = gd / (1.f + gd);
  bdx = px / edelta;
  bdy = py / edelta;
  bdz = pz / edelta;
  bp0 = bdx * px0 + bdy * py0 + bdz * pz0;
  bpp = bdx * p1p + bdy * p2p + bdz * p3p;
  bpn = bdx * p1m + bdy * p2m + bdz * p3m;
  // C FOR THE NUCLEON
  p(1, i) = px0 + bdx * gd * (fgd * bp0 + ep0);
  p(2, i) = py0 + bdy * gd * (fgd * bp0 + ep0);
  p(3, i) = pz0 + bdz * gd * (fgd * bp0 + ep0);
  e(i) = am;
  id(i) = 0;
  sve.enucl = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                        fem::pow2(p(3, i)) + fem::pow2(e(i)));
  // C WE ASSUME THAT THE SPACIAL COORDINATE OF THE PION0
  // C IS in a sphere of radius 0.5 fm around N*
  // C FOR PION+
  ppion(1, nnn, irun) = p1p + bdx * gd * (fgd * bpp + epp);
  ppion(2, nnn, irun) = p2p + bdy * gd * (fgd * bpp + epp);
  ppion(3, nnn, irun) = p3p + bdz * gd * (fgd * bpp + epp);
  sve.epion1 = fem::sqrt(
      fem::pow2(ppion(1, nnn, irun)) + fem::pow2(ppion(2, nnn, irun)) +
      fem::pow2(ppion(3, nnn, irun)) + fem::pow2(epion(nnn, irun)));
  // Clin-2/20/03 no additional smearing for position of decay daughters:
  // C200         X0 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y0 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z0 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 200
  // C        RPION(1,NNN,IRUN)=R(1,I)+0.5*x0
  // C        RPION(2,NNN,IRUN)=R(2,I)+0.5*y0
  // C        RPION(3,NNN,IRUN)=R(3,I)+0.5*z0
  rpion(1, nnn, irun) = r(1, i);
  rpion(2, nnn, irun) = r(2, i);
  rpion(3, nnn, irun) = r(3, i);
  // C FOR PION-
  ppion(1, nnn + 1, irun) = p1m + bdx * gd * (fgd * bpn + epn);
  ppion(2, nnn + 1, irun) = p2m + bdy * gd * (fgd * bpn + epn);
  ppion(3, nnn + 1, irun) = p3m + bdz * gd * (fgd * bpn + epn);
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i);
  dppion(nnn + 1, irun) = dpertp(i);
  // C
  sve.epion2 = fem::sqrt(
      fem::pow2(ppion(1, nnn + 1, irun)) + fem::pow2(ppion(2, nnn + 1, irun)) +
      fem::pow2(ppion(3, nnn + 1, irun)) + fem::pow2(epion(nnn + 1, irun)));
  // Clin-2/20/03 no additional smearing for position of decay daughters:
  // C300         X0 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y0 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z0 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 300
  // C        RPION(1,NNN+1,IRUN)=R(1,I)+0.5*x0
  // C        RPION(2,NNN+1,IRUN)=R(2,I)+0.5*y0
  // C        RPION(3,NNN+1,IRUN)=R(3,I)+0.5*z0
  rpion(1, nnn + 1, irun) = r(1, i);
  rpion(2, nnn + 1, irun) = r(2, i);
  rpion(3, nnn + 1, irun) = r(3, i);
  // C
  // C check energy conservation in the decay
  // C       efinal=enucl+epion1+epion2
  // C       DEEE=(EDELTA-EFINAL)/EDELTA
  // C       IF(ABS(DEEE).GE.1.E-03)write(6,*)1,edelta,efinal
  // C
  sve.devio =
      fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppion(1, nnn, irun)) +
                fem::pow2(ppion(2, nnn, irun)) +
                fem::pow2(ppion(3, nnn, irun))) +
      fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                fem::pow2(p(3, i))) +
      fem::sqrt(fem::pow2(epion(nnn + 1, irun)) +
                fem::pow2(ppion(1, nnn + 1, irun)) +
                fem::pow2(ppion(2, nnn + 1, irun)) +
                fem::pow2(ppion(3, nnn + 1, irun))) -
      e1;
  // C        if(abs(devio).gt.0.02) write(93,*) 'decay2(): nt=',nt,devio,lb1
  // C
  // C     add decay time to daughter's formation time at the last timestep:
  if (nt == cmn.ntmax) {
    tau0 = hbarc / wid;
    taudcy = tau0 * (-1.f) * fem::alog(1.f - ranart(nseed));
    // C     lorentz boost:
    taudcy = taudcy * e1 / cmn.em1;
    tfnl += taudcy;
    xfnl += px1 / e1 * taudcy;
    yfnl += py1 / e1 * taudcy;
    zfnl += pz1 / e1 * taudcy;
    r(1, i) = xfnl;
    r(2, i) = yfnl;
    r(3, i) = zfnl;
    tfdcy(i) = tfnl;
    rpion(1, nnn, irun) = xfnl;
    rpion(2, nnn, irun) = yfnl;
    rpion(3, nnn, irun) = zfnl;
    tfdpi(nnn, irun) = tfnl;
    rpion(1, nnn + 1, irun) = xfnl;
    rpion(2, nnn + 1, irun) = yfnl;
    rpion(3, nnn + 1, irun) = zfnl;
    tfdpi(nnn + 1, irun) = tfnl;
  }
  // C
}

struct decay2_save {
  float dm;
  int lbanti;
  int lbi;
  int nlab;
  float x3;

  decay2_save()
      : dm(fem::float0),
        lbanti(fem::int0),
        lbi(fem::int0),
        nlab(fem::int0),
        x3(fem::float0) {}
};

// C
// C-----------------------------------------------------------------------------
// C PURPOSE:1. N*-->N+PION+PION  DECAY PRODUCTS
// C         2. DETERMINE THE MOMENTUM AND COORDINATES OF NUCLEON AND PION
// C            AFTER THE DELTA OR N* DECAYING
// C DATE   : NOV.7,1994
// C----------------------------------------------------------------------------
void decay2(common& cmn, int const& irun, int const& i, int const& nnn,
            int const& iseed, float const& wid, int const& nt) {
  FEM_CMN_SVE(decay2);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON pc
  const int maxr = 1;
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  // COMMON pd
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  int& lbanti = sve.lbanti;
  int& lbi = sve.lbi;
  int& nlab = sve.nlab;
  float& x3 = sve.x3;
  //
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /RNDF77/
  // C
  lbanti = lb(i);
  // C
  sve.dm = e(i);
  // C DETERMINE THE DECAY PRODUCTS
  // C FOR N*+(1440) DECAY
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if (fem::iabs(lb(i)) == 11) {
    x3 = ranart(nseed);
    if (x3 < (1.f / 3)) {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    } else if (x3 < 2.f / 3 && x3 > 1.f / 3.f) {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 3;
      epion(nnn + 1, irun) = ap2;
    } else {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    }
    // C FOR N*0(1440) DECAY
  } else if (fem::iabs(lb(i)) == 10) {
    x3 = ranart(nseed);
    if (x3 < (1.f / 3)) {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    } else if (x3 < 2.f / 3 && x3 > 1.f / 3.f) {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    } else {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 3;
      epion(nnn + 1, irun) = ap2;
    }
  }
  // C
  dkine2(cmn, irun, i, nnn, nlab, iseed, wid, nt);
  // C
  // C     anti-particle ID for anti-N* decays:
  if (lbanti < 0) {
    lbi = lb(i);
    if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    } else if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    }
    lb(i) = lbi;
    // C
    lbi = lpion(nnn, irun);
    if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    } else if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    }
    lpion(nnn, irun) = lbi;
    // C
    lbi = lpion(nnn + 1, irun);
    if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    } else if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    }
    lpion(nnn + 1, irun) = lbi;
  }
  // C
}

struct dreson_save {
  float dm;
  double e10;
  double e20;
  int i;
  double p1;
  double p2;
  double p3;
  double scheck;

  dreson_save()
      : dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        i(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0) {}
};

// C---------------------------------------------------------------------------
// C PURPOSE : CALCULATE THE MASS AND MOMENTUM OF BARYON RESONANCE
// C           AFTER PION OR ETA BEING ABSORBED BY A NUCLEON
// C NOTE    :
// C
// C DATE    : JAN.29,1990
void dreson(common& cmn, int const& i1, int const& i2) {
  FEM_CMN_SVE(dreson);
  common_write write(cmn);
  // COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON cc
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  int& i = sve.i;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  //
  // Clin-9/2012: improve precision for argument in sqrt():
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // C 1. DETERMINE THE MOMENTUM COMPONENT OF DELTA/N* IN THE LAB. FRAME
  // Clin-9/2012: improve precision for argument in sqrt():
  // C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  // C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  // C
  if (fem::iabs(lb(i2)) == 1 || fem::iabs(lb(i2)) == 2 ||
      (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 17)) {
    e(i1) = 0.f;
    i = i2;
  } else {
    e(i2) = 0.f;
    i = i1;
  }
  p(1, i) = p(1, i1) + p(1, i2);
  p(2, i) = p(2, i1) + p(2, i2);
  p(3, i) = p(3, i1) + p(3, i2);
  // C 2. DETERMINE THE MASS OF DELTA/N* BY USING THE REACTION KINEMATICS
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck17: ", scheck;
    write(99, star), "scheck17", scheck, e10, e20, p(1, i), p(2, i), p(3, i);
    write(99, star), "scheck17-1", e(i1), p(1, i1), p(2, i1), p(3, i1);
    write(99, star), "scheck17-2", e(i2), p(1, i2), p(2, i2), p(3, i2);
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  // C        DM=SQRT((E10+E20)**2-P(1,I)**2-P(2,I)**2-P(3,I)**2)
  // C
  e(i) = dm;
}

struct xnpi_save {
  float avmass;
  float avpi;
  float dm;
  double e10;
  double e20;
  float f1;
  float gam;
  double p1;
  double p2;
  double p3;
  float pdelt2;
  float pstar2;
  double scheck;

  xnpi_save()
      : avmass(fem::float0),
        avpi(fem::float0),
        dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        f1(fem::float0),
        gam(fem::float0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        pdelt2(fem::float0),
        pstar2(fem::float0),
        scheck(fem::double0) {}
};

// C---------------------------------------------------------------------------
// C PURPOSE : CALCULATE THE PION+NUCLEON CROSS SECTION ACCORDING TO THE
// C           BREIT-WIGNER FORMULA/(p*)**2
// C VARIABLE : LA = 1 FOR DELTA RESONANCE
// C            LA = 0 FOR N*(1440) RESONANCE
// C            LA = 2 FRO N*(1535) RESONANCE
// C DATE    : JAN.29,1990
float xnpi(common& cmn, int const& i1, int const& i2, int const& la,
           float const& xmax) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xnpi);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_cref<float> e(cmn.e, dimension(maxstr));
  //
  float& avmass = sve.avmass;
  float& avpi = sve.avpi;
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  float& f1 = sve.f1;
  float& gam = sve.gam;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  float& pdelt2 = sve.pdelt2;
  float& pstar2 = sve.pstar2;
  double& scheck = sve.scheck;
  const float amn = 0.939457f;
  const float amp = 0.93828f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  // Clin-9/2012: improve precision for argument in sqrt():
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  avmass = 0.5f * (amn + amp);
  avpi = (2.f * ap2 + ap1) / 3.f;
  // C 1. DETERMINE THE MOMENTUM COMPONENT OF DELTA IN THE LAB. FRAME
  // Clin-9/2012: improve precision for argument in sqrt():
  // C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  // C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  // C        P1=P(1,I1)+P(1,I2)
  // C        P2=P(2,I1)+P(2,I2)
  // C        P3=P(3,I1)+P(3,I2)
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  // C
  // C 2. DETERMINE THE MASS OF DELTA BY USING OF THE REACTION KINEMATICS
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck19: ", scheck;
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  // C        DM=SQRT((E10+E20)**2-P1**2-P2**2-P3**2)
  // C
  if (dm <= 1.1f) {
    return_value = 1.e-09f;
    return return_value;
  }
  // C 3. DETERMINE THE PION+NUCLEON CROSS SECTION ACCORDING TO THE
  // C    BREIT-WIGNER FORMULA IN UNIT OF FM**2
  if (la == 1) {
    gam = width(cmn, dm);
    f1 = 0.25f * fem::pow2(gam) /
         (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.232f)));
    pdelt2 = 0.051622f;
    goto statement_10;
  }
  if (la == 0) {
    gam = w1440(cmn, dm);
    f1 = 0.25f * fem::pow2(gam) /
         (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.440f)));
    pdelt2 = 0.157897f;
    goto statement_10;
  }
  if (la == 2) {
    gam = w1535(cmn, dm);
    f1 = 0.25f * fem::pow2(gam) /
         (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.535f)));
    pdelt2 = 0.2181f;
  }
statement_10:
  pstar2 = fem::pow2(((fem::pow2(dm) - fem::pow2(avmass) + fem::pow2(avpi)) /
                      (2.f * dm))) -
           fem::pow2(avpi);
  if (pstar2 <= 0.f) {
    return_value = 1.e-09f;
  } else {
    // C give the cross section in unit of fm**2
    return_value = f1 * (pdelt2 / pstar2) * xmax / 10.f;
  }
  return return_value;
}

struct pnlka_save {
  float aka;
  float ala;
  float ana;
  float sbbk;
  float t1;

  pnlka_save()
      : aka(fem::float0),
        ala(fem::float0),
        ana(fem::float0),
        sbbk(fem::float0),
        t1(fem::float0) {}
};

// C--------------------------------------------------------------------------
// C****subprogram * kaon production from pi+B collisions *******************
float pnlka(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pnlka);
  // SAVE
  float& aka = sve.aka;
  float& ala = sve.ala;
  float& sbbk = sve.sbbk;
  float& t1 = sve.t1;
  //
  // C units: fm**2
  // C**********************************C
  ala = 1.116f;
  aka = 0.498f;
  sve.ana = 0.939f;
  t1 = ala + aka;
  if (srt <= t1) {
    return_value = 0;
  } else {
    if (srt < 1.7f) {
      sbbk = (0.9f / 0.091f) * (srt - t1);
    }
    if (srt >= 1.7f) {
      sbbk = 0.09f / (srt - 1.6f);
    }
    return_value = 0.25f * sbbk;
    // C give the cross section in units of fm**2
    return_value = return_value / 10.f;
  }
  return return_value;
}

struct pnska_save {
  float aka;
  float ala;
  float ana;
  float asa;
  float sbb1;
  float sbb2;
  float t1;

  pnska_save()
      : aka(fem::float0),
        ala(fem::float0),
        ana(fem::float0),
        asa(fem::float0),
        sbb1(fem::float0),
        sbb2(fem::float0),
        t1(fem::float0) {}
};

// C-------------------------------------------------------------------------
// C****subprogram * kaon production from pi+B collisions *******************
float pnska(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pnska);
  // SAVE
  float& aka = sve.aka;
  float& asa = sve.asa;
  float& sbb1 = sve.sbb1;
  float& sbb2 = sve.sbb2;
  float& t1 = sve.t1;
  //
  // C**********************************
  if (srt > 3.0f) {
    return_value = 0;
    return return_value;
  }
  sve.ala = 1.116f;
  aka = 0.498f;
  sve.ana = 0.939f;
  asa = 1.197f;
  t1 = asa + aka;
  if (srt <= t1) {
    return_value = 0;
    return return_value;
  }
  if (srt < 1.9f) {
    sbb1 = (0.7f / 0.218f) * (srt - t1);
  }
  if (srt >= 1.9f) {
    sbb1 = 0.14f / (srt - 1.7f);
  }
  sbb2 = 0.f;
  if (srt > 1.682f) {
    sbb2 = 0.5f * (1.f - 0.75f * (srt - 1.682f));
  }
  return_value = 0.25f * (sbb1 + sbb2);
  // C give the cross section in fm**2
  return_value = return_value / 10.f;
  return return_value;
}

struct wida1_save {
  float coupa;
  float epi;
  float epirho;
  float erho;
  int icount;
  float pimass;
  float qqp;
  float qqp2;
  float rhomax;

  wida1_save()
      : coupa(fem::float0),
        epi(fem::float0),
        epirho(fem::float0),
        erho(fem::float0),
        icount(fem::int0),
        pimass(fem::float0),
        qqp(fem::float0),
        qqp2(fem::float0),
        rhomax(fem::float0) {}
};

// C***********************************
// C FUNCTION WA1(DMASS) GIVES THE A1 DECAY WIDTH
// C
void wida1(common& cmn, float const& dmass, float& rhomp, float& wa1,
           int const& iseed) {
  FEM_CMN_SVE(wida1);
  float& coupa = sve.coupa;
  float& epi = sve.epi;
  float& epirho = sve.epirho;
  float& erho = sve.erho;
  int& icount = sve.icount;
  float& pimass = sve.pimass;
  float& qqp = sve.qqp;
  float& qqp2 = sve.qqp2;
  float& rhomax = sve.rhomax;
  // C
  pimass = 0.137265f;
  coupa = 14.8f;
  // C
  rhomax = dmass - pimass - 0.02f;
  if (rhomax <= 0) {
    rhomp = 0.f;
    // C   !! no decay
    wa1 = -10.f;
  }
  icount = 0;
statement_711:
  rhomp = rhomas(cmn, rhomax, iseed);
  icount++;
  if (dmass <= (pimass + rhomp)) {
    if (icount <= 100) {
      goto statement_711;
    } else {
      rhomp = 0.f;
      // C   !! no decay
      wa1 = -10.f;
      return;
    }
  }
  qqp2 = (fem::pow2(dmass) - fem::pow2((rhomp + pimass))) *
         (fem::pow2(dmass) - fem::pow2((rhomp - pimass)));
  qqp = fem::sqrt(qqp2) / (2.0f * dmass);
  epi = fem::sqrt(fem::pow2(pimass) + fem::pow2(qqp));
  erho = fem::sqrt(fem::pow2(rhomp) + fem::pow2(qqp));
  epirho = 2.0f * fem::pow2((epi * erho + fem::pow2(qqp))) +
           fem::pow2(rhomp) * fem::pow2(epi);
  wa1 = fem::pow2(coupa) * qqp * epirho / (24.0f * 3.1416f * fem::pow2(dmass));
}

struct xn1535_save {
  float avmass;
  float avpi;
  float dm;
  double e10;
  double e20;
  float f1;
  float gam;
  float gam0;
  double p1;
  double p2;
  double p3;
  double scheck;
  float xmax;

  xn1535_save()
      : avmass(fem::float0),
        avpi(fem::float0),
        dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        f1(fem::float0),
        gam(fem::float0),
        gam0(fem::float0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0),
        xmax(fem::float0) {}
};

// C***************
// C PURPOSE : CALCULATE THE PION(ETA)+NUCLEON CROSS SECTION
// C           ACCORDING TO THE BREIT-WIGNER FORMULA,
// C           NOTE THAT N*(1535) IS S_11
// C VARIABLE : LA = 1 FOR PI+N
// C            LA = 0 FOR ETA+N
// C DATE    : MAY 16, 1994
// C***************
float xn1535(common& cmn, int const& i1, int const& i2, int const& la) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xn1535);
  common_write write(cmn);
  // COMMON bb
  const int maxstr = 150001;
  arr_cref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON cc
  arr_cref<float> e(cmn.e, dimension(maxstr));
  //
  // SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  float& f1 = sve.f1;
  float& gam = sve.gam;
  float& gam0 = sve.gam0;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  float& xmax = sve.xmax;
  //
  // Clin-9/2012: improve precision for argument in sqrt():
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  const float amn = 0.939457f;
  const float amp = 0.93828f;
  sve.avmass = 0.5f * (amn + amp);
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  sve.avpi = (2.f * ap2 + ap1) / 3.f;
  // C 1. DETERMINE THE MOMENTUM COMPONENT OF N*(1535) IN THE LAB. FRAME
  // Clin-9/2012: improve precision for argument in sqrt():
  // C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  // C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  // C        P1=P(1,I1)+P(1,I2)
  // C        P2=P(2,I1)+P(2,I2)
  // C        P3=P(3,I1)+P(3,I2)
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  // C
  // C 2. DETERMINE THE MASS OF DELTA BY USING OF THE REACTION KINEMATICS
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck21: ", scheck;
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  // C        DM=SQRT((E10+E20)**2-P1**2-P2**2-P3**2)
  // C
  if (dm <= 1.1f) {
    return_value = 1.e-06f;
    return return_value;
  }
  // C 3. DETERMINE THE PION(ETA)+NUCLEON->N*(1535) CROSS SECTION ACCORDING TO
  // THE C    BREIT-WIGNER FORMULA IN UNIT OF FM**2
  gam = w1535(cmn, dm);
  gam0 = 0.15f;
  f1 = 0.25f * fem::pow2(gam0) /
       (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.535f)));
  if (la == 1) {
    xmax = 11.3f;
  } else {
    xmax = 74.f;
  }
  return_value = f1 * xmax / 10.f;
  return return_value;
}

struct pp2_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmax;
  float pmin;
  float scheck;

  pp2_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0),
        scheck(fem::float0) {}
};

// C*****************************************
// C for pp-->elastic
// C      real*4 function pp2(srt)
float pp2(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pp2);
  common_write write(cmn);
  // SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  float& scheck = sve.scheck;
  //
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (scheck < 0) {
    write(99, star), "scheck33: ", scheck;
    scheck = 0.f;
  }
  plab = fem::sqrt(scheck);
  // C      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
  // C
  pmin = 2.f;
  pmax = 2050;
  if (plab > pmax) {
    return_value = 8.f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 25.f;
    return return_value;
  }
  // C* fit parameters
  a = 11.2f;
  b = 25.5f;
  c = 0.151f;
  d = -1.62f;
  an = -1.12f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0;
  }
  return return_value;
}

struct ppt_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmax;
  float pmin;
  float scheck;

  ppt_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0),
        scheck(fem::float0) {}
};

// C
// C*****************************************
// C for pp-->total
// C      real*4 function ppt(srt)
float ppt(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppt);
  common_write write(cmn);
  // SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  float& scheck = sve.scheck;
  //
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (scheck < 0) {
    write(99, star), "scheck34: ", scheck;
    scheck = 0.f;
  }
  plab = fem::sqrt(scheck);
  // C      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
  // C
  pmin = 3.f;
  pmax = 2100;
  if ((plab < pmin) || (plab > pmax)) {
    return_value = 55.f;
    return return_value;
  }
  // C* fit parameters
  a = 45.6f;
  b = 219.0f;
  c = 0.410f;
  d = -3.41f;
  an = -4.23f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0.0f;
  }
  return return_value;
}

struct ppxs_save {
  float d00;
  float d11;
  float d20;
  float erh;
  float erho;
  float esi;
  float esigma;
  float q;
  float s0;
  float s1;
  float s2;
  float trho;
  float tsigma;

  ppxs_save()
      : d00(fem::float0),
        d11(fem::float0),
        d20(fem::float0),
        erh(fem::float0),
        erho(fem::float0),
        esi(fem::float0),
        esigma(fem::float0),
        q(fem::float0),
        s0(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        trho(fem::float0),
        tsigma(fem::float0) {}
};

// C****************************
void ppxs(common& cmn, int const& lb1, int const& lb2, float const& srt,
          float& ppsig, float& spprho, int& ipp) {
  FEM_CMN_SVE(ppxs);
  float& d00 = sve.d00;
  float& d11 = sve.d11;
  float& d20 = sve.d20;
  float& erh = sve.erh;
  float& erho = sve.erho;
  float& esi = sve.esi;
  float& esigma = sve.esigma;
  float& q = sve.q;
  float& s0 = sve.s0;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& trho = sve.trho;
  float& tsigma = sve.tsigma;
  const float amp = 0.14f;
  const float pi = 3.1415926f;
  // C purpose: this subroutine gives the cross section for pion+pion
  // C          elastic collision
  // C variables:
  // C       input: lb1,lb2 and srt are the labels and srt for I1 and I2
  // C       output: ppsig: pp xsection
  // C               ipp: label for the pion+pion channel
  // C               Ipp=0 NOTHING HAPPEND
  // C                  1 for Pi(+)+PI(+) DIRECT
  // C                   2     PI(+)+PI(0) FORMING RHO(+)
  // C                  3     PI(+)+PI(-) FORMING RHO(0)
  // C                   4     PI(0)+PI(O) DIRECT
  // C                  5     PI(0)+PI(-) FORMING RHO(-)
  // C                  6     PI(-)+PI(-) DIRECT
  // C reference: G.F. Bertsch, Phys. Rev. D37 (1988) 1202.
  // C date : Aug 29, 1994
  // C****************************
  ppsig = 0.0f;
  // C
  // Cbzdbg10/15/99
  spprho = 0.0f;
  // Cbzdbg10/15/99 end
  // C
  ipp = 0;
  if (srt <= 0.3f) {
    return;
  }
  q = fem::sqrt(fem::pow2((srt / 2)) - fem::pow2(amp));
  esigma = 5.8f * amp;
  tsigma = 2.06f * q;
  erho = 0.77f;
  trho = 0.095f * q * fem::pow2((q / amp / (1.f + fem::pow2((q / erho)))));
  esi = esigma - srt;
  if (esi == 0) {
    d00 = pi / 2.f;
    goto statement_10;
  }
  d00 = fem::atan(tsigma / 2.f / esi);
statement_10:
  erh = erho - srt;
  if (erh == 0.f) {
    d11 = pi / 2.f;
    goto statement_20;
  }
  d11 = fem::atan(trho / 2.f / erh);
statement_20:
  d20 = -0.12f * q / amp;
  s0 = 8.f * pi * fem::pow2(fem::sin(d00)) / fem::pow2(q);
  s1 = 8 * pi * 3 * fem::pow2(fem::sin(d11)) / fem::pow2(q);
  s2 = 8 * pi * 5 * fem::pow2(fem::sin(d20)) / fem::pow2(q);
  // C    !! GeV^-2 to mb
  s0 = s0 * fem::pow2(0.197f) * 10.f;
  s1 = s1 * fem::pow2(0.197f) * 10.f;
  s2 = s2 * fem::pow2(0.197f) * 10.f;
  // C       ppXS=s0/9.+s1/3.+s2*0.56
  // C       if(ppxs.le.0)ppxs=0.00001
  spprho = s1 / 2.f;
  // C (1) PI(+)+PI(+)
  if (lb1 == 5 && lb2 == 5) {
    ipp = 1;
    ppsig = s2;
    return;
  }
  // C (2) PI(+)+PI(0)
  if ((lb1 == 5 && lb2 == 4) || (lb1 == 4 && lb2 == 5)) {
    ipp = 2;
    ppsig = s2 / 2.f + s1 / 2.f;
    return;
  }
  // C (3) PI(+)+PI(-)
  if ((lb1 == 5 && lb2 == 3) || (lb1 == 3 && lb2 == 5)) {
    ipp = 3;
    ppsig = s2 / 6.f + s1 / 2.f + s0 / 3.f;
    return;
  }
  // C (4) PI(0)+PI(0)
  if (lb1 == 4 && lb2 == 4) {
    ipp = 4;
    ppsig = 2 * s2 / 3.f + s0 / 3.f;
    return;
  }
  // C (5) PI(0)+PI(-)
  if ((lb1 == 4 && lb2 == 3) || (lb1 == 3 && lb2 == 4)) {
    ipp = 5;
    ppsig = s2 / 2.f + s1 / 2.f;
    return;
  }
  // C (6) PI(-)+PI(-)
  if (lb1 == 3 && lb2 == 3) {
    ipp = 6;
    ppsig = s2;
  }
}

struct twopi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  float pmass1;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  twopi_save()
      : earray(dimension(19), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        xarray(dimension(19), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for ppi(+)-->DELTA+pi
// C      real*4 function TWOPI(srt)
float twopi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(twopi);
  // SAVE
  arr_ref<float> earray(sve.earray, dimension(19));
  int& ie = sve.ie;
  float& plab = sve.plab;
  arr_ref<float> xarray(sve.xarray, dimension(19));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {
          0.300e-05f, 0.187e+01f, 0.110e+02f, 0.149e+02f, 0.935e+01f,
          0.765e+01f, 0.462e+01f, 0.345e+01f, 0.241e+01f, 0.185e+01f,
          0.165e+01f, 0.150e+01f, 0.132e+01f, 0.117e+01f, 0.116e+01f,
          0.100e+01f, 0.856e+00f, 0.745e+00f, 0.300e-05f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {
          0.122e+01f, 0.147e+01f, 0.172e+01f, 0.197e+01f, 0.222e+01f,
          0.247e+01f, 0.272e+01f, 0.297e+01f, 0.322e+01f, 0.347e+01f,
          0.372e+01f, 0.397e+01f, 0.422e+01f, 0.447e+01f, 0.472e+01f,
          0.497e+01f, 0.522e+01f, 0.547e+01f, 0.572e+01f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  This function contains the experimental pi+p-->DELTA+PION cross sections
  // * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  // C      real*4   xarray(19), earray(19)
  // C
  sve.pmass = 0.14f;
  sve.pmass1 = 0.938f;
  return_value = 0.000001f;
  if (srt <= 1.22f) {
    return return_value;
  }
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  plab = srt;
  if (plab < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 19) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct threpi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  float pmass1;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  threpi_save()
      : earray(dimension(15), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        xarray(dimension(15), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for ppi(+)-->DELTA+RHO
// C      real*4 function THREPI(srt)
float threpi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(threpi);
  // SAVE
  arr_ref<float> earray(sve.earray, dimension(15));
  int& ie = sve.ie;
  float& plab = sve.plab;
  arr_ref<float> xarray(sve.xarray, dimension(15));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {
          8.0000000e-06f, 6.1999999e-05f, 1.881940f, 5.025690f, 11.80154f,
          13.92114f,      15.07308f,      11.79571f, 11.53772f, 10.01197f,
          9.792673f,      9.465264f,      8.970490f, 7.944254f, 6.886320f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {
          0.122e+01f, 0.147e+01f, 0.172e+01f, 0.197e+01f, 0.222e+01f,
          0.247e+01f, 0.272e+01f, 0.297e+01f, 0.322e+01f, 0.347e+01f,
          0.372e+01f, 0.397e+01f, 0.422e+01f, 0.447e+01f, 0.472e+01f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  This function contains the experimental pi+p-->DELTA + rho cross
  // sections  * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross
  // section in mb                                    * C  earray = EXPerimental
  // table with proton energies in MeV                    * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  // C      real*4   xarray(15), earray(15)
  // C
  sve.pmass = 0.14f;
  sve.pmass1 = 0.938f;
  return_value = 0.000001f;
  if (srt <= 1.36f) {
    return return_value;
  }
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  plab = srt;
  if (plab < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 15) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct fourpi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  float pmass1;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  fourpi_save()
      : earray(dimension(10), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        xarray(dimension(10), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for ppi(+)-->DELTA+omega
// C      real*4 function FOURPI(srt)
float fourpi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fourpi);
  // SAVE
  arr_ref<float> earray(sve.earray, dimension(10));
  int& ie = sve.ie;
  float& plab = sve.plab;
  arr_ref<float> xarray(sve.xarray, dimension(10));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {0.0001f,   1.986597f, 6.411932f, 7.636956f,
                                     9.598362f, 9.889740f, 10.24317f, 10.80138f,
                                     11.86988f, 12.83925f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {
          2.468f,     2.718f,     2.968f,     0.322e+01f, 0.347e+01f,
          0.372e+01f, 0.397e+01f, 0.422e+01f, 0.447e+01f, 0.472e+01f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  This function contains the experimental pi+p-->DELTA+PION cross sections
  // * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  // C      real*4   xarray(10), earray(10)
  // C
  sve.pmass = 0.14f;
  sve.pmass1 = 0.938f;
  return_value = 0.000001f;
  if (srt <= 1.52f) {
    return return_value;
  }
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  plab = srt;
  if (plab < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 10) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct crpn_save {
  float ameson;
  float aomega;
  float arho;
  float c1;
  float cc1;
  float ct1;
  float dm;
  float dmax;
  float em1;
  float em2;
  int ianti;
  int ii;
  int ipi;
  int jj;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float x1;
  float x2;
  float xptr;

  crpn_save()
      : ameson(fem::float0),
        aomega(fem::float0),
        arho(fem::float0),
        c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        dm(fem::float0),
        dmax(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        ii(fem::int0),
        ipi(fem::int0),
        jj(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xptr(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crpn(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& xkaon0,
          float const& xkaon, float const& xphi, float const& xphin) {
  FEM_CMN_SVE(crpn);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& iseed = cmn.iseed;
  int& nseed = cmn.nseed;
  //
  float& ameson = sve.ameson;
  float& aomega = sve.aomega;
  float& arho = sve.arho;
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& dm = sve.dm;
  float& dmax = sve.dmax;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kaonc = sve.kaonc;
  int& ntag = sve.ntag;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xptr = sve.xptr;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float aphi = 1.020f;
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  // C     PURPOSE:                                                         *
  // C           DEALING WITH PION+N-->L/S+KAON PROCESS AND PION PRODUCTION *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     7  PION+N-->L/S+KAON
  // C           iblock   - 77 pion+N-->Delta+pion
  // C           iblock   - 78 pion+N-->Delta+RHO
  // C           iblock   - 79 pion+N-->Delta+OMEGA
  // C           iblock   - 222 pion+N-->Phi
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
  }
  if (xkaon0 / (xkaon + xphi) >= x1) {
    // C kaon production
    // C-----------------------------------------------------------------------
    iblock = 7;
    if (ianti == 1) {
      iblock = -7;
    }
    ntag = 0;
    // C RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
    // C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
    // C MOMENTA FOR PARTICLES IN THE FINAL STATE.
    kaonc = 0;
    if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
      kaonc = 1;
    }
    if (e(i1) <= 0.2f) {
      lb(i1) = 23;
      e(i1) = aka;
      if (kaonc == 1) {
        lb(i2) = 14;
        e(i2) = ala;
      } else {
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        e(i2) = asa;
      }
      if (ianti == 1) {
        lb(i1) = 21;
        lb(i2) = -lb(i2);
      }
    } else {
      lb(i2) = 23;
      e(i2) = aka;
      if (kaonc == 1) {
        lb(i1) = 14;
        e(i1) = ala;
      } else {
        lb(i1) = 15 + fem::fint(3 * ranart(nseed));
        e(i1) = asa;
      }
      if (ianti == 1) {
        lb(i2) = 21;
        lb(i1) = -lb(i1);
      }
    }
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
    // C to gererate the momentum for the kaon and L/S
  } else if (xphi / (xkaon + xphi) >= x1) {
    iblock = 222;
    if (xphin / xphi >= ranart(nseed)) {
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      e(i1) = amn;
    } else {
      lb(i1) = 6 + fem::fint(4 * ranart(nseed));
      e(i1) = am0;
    }
    // C  !! at present only baryon
    if (ianti == 1) {
      lb(i1) = -lb(i1);
    }
    lb(i2) = 29;
    e(i2) = aphi;
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
  } else {
    // C CHECK WHAT KIND OF PION PRODUCTION PROCESS HAS HAPPENED
    if (ranart(nseed) <= twopi(cmn, srt) / (twopi(cmn, srt) + threpi(cmn, srt) +
                                            fourpi(cmn, srt))) {
      iblock = 77;
    } else {
      if (threpi(cmn, srt) / (threpi(cmn, srt) + fourpi(cmn, srt)) >
          ranart(nseed)) {
        iblock = 78;
      } else {
        iblock = 79;
      }
    }
    ntag = 0;
    // C pion production (Delta+pion/rho/omega in the final state)
    // C generate the mass of the delta resonance
    x2 = ranart(nseed);
    // C relable the particles
    if (iblock == 77) {
      // C GENERATE THE DELTA MASS
      dmax = srt - ap1 - 0.02f;
      dm = rmass(cmn, dmax, iseed);
      // C pion+baryon-->pion+delta
      // C Relable particles, I1 is assigned to the Delta and I2 is assigned to
      // the C meson C(1) for pi(+)+p-->D(+)+P(+) OR D(++)+p(0)
      if (((lb(i1) == 1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          } else {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 4;
            sve.ipi = 4;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          } else {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      // C(2) for pi(-)+p-->D(0)+P(0) OR D(+)+p(-),or D(-)+p(+)
      if (((lb(i1) == 1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      // C(3) for pi(+)+n-->D(+)+Pi(0) OR D(++)+p(-) or D(0)+pi(+)
      if (((lb(i1) == 2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      // C(4) for pi(0)+p-->D(+)+Pi(0) OR D(++)+p(-) or D(0)+pi(+)
      if ((fem::iabs(lb(i1)) == 1 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 1)) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      // C(5) for pi(-)+n-->D(-)+P(0) OR D(0)+p(-)
      if (((lb(i1) == 2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          } else {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          } else {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      // C(6) for pi(0)+n-->D(0)+P(0), D(-)+p(+) or D(+)+p(-)
      if ((fem::iabs(lb(i1)) == 2 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 2)) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 <= 0.67f && x2 > 0.33f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 <= 0.67f && x2 > 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
    }
    if (iblock == 78) {
      rmasdd(cmn, srt, 1.232f, 0.77f, 1.08f, 0.28f, iseed, 4, dm, ameson);
      arho = ameson;
      // C pion+baryon-->Rho+delta
      // C(1) for pi(+)+p-->D(+)+rho(+) OR D(++)+rho(0)
      if (((lb(i1) == 1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          } else {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          } else {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      // C(2) for pi(-)+p-->D(+)+rho(-) OR D(0)+rho(0) or D(-)+rho(+)
      if (((lb(i1) == 1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      // C(3) for pi(+)+n-->D(+)+rho(0) OR D(++)+rho(-) or D(0)+rho(+)
      if (((lb(i1) == 2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      // C(4) for pi(0)+p-->D(+)+rho(0) OR D(++)+rho(-) or D(0)+rho(+)
      if ((fem::iabs(lb(i1)) == 1 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 1)) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      // C(5) for pi(-)+n-->D(-)+rho(0) OR D(0)+rho(-)
      if (((lb(i1) == 2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          } else {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          } else {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      // C(6) for pi(0)+n-->D(0)+rho(0), D(-)+rho(+) and D(+)+rho(-)
      if ((fem::iabs(lb(i1)) == 2 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 2)) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 <= 0.67f && x2 > 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
          }
        }
      }
    }
    if (iblock == 79) {
      aomega = 0.782f;
      // C GENERATE THE DELTA MASS
      dmax = srt - 0.782f - 0.02f;
      dm = rmass(cmn, dmax, iseed);
      // C pion+baryon-->omega+delta
      // C(1) for pi(+)+p-->D(++)+omega(0)
      if (((lb(i1) == 1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          lb(i1) = 9;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 9;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      // C(2) for pi(-)+p-->D(0)+omega(0)
      if (((lb(i1) == 1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          lb(i1) = 7;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 7;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      // C(3) for pi(+)+n-->D(+)+omega(0)
      if (((lb(i1) == 2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          lb(i1) = 8;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 8;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      // C(4) for pi(0)+p-->D(+)+omega(0)
      if ((fem::iabs(lb(i1)) == 1 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 1)) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          lb(i1) = 8;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 8;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      // C(5) for pi(-)+n-->D(-)+omega(0)
      if (((lb(i1) == 2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          lb(i1) = 6;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 6;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
        }
      }
      // C(6) for pi(0)+n-->D(0)+omega(0)
      if ((fem::iabs(lb(i1)) == 2 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 2)) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          lb(i1) = 7;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 7;
          e(i2) = dm;
          lb(i1) = 26;
          e(i1) = arho;
          goto statement_40;
        }
      }
    }
  statement_40:
    em1 = e(i1);
    em2 = e(i2);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(ii) = -lb(ii);
      jj = i2;
      if (ii == i2) {
        jj = i1;
      }
      if (iblock == 77) {
        if (lb(jj) == 3) {
          lb(jj) = 5;
        } else if (lb(jj) == 5) {
          lb(jj) = 3;
        }
      } else if (iblock == 78) {
        if (lb(jj) == 25) {
          lb(jj) = 27;
        } else if (lb(jj) == 27) {
          lb(jj) = 25;
        }
      }
    }
  }
// C-----------------------------------------------------------------------
// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
// C ENERGY CONSERVATION
statement_50:
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 0.00000001f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C here we use the same transverse momentum distribution as for
  // C pp collisions, it might be necessary to use a different distribution
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  // C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, iseed);
  // Clin-10/25/02-end
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck36: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  // C         c1=sqrt(pr**2-cc1**2)/pr
  // C
  // C          C1   = 1.0 - 2.0 * RANART(NSEED)
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct cren_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ianti;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  cren_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C*********************************
// C                                                                      *
void cren(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(cren);
  // COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& kaonc = sve.kaonc;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     PURPOSE:                                                         *
  // C             DEALING WITH ETA+N-->L/S+KAON PROCESS                   *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     7  ETA+N-->L/S+KAON
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  sve.ntag = 0;
  iblock = 7;
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
    iblock = -7;
  }
  // C RELABLE PARTICLES FOR THE PROCESS eta+n-->LAMBDA K OR SIGMA k
  // C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
  // C MOMENTA FOR PARTICLES IN THE FINAL STATE.
  kaonc = 0;
  if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
    kaonc = 1;
  }
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  if (e(i1) <= 0.6f) {
    lb(i1) = 23;
    e(i1) = aka;
    if (kaonc == 1) {
      lb(i2) = 14;
      e(i2) = ala;
    } else {
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      e(i2) = asa;
    }
    if (ianti == 1) {
      lb(i1) = 21;
      lb(i2) = -lb(i2);
    }
  } else {
    lb(i2) = 23;
    e(i2) = aka;
    if (kaonc == 1) {
      lb(i1) = 14;
      e(i1) = ala;
    } else {
      lb(i1) = 15 + fem::fint(3 * ranart(nseed));
      e(i1) = asa;
    }
    if (ianti == 1) {
      lb(i2) = 21;
      lb(i1) = -lb(i1);
    }
  }
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crdir_save {
  float c1;
  float cc1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float xptr;

  crdir_save()
      : c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        xptr(fem::float0) {}
};

// C*********************************
// C                                                                      *
// C      SUBROUTINE Crdir(PX,PY,PZ,SRT,I1,I2)
void crdir(common& cmn, float& px, float& py, float& pz, float const& srt,
           int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crdir);
  common_write write(cmn);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  //
  // SAVE
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& xptr = sve.xptr;
  //
  // C     PURPOSE:                                                         *
  // C             DEALING WITH pion+N-->pion+N PROCESS                   *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 999;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  // C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, cmn.iseed);
  // Clin-10/25/02-end
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck37: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  // C         c1=sqrt(pr**2-cc1**2)/pr
  // C
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(cmn.nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE the momentum
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crpd_save {
  float c1;
  float cc1;
  float ct1;
  float em1;
  float em2;
  int ianti;
  int ii;
  int jj;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float x1;
  float x2;
  float xptr;

  crpd_save()
      : c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xptr(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crpd(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& xkaon0,
          float const& xkaon, float const& xphi, float const& xphin) {
  FEM_CMN_SVE(crpd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kaonc = sve.kaonc;
  int& ntag = sve.ntag;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xptr = sve.xptr;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float aphi = 1.020f;
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  // C     PURPOSE:                                                         *
  // C     DEALING WITH PION+D(N*)-->PION +N OR
  // C                                             L/S+KAON PROCESS         *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     7  PION+D(N*)-->L/S+KAON
  // C           iblock   - 80 pion+D(N*)-->pion+N
  // C           iblock   - 81 RHO+D(N*)-->PION+N
  // C           iblock   - 82 OMEGA+D(N*)-->PION+N
  // C                     222  PION+D --> PHI
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
  }
  if (xkaon0 / (xkaon + xphi) >= x1) {
    // C kaon production
    // C-----------------------------------------------------------------------
    iblock = 7;
    if (ianti == 1) {
      iblock = -7;
    }
    ntag = 0;
    // C RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
    // C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
    // C MOMENTA FOR PARTICLES IN THE FINAL STATE.
    kaonc = 0;
    if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
      kaonc = 1;
    }
    // Clin-8/17/00     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
    if (e(i1) <= 0.2f) {
      lb(i1) = 23;
      e(i1) = aka;
      if (kaonc == 1) {
        lb(i2) = 14;
        e(i2) = ala;
      } else {
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        e(i2) = asa;
      }
      if (ianti == 1) {
        lb(i1) = 21;
        lb(i2) = -lb(i2);
      }
    } else {
      lb(i2) = 23;
      e(i2) = aka;
      if (kaonc == 1) {
        lb(i1) = 14;
        e(i1) = ala;
      } else {
        lb(i1) = 15 + fem::fint(3 * ranart(nseed));
        e(i1) = asa;
      }
      if (ianti == 1) {
        lb(i2) = 21;
        lb(i1) = -lb(i1);
      }
    }
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
    // C to gererate the momentum for the kaon and L/S
    // C
    // C* Phi production
  } else if (xphi / (xkaon + xphi) >= x1) {
    iblock = 222;
    if (xphin / xphi >= ranart(nseed)) {
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      e(i1) = amn;
    } else {
      lb(i1) = 6 + fem::fint(4 * ranart(nseed));
      e(i1) = am0;
    }
    // C   !! at present only baryon
    if (ianti == 1) {
      lb(i1) = -lb(i1);
    }
    lb(i2) = 29;
    e(i2) = aphi;
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
  } else {
    // C PION REABSORPTION HAS HAPPENED
    x2 = ranart(nseed);
    iblock = 80;
    ntag = 0;
    // C Relable particles, I1 is assigned to the nucleon
    // C and I2 is assigned to the pion
    // C for the reverse of the following process
    // C(1) for D(+)+P(+)-->p+pion(+)
    if (((lb(i1) == 8 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C
    // C(2) for D(0)+P(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 7 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 7)) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(3) for D(+)+Pi(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 8 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 8)) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(4) for D(-)+Pi(0)-->n+pi(-)
    if ((fem::iabs(lb(i1)) == 6 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 6)) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(5) for D(+)+Pi(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 8 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(6) D(0)+P(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 7 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(7) for D(0)+Pi(-)-->n+pi(-)
    if (((lb(i1) == 7 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(8) D(-)+P(+)-->n+pi(0) or p+pi(-)
    if (((lb(i1) == 6 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 6)) ||
        ((lb(i1) == -6 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -6))) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C
    // C(9) D(++)+P(-)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 9 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 9)) ||
        ((lb(i1) == -9 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -9))) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(10) for D(++)+Pi(0)-->p+pi(+)
    if ((fem::iabs(lb(i1)) == 9 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 9)) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(11) for N*(1440)(+)or N*(1535)(+)+P(+)-->p+pion(+)
    if (((lb(i1) == 11 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 11) ||
         (lb(i1) == 13 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -11) ||
         (lb(i1) == -13 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(12) for N*(1440) or N*(1535)(0)+P(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 10 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 10) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 12) ||
        (lb(i2) == 4 && fem::iabs(lb(i1)) == 12)) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(13) for N*(1440) or N*(1535)(+)+Pi(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 11 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 11) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 13) ||
        (lb(i2) == 4 && fem::iabs(lb(i1)) == 13)) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(14) for N*(1440) or N*(1535)(+)+Pi(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 11 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 11) ||
         (lb(i1) == 3 && lb(i2) == 13) || (lb(i2) == 3 && lb(i1) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -11) ||
         (lb(i1) == 5 && lb(i2) == -13) || (lb(i2) == 5 && lb(i1) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(15) N*(1440) or N*(1535)(0)+P(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 10 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 10) ||
         (lb(i1) == 12 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 12)) ||
        ((lb(i1) == -10 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -10) ||
         (lb(i1) == -12 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -12))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(16) for N*(1440) or N*(1535) (0)+Pi(-)-->n+pi(-)
    if (((lb(i1) == 10 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 10) ||
         (lb(i1) == 3 && lb(i2) == 12) || (lb(i1) == 12 && lb(i2) == 3)) ||
        ((lb(i1) == -10 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -10) ||
         (lb(i1) == 5 && lb(i2) == -12) || (lb(i1) == -12 && lb(i2) == 5))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
  statement_40:
    em1 = e(i1);
    em2 = e(i2);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(ii) = -lb(ii);
      jj = i2;
      if (ii == i2) {
        jj = i1;
      }
      if (lb(jj) == 3) {
        lb(jj) = 5;
      } else if (lb(jj) == 5) {
        lb(jj) = 3;
      }
    }
  }
// C-----------------------------------------------------------------------
// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
// C ENERGY CONSERVATION
statement_50:
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  // C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, cmn.iseed);
  // Clin-10/25/02-end
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck38: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  // C         c1=sqrt(pr**2-cc1**2)/pr
  // C
  // C         C1   = 1.0 - 2.0 * RANART(NSEED)
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C rotate the momentum
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crrd_save {
  float c1;
  float cc1;
  float ct1;
  float em1;
  float em2;
  int ianti;
  int ii;
  int jj;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float x1;
  float x2;
  float xptr;

  crrd_save()
      : c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xptr(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crrd(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& xkaon0,
          float const& xkaon, float const& xphi, float const& xphin) {
  FEM_CMN_SVE(crrd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kaonc = sve.kaonc;
  int& ntag = sve.ntag;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xptr = sve.xptr;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float aphi = 1.02f;
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  // C     PURPOSE:                                                         *
  // C     DEALING WITH rho(omega)+N or D(N*)-->PION +N OR
  // C                                             L/S+KAON PROCESS         *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     7  rho(omega)+N or D(N*)-->L/S+KAON
  // C           iblock   - 80 pion+D(N*)-->pion+N
  // C           iblock   - 81 RHO+D(N*)-->PION+N
  // C           iblock   - 82 OMEGA+D(N*)-->PION+N
  // C           iblock   - 222 pion+N-->Phi
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
  }
  x1 = ranart(nseed);
  if (xkaon0 / (xkaon + xphi) >= x1) {
    // C kaon production
    // C-----------------------------------------------------------------------
    iblock = 7;
    if (ianti == 1) {
      iblock = -7;
    }
    ntag = 0;
    // C RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
    // C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
    // C MOMENTA FOR PARTICLES IN THE FINAL STATE.
    kaonc = 0;
    if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
      kaonc = 1;
    }
    // Clin-8/17/00     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
    if (e(i1) <= 0.92f) {
      lb(i1) = 23;
      e(i1) = aka;
      if (kaonc == 1) {
        lb(i2) = 14;
        e(i2) = ala;
      } else {
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        e(i2) = asa;
      }
      if (ianti == 1) {
        lb(i1) = 21;
        lb(i2) = -lb(i2);
      }
    } else {
      lb(i2) = 23;
      e(i2) = aka;
      if (kaonc == 1) {
        lb(i1) = 14;
        e(i1) = ala;
      } else {
        lb(i1) = 15 + fem::fint(3 * ranart(nseed));
        e(i1) = asa;
      }
      if (ianti == 1) {
        lb(i2) = 21;
        lb(i1) = -lb(i1);
      }
    }
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
    // C to gererate the momentum for the kaon and L/S
    // C
    // C* Phi production
  } else if (xphi / (xkaon + xphi) >= x1) {
    iblock = 222;
    if (xphin / xphi >= ranart(nseed)) {
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      e(i1) = amn;
    } else {
      lb(i1) = 6 + fem::fint(4 * ranart(nseed));
      e(i1) = am0;
    }
    // C   !! at present only baryon
    if (ianti == 1) {
      lb(i1) = -lb(i1);
    }
    lb(i2) = 29;
    e(i2) = aphi;
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
  } else {
    // C rho(omega) REABSORPTION HAS HAPPENED
    x2 = ranart(nseed);
    iblock = 81;
    ntag = 0;
    if (lb(i1) == 28 || lb(i2) == 28) {
      goto statement_60;
    }
    // C we treat Rho reabsorption in the following
    // C Relable particles, I1 is assigned to the Delta
    // C and I2 is assigned to the meson
    // C for the reverse of the following process
    // C(1) for D(+)+rho(+)-->p+pion(+)
    if (((lb(i1) == 8 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(2) for D(0)+rho(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 7 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 7)) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(3) for D(+)+rho(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 8 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 8)) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(4) for D(-)+rho(0)-->n+pi(-)
    if ((fem::iabs(lb(i1)) == 6 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 6)) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(5) for D(+)+rho(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 8 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(6) D(0)+rho(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 7 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(7) for D(0)+rho(-)-->n+pi(-)
    if (((lb(i1) == 7 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(8) D(-)+rho(+)-->n+pi(0) or p+pi(-)
    if (((lb(i1) == 6 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 6)) ||
        ((lb(i1) == -6 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -6))) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(9) D(++)+rho(-)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 9 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 9)) ||
        ((lb(i1) == -9 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -9))) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(10) for D(++)+rho(0)-->p+pi(+)
    if ((fem::iabs(lb(i1)) == 9 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 9)) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(11) for N*(1440)(+)or N*(1535)(+)+rho(+)-->p+pion(+)
    if (((lb(i1) == 11 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 11) ||
         (lb(i1) == 13 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -11) ||
         (lb(i1) == -13 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(12) for N*(1440) or N*(1535)(0)+rho(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 10 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 10) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 12) ||
        (lb(i2) == 26 && fem::iabs(lb(i1)) == 12)) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(13) for N*(1440) or N*(1535)(+)+rho(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 11 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 11) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 13) ||
        (lb(i2) == 26 && fem::iabs(lb(i1)) == 13)) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(14) for N*(1440) or N*(1535)(+)+rho(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 11 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 11) ||
         (lb(i1) == 25 && lb(i2) == 13) || (lb(i2) == 25 && lb(i1) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -11) ||
         (lb(i1) == 27 && lb(i2) == -13) || (lb(i2) == 27 && lb(i1) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(15) N*(1440) or N*(1535)(0)+rho(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 10 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 10) ||
         (lb(i1) == 12 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 12)) ||
        ((lb(i1) == -10 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -10) ||
         (lb(i1) == -12 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -12))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(16) for N*(1440) or N*(1535) (0)+rho(-)-->n+pi(-)
    if (((lb(i1) == 10 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 10) ||
         (lb(i1) == 25 && lb(i2) == 12) || (lb(i1) == 12 && lb(i2) == 25)) ||
        ((lb(i1) == -10 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -10) ||
         (lb(i1) == 27 && lb(i2) == -12) || (lb(i1) == -12 && lb(i2) == 27))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
  statement_60:
    iblock = 82;
    // C FOR OMEGA REABSORPTION
    // C Relable particles, I1 is assigned to the Delta
    // C and I2 is assigned to the meson
    // C for the reverse of the following process
    // C(1) for D(0)+OMEGA(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 7 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 7)) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(2) for D(+)+OMEGA(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 8 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 8)) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(3) for D(-)+OMEGA(0)-->n+pi(-)
    if ((fem::iabs(lb(i1)) == 6 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 6)) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(4) for D(++)+OMEGA(0)-->p+pi(+)
    if ((fem::iabs(lb(i1)) == 9 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 9)) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    // C(5) for N*(1440) or N*(1535)(0)+omega(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 10 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 10) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 12) ||
        (lb(i2) == 28 && fem::iabs(lb(i1)) == 12)) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    // C(6) for N*(1440) or N*(1535)(+)+omega(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 11 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 11) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 13) ||
        (lb(i2) == 28 && fem::iabs(lb(i1)) == 13)) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
  statement_40:
    em1 = e(i1);
    em2 = e(i2);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(ii) = -lb(ii);
      jj = i2;
      if (ii == i2) {
        jj = i1;
      }
      if (lb(jj) == 3) {
        lb(jj) = 5;
      } else if (lb(jj) == 5) {
        lb(jj) = 3;
      }
    }
  }
// C-----------------------------------------------------------------------
// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
// C ENERGY CONSERVATION
statement_50:
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C          C1   = 1.0 - 2.0 * RANART(NSEED)
  // C
  // Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  // C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, cmn.iseed);
  // Clin-10/25/02-end
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck39: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  // C         c1=sqrt(pr**2-cc1**2)/pr
  // C
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE THE MOMENTUM
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crlaba_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float rrr;
  float s1;
  float st1;
  float t1;

  crlaba_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        rrr(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C*********************************
// C sp 03/19/01                                                          *
// C                                                                      *
void crlaba(common& cmn, float& px, float& py, float& pz, float const& srt,
            float const& brel, float const& brsgm, int const& i1, int const& i2,
            int const& /* nt */, int& iblock, int const& nchrg,
            int const& icase) {
  FEM_CMN_SVE(crlaba);
  // COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& rrr = sve.rrr;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     PURPOSE:                                                         *
  // C            DEALING WITH   K+ + N(D,N*)-bar <-->  La(Si)-bar + pi     *
  // C     NOTE   :                                                         *
  // C                                                                      *
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     8-> elastic scatt                               *
  // C                     100-> K+ + N-bar -> Sigma-bar + PI
  // C                     102-> PI + Sigma(Lambda)-bar -> K+ + N-bar
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  // C
  const float asa = 1.1974f;
  const float ala = 1.1157f;
  if (icase == 3) {
    rrr = ranart(nseed);
    if (rrr < brel) {
      // C            !! elastic scat.  (avoid in reverse process)
      iblock = 8;
    } else {
      iblock = 100;
      if (rrr < (brel + brsgm)) {
        // C*    K+ + N-bar -> Sigma-bar + PI
        lb(i1) = -15 - fem::fint(3 * ranart(nseed));
        // C
        e(i1) = asa;
      } else {
        // C*    K+ + N-bar -> Lambda-bar + PI
        lb(i1) = -14;
        e(i1) = ala;
      }
      lb(i2) = 3 + fem::fint(3 * ranart(nseed));
      e(i2) = 0.138f;
    }
  }
  // C
  const float aka = 0.498f;
  if (icase == 4) {
    rrr = ranart(nseed);
    if (rrr < brel) {
      // C            !! elastic scat.
      iblock = 8;
    } else {
      iblock = 102;
      // C    PI + Sigma(Lambda)-bar -> K+ + N-bar
      // C         ! K+
      lb(i1) = 23;
      lb(i2) = -1 - fem::fint(2 * ranart(nseed));
      if (nchrg == -2) {
        lb(i2) = -6;
      }
      if (nchrg == 1) {
        lb(i2) = -9;
      }
      e(i1) = aka;
      e(i2) = 0.938f;
      if (nchrg == -2 || nchrg == 1) {
        e(i2) = 1.232f;
      }
    }
  }
  // C
  em1 = e(i1);
  em2 = e(i2);
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crkn_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crkn_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crkn(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crkn);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     PURPOSE:                                                         *
  // C             DEALING WITH kaON+N/pi-->KAON +N/pi elastic PROCESS      *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     8-> PION+N-->L/S+KAON
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  // C-----------------------------------------------------------------------
  iblock = 8;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
}

struct pbarfs_save {
  float ene;
  arr<float> factor;
  int n;
  int ntry;
  float pmax;
  arr<float> pnpi;
  float thisp;

  pbarfs_save()
      : ene(fem::float0),
        factor(dimension(6), fem::fill0),
        n(fem::int0),
        ntry(fem::int0),
        pmax(fem::float0),
        pnpi(dimension(6), fem::fill0),
        thisp(fem::float0) {}
};

// Cbali1/16/99 end
// C*********************************
// Cbali2/6/99
// C*******************************************
// C Purpose: To generate randomly the no. of pions in the final
// C          state of pp_bar annihilation according to a statistical
// C          model by using of the rejection method.
// Cbz2/25/99
// C      real*4 function pbarfs(srt,npion,iseed)
void pbarfs(common& cmn, float const& srt, int& npion, int const& /* iseed */) {
  FEM_CMN_SVE(pbarfs);
  int& nseed = cmn.nseed;
  //
  float& ene = sve.ene;
  arr_ref<float> factor(sve.factor, dimension(6));
  int& n = sve.n;
  int& ntry = sve.ntry;
  float& pmax = sve.pmax;
  arr_ref<float> pnpi(sve.pnpi, dimension(6));
  float& thisp = sve.thisp;
  const float pimass = 0.140f;
  const float pi = 3.1415926f;
  // Cbz2/25/99end
  // C Quantities:
  // C  srt: DSQRT(s) in GeV * C  npion: No. of pions produced in the
  // annihilation of ppbar at srt        * C  nmax=6, cutoff of the maximum no.
  // of n the code can handle
  // C
  // C  Reference: C.M. Ko and R. Yuan, Phys. Lett. B192 (1987) 31      *
  // C
  // C*****************************************
  // Cc      SAVE /RNDF77/
  // C the factorial coefficients in the pion no. distribution
  // C from n=2 to 6 calculated use the formula in the reference
  factor(2) = 1.f;
  factor(3) = 1.17e-01f;
  factor(4) = 3.27e-03f;
  factor(5) = 3.58e-05f;
  factor(6) = 1.93e-07f;
  ene = fem::pow3((srt / pimass)) / (6.f * fem::pow2(pi));
  // C the relative probability from n=2 to 6
  FEM_DO_SAFE(n, 2, 6) { pnpi(n) = fem::pow(ene, n) * factor(n); }
  // C find the maximum of the probabilities, I checked a
  // C Fortan manual: max() returns the maximum value of
  // C the same type as in the argument list
  pmax = fem::max(pnpi(2), pnpi(3), pnpi(4), pnpi(5), pnpi(6));
  // C randomly generate n between 2 and 6
  ntry = 0;
statement_10:
  npion = 2 + fem::fint(5 * ranart(nseed));
  // Clin-4/2008 check bounds:
  if (npion > 6) {
    goto statement_10;
  }
  thisp = pnpi(npion) / pmax;
  ntry++;
  // C decide whether to take this npion according to the distribution
  // C using rejection method.
  if ((thisp < ranart(nseed)) && (ntry <= 20)) {
    goto statement_10;
  }
  // C now take the last generated npion and return
}

struct crppba_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int nchrg1;
  int nchrg2;
  int npion;
  float pmass1;
  float pmass2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crppba_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        nchrg1(fem::int0),
        nchrg2(fem::int0),
        npion(fem::int0),
        pmass1(fem::float0),
        pmass2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crppba(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crppba);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& nchrg1 = sve.nchrg1;
  int& nchrg2 = sve.nchrg2;
  int& npion = sve.npion;
  float& pmass1 = sve.pmass1;
  float& pmass2 = sve.pmass2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  const float ap1 = 0.13496f;
  const float ap2 = 0.13957f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  const float pi = 3.1415926f;
  // C     PURPOSE:                                                         *
  // C
  // Clin-8/29/00*             DEALING WITH anti-nucleon annihilation with
  // C             DEALING WITH anti-baryon annihilation with
  // C
  // C             nucleons or baryon resonances
  // C             Determine:                                               *
  // C             (1) no. of pions in the final state
  // C             (2) relable particles in the final state
  // C             (3) new momenta of final state particles                 *
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - INFORMATION about the reaction channel          *
  // C
  // C           iblock   - 1902 annihilation-->pion(+)+pion(-)   (2 pion)
  // C           iblock   - 1903 annihilation-->pion(+)+rho(-)    (3 pion)
  // C           iblock   - 1904 annihilation-->rho(+)+rho(-)     (4 pion)
  // C           iblock   - 1905 annihilation-->rho(0)+omega      (5 pion)
  // C           iblock   - 1906 annihilation-->omega+omega       (6 pion)
  // C       charge conservation is enforced in relabling particles
  // C       in the final state (note: at the momentum we don't check the
  // C       initial charges while dealing with annihilation, since some
  // C       annihilation channels between antinucleons and nucleons (baryon
  // C       resonances) might be forbiden by charge conservation, this effect
  // C       should be small, but keep it in mind.
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  // C determine the no. of pions in the final state using a
  // C statistical model
  pbarfs(cmn, srt, npion, cmn.iseed);
  // C find the masses of the final state particles before calculate
  // C their momenta, and relable them. The masses of rho and omega
  // C will be generated according to the Breit Wigner formula       (NOTE!!!
  // C NOT DONE YET, AT THE MOMENT LET US USE FIXED RHO AND OMEGA MAEES)
  // Cbali2/22/99
  // C Here we generate two stes of integer random numbers (3,4,5)
  // C one or both of them are used directly as the lables of pions
  // C similarly, 22+nchrg1 and 22+nchrg2 are used directly
  // C to label rhos
  nchrg1 = 3 + fem::fint(3 * ranart(nseed));
  nchrg2 = 3 + fem::fint(3 * ranart(nseed));
  // C the corresponding masses of pions
  pmass1 = ap1;
  pmass2 = ap1;
  if (nchrg1 == 3 || nchrg1 == 5) {
    pmass1 = ap2;
  }
  if (nchrg2 == 3 || nchrg2 == 5) {
    pmass2 = ap2;
  }
  // C (1) for 2 pion production
  if (npion == 2) {
    iblock = 1902;
    // C randomly generate the charges of final state particles,
    lb(i1) = nchrg1;
    e(i1) = pmass1;
    lb(i2) = nchrg2;
    e(i2) = pmass2;
    // C TO CALCULATE THE FINAL MOMENTA
    goto statement_50;
  }
  // C (2) FOR 3 PION PRODUCTION
  if (npion == 3) {
    iblock = 1903;
    lb(i1) = nchrg1;
    e(i1) = pmass1;
    lb(i2) = 22 + nchrg2;
    e(i2) = amrho;
    goto statement_50;
  }
  // C (3) FOR 4 PION PRODUCTION
  // C we allow both rho+rho and pi+omega with 50-50% probability
  if (npion == 4) {
    iblock = 1904;
    // C determine rho+rho or pi+omega
    if (ranart(nseed) >= 0.5f) {
      // C rho+rho
      lb(i1) = 22 + nchrg1;
      e(i1) = amrho;
      lb(i2) = 22 + nchrg2;
      e(i2) = amrho;
    } else {
      // C pion+omega
      lb(i1) = nchrg1;
      e(i1) = pmass1;
      lb(i2) = 28;
      e(i2) = amomga;
    }
    goto statement_50;
  }
  // C (4) FOR 5 PION PRODUCTION
  if (npion == 5) {
    iblock = 1905;
    // C RHO AND OMEGA
    lb(i1) = 22 + nchrg1;
    e(i1) = amrho;
    lb(i2) = 28;
    e(i2) = amomga;
    goto statement_50;
  }
  // C (5) FOR 6 PION PRODUCTION
  if (npion == 6) {
    iblock = 1906;
    // C OMEGA AND OMEGA
    lb(i1) = 28;
    e(i1) = amomga;
    lb(i2) = 28;
    e(i2) = amomga;
  }
// Cbali2/22/99
statement_50:
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crkhyp_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;
  float x1;

  crkhyp_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0) {}
};

// C*********************************
// C     PURPOSE:                                                         *
// C             DEALING WITH K+Y -> piN scattering
// C
void crkhyp(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, float const& xky1, float& xky2,
            float& xky3, float& xky4, float& xky5, float& xky6, float& xky7,
            float& xky8, float& xky9, float& xky10, float& xky11, float& xky12,
            float& xky13, float& xky14, float& xky15, float& xky16,
            float const& /* xky17 */, float const& sigk, int const& ikmp,
            int& iblock) {
  FEM_CMN_SVE(crkhyp);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  const float pimass = 0.140f;
  const float amp = 0.93828f;
  const float am0 = 1.232f;
  const float am1440 = 1.44f;
  const float am1535 = 1.535f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  const float ameta = 0.5473f;
  const float aphi = 1.02f;
  const float amn = 0.939457f;
  const float pi = 3.1415926f;
  // C
  // C             Determine:                                               *
  // C             (1) relable particles in the final state                 *
  // C             (2) new momenta of final state particles                 *
  // C                                                                        *
  // C     QUANTITIES:                                                    *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - INFORMATION about the reaction channel          *
  // C                                                                     *
  // C             iblock   - 1908                                          *
  // C             iblock   - 222   !! phi                                  *
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1908;
  // C
  x1 = ranart(nseed) * sigk;
  xky2 += xky1;
  xky3 += xky2;
  xky4 += xky3;
  xky5 += xky4;
  xky6 += xky5;
  xky7 += xky6;
  xky8 += xky7;
  xky9 += xky8;
  xky10 += xky9;
  xky11 += xky10;
  xky12 += xky11;
  xky13 += xky12;
  xky14 += xky13;
  xky15 += xky14;
  xky16 += xky15;
  if (x1 <= xky1) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky3) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky4) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = am1535;
    goto statement_100;
  } else if (x1 <= xky5) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky6) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky7) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky8) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = am1535;
    goto statement_100;
  } else if (x1 <= xky9) {
    lb(i1) = 28;
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky10) {
    lb(i1) = 28;
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky11) {
    lb(i1) = 28;
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky12) {
    lb(i1) = 28;
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = am1535;
    goto statement_100;
  } else if (x1 <= xky13) {
    lb(i1) = 0;
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky14) {
    lb(i1) = 0;
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky15) {
    lb(i1) = 0;
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky16) {
    lb(i1) = 0;
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = am1535;
    goto statement_100;
  } else {
    lb(i1) = 29;
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = aphi;
    e(i2) = amn;
    iblock = 222;
    goto statement_100;
  }
// C
statement_100:
  if (ikmp == -1) {
    lb(i2) = -lb(i2);
  }
  // C
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crlan_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crlan_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crlan(common& cmn, float& px, float& py, float& pz, float const& srt,
           int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crlan);
  // COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     PURPOSE:                                                         *
  // C      DEALING WITH La/Si-bar + N --> K+ + pi PROCESS                  *
  // C                   La/Si + N-bar --> K- + pi                          *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      71
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  iblock = 71;
  sve.ntag = 0;
  if ((lb(i1) >= 14 && lb(i1) <= 17) || (lb(i2) >= 14 && lb(i2) <= 17)) {
    lb(i1) = 21;
  } else {
    lb(i1) = 23;
  }
  lb(i2) = 3 + fem::fint(3 * ranart(nseed));
  const float aka = 0.498f;
  e(i1) = aka;
  e(i2) = 0.138f;
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crkpla_save {
  float c1;
  float ct1;
  float dskn;
  float dsknr;
  int ic;
  float pdd;
  float pff;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float randu;
  float s1;
  float scheck;
  float sig1;
  float sig2;
  float sigkp;
  float sigm;
  float sigpik;
  float st1;
  float t1;
  float xkp0;
  float xkp1;
  float xkp10;
  float xkp2;
  float xkp3;
  float xkp4;
  float xkp5;
  float xkp6;
  float xkp7;
  float xkp8;
  float xkp9;

  crkpla_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        ic(fem::int0),
        pdd(fem::float0),
        pff(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        randu(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        sig1(fem::float0),
        sig2(fem::float0),
        sigkp(fem::float0),
        sigm(fem::float0),
        sigpik(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        xkp0(fem::float0),
        xkp1(fem::float0),
        xkp10(fem::float0),
        xkp2(fem::float0),
        xkp3(fem::float0),
        xkp4(fem::float0),
        xkp5(fem::float0),
        xkp6(fem::float0),
        xkp7(fem::float0),
        xkp8(fem::float0),
        xkp9(fem::float0) {}
};

// Csp11/03/01 end
// C*********************************
// C                                                                      *
void crkpla(common& cmn, float& px, float& py, float& pz, float const& ec,
            float const& srt, float const& spika, float& emm1, float& emm2,
            int& lbp1, int& lbp2, int const& i1, int const& i2, int& icase,
            float const& srhoks) {
  FEM_CMN_SVE(crkpla);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  int& ic = sve.ic;
  float& pdd = sve.pdd;
  float& pff = sve.pff;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& randu = sve.randu;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& sig1 = sve.sig1;
  float& sig2 = sve.sig2;
  float& sigkp = sve.sigkp;
  float& sigm = sve.sigm;
  float& sigpik = sve.sigpik;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& xkp0 = sve.xkp0;
  float& xkp1 = sve.xkp1;
  float& xkp10 = sve.xkp10;
  float& xkp2 = sve.xkp2;
  float& xkp3 = sve.xkp3;
  float& xkp4 = sve.xkp4;
  float& xkp5 = sve.xkp5;
  float& xkp6 = sve.xkp6;
  float& xkp7 = sve.xkp7;
  float& xkp8 = sve.xkp8;
  float& xkp9 = sve.xkp9;
  const float aka = 0.498f;
  const float ap1 = 0.13496f;
  const float ala = 1.1157f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float am1440 = 1.44f;
  const float am1535 = 1.535f;
  const float asa = 1.1974f;
  const float aphi = 1.02f;
  const float pi = 3.1415926f;
  const float aks = 0.895f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  // C
  // C     PURPOSE:                                                         *
  // C     DEALING WITH  K+ + Pi ---> La/Si-bar + B, phi+K, phi+K* OR  K* *
  // C                   K- + Pi ---> La/Si + B-bar  OR   K*-bar          *
  // C
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      71
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  emm1 = 0.f;
  emm2 = 0.f;
  lbp1 = 0;
  lbp2 = 0;
  xkp0 = spika;
  xkp1 = 0.f;
  xkp2 = 0.f;
  xkp3 = 0.f;
  xkp4 = 0.f;
  xkp5 = 0.f;
  xkp6 = 0.f;
  xkp7 = 0.f;
  xkp8 = 0.f;
  xkp9 = 0.f;
  xkp10 = 0.f;
  sigm = 15.f;
  // C         if(lb(i1).eq.21.or.lb(i2).eq.21)sigm=10.
  pdd = (fem::pow2(srt) - fem::pow2((aka + ap1))) *
        (fem::pow2(srt) - fem::pow2((aka - ap1)));
  // C
  if (srt < (ala + amn)) {
    goto statement_70;
  }
  xkp1 = sigm * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + amn))) *
         (fem::pow2(srt) - fem::pow2((ala - amn))) / pdd;
  if (srt > (ala + am0)) {
    xkp2 = sigm * (16.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + am0))) *
           (fem::pow2(srt) - fem::pow2((ala - am0))) / pdd;
  }
  if (srt > (ala + am1440)) {
    xkp3 = sigm * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + am1440))) *
           (fem::pow2(srt) - fem::pow2((ala - am1440))) / pdd;
  }
  if (srt > (ala + am1535)) {
    xkp4 = sigm * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + am1535))) *
           (fem::pow2(srt) - fem::pow2((ala - am1535))) / pdd;
  }
  // C
  if (srt > (asa + amn)) {
    xkp5 = sigm * 4.f * (fem::pow2(srt) - fem::pow2((asa + amn))) *
           (fem::pow2(srt) - fem::pow2((asa - amn))) / pdd;
  }
  if (srt > (asa + am0)) {
    xkp6 = sigm * 16.f * (fem::pow2(srt) - fem::pow2((asa + am0))) *
           (fem::pow2(srt) - fem::pow2((asa - am0))) / pdd;
  }
  if (srt > (asa + am1440)) {
    xkp7 = sigm * 4.f * (fem::pow2(srt) - fem::pow2((asa + am1440))) *
           (fem::pow2(srt) - fem::pow2((asa - am1440))) / pdd;
  }
  if (srt > (asa + am1535)) {
    xkp8 = sigm * 4.f * (fem::pow2(srt) - fem::pow2((asa + am1535))) *
           (fem::pow2(srt) - fem::pow2((asa - am1535))) / pdd;
  }
statement_70:
  sig1 = 195.639f;
  sig2 = 372.378f;
  if (srt > aphi + aka) {
    pff = fem::sqrt((fem::pow2(srt) - fem::pow2((aphi + aka))) *
                    (fem::pow2(srt) - fem::pow2((aphi - aka))));
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = pdd;
    if (scheck <= 0) {
      write(99, star), "scheck40: ", scheck;
      FEM_STOP(0);
    }
    // C
    xkp9 = sig1 * pff / fem::sqrt(pdd) * 1.f / 32.f / pi / fem::pow2(srt);
    if (srt > aphi + aks) {
      pff = fem::sqrt((fem::pow2(srt) - fem::pow2((aphi + aks))) *
                      (fem::pow2(srt) - fem::pow2((aphi - aks))));
      // C
      // Clin-9/2012: check argument in sqrt():
      scheck = pdd;
      if (scheck <= 0) {
        write(99, star), "scheck41: ", scheck;
        FEM_STOP(0);
      }
      // C
      xkp10 = sig2 * pff / fem::sqrt(pdd) * 3.f / 32.f / pi / fem::pow2(srt);
    }
  }
  // C
  // Clin-8/15/02 K pi -> K* (rho omega), from detailed balance,
  // C neglect rho and omega mass difference for now:
  sigpik = 0.f;
  if (srt > (amrho + aks)) {
    sigpik = srhoks * 9.f * (fem::pow2(srt) - fem::pow2((0.77f - aks))) *
             (fem::pow2(srt) - fem::pow2((0.77f + aks))) / 4 / fem::pow2(srt) /
             (fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
    if (srt > (amomga + aks)) {
      sigpik = sigpik * 12.f / 9.f;
    }
  }
  // C
  sigkp = xkp0 + xkp1 + xkp2 + xkp3 + xkp4 + xkp5 + xkp6 + xkp7 + xkp8 + xkp9 +
          xkp10 + sigpik;
  icase = 0;
  dskn = fem::sqrt(sigkp / pi / 10.f);
  dsknr = dskn + 0.1f;
  distce(cmn, i1, i2, dsknr, dskn, cmn.dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  // C
  randu = ranart(nseed) * sigkp;
  xkp1 += xkp0;
  xkp2 += xkp1;
  xkp3 += xkp2;
  xkp4 += xkp3;
  xkp5 += xkp4;
  xkp6 += xkp5;
  xkp7 += xkp6;
  xkp8 += xkp7;
  xkp9 += xkp8;
  // C
  xkp10 += xkp9;
  // C
  // C   !! K* formation
  if (randu <= xkp0) {
    icase = 1;
    return;
  } else {
    // C La/Si-bar + B formation
    icase = 2;
    if (randu <= xkp1) {
      lbp1 = -14;
      lbp2 = 1 + fem::fint(2 * ranart(nseed));
      emm1 = ala;
      emm2 = amn;
      goto statement_60;
    } else if (randu <= xkp2) {
      lbp1 = -14;
      lbp2 = 6 + fem::fint(4 * ranart(nseed));
      emm1 = ala;
      emm2 = am0;
      goto statement_60;
    } else if (randu <= xkp3) {
      lbp1 = -14;
      lbp2 = 10 + fem::fint(2 * ranart(nseed));
      emm1 = ala;
      emm2 = am1440;
      goto statement_60;
    } else if (randu <= xkp4) {
      lbp1 = -14;
      lbp2 = 12 + fem::fint(2 * ranart(nseed));
      emm1 = ala;
      emm2 = am1535;
      goto statement_60;
    } else if (randu <= xkp5) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 1 + fem::fint(2 * ranart(nseed));
      emm1 = asa;
      emm2 = amn;
      goto statement_60;
    } else if (randu <= xkp6) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 6 + fem::fint(4 * ranart(nseed));
      emm1 = asa;
      emm2 = am0;
      goto statement_60;
    } else if (randu < xkp7) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 10 + fem::fint(2 * ranart(nseed));
      emm1 = asa;
      emm2 = am1440;
      goto statement_60;
    } else if (randu < xkp8) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 12 + fem::fint(2 * ranart(nseed));
      emm1 = asa;
      emm2 = am1535;
      goto statement_60;
    } else if (randu < xkp9) {
      // C       !! phi +K  formation (iblock=224)
      icase = 3;
      lbp1 = 29;
      lbp2 = 23;
      emm1 = aphi;
      emm2 = aka;
      if (lb(i1) == 21 || lb(i2) == 21) {
        // C         !! phi +K-bar  formation (iblock=124)
        lbp2 = 21;
        icase = -3;
      }
      goto statement_60;
    } else if (randu < xkp10) {
      // C       !! phi +K* formation (iblock=226)
      icase = 4;
      lbp1 = 29;
      lbp2 = 30;
      emm1 = aphi;
      emm2 = aks;
      if (lb(i1) == 21 || lb(i2) == 21) {
        lbp2 = -30;
        icase = -4;
      }
      goto statement_60;
      // C
    } else {
      // C       !! (rho,omega) +K* formation (iblock=88)
      icase = 5;
      lbp1 = 25 + fem::fint(3 * ranart(nseed));
      lbp2 = 30;
      emm1 = amrho;
      emm2 = aks;
      if (srt > (amomga + aks) && ranart(nseed) < 0.25f) {
        lbp1 = 28;
        emm1 = amomga;
      }
      if (lb(i1) == 21 || lb(i2) == 21) {
        lbp2 = -30;
        icase = -5;
      }
      // C
    }
  }
// C
statement_60:
  if (icase == 2 && (lb(i1) == 21 || lb(i2) == 21)) {
    lbp1 = -lbp1;
    lbp2 = -lbp2;
  }
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(emm1) - fem::pow2(emm2))) -
        4.0f * fem::pow2((emm1 * emm2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crkkpi_save {
  float x1;

  crkkpi_save() : x1(fem::float0) {}
};

// Cbali2/7/99end
// Cbali3/5/99
// C*********************************
// C     PURPOSE:                                                         *
// C     assign final states for K+K- --> light mesons
// C
void crkkpi(common& cmn, int const& i1, int const& i2, float const& xsk1,
            float& xsk2, float& xsk3, float& xsk4, float& xsk5, float& xsk6,
            float& xsk7, float& xsk8, float& xsk9, float& xsk10,
            float const& /* xsk11 */, float const& sigk, int& iblock, int& lbp1,
            int& lbp2, float& emm1, float& emm2) {
  FEM_CMN_SVE(crkkpi);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& x1 = sve.x1;
  const float ap2 = 0.13957f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  const float ameta = 0.5473f;
  // C
  // C     QUANTITIES:                                                     *
  // C           IBLOCK   - INFORMATION about the reaction channel          *
  // C
  // C             iblock   - 1907
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  iblock = 1907;
  x1 = ranart(nseed) * sigk;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  xsk5 += xsk4;
  xsk6 += xsk5;
  xsk7 += xsk6;
  xsk8 += xsk7;
  xsk9 += xsk8;
  xsk10 += xsk9;
  if (x1 <= xsk1) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 3 + fem::fint(3 * ranart(nseed));
    e(i1) = ap2;
    e(i2) = ap2;
    goto statement_100;
  } else if (x1 <= xsk2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = ap2;
    e(i2) = amrho;
    goto statement_100;
  } else if (x1 <= xsk3) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 28;
    e(i1) = ap2;
    e(i2) = amomga;
    goto statement_100;
  } else if (x1 <= xsk4) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 0;
    e(i1) = ap2;
    e(i2) = ameta;
    goto statement_100;
  } else if (x1 <= xsk5) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = amrho;
    goto statement_100;
  } else if (x1 <= xsk6) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 28;
    e(i1) = amrho;
    e(i2) = amomga;
    goto statement_100;
  } else if (x1 <= xsk7) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 0;
    e(i1) = amrho;
    e(i2) = ameta;
    goto statement_100;
  } else if (x1 <= xsk8) {
    lb(i1) = 28;
    lb(i2) = 28;
    e(i1) = amomga;
    e(i2) = amomga;
    goto statement_100;
  } else if (x1 <= xsk9) {
    lb(i1) = 28;
    lb(i2) = 0;
    e(i1) = amomga;
    e(i2) = ameta;
    goto statement_100;
  } else if (x1 <= xsk10) {
    lb(i1) = 0;
    lb(i2) = 0;
    e(i1) = ameta;
    e(i2) = ameta;
  } else {
    iblock = 222;
    rhores(cmn, i1, i2);
    // C     !! phi
    lb(i1) = 29;
    // C          return
    e(i2) = 0.f;
  }
// C
statement_100:
  lbp1 = lb(i1);
  lbp2 = lb(i2);
  emm1 = e(i1);
  emm2 = e(i2);
  // C
}

struct pipik_save {
  arr<float> earray;
  int ie;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  pipik_save()
      : earray(dimension(5), fem::fill0),
        ie(fem::int0),
        pmass(fem::float0),
        xarray(dimension(5), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C for pion+pion-->K+K-
// C      real*4 function pipik(srt)
float pipik(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pipik);
  arr_ref<float> earray(sve.earray, dimension(5));
  int& ie = sve.ie;
  arr_ref<float> xarray(sve.xarray, dimension(5));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {0.001f, 0.7f, 1.5f, 1.7f, 2.0f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {1.f, 1.2f, 1.6f, 2.0f, 2.4f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  // C  NOTE: DEVIDE THE CROSS SECTION TO OBTAIN K+ PRODUCTION *
  // C*****************************************
  // C      real*4   xarray(5), earray(5)
  // C
  sve.pmass = 0.9383f;
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0.f;
  if (srt <= 1.f) {
    return return_value;
  }
  if (srt > 2.4f) {
    return_value = 2.0f / 2.f;
    return return_value;
  }
  if (srt < earray(1)) {
    return_value = xarray(1) / 2.f;
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 5) {
    if (earray(ie) == srt) {
      return_value = xarray(ie);
      goto statement_10;
    } else if (earray(ie) > srt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(srt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      goto statement_10;
    }
  }
statement_10:
  return_value = return_value / 2.f;
  return return_value;
}

struct xkkann_save {
  float fwdp;
  float pf2;
  float pi2;
  float pkaon;
  float s;
  float scheck;
  float xm1;
  float xm2;
  float xpion0;

  xkkann_save()
      : fwdp(fem::float0),
        pf2(fem::float0),
        pi2(fem::float0),
        pkaon(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        xm1(fem::float0),
        xm2(fem::float0),
        xpion0(fem::float0) {}
};

// C*********************************
// Cbali2/6/99 end
// Cbz3/9/99 kkbar
// Cbali3/5/99
// C*****************************************
// C purpose: Xsection for K+ K- to pi+ pi-
// C      real*4 function xkkpi(srt)
// C  srt    = DSQRT(s) in GeV                                  *
// C  xkkpi   = xsection in mb obtained from
// C           the detailed balance                             *
// C ******************************************
// C          parameter (pimass=0.140,aka=0.498)
// C       xkkpi=1.e-08
// C       ppi2=(srt/2)**2-pimass**2
// C       pk2=(srt/2)**2-aka**2
// C       if(ppi2.le.0.or.pk2.le.0)return
// Cbz3/9/99 kkbar
// C       xkkpi=ppi2/pk2*pipik(srt)
// C       xkkpi=9.0 / 4.0 * ppi2/pk2*pipik(srt)
// C        xkkpi = 2.0 * xkkpi
// Cbz3/9/99 kkbar end
// C
// Cbz3/9/99 kkbar
// C       end
// C       return
// C        END
// Cbz3/9/99 kkbar end
// C
// Cbali3/5/99 end
// Cbz3/9/99 kkbar end
// C
// Cbz3/9/99 kkbar
// C****************************
// C purpose: Xsection for K+ K- to pi+ pi-
void xkkann(common& cmn, float const& srt, float& xsk1, float& xsk2,
            float& xsk3, float& xsk4, float& xsk5, float& xsk6, float& xsk7,
            float& xsk8, float& xsk9, float& xsk10, float& xsk11, float& sigk,
            float const& rrkk) {
  FEM_CMN_SVE(xkkann);
  common_write write(cmn);
  // SAVE
  float& fwdp = sve.fwdp;
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& pkaon = sve.pkaon;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& xm1 = sve.xm1;
  float& xm2 = sve.xm2;
  float& xpion0 = sve.xpion0;
  //
  // C  srt    = DSQRT(s) in GeV                                       *
  // C  xsk1   = annihilation into pi pi                               *
  // C  xsk2   = annihilation into pi rho (shifted to XKKSAN)         *
  // C  xsk3   = annihilation into pi omega (shifted to XKKSAN)       *
  // C  xsk4   = annihilation into pi eta                              *
  // C  xsk5   = annihilation into rho rho                             *
  // C  xsk6   = annihilation into rho omega                           *
  // C  xsk7   = annihilation into rho eta (shifted to XKKSAN)        *
  // C  xsk8   = annihilation into omega omega                         *
  // C  xsk9   = annihilation into omega eta (shifted to XKKSAN)      *
  // C  xsk10  = annihilation into eta eta                             *
  // C  sigk   = xsection in mb obtained from                          *
  // C           the detailed balance                                  *
  // C ***************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /EE/
  // Cc      SAVE /DD/
  // C
  s = fem::pow2(srt);
  sigk = 1.e-08f;
  xsk1 = 0.0f;
  xsk2 = 0.0f;
  xsk3 = 0.0f;
  xsk4 = 0.0f;
  xsk5 = 0.0f;
  xsk6 = 0.0f;
  xsk7 = 0.0f;
  xsk8 = 0.0f;
  xsk9 = 0.0f;
  xsk10 = 0.0f;
  xsk11 = 0.0f;
  // C
  xpion0 = pipik(cmn, srt);
  // C.....take into account both K+ and K0
  xpion0 = 2.0f * xpion0;
  const float aka = 0.498f;
  pi2 = s * (s - 4.0f * fem::pow2(aka));
  if (pi2 <= 0.0f) {
    return;
  }
  // C
  const float pimass = 0.140f;
  xm1 = pimass;
  xm2 = pimass;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk1 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  // Clin-8/28/00 (pi eta) eta -> K+K- is assumed the same as pi pi -> K+K-:
  xm1 = pimass;
  const float etam = 0.5473f;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk4 = 3.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  xm1 = etam;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk10 = 1.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  xpion0 = rrkk;
  // C
  // Clin-11/07/00: (pi eta) (rho omega) -> K* Kbar (or K*bar K) instead to K
  // Kbar: C        XM1 = PIMASS C        XM2 = RHOM C        PF2 = (S - (XM1 +
  // XM2) ** 2) * (S - (XM1 - XM2) ** 2) C        IF (PF2 .GT. 0.0) THEN C XSK2
  // = 27.0 / 4.0 * PF2 / PI2 * XPION0 C        END IF
  // C
  // C        XM1 = PIMASS
  // C        XM2 = OMEGAM
  // C        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
  // C        IF (PF2 .GT. 0.0) THEN
  // C           XSK3 = 9.0 / 4.0 * PF2 / PI2 * XPION0
  // C        END IF
  // C
  const float rhom = 0.770f;
  xm1 = rhom;
  xm2 = rhom;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk5 = 81.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  xm1 = rhom;
  const float omegam = 0.7819f;
  xm2 = omegam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk6 = 27.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  // C        XM1 = RHOM
  // C        XM2 = ETAM
  // C        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
  // C        IF (PF2 .GT. 0.0) THEN
  // C           XSK7 = 9.0 / 4.0 * PF2 / PI2 * XPION0
  // C        END IF
  // C
  xm1 = omegam;
  xm2 = omegam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk8 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  // C        XM1 = OMEGAM
  // C        XM2 = ETAM
  // C        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
  // C        IF (PF2 .GT. 0.0) THEN
  // C           XSK9 = 3.0 / 4.0 * PF2 / PI2 * XPION0
  // C        END IF
  // C
  // C* K+ + K- --> phi
  const float aphi = 1.02f;
  fwdp = 1.68f * fem::pow((fem::pow2(aphi) - 4.f * fem::pow2(aka)), 1.5f) /
         6.f / aphi / aphi;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(srt) - 4.0f * fem::pow2(aka);
  if (scheck <= 0) {
    write(99, star), "scheck47: ", scheck;
    FEM_STOP(0);
  }
  pkaon = 0.5f * fem::sqrt(scheck);
  // C          pkaon=0.5*sqrt(srt**2-4.0*aka**2)
  // C
  xsk11 = 30.f * 3.14159f * fem::pow2(0.1973f) * fem::pow2((aphi * fwdp)) /
          (fem::pow2((fem::pow2(srt) - fem::pow2(aphi))) +
           fem::pow2((aphi * fwdp))) /
          fem::pow2(pkaon);
  // C
  sigk = xsk1 + xsk2 + xsk3 + xsk4 + xsk5 + xsk6 + xsk7 + xsk8 + xsk9 + xsk10 +
         xsk11;
  // C
}

struct xkksan_save {
  float pf2;
  float pi2;
  float s;
  float xm1;
  float xm2;
  float xpion0;

  xkksan_save()
      : pf2(fem::float0),
        pi2(fem::float0),
        s(fem::float0),
        xm1(fem::float0),
        xm2(fem::float0),
        xpion0(fem::float0) {}
};

// C
// C****************************
// C purpose: Xsection for K* Kbar or K*bar K to pi(eta) rho(omega)
void xkksan(common& cmn, int const& i1, int const& i2, float const& srt,
            float& sigks1, float& sigks2, float& sigks3, float& sigks4,
            float& sigk, float const& prkk) {
  FEM_CMN_SVE(xkksan);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  //
  // SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s = sve.s;
  float& xm1 = sve.xm1;
  float& xm2 = sve.xm2;
  float& xpion0 = sve.xpion0;
  //
  // C  srt    = DSQRT(s) in GeV                                       *
  // C  sigk   = xsection in mb obtained from                          *
  // C           the detailed balance                                  *
  // C ***************************
  // Cc      SAVE /CC/
  // C
  s = fem::pow2(srt);
  sigks1 = 1.e-08f;
  sigks2 = 1.e-08f;
  sigks3 = 1.e-08f;
  sigks4 = 1.e-08f;
  // C
  xpion0 = prkk;
  // Clin note that prkk is for pi (rho omega) -> K* Kbar (AND!) K*bar K:
  xpion0 = xpion0 / 2;
  // C
  // Cc
  // C        PI2 = (S - (aks + AKA) ** 2) * (S - (aks - AKA) ** 2)
  pi2 = (s - fem::pow2((e(i1) + e(i2)))) * (s - fem::pow2((e(i1) - e(i2))));
  sigk = 1.e-08f;
  if (pi2 <= 0.0f) {
    return;
  }
  // C
  const float pimass = 0.140f;
  xm1 = pimass;
  const float rhom = 0.770f;
  xm2 = rhom;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pi2 > 0.0f && pf2 > 0.0f) {
    sigks1 = 27.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  xm1 = pimass;
  const float omegam = 0.7819f;
  xm2 = omegam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pi2 > 0.0f && pf2 > 0.0f) {
    sigks2 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  xm1 = rhom;
  const float etam = 0.5473f;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    sigks3 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  xm1 = omegam;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    sigks4 = 3.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  // C
  sigk = sigks1 + sigks2 + sigks3 + sigks4;
  // C
}

struct crkspi_save {
  float x1;

  crkspi_save() : x1(fem::float0) {}
};

// C
// C*********************************
// C     PURPOSE:                                                         *
// C     assign final states for KK*bar or K*Kbar --> light mesons
// C
// C      SUBROUTINE Crkspi(PX,PY,PZ,SRT,I1,I2,IBLOCK)
void crkspi(common& cmn, int const& i1, int const& i2, float const& xsk1,
            float& xsk2, float& xsk3, float& xsk4, float const& sigk,
            int& iblock, int& lbp1, int& lbp2, float& emm1, float& emm2) {
  FEM_CMN_SVE(crkspi);
  // COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& x1 = sve.x1;
  //
  // C             iblock   - 466
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  iblock = 466;
  // C charges of final state mesons:
  // C
  x1 = ranart(nseed) * sigk;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  const float ap2 = 0.13957f;
  const float rhom = 0.770f;
  const float amomga = 0.782f;
  const float aeta = 0.548f;
  if (x1 <= xsk1) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = ap2;
    e(i2) = rhom;
  } else if (x1 <= xsk2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 28;
    e(i1) = ap2;
    e(i2) = amomga;
  } else if (x1 <= xsk3) {
    lb(i1) = 0;
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = aeta;
    e(i2) = rhom;
  } else {
    lb(i1) = 0;
    lb(i2) = 28;
    e(i1) = aeta;
    e(i2) = amomga;
  }
  // C
  const float ap1 = 0.13496f;
  if (lb(i1) == 4) {
    e(i1) = ap1;
  }
  lbp1 = lb(i1);
  lbp2 = lb(i2);
  emm1 = e(i1);
  emm2 = e(i2);
  // C
}

struct crkphi_save {
  float c1;
  float ct1;
  float dnr;
  float dskn;
  float dsknr;
  int ic;
  int lb1;
  int lb2;
  float pii;
  float pr;
  float pr2;
  float prkk0;
  float px0;
  float py0;
  float pz0;
  float ranx;
  float rrkk0;
  float s1;
  float sig;
  float sig1;
  float sig2;
  float sig3;
  float sigks;
  float sigks1;
  float sigks2;
  float sigks3;
  float sigks4;
  float sigm;
  float sigm0;
  float srr1;
  float srr2;
  float srr3;
  float srri;
  float srrt;
  float st1;
  float t1;
  float xsk1;
  float xsk10;
  float xsk11;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;
  float xsk6;
  float xsk7;
  float xsk8;
  float xsk9;

  crkphi_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dnr(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        ic(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        pii(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        prkk0(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        ranx(fem::float0),
        rrkk0(fem::float0),
        s1(fem::float0),
        sig(fem::float0),
        sig1(fem::float0),
        sig2(fem::float0),
        sig3(fem::float0),
        sigks(fem::float0),
        sigks1(fem::float0),
        sigks2(fem::float0),
        sigks3(fem::float0),
        sigks4(fem::float0),
        sigm(fem::float0),
        sigm0(fem::float0),
        srr1(fem::float0),
        srr2(fem::float0),
        srr3(fem::float0),
        srri(fem::float0),
        srrt(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        xsk1(fem::float0),
        xsk10(fem::float0),
        xsk11(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0),
        xsk6(fem::float0),
        xsk7(fem::float0),
        xsk8(fem::float0),
        xsk9(fem::float0) {}
};

// C*********************************
// C                                                                      *
void crkphi(common& cmn, float& px, float& py, float& pz, float const& ec,
            float const& srt, int& iblock, float& emm1, float& emm2, int& lbp1,
            int& lbp2, int const& i1, int const& i2, int& ikk, int& icase,
            float const& rrkk, float const& prkk) {
  FEM_CMN_SVE(crkphi);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dnr = sve.dnr;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  int& ic = sve.ic;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pii = sve.pii;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& prkk0 = sve.prkk0;
  float& ranx = sve.ranx;
  float& rrkk0 = sve.rrkk0;
  float& s1 = sve.s1;
  float& sig = sve.sig;
  float& sig1 = sve.sig1;
  float& sig2 = sve.sig2;
  float& sig3 = sve.sig3;
  float& sigks = sve.sigks;
  float& sigks1 = sve.sigks1;
  float& sigks2 = sve.sigks2;
  float& sigks3 = sve.sigks3;
  float& sigks4 = sve.sigks4;
  float& sigm = sve.sigm;
  float& sigm0 = sve.sigm0;
  float& srr1 = sve.srr1;
  float& srr2 = sve.srr2;
  float& srr3 = sve.srr3;
  float& srri = sve.srri;
  float& srrt = sve.srrt;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& xsk1 = sve.xsk1;
  float& xsk10 = sve.xsk10;
  float& xsk11 = sve.xsk11;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  float& xsk6 = sve.xsk6;
  float& xsk7 = sve.xsk7;
  float& xsk8 = sve.xsk8;
  float& xsk9 = sve.xsk9;
  //
  // C
  // C     PURPOSE:                                                         *
  // C     DEALING WITH   KKbar, KK*bar, KbarK*, K*K*bar --> Phi + pi(rho,omega)
  // C     and KKbar --> (pi eta) (pi eta), (rho omega) (rho omega)
  // C     and KK*bar or Kbar K* --> (pi eta) (rho omega)
  // C
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      222
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  lb1 = lb(i1);
  lb2 = lb(i2);
  icase = 0;
  // C
  // C        if(srt .lt. aphi+ap1)return
  // Cc        if(srt .lt. aphi+ap1) then
  const float aphi = 1.02f;
  const float ap1 = 0.13496f;
  const float aomega = 0.7819f;
  const float arho = 0.77f;
  if (srt < (aphi + ap1)) {
    sig1 = 0.f;
    sig2 = 0.f;
    sig3 = 0.f;
  } else {
    // C
    if ((lb1 == 23 && lb2 == 21) || (lb2 == 23 && lb1 == 21)) {
      dnr = 4.f;
      ikk = 2;
    } else if ((lb1 == 21 && lb2 == 30) || (lb2 == 21 && lb1 == 30) ||
               (lb1 == 23 && lb2 == -30) || (lb2 == 23 && lb1 == -30)) {
      dnr = 12.f;
      ikk = 1;
    } else {
      dnr = 36.f;
      ikk = 0;
    }
    // C
    sig1 = 0.f;
    sig2 = 0.f;
    sig3 = 0.f;
    srri = e(i1) + e(i2);
    srr1 = aphi + ap1;
    srr2 = aphi + aomega;
    srr3 = aphi + arho;
    // C
    pii = (fem::pow2(srt) - fem::pow2((e(i1) + e(i2)))) *
          (fem::pow2(srt) - fem::pow2((e(i1) - e(i2))));
    srrt = srt - fem::amax1(srri, srr1);
    // Cc   to avoid divergent/negative values at small srrt:
    // C          if(srrt .lt. 0.3)then
    if (srrt < 0.3f && srrt > 0.01f) {
      sig = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
    } else {
      sig = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
    }
    sig1 = sig * (9.f / dnr) * (fem::pow2(srt) - fem::pow2((aphi + ap1))) *
           (fem::pow2(srt) - fem::pow2((aphi - ap1))) / pii;
    if (srt > aphi + aomega) {
      srrt = srt - fem::amax1(srri, srr2);
      // Cc         if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        sig = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        sig = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
      sig2 = sig * (9.f / dnr) * (fem::pow2(srt) - fem::pow2((aphi + aomega))) *
             (fem::pow2(srt) - fem::pow2((aphi - aomega))) / pii;
    }
    if (srt > aphi + arho) {
      srrt = srt - fem::amax1(srri, srr3);
      // Cc         if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        sig = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        sig = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
      sig3 = sig * (27.f / dnr) * (fem::pow2(srt) - fem::pow2((aphi + arho))) *
             (fem::pow2(srt) - fem::pow2((aphi - arho))) / pii;
    }
    // C         sig1 = amin1(20.,sig1)
    // C         sig2 = amin1(20.,sig2)
    // C         sig3 = amin1(20.,sig3)
  }
  // C
  rrkk0 = rrkk;
  prkk0 = prkk;
  sigm = 0.f;
  if ((lb1 == 23 && lb2 == 21) || (lb2 == 23 && lb1 == 21)) {
    xkkann(cmn, srt, xsk1, xsk2, xsk3, xsk4, xsk5, xsk6, xsk7, xsk8, xsk9,
           xsk10, xsk11, sigm, rrkk0);
  } else if ((lb1 == 21 && lb2 == 30) || (lb2 == 21 && lb1 == 30) ||
             (lb1 == 23 && lb2 == -30) || (lb2 == 23 && lb1 == -30)) {
    xkksan(cmn, i1, i2, srt, sigks1, sigks2, sigks3, sigks4, sigm, prkk0);
  } else {
  }
  // C
  // C         sigks = sig1 + sig2 + sig3
  sigm0 = sigm;
  sigks = sig1 + sig2 + sig3 + sigm;
  const float pi = 3.1415926f;
  dskn = fem::sqrt(sigks / pi / 10.f);
  dsknr = dskn + 0.1f;
  distce(cmn, i1, i2, dsknr, dskn, cmn.dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  icase = 1;
  ranx = ranart(nseed);
  // C
  lbp1 = 29;
  emm1 = aphi;
  if (ranx <= sig1 / sigks) {
    lbp2 = 3 + fem::fint(3 * ranart(nseed));
    emm2 = ap1;
  } else if (ranx <= (sig1 + sig2) / sigks) {
    lbp2 = 28;
    emm2 = aomega;
  } else if (ranx <= (sig1 + sig2 + sig3) / sigks) {
    lbp2 = 25 + fem::fint(3 * ranart(nseed));
    emm2 = arho;
  } else {
    if ((lb1 == 23 && lb2 == 21) || (lb2 == 23 && lb1 == 21)) {
      crkkpi(cmn, i1, i2, xsk1, xsk2, xsk3, xsk4, xsk5, xsk6, xsk7, xsk8, xsk9,
             xsk10, xsk11, sigm0, iblock, lbp1, lbp2, emm1, emm2);
    } else if ((lb1 == 21 && lb2 == 30) || (lb2 == 21 && lb1 == 30) ||
               (lb1 == 23 && lb2 == -30) || (lb2 == 23 && lb1 == -30)) {
      crkspi(cmn, i1, i2, sigks1, sigks2, sigks3, sigks4, sigm0, iblock, lbp1,
             lbp2, emm1, emm2);
    } else {
    }
  }
  // C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(emm1) - fem::pow2(emm2))) -
        4.0f * fem::pow2((emm1 * emm2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crksph_save {
  float c1;
  float ct1;
  float dnr;
  float dskn;
  float dsknr;
  int ic;
  int lb1;
  int lb2;
  float pff;
  float pii;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float ranx;
  float s1;
  float scheck;
  float sig1;
  float sig11;
  float sig2;
  float sig22;
  float sigela;
  float sigkm;
  float sigks;
  float st1;
  float t1;

  crksph_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dnr(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        ic(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        pff(fem::float0),
        pii(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        ranx(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        sig1(fem::float0),
        sig11(fem::float0),
        sig2(fem::float0),
        sig22(fem::float0),
        sigela(fem::float0),
        sigkm(fem::float0),
        sigks(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// Csp11/21/01 end
// C*********************************
// C                                                                      *
void crksph(common& cmn, float& px, float& py, float& pz, float const& ec,
            float const& srt, float& emm1, float& emm2, int& lbp1, int& lbp2,
            int const& i1, int const& i2, int& ikkg, int& ikkl, int& iblock,
            int& icase, float const& srhoks) {
  FEM_CMN_SVE(crksph);
  common_write write(cmn);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dnr = sve.dnr;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  int& ic = sve.ic;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pff = sve.pff;
  float& pii = sve.pii;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& ranx = sve.ranx;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& sig1 = sve.sig1;
  float& sig11 = sve.sig11;
  float& sig2 = sve.sig2;
  float& sig22 = sve.sig22;
  float& sigela = sve.sigela;
  float& sigkm = sve.sigkm;
  float& sigks = sve.sigks;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C
  // C     PURPOSE:                                                         *
  // C     DEALING WITH   K + rho(omega) or K* + pi(rho,omega)
  // C                    --> Phi + K(K*), pi + K* or pi + K, and elastic
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      222
  // C                      223 --> phi + pi(rho,omega)
  // C                      224 --> phi + K <-> K + pi(rho,omega)
  // C                      225 --> phi + K <-> K* + pi(rho,omega)
  // C                      226 --> phi + K* <-> K + pi(rho,omega)
  // C                      227 --> phi + K* <-> K* + pi(rho,omega)
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  lb1 = lb(i1);
  lb2 = lb(i2);
  icase = 0;
  sigela = 10.f;
  sigkm = 0.f;
  // C     K(K*) + rho(omega) -> pi K*(K)
  const float ap2 = 0.13957f;
  const float aks = 0.895f;
  if ((lb1 >= 25 && lb1 <= 28) || (lb2 >= 25 && lb2 <= 28)) {
    if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
      sigkm = srhoks;
      // Clin-2/26/03 check whether (rho K) is above the (pi K*) thresh:
    } else if ((lb1 == 23 || lb1 == 21 || lb2 == 23 || lb2 == 21) &&
               srt > (ap2 + aks)) {
      sigkm = srhoks;
    }
  }
  // C
  // C        if(srt .lt. aphi+aka)return
  const float aphi = 1.02f;
  const float aka = 0.498f;
  const float pi = 3.1415926f;
  if (srt < (aphi + aka)) {
    sig11 = 0.f;
    sig22 = 0.f;
  } else {
    // C
    // C K*-bar +pi --> phi + (K,K*)-bar
    if ((fem::iabs(lb1) == 30 && (lb2 >= 3 && lb2 <= 5)) ||
        (fem::iabs(lb2) == 30 && (lb1 >= 3 && lb1 <= 5))) {
      dnr = 18.f;
      ikkl = 0;
      iblock = 225;
      // C               sig1 = 15.0
      // C               sig2 = 30.0
      // Clin-2/06/03 these large values reduces to ~10 mb for sig11 or sig22
      // C     due to the factors of ~1/(32*pi*s)~1/200:
      sig1 = 2047.042f;
      sig2 = 1496.692f;
      // C K(-bar)+rho --> phi + (K,K*)-bar
    } else if ((lb1 == 23 || lb1 == 21 && (lb2 >= 25 && lb2 <= 27)) ||
               (lb2 == 23 || lb2 == 21 && (lb1 >= 25 && lb1 <= 27))) {
      dnr = 18.f;
      ikkl = 1;
      iblock = 224;
      // C               sig1 = 3.5
      // C               sig2 = 9.0
      sig1 = 526.702f;
      sig2 = 1313.960f;
      // C K*(-bar) +rho
    } else if ((fem::iabs(lb1) == 30 && (lb2 >= 25 && lb2 <= 27)) ||
               (fem::iabs(lb2) == 30 && (lb1 >= 25 && lb1 <= 27))) {
      dnr = 54.f;
      ikkl = 0;
      iblock = 225;
      // C               sig1 = 3.5
      // C               sig2 = 9.0
      sig1 = 1371.257f;
      sig2 = 6999.840f;
      // C K(-bar) + omega
    } else if (((lb1 == 23 || lb1 == 21) && lb2 == 28) ||
               ((lb2 == 23 || lb2 == 21) && lb1 == 28)) {
      dnr = 6.f;
      ikkl = 1;
      iblock = 224;
      // C               sig1 = 3.5
      // C               sig2 = 6.5
      sig1 = 355.429f;
      sig2 = 440.558f;
      // C K*(-bar) +omega
    } else {
      dnr = 18.f;
      ikkl = 0;
      iblock = 225;
      // C               sig1 = 3.5
      // C               sig2 = 15.0
      sig1 = 482.292f;
      sig2 = 1698.903f;
    }
    // C
    sig11 = 0.f;
    sig22 = 0.f;
    // C         sig11=sig1*(6./dnr)*(srt**2-(aphi+aka)**2)*
    // C    &           (srt**2-(aphi-aka)**2)/(srt**2-(e(i1)+e(i2))**2)/
    // C    &           (srt**2-(e(i1)-e(i2))**2)
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = (fem::pow2(srt) - fem::pow2((e(i1) + e(i2)))) *
             (fem::pow2(srt) - fem::pow2((e(i1) - e(i2))));
    if (scheck <= 0) {
      write(99, star), "scheck42: ", scheck;
      FEM_STOP(0);
    }
    pii = fem::sqrt(scheck);
    // C        pii = sqrt((srt**2-(e(i1)+e(i2))**2)*(srt**2-(e(i1)-e(i2))**2))
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = (fem::pow2(srt) - fem::pow2((aphi + aka))) *
             (fem::pow2(srt) - fem::pow2((aphi - aka)));
    if (scheck < 0) {
      write(99, star), "scheck43: ", scheck;
      scheck = 0.f;
    }
    pff = fem::sqrt(scheck);
    // C        pff = sqrt((srt**2-(aphi+aka)**2)*(srt**2-(aphi-aka)**2))
    // C
    sig11 = sig1 * pff / pii * 6.f / dnr / 32.f / pi / fem::pow2(srt);
    // C
    if (srt > aphi + aks) {
      // C         sig22=sig2*(18./dnr)*(srt**2-(aphi+aks)**2)*
      // C    &           (srt**2-(aphi-aks)**2)/(srt**2-(e(i1)+e(i2))**2)/
      // C    &           (srt**2-(e(i1)-e(i2))**2)
      pff = fem::sqrt((fem::pow2(srt) - fem::pow2((aphi + aks))) *
                      (fem::pow2(srt) - fem::pow2((aphi - aks))));
      sig22 = sig2 * pff / pii * 18.f / dnr / 32.f / pi / fem::pow2(srt);
    }
    // C         sig11 = amin1(20.,sig11)
    // C         sig22 = amin1(20.,sig22)
    // C
  }
  // C
  // C         sigks = sig11 + sig22
  sigks = sig11 + sig22 + sigela + sigkm;
  // C
  dskn = fem::sqrt(sigks / pi / 10.f);
  dsknr = dskn + 0.1f;
  distce(cmn, i1, i2, dsknr, dskn, cmn.dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  icase = 1;
  ranx = ranart(nseed);
  // C
  if (ranx <= (sigela / sigks)) {
    lbp1 = lb1;
    emm1 = e(i1);
    lbp2 = lb2;
    emm2 = e(i2);
    iblock = 111;
  } else if (ranx <= ((sigela + sigkm) / sigks)) {
    lbp1 = 3 + fem::fint(3 * ranart(nseed));
    emm1 = 0.14f;
    if (lb1 == 23 || lb2 == 23) {
      lbp2 = 30;
      emm2 = aks;
    } else if (lb1 == 21 || lb2 == 21) {
      lbp2 = -30;
      emm2 = aks;
    } else if (lb1 == 30 || lb2 == 30) {
      lbp2 = 23;
      emm2 = aka;
    } else {
      lbp2 = 21;
      emm2 = aka;
    }
    iblock = 112;
  } else if (ranx <= ((sigela + sigkm + sig11) / sigks)) {
    lbp2 = 23;
    emm2 = aka;
    ikkg = 1;
    if (lb1 == 21 || lb2 == 21 || lb1 == -30 || lb2 == -30) {
      lbp2 = 21;
      iblock = iblock - 100;
    }
    lbp1 = 29;
    emm1 = aphi;
  } else {
    lbp2 = 30;
    emm2 = aks;
    ikkg = 0;
    iblock += 2;
    if (lb1 == 21 || lb2 == 21 || lb1 == -30 || lb2 == -30) {
      lbp2 = -30;
      iblock = iblock - 100;
    }
    lbp1 = 29;
    emm1 = aphi;
  }
  // C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(emm1) - fem::pow2(emm2))) -
        4.0f * fem::pow2((emm1 * emm2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct pionpp_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmass1;
  float pmax;
  float pmin;

  pionpp_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0) {}
};

// C*********************************
// C TOTAL PION-P INELASTIC CROSS SECTION
// C  from the CERN data book
// C  date: Sept.2, 1994
// C  for pion++p-->Delta+pion
// C      real*4 function pionpp(srt)
float pionpp(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pionpp);
  // SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmass1 = sve.pmass1;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  //
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in fm**2
  // * C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C *
  // C*****************************************
  pmass = 0.14f;
  pmass1 = 0.938f;
  return_value = 0.00001f;
  if (srt <= 1.22f) {
    return return_value;
  }
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - fem::pow2(pmass) - fem::pow2(pmass1)) /
                 (2.f * pmass1))) -
      fem::pow2(pmass));
  pmin = 0.3f;
  pmax = 25.0f;
  if (plab > pmax) {
    return_value = 20.f / 10.f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 0.f;
    return return_value;
  }
  // C* fit parameters
  a = 24.3f;
  b = -12.3f;
  c = 0.324f;
  an = -1.91f;
  d = -2.44f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0;
  }
  return_value = return_value / 10.f;
  return return_value;
}

struct pipp1_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmass1;
  float pmax;
  float pmin;

  pipp1_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0) {}
};

// C*********************************
// C elementary cross sections
// C  from the CERN data book
// C  date: Sept.2, 1994
// C  for pion-+p-->INELASTIC
// C      real*4 function pipp1(srt)
float pipp1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pipp1);
  // SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmass1 = sve.pmass1;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  //
  // C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in fm**2
  // * C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  // EXPerimental table with cross sections in mb (curve to guide eye) * C UNITS:
  // FM**2 C*****************************************
  pmass = 0.14f;
  pmass1 = 0.938f;
  return_value = 0.0001f;
  if (srt <= 1.22f) {
    return return_value;
  }
  // C 1.Calculate p(lab)  from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  // C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - fem::pow2(pmass) - fem::pow2(pmass1)) /
                 (2.f * pmass1))) -
      fem::pow2(pmass));
  pmin = 0.3f;
  pmax = 25.0f;
  if (plab > pmax) {
    return_value = 20.f / 10.f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 0.f;
    return return_value;
  }
  // C* fit parameters
  a = 26.6f;
  b = -7.18f;
  c = 0.327f;
  an = -1.86f;
  d = -2.81f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0;
  }
  return_value = return_value / 10.f;
  return return_value;
}

struct reab_save {
  float arho1;
  float ed;
  float factor;
  int lb1;
  int lb2;
  float pin2;
  float pout2;
  float xpro;

  reab_save()
      : arho1(fem::float0),
        ed(fem::float0),
        factor(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pin2(fem::float0),
        pout2(fem::float0),
        xpro(fem::float0) {}
};

// C*****************************************
// C for pion (rho or omega)+baryon resonance collisions
// C      real*4 function reab(i1,i2,srt,ictrl)
float reab(common& cmn, int const& i1, int const& i2, float const& srt,
           int const& ictrl) {
  float return_value = fem::float0;
  FEM_CMN_SVE(reab);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& arho1 = sve.arho1;
  float& ed = sve.ed;
  float& factor = sve.factor;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pin2 = sve.pin2;
  float& pout2 = sve.pout2;
  float& xpro = sve.xpro;
  //
  // C  This function calculates the cross section for
  // C  pi+Delta(N*)-->N+PION process * C  srt    = DSQRT(s) in GeV * C  reab =
  // cross section in fm**2                                            * C
  // ictrl=1,2,3 for pion, rho and omega+D(N*)
  // C***************************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /EE/
  lb1 = lb(i1);
  lb2 = lb(i2);
  return_value = 0;
  const float amn = 0.938f;
  const float ap1 = 0.14f;
  if (ictrl == 1 && srt <= (amn + 2.f * ap1 + 0.02f)) {
    return return_value;
  }
  const float aomega = 0.782f;
  if (ictrl == 3 && srt <= (amn + ap1 + aomega + 0.02f)) {
    return return_value;
  }
  pin2 = fem::pow2(((fem::pow2(srt) + fem::pow2(ap1) - fem::pow2(amn)) /
                    (2.f * srt))) -
         fem::pow2(ap1);
  if (pin2 <= 0) {
    return return_value;
  }
  // C for pion+D(N*)-->pion+N
  if (ictrl == 1) {
    if (e(i1) > 1) {
      ed = e(i1);
    } else {
      ed = e(i2);
    }
    pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(ap1) - fem::pow2(ed)) /
                       (2.f * srt))) -
            fem::pow2(ap1);
    if (pout2 <= 0) {
      return return_value;
    }
    xpro = twopi(cmn, srt) / 10.f;
    factor = 1 / 3.f;
    if (((lb1 == 8 && lb2 == 5) || (lb1 == 5 && lb2 == 8)) ||
        ((lb1 == -8 && lb2 == 3) || (lb1 == 3 && lb2 == -8))) {
      factor = 1 / 4.f;
    }
    if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
        (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
      factor = 1.f;
    }
    return_value = factor * pin2 / pout2 * xpro;
    return return_value;
  }
  // C for rho reabsorption
  if (ictrl == 2) {
    if (lb(i2) >= 25) {
      ed = e(i1);
      arho1 = e(i2);
    } else {
      ed = e(i2);
      arho1 = e(i1);
    }
    if (srt <= (amn + ap1 + arho1 + 0.02f)) {
      return return_value;
    }
    pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(arho1) - fem::pow2(ed)) /
                       (2.f * srt))) -
            fem::pow2(arho1);
    if (pout2 <= 0) {
      return return_value;
    }
    xpro = threpi(cmn, srt) / 10.f;
    factor = 1 / 3.f;
    if (((lb1 == 8 && lb2 == 27) || (lb1 == 27 && lb2 == 8)) ||
        ((lb1 == -8 && lb2 == 25) || (lb1 == 25 && lb2 == -8))) {
      factor = 1 / 4.f;
    }
    if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
        (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
      factor = 1.f;
    }
    return_value = factor * pin2 / pout2 * xpro;
    return return_value;
  }
  // C for omega reabsorption
  if (ictrl == 3) {
    if (e(i1) > 1) {
      ed = e(i1);
    }
    if (e(i2) > 1) {
      ed = e(i2);
    }
    pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(aomega) - fem::pow2(ed)) /
                       (2.f * srt))) -
            fem::pow2(aomega);
    if (pout2 <= 0) {
      return return_value;
    }
    xpro = fourpi(cmn, srt) / 10.f;
    factor = 1 / 6.f;
    if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
        (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
      factor = 1.f / 3.f;
    }
    return_value = factor * pin2 / pout2 * xpro;
  }
  return return_value;
}

struct xpp_save {
  arr<float> earray;
  float ekin;
  int ie;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  xpp_save()
      : earray(dimension(14), fem::fill0),
        ekin(fem::float0),
        ie(fem::int0),
        pmass(fem::float0),
        xarray(dimension(14), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
// C      real*4 function Xpp(srt)
float xpp(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xpp);
  arr_ref<float> earray(sve.earray, dimension(14));
  float& ekin = sve.ekin;
  int& ie = sve.ie;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(14));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {20.f,  30.f,  40.f,  60.f,  80.f,
                                     100.f, 170.f, 250.f, 310.f, 350.f,
                                     460.f, 560.f, 660.f, 800.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      fem::data_values data;
      data.values, 150.f, 90.f, 80.6f, 48.0f, 36.6f, 31.6f, 25.9f, 24.0f;
      data.values, 23.1f, 24.0f, 28.3f, 33.6f, 41.5f, 47;
      data, xarray;
    }
  }
  // C  This function contains the experimental total n-p cross sections * C srt
  // = DSQRT(s) in GeV                                                   * C xsec
  // = production cross section in mb                                    * C
  // earray = EXPerimental table with proton energies in MeV                    *
  // C  xarray = EXPerimental table with cross sections in mb (curve to guide
  // eye) * C  WITH A CUTOFF AT 55MB * C*****************************************
  // C      real*4   xarray(14), earray(14)
  // C
  pmass = 0.9383f;
  // C 1.Calculate E_kin(lab) [MeV] from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  ekin = 2000.f * pmass * (fem::pow2((srt / (2.f * pmass))) - 1.f);
  if (ekin < earray(1)) {
    return_value = xarray(1);
    if (return_value > 55) {
      return_value = 55;
    }
    return return_value;
  }
  if (ekin > earray(14)) {
    return_value = xarray(14);
    return return_value;
  }
  // C
  // C 2.Interpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 14) {
    if (earray(ie) == ekin) {
      return_value = xarray(ie);
      if (return_value > 55) {
        return_value = 55.f;
      }
      return return_value;
    }
    if (earray(ie) > ekin) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(ekin) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      if (return_value > 55) {
        return_value = 55.f;
      }
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct xnp_save {
  arr<float> earray;
  float ekin;
  int ie;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  xnp_save()
      : earray(dimension(11), fem::fill0),
        ekin(fem::float0),
        ie(fem::int0),
        pmass(fem::float0),
        xarray(dimension(11), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
float xnp(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xnp);
  arr_ref<float> earray(sve.earray, dimension(11));
  float& ekin = sve.ekin;
  int& ie = sve.ie;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(11));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {20.f,  30.f,  40.f,  60.f,  90.f, 135.0f,
                                     200.f, 300.f, 400.f, 600.f, 800.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {410.f, 270.f, 214.5f, 130.f, 78.f, 53.5f,
                                     41.6f, 35.9f, 34.2f,  34.3f, 34.9f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  // C  This function contains the experimental total n-p cross sections * C srt
  // = DSQRT(s) in GeV                                                   * C xsec
  // = production cross section in mb                                    * C
  // earray = EXPerimental table with proton energies in MeV                    *
  // C  xarray = EXPerimental table with cross sections in mb (curve to guide
  // eye) * C  WITH  A CUTOFF AT 55MB *
  // C*****************************************
  // C      real*4   xarray(11), earray(11)
  // C
  pmass = 0.9383f;
  // C 1.Calculate E_kin(lab) [MeV] from srt [GeV]
  // C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  ekin = 2000.f * pmass * (fem::pow2((srt / (2.f * pmass))) - 1.f);
  if (ekin < earray(1)) {
    return_value = xarray(1);
    if (return_value > 55) {
      return_value = 55;
    }
    return return_value;
  }
  if (ekin > earray(11)) {
    return_value = xarray(11);
    return return_value;
  }
  // C
  // CInterpolate double logarithmically to find sigma(srt)
  // C
  FEM_DO_SAFE(ie, 1, 11) {
    if (earray(ie) == ekin) {
      return_value = xarray(ie);
      if (return_value > 55) {
        return_value = 55.f;
      }
      return return_value;
    }
    if (earray(ie) > ekin) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(ekin) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      if (return_value > 55) {
        return_value = 55;
      }
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct xnd_save {
  float ada;
  float ak0;
  float akp;
  float al;
  float ana;
  float as;
  float deltam;
  float em1;
  float em2;
  float es;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float pr;
  float prf;
  float renom;
  float renom1;
  float renomn;
  float sigdn;
  float signd;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float x1440;
  float x1535;

  xnd_save()
      : ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        deltam(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        es(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        pr(fem::float0),
        prf(fem::float0),
        renom(fem::float0),
        renom1(fem::float0),
        renomn(fem::float0),
        sigdn(fem::float0),
        signd(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        x1440(fem::float0),
        x1535(fem::float0) {}
};

// C
// C*********************************
// C                                                                      *
void xnd(common& cmn, float const& px, float const& py, float const& pz,
         float const& srt, int const& i1, int const& i2, float& xinel,
         float& sigk, float& xsk1, float& xsk2, float& xsk3, float& xsk4,
         float& xsk5) {
  FEM_CMN_SVE(xnd);
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& deltam = sve.deltam;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& es = sve.es;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& pr = sve.pr;
  float& prf = sve.prf;
  float& renom = sve.renom;
  float& renom1 = sve.renom1;
  float& renomn = sve.renomn;
  float& sigdn = sve.sigdn;
  float& signd = sve.signd;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& x1440 = sve.x1440;
  float& x1535 = sve.x1535;
  const float avmass = 0.9383f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  // C     PURPOSE:                                                         *
  // C             calculate NUCLEON-BARYON RESONANCE inelatic Xsection     *
  // C     NOTE   :                                                         *
  // C     QUANTITIES:                                                 *
  // C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  // C                      N12,                                            *
  // C                      M12=1 FOR p+n-->delta(+)+ n                     *
  // C                          2     p+n-->delta(0)+ p                     *
  // C                          3     p+p-->delta(++)+n                     *
  // C                          4     p+p-->delta(+)+p                      *
  // C                          5     n+n-->delta(0)+n                      *
  // C                          6     n+n-->delta(-)+p                      *
  // C                          7     n+p-->N*(0)(1440)+p                   *
  // C                          8     n+p-->N*(+)(1440)+n                   *
  // C                        9     p+p-->N*(+)(1535)+p                     *
  // C                        10    n+n-->N*(0)(1535)+n                     *
  // C                         11    n+p-->N*(+)(1535)+n                     *
  // C                        12    n+p-->N*(0)(1535)+p
  // C                        13    D(++)+D(-)-->N*(+)(1440)+n
  // C                         14    D(++)+D(-)-->N*(0)(1440)+p
  // C                        15    D(+)+D(0)--->N*(+)(1440)+n
  // C                        16    D(+)+D(0)--->N*(0)(1440)+p
  // C                        17    D(++)+D(0)-->N*(+)(1535)+p
  // C                        18    D(++)+D(-)-->N*(0)(1535)+p
  // C                        19    D(++)+D(-)-->N*(+)(1535)+n
  // C                        20    D(+)+D(+)-->N*(+)(1535)+p
  // C                        21    D(+)+D(0)-->N*(+)(1535)+n
  // C                        22    D(+)+D(0)-->N*(0)(1535)+p
  // C                        23    D(+)+D(-)-->N*(0)(1535)+n
  // C                        24    D(0)+D(0)-->N*(0)(1535)+n
  // C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  // C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  // C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  // C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  // C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  // C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  // C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  // C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  // C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  // C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  // C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  // C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  // C                            and more
  // C**********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /BG/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /input1/
  // C
  // C-----------------------------------------------------------------------
  xinel = 0.f;
  sigk = 0;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  xsk5 = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  // C     CAN HAPPEN ANY MORE ==> RETURN (2.04 = 2*AVMASS + PI-MASS+0.02)
  if (srt < 2.04f) {
    return;
  }
  // C Resonance absorption or Delta + N-->N*(1440), N*(1535)
  // C COM: TEST FOR DELTA OR N* ABSORPTION
  // C      IN THE PROCESS DELTA+N-->NN, N*+N-->NN
  prf = fem::sqrt(0.25f * fem::pow2(srt) - fem::pow2(avmass));
  if (em1 > 1.f) {
    deltam = em1;
  } else {
    deltam = em2;
  }
  renom = deltam * fem::pow2(prf) / denom(cmn, srt, 1.f) / pr;
  renomn = deltam * fem::pow2(prf) / denom(cmn, srt, 2.f) / pr;
  renom1 = deltam * fem::pow2(prf) / denom(cmn, srt, -1.f) / pr;
  // C avoid the inelastic collisions between n+delta- -->N+N
  // C       and p+delta++ -->N+N due to charge conservation,
  // C       but they can scatter to produce kaons
  if ((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) {
    renom = 0.f;
  }
  if ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) {
    renom = 0.f;
  }
  if ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) {
    renom = 0.f;
  }
  if ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9)) {
    renom = 0.f;
  }
  m1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
  x1440 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
  // C CROSS SECTION FOR KAON PRODUCTION from the four channels
  // C for NLK channel
  akp = 0.498f;
  sve.ak0 = 0.498f;
  ana = 0.94f;
  ada = 1.232f;
  al = 1.1157f;
  as = 1.1197f;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  // C      !! phi production
  xsk5 = 0;
  t1nlk = ana + al + akp;
  if (srt <= t1nlk) {
    goto statement_222;
  }
  xsk1 = 1.5f * pplpk(cmn, srt);
  // C for DLK channel
  t1dlk = ada + al + akp;
  t2dlk = ada + al - akp;
  if (srt <= t1dlk) {
    goto statement_222;
  }
  es = srt;
  pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
           (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
  sve.pmdlk = fem::sqrt(pmdlk2);
  xsk3 = 1.5f * pplpk(cmn, srt);
  // C for NSK channel
  t1nsk = ana + as + akp;
  t2nsk = ana + as - akp;
  if (srt <= t1nsk) {
    goto statement_222;
  }
  pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
           (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
  sve.pmnsk = fem::sqrt(pmnsk2);
  xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  // C for DSK channel
  t1dsk = ada + as + akp;
  t2dsk = ada + as - akp;
  if (srt <= t1dsk) {
    goto statement_222;
  }
  pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
           (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
  sve.pmdsk = fem::sqrt(pmdsk2);
  xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  // Csp11/21/01
  // C phi production
  if (srt <= (2.f * amn + aphi)) {
    goto statement_222;
  }
  // C  !! mb put the correct form
  xsk5 = 0.0001f;
// Csp11/21/01 end
// C
// C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
statement_222:
  sigk = xsk1 + xsk2 + xsk3 + xsk4;
  // C
  // Cbz3/7/99 neutralk
  xsk1 = 2.0f * xsk1;
  xsk2 = 2.0f * xsk2;
  xsk3 = 2.0f * xsk3;
  xsk4 = 2.0f * xsk4;
  sigk = 2.0f * sigk + xsk5;
  // Cbz3/7/99 neutralk end
  // C
  // C avoid the inelastic collisions between n+delta- -->N+N
  // C       and p+delta++ -->N+N due to charge conservation,
  // C       but they can scatter to produce kaons
  if (((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) ||
      ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) ||
      ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) ||
      ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9))) {
    xinel = sigk;
    return;
  }
  // C WE DETERMINE THE REACTION CHANNELS IN THE FOLLOWING
  // C FOR n+delta(++)-->p+p or n+delta(++)-->n+N*(+)(1440),n+N*(+)(1535)
  // C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
  if (lb(i1) * lb(i2) == 18 &&
      (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
    signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  // C FOR p+delta(-)-->n+n or p+delta(-)-->n+N*(0)(1440),n+N*(0)(1535)
  // C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
  if (lb(i1) * lb(i2) == 6 &&
      (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
    signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  // C FOR p+delta(+)-->p+p, N*(+)(144)+p, N*(+)(1535)+p
  // Cbz11/25/98
  if (lb(i1) * lb(i2) == 8 &&
      (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
    signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  // C FOR n+delta(0)-->n+n, N*(0)(144)+n, N*(0)(1535)+n
  if (lb(i1) * lb(i2) == 14 &&
      (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2)) {
    signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  // C FOR n+delta(+)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
  // C                       N*(+)(1535)+n,N*(0)(1535)+p
  if (lb(i1) * lb(i2) == 16 &&
      (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
    signd = 0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
    sigdn = 0.5f * signd * renom;
    xinel = sigdn + 2.f * x1440 + 2.f * x1535 + sigk;
    return;
  }
  // C FOR p+delta(0)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
  // C                       N*(+)(1535)+n,N*(0)(1535)+p
  if (lb(i1) * lb(i2) == 7) {
    signd = 0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
    sigdn = 0.5f * signd * renom;
    xinel = sigdn + 2.f * x1440 + 2.f * x1535 + sigk;
    return;
  }
  // C FOR p+N*(0)(14)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
  // C OR  P+N*(0)(14)-->D(+)+N, D(0)+P,
  if (lb(i1) * lb(i2) == 10 &&
      (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
    signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    sigdn = signd * renomn;
    xinel = sigdn + x1535 + sigk;
    return;
  }
  // C FOR n+N*(+)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
  if (lb(i1) * lb(i2) == 22 &&
      (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
    signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    sigdn = signd * renomn;
    xinel = sigdn + x1535 + sigk;
    return;
  }
  // C FOR N*(1535)+N-->N+N COLLISIONS
  if ((fem::iabs(lb(i1)) == 12) || (fem::iabs(lb(i1)) == 13) ||
      (fem::iabs(lb(i2)) == 12) || (fem::iabs(lb(i2)) == 13)) {
    signd = x1535;
    sigdn = signd * renom1;
    xinel = sigdn + sigk;
    return;
  }
}

struct xddin_save {
  float ada;
  float ak0;
  float akp;
  float al;
  float ana;
  float as;
  float em1;
  float em2;
  float es;
  int idd;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float pr;
  float s2d;
  float sig2;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float x1535;

  xddin_save()
      : ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        es(fem::float0),
        idd(fem::int0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        pr(fem::float0),
        s2d(fem::float0),
        sig2(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        x1535(fem::float0) {}
};

// C*********************************
// C                                                                      *
void xddin(common& cmn, float const& px, float const& py, float const& pz,
           float const& srt, int const& i1, int const& i2, float& xinel,
           float& sigk, float& xsk1, float& xsk2, float& xsk3, float& xsk4,
           float& xsk5) {
  FEM_CMN_SVE(xddin);
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& es = sve.es;
  int& idd = sve.idd;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& s2d = sve.s2d;
  float& sig2 = sve.sig2;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& x1535 = sve.x1535;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  // C     PURPOSE:                                                         *
  // C             DEALING WITH BARYON RESONANCE-BARYON RESONANCE COLLISIONS*
  // C     NOTE   :                                                         *
  // C           VALID ONLY FOR BARYON-BARYON-DISTANCES LESS THAN 1.32 FM   *
  // C           (1.32 = 2 * HARD-CORE-RADIUS [HRC] )                       *
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  // C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      0-> COLLISION CANNOT HAPPEN                     *
  // C                      1-> N-N ELASTIC COLLISION                       *
  // C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  // C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  // C                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
  // C                     5-> DELTA(N*)+DELTA(N*)   TOTAL   COLLISIONS    *
  // C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  // C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  // C                      N12,                                            *
  // C                      M12=1 FOR p+n-->delta(+)+ n                     *
  // C                          2     p+n-->delta(0)+ p                     *
  // C                          3     p+p-->delta(++)+n                     *
  // C                          4     p+p-->delta(+)+p                      *
  // C                          5     n+n-->delta(0)+n                      *
  // C                          6     n+n-->delta(-)+p                      *
  // C                          7     n+p-->N*(0)(1440)+p                   *
  // C                          8     n+p-->N*(+)(1440)+n                   *
  // C                        9     p+p-->N*(+)(1535)+p                     *
  // C                        10    n+n-->N*(0)(1535)+n                     *
  // C                         11    n+p-->N*(+)(1535)+n                     *
  // C                        12    n+p-->N*(0)(1535)+p
  // C                        13    D(++)+D(-)-->N*(+)(1440)+n
  // C                         14    D(++)+D(-)-->N*(0)(1440)+p
  // C                        15    D(+)+D(0)--->N*(+)(1440)+n
  // C                        16    D(+)+D(0)--->N*(0)(1440)+p
  // C                        17    D(++)+D(0)-->N*(+)(1535)+p
  // C                        18    D(++)+D(-)-->N*(0)(1535)+p
  // C                        19    D(++)+D(-)-->N*(+)(1535)+n
  // C                        20    D(+)+D(+)-->N*(+)(1535)+p
  // C                        21    D(+)+D(0)-->N*(+)(1535)+n
  // C                        22    D(+)+D(0)-->N*(0)(1535)+p
  // C                        23    D(+)+D(-)-->N*(0)(1535)+n
  // C                        24    D(0)+D(0)-->N*(0)(1535)+n
  // C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  // C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  // C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  // C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  // C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  // C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  // C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  // C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  // C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  // C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  // C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  // C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  // C                        +++
  // C               AND MORE CHANNELS AS LISTED IN THE NOTE BOOK
  // C
  // C NOTE ABOUT N*(1440) RESORANCE:                                       *
  // C     As it has been discussed in VerWest's paper,I= 1 (initial isospin)
  // C     channel can all be attributed to delta resorance while I= 0      *
  // C     channel can all be  attribured to N* resorance.Only in n+p       *
  // C     one can have I=0 channel so is the N*(1440) resorance            *
  // C REFERENCES:    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)        *
  // C                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
  // C                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
  // C                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615        *
  // C                    CUTOFF = 2 * AVMASS + 20 MEV                      *
  // C                                                                      *
  // C       for N*(1535) we use the parameterization by Gy. Wolf et al     *
  // C       Nucl phys A552 (1993) 349, added May 18, 1994                  *
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /BG/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /input1/
  // C-----------------------------------------------------------------------
  xinel = 0;
  sigk = 0;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  xsk5 = 0;
  sve.em1 = e(i1);
  sve.em2 = e(i2);
  sve.pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  // C     IF THERE WERE 2 N*(1535) AND THEY DIDN'T SCATT. ELAST.,
  // C     ALLOW THEM TO PRODUCE KAONS. NO OTHER INELASTIC CHANNELS
  // C     ARE KNOWN
  // C       if((lb(i1).ge.12).and.(lb(i2).ge.12))return
  // C     ALL the inelastic collisions between N*(1535) and Delta as well
  // C     as N*(1440) TO PRODUCE KAONS, NO OTHER CHANNELS ARE KNOWN
  // C       if((lb(i1).ge.12).and.(lb(i2).ge.3))return
  // C       if((lb(i2).ge.12).and.(lb(i1).ge.3))return
  // C     calculate the N*(1535) production cross section in I1+I2 collisions
  n1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
  // C
  // C for Delta+Delta-->N*(1440 OR 1535)+N AND N*(1440)+N*(1440)-->N*(1535)+X
  // C     AND DELTA+N*(1440)-->N*(1535)+X
  // C WE ASSUME THEY HAVE THE SAME CROSS SECTIONS as CORRESPONDING N+N
  // COLLISION): C FOR D++D0,
  // D+D+,D+D-,D0D0,N*+N*+,N*0N*0,N*(+)D+,N*(+)D(-),N*(0)D(0) C N*(1535)
  // production, kaon production and reabsorption through C D(N*)+D(N*)-->NN are
  // ALLOWED. C CROSS SECTION FOR KAON PRODUCTION from the four channels are C
  // for NLK channel
  akp = 0.498f;
  sve.ak0 = 0.498f;
  ana = 0.94f;
  ada = 1.232f;
  al = 1.1157f;
  as = 1.1197f;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  t1nlk = ana + al + akp;
  if (srt <= t1nlk) {
    goto statement_222;
  }
  xsk1 = 1.5f * pplpk(cmn, srt);
  // C for DLK channel
  t1dlk = ada + al + akp;
  t2dlk = ada + al - akp;
  if (srt <= t1dlk) {
    goto statement_222;
  }
  es = srt;
  pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
           (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
  sve.pmdlk = fem::sqrt(pmdlk2);
  xsk3 = 1.5f * pplpk(cmn, srt);
  // C for NSK channel
  t1nsk = ana + as + akp;
  t2nsk = ana + as - akp;
  if (srt <= t1nsk) {
    goto statement_222;
  }
  pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
           (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
  sve.pmnsk = fem::sqrt(pmnsk2);
  xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  // C for DSK channel
  t1dsk = ada + as + akp;
  t2dsk = ada + as - akp;
  if (srt <= t1dsk) {
    goto statement_222;
  }
  pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
           (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
  sve.pmdsk = fem::sqrt(pmdsk2);
  xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  // Csp11/21/01
  // C phi production
  if (srt <= (2.f * amn + aphi)) {
    goto statement_222;
  }
  // C  !! mb put the correct form
  xsk5 = 0.0001f;
// Csp11/21/01 end
// C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
statement_222:
  sigk = xsk1 + xsk2 + xsk3 + xsk4;
  // C
  // Cbz3/7/99 neutralk
  xsk1 = 2.0f * xsk1;
  xsk2 = 2.0f * xsk2;
  xsk3 = 2.0f * xsk3;
  xsk4 = 2.0f * xsk4;
  sigk = 2.0f * sigk + xsk5;
  // Cbz3/7/99 neutralk end
  // C
  idd = fem::iabs(lb(i1) * lb(i2));
  // C The reabsorption cross section for the process
  // C D(N*)D(N*)-->NN is
  s2d = reab2d(cmn, i1, i2, srt);
  // C
  // Cbz3/16/99 pion
  s2d = 0.f;
  // Cbz3/16/99 pion end
  // C
  // C(1) N*(1535)+D(N*(1440)) reactions
  // C    we allow kaon production and reabsorption only
  if (((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 12)) ||
      ((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 6)) ||
      ((fem::iabs(lb(i2)) >= 12) && (fem::iabs(lb(i1)) >= 6))) {
    xinel = sigk + s2d;
    return;
  }
  // C channels have the same charge as pp
  if ((idd == 63) || (idd == 64) || (idd == 48) || (idd == 49) ||
      (idd == 11 * 11) || (idd == 10 * 10) || (idd == 88) || (idd == 66) ||
      (idd == 90) || (idd == 70)) {
    xinel = x1535 + sigk + s2d;
    return;
  }
  // C IN DELTA+N*(1440) and N*(1440)+N*(1440) COLLISIONS,
  // C N*(1535), kaon production and reabsorption are ALLOWED
  // C IN N*(1440)+N*(1440) COLLISIONS, ONLY N*(1535) IS ALLOWED
  if ((idd == 110) || (idd == 77) || (idd == 80)) {
    xinel = x1535 + sigk + s2d;
    return;
  }
  if ((idd == 54) || (idd == 56)) {
    // C LIKE FOR N+P COLLISION,
    // C IN DELTA+DELTA COLLISIONS BOTH N*(1440) AND N*(1535) CAN BE PRODUCED
    sig2 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    xinel = 2.f * (sig2 + x1535) + sigk + s2d;
    return;
  }
}

struct dirct1_save {
  arr<float> earray;
  int ie;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  dirct1_save()
      : earray(dimension(122), fem::fill0),
        ie(fem::int0),
        xarray(dimension(122), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C*****************************************
float dirct1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dirct1);
  arr_ref<float> earray(sve.earray, dimension(122));
  int& ie = sve.ie;
  arr_ref<float> xarray(sve.xarray, dimension(122));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {
          1.568300f, 1.578300f, 1.588300f, 1.598300f, 1.608300f, 1.618300f,
          1.628300f, 1.638300f, 1.648300f, 1.658300f, 1.668300f, 1.678300f,
          1.688300f, 1.698300f, 1.708300f, 1.718300f, 1.728300f, 1.738300f,
          1.748300f, 1.758300f, 1.768300f, 1.778300f, 1.788300f, 1.798300f,
          1.808300f, 1.818300f, 1.828300f, 1.838300f, 1.848300f, 1.858300f,
          1.868300f, 1.878300f, 1.888300f, 1.898300f, 1.908300f, 1.918300f,
          1.928300f, 1.938300f, 1.948300f, 1.958300f, 1.968300f, 1.978300f,
          1.988300f, 1.998300f, 2.008300f, 2.018300f, 2.028300f, 2.038300f,
          2.048300f, 2.058300f, 2.068300f, 2.078300f, 2.088300f, 2.098300f,
          2.108300f, 2.118300f, 2.128300f, 2.138300f, 2.148300f, 2.158300f,
          2.168300f, 2.178300f, 2.188300f, 2.198300f, 2.208300f, 2.218300f,
          2.228300f, 2.238300f, 2.248300f, 2.258300f, 2.268300f, 2.278300f,
          2.288300f, 2.298300f, 2.308300f, 2.318300f, 2.328300f, 2.338300f,
          2.348300f, 2.358300f, 2.368300f, 2.378300f, 2.388300f, 2.398300f,
          2.408300f, 2.418300f, 2.428300f, 2.438300f, 2.448300f, 2.458300f,
          2.468300f, 2.478300f, 2.488300f, 2.498300f, 2.508300f, 2.518300f,
          2.528300f, 2.538300f, 2.548300f, 2.558300f, 2.568300f, 2.578300f,
          2.588300f, 2.598300f, 2.608300f, 2.618300f, 2.628300f, 2.638300f,
          2.648300f, 2.658300f, 2.668300f, 2.678300f, 2.688300f, 2.698300f,
          2.708300f, 2.718300f, 2.728300f, 2.738300f, 2.748300f, 2.758300f,
          2.768300f, 2.778300f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {
          1.7764091e-02f, 0.5643668f, 0.8150568f, 1.045565f, 2.133695f,
          3.327922f,      4.206488f,  3.471242f,  4.486876f, 5.542213f,
          6.800052f,      7.192446f,  6.829848f,  6.580306f, 6.868410f,
          8.527946f,      10.15720f,  9.716511f,  9.298335f, 8.901310f,
          10.31213f,      10.52185f,  11.17630f,  11.61639f, 12.05577f,
          12.71596f,      13.46036f,  14.22060f,  14.65449f, 14.94775f,
          14.93310f,      15.32907f,  16.56481f,  16.29422f, 15.18548f,
          14.12658f,      13.72544f,  13.24488f,  13.31003f, 14.42680f,
          12.84423f,      12.49025f,  12.14858f,  11.81870f, 11.18993f,
          11.35816f,      11.09447f,  10.83873f,  10.61592f, 10.53754f,
          9.425521f,      8.195912f,  9.661075f,  9.696192f, 9.200142f,
          8.953734f,      8.715461f,  8.484999f,  8.320765f, 8.255512f,
          8.190969f,      8.127125f,  8.079508f,  8.073004f, 8.010611f,
          7.948909f,      7.887895f,  7.761005f,  7.626290f, 7.494696f,
          7.366132f,      7.530178f,  8.392097f,  9.046881f, 8.962544f,
          8.879403f,      8.797427f,  8.716601f,  8.636904f, 8.558312f,
          8.404368f,      8.328978f,  8.254617f,  8.181265f, 8.108907f,
          8.037527f,      7.967100f,  7.897617f,  7.829057f, 7.761405f,
          7.694647f,      7.628764f,  7.563742f,  7.499570f, 7.387562f,
          7.273281f,      7.161334f,  6.973375f,  6.529592f, 6.280323f,
          6.293136f,      6.305725f,  6.318097f,  6.330258f, 6.342214f,
          6.353968f,      6.365528f,  6.376895f,  6.388079f, 6.399081f,
          6.409906f,      6.420560f,  6.431045f,  6.441367f, 6.451529f,
          6.461533f,      6.471386f,  6.481091f,  6.490650f, 6.476413f,
          6.297259f,      6.097826f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  // C  This function contains the experimental, direct pion(+) + p cross
  // sections * C  srt    = DSQRT(s) in GeV * C  dirct1  = cross section in fm**2
  // * C  earray = EXPerimental table with the srt C  xarray = EXPerimental table
  // with cross sections in mb (curve to guide eye) *
  // C*****************************************
  // C      real*4   xarray(122), earray(122)
  // C
  if (srt < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  if (srt > earray(122)) {
    return_value = xarray(122);
    return_value = return_value / 10.f;
    return return_value;
  }
  // C
  // CInterpolate double logarithmically to find xdirct2(srt)
  // C
  FEM_DO_SAFE(ie, 1, 122) {
    if (earray(ie) == srt) {
      return_value = xarray(ie);
      return_value = return_value / 10.f;
      return return_value;
    }
    if (earray(ie) > srt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(srt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return_value = return_value / 10.f;
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct dirct2_save {
  arr<float> earray;
  int ie;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  dirct2_save()
      : earray(dimension(122), fem::fill0),
        ie(fem::int0),
        xarray(dimension(122), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

// C******************************
// C*****************************************
float dirct2(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dirct2);
  arr_ref<float> earray(sve.earray, dimension(122));
  int& ie = sve.ie;
  arr_ref<float> xarray(sve.xarray, dimension(122));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {
          1.568300f, 1.578300f, 1.588300f, 1.598300f, 1.608300f, 1.618300f,
          1.628300f, 1.638300f, 1.648300f, 1.658300f, 1.668300f, 1.678300f,
          1.688300f, 1.698300f, 1.708300f, 1.718300f, 1.728300f, 1.738300f,
          1.748300f, 1.758300f, 1.768300f, 1.778300f, 1.788300f, 1.798300f,
          1.808300f, 1.818300f, 1.828300f, 1.838300f, 1.848300f, 1.858300f,
          1.868300f, 1.878300f, 1.888300f, 1.898300f, 1.908300f, 1.918300f,
          1.928300f, 1.938300f, 1.948300f, 1.958300f, 1.968300f, 1.978300f,
          1.988300f, 1.998300f, 2.008300f, 2.018300f, 2.028300f, 2.038300f,
          2.048300f, 2.058300f, 2.068300f, 2.078300f, 2.088300f, 2.098300f,
          2.108300f, 2.118300f, 2.128300f, 2.138300f, 2.148300f, 2.158300f,
          2.168300f, 2.178300f, 2.188300f, 2.198300f, 2.208300f, 2.218300f,
          2.228300f, 2.238300f, 2.248300f, 2.258300f, 2.268300f, 2.278300f,
          2.288300f, 2.298300f, 2.308300f, 2.318300f, 2.328300f, 2.338300f,
          2.348300f, 2.358300f, 2.368300f, 2.378300f, 2.388300f, 2.398300f,
          2.408300f, 2.418300f, 2.428300f, 2.438300f, 2.448300f, 2.458300f,
          2.468300f, 2.478300f, 2.488300f, 2.498300f, 2.508300f, 2.518300f,
          2.528300f, 2.538300f, 2.548300f, 2.558300f, 2.568300f, 2.578300f,
          2.588300f, 2.598300f, 2.608300f, 2.618300f, 2.628300f, 2.638300f,
          2.648300f, 2.658300f, 2.668300f, 2.678300f, 2.688300f, 2.698300f,
          2.708300f, 2.718300f, 2.728300f, 2.738300f, 2.748300f, 2.758300f,
          2.768300f, 2.778300f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {
          0.5773182f, 1.404156f, 2.578629f, 3.832013f, 4.906011f, 9.076963f,
          13.10492f,  10.65975f, 15.31156f, 19.77611f, 19.92874f, 18.68979f,
          19.80114f,  18.39536f, 14.34269f, 13.35353f, 13.58822f, 14.57031f,
          10.24686f,  11.23386f, 9.764803f, 10.35652f, 10.53539f, 10.07524f,
          9.582198f,  9.596469f, 9.818489f, 9.012848f, 9.378012f, 9.529244f,
          9.529698f,  8.835624f, 6.671396f, 8.797758f, 8.133437f, 7.866227f,
          7.823946f,  7.808504f, 7.791755f, 7.502062f, 7.417275f, 7.592349f,
          7.752028f,  7.910585f, 8.068122f, 8.224736f, 8.075289f, 7.895902f,
          7.721359f,  7.551512f, 7.386224f, 7.225343f, 7.068739f, 6.916284f,
          6.767842f,  6.623294f, 6.482520f, 6.345404f, 6.211833f, 7.339510f,
          7.531462f,  7.724824f, 7.919620f, 7.848021f, 7.639856f, 7.571083f,
          7.508881f,  7.447474f, 7.386855f, 7.327011f, 7.164454f, 7.001266f,
          6.842526f,  6.688094f, 6.537823f, 6.391583f, 6.249249f, 6.110689f,
          5.975790f,  5.894200f, 5.959503f, 6.024602f, 6.089505f, 6.154224f,
          6.218760f,  6.283128f, 6.347331f, 6.297411f, 6.120248f, 5.948606f,
          6.494864f,  6.357106f, 6.222824f, 6.091910f, 5.964267f, 5.839795f,
          5.718402f,  5.599994f, 5.499146f, 5.451325f, 5.404156f, 5.357625f,
          5.311721f,  5.266435f, 5.301964f, 5.343963f, 5.385833f, 5.427577f,
          5.469200f,  5.510702f, 5.552088f, 5.593359f, 5.634520f, 5.675570f,
          5.716515f,  5.757356f, 5.798093f, 5.838732f, 5.879272f, 5.919717f,
          5.960068f,  5.980941f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  // C  This function contains the experimental, direct pion(-) + p cross
  // sections * C  srt    = DSQRT(s) in GeV * C  dirct2 = cross section in fm**2
  // C  earray = EXPerimental table with the srt
  // C  xarray = EXPerimental table with cross sections in mb (curve to guide
  // eye) * C***************************************** C      real*4 xarray(122),
  // earray(122)
  // C
  if (srt < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  if (srt > earray(122)) {
    return_value = xarray(122);
    return_value = return_value / 10.f;
    return return_value;
  }
  // C
  // CInterpolate double logarithmically to find xdirct2(srt)
  // C
  FEM_DO_SAFE(ie, 1, 122) {
    if (earray(ie) == srt) {
      return_value = xarray(ie);
      return_value = return_value / 10.f;
      return return_value;
    }
    if (earray(ie) > srt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(srt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return_value = return_value / 10.f;
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct fdr_save {
  float ak02;
  float ak2;
  float amd;
  float amp;
  float b;
  float q;
  float q0;

  fdr_save()
      : ak02(fem::float0),
        ak2(fem::float0),
        amd(fem::float0),
        amp(fem::float0),
        b(fem::float0),
        q(fem::float0),
        q0(fem::float0) {}
};

// C**************************8
// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
// CKITAZOE'S FORMULA
// C        REAL*4 FUNCTION FDR(DMASS,aj,al,width,widb0,srt,em1,em2)
float fdr(common& cmn, float const& dmass, float const& aj, float const& al,
          float const& width, float const& widb0, float const& srt,
          float const& em1, float const& em2) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fdr);
  // SAVE
  float& ak02 = sve.ak02;
  float& ak2 = sve.ak2;
  float& amd = sve.amd;
  float& amp = sve.amp;
  float& b = sve.b;
  float& q = sve.q;
  float& q0 = sve.q0;
  //
  amd = em1;
  amp = em2;
  ak02 =
      0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(amd) - fem::pow2(amp))) -
      fem::pow2((amp * amd));
  if (ak02 > 0.f) {
    q0 = fem::sqrt(ak02 / dmass);
  } else {
    q0 = 0.0f;
    return_value = 0;
    return return_value;
  }
  ak2 = 0.25f * fem::pow2((fem::pow2(srt) - fem::pow2(amd) - fem::pow2(amp))) -
        fem::pow2((amp * amd));
  if (ak2 > 0.f) {
    q = fem::sqrt(ak2 / dmass);
  } else {
    q = 0.00f;
    return_value = 0;
    return return_value;
  }
  b = widb0 * 1.2f * dmass / srt * fem::pow((q / q0), (2.f * al + 1)) /
      (1.f + 0.2f * fem::pow((q / q0), (2 * al)));
  return_value = (2.f * aj + 1) * fem::pow2(width) * b /
                 (fem::pow2((srt - dmass)) + 0.25f * fem::pow2(width)) /
                 (6.f * fem::pow2(q));
  return return_value;
}

struct erhon_save {
  arr<float> arrayb;
  arr<float> arrayj;
  arr<float> arrayl;
  arr<float> arraym;
  arr<float> arrayw;
  float branch;
  int ir;
  float pi;
  float xs;
  float xs0;

  erhon_save()
      : arrayb(dimension(19), fem::fill0),
        arrayj(dimension(19), fem::fill0),
        arrayl(dimension(19), fem::fill0),
        arraym(dimension(19), fem::fill0),
        arrayw(dimension(19), fem::fill0),
        branch(fem::float0),
        ir(fem::int0),
        pi(fem::float0),
        xs(fem::float0),
        xs0(fem::float0) {}
};

// C******************************
// C*****************************
// C this program calculates the elastic cross section for rho+nucleon
// C through higher resonances
// C       real*4 function ErhoN(em1,em2,lb1,lb2,srt)
float erhon(common& cmn, float const& em1, float const& em2, int const& lb1,
            int const& lb2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(erhon);
  // SAVE
  arr_ref<float> arrayb(sve.arrayb, dimension(19));
  arr_ref<float> arrayj(sve.arrayj, dimension(19));
  arr_ref<float> arrayl(sve.arrayl, dimension(19));
  arr_ref<float> arraym(sve.arraym, dimension(19));
  arr_ref<float> arrayw(sve.arrayw, dimension(19));
  float& branch = sve.branch;
  int& ir = sve.ir;
  float& pi = sve.pi;
  float& xs = sve.xs;
  float& xs0 = sve.xs0;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {0.5f, 1.5f, 0.5f, 0.5f, 2.5f, 2.5f, 1.5f,
                                     0.5f, 1.5f, 3.5f, 1.5f, 0.5f, 1.5f, 0.5f,
                                     2.5f, 0.5f, 1.5f, 2.5f, 3.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayj;
    }
    {
      static const int values[] = {1, 2, 0, 0, 2, 3, 2, 1, 1, 3,
                                   1, 0, 2, 0, 3, 1, 1, 2, 3};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), arrayl;
    }
    {
      static const float values[] = {1.44f,  1.52f, 1.535f, 1.65f, 1.675f,
                                     1.68f,  1.70f, 1.71f,  1.72f, 1.99f,
                                     1.60f,  1.62f, 1.70f,  1.90f, 1.905f,
                                     1.910f, 1.86f, 1.93f,  1.95f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arraym;
    }
    {
      static const float values[] = {0.2f,   0.125f, 0.15f, 0.15f, 0.155f,
                                     0.125f, 0.1f,   0.11f, 0.2f,  0.29f,
                                     0.25f,  0.16f,  0.28f, 0.15f, 0.3f,
                                     0.22f,  0.25f,  0.25f, 0.24f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayw;
    }
    {
      static const float values[] = {0.15f,  0.20f, 0.05f, 0.175f, 0.025f,
                                     0.125f, 0.1f,  0.20f, 0.53f,  0.34f,
                                     0.05f,  0.07f, 0.15f, 0.45f,  0.45f,
                                     0.058f, 0.08f, 0.12f, 0.08f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayb;
    }
  }
  // C date : Dec. 19, 1994
  // C ****************************
  // C       implicit real*4 (a-h,o-z)
  // C
  // C the minimum energy for pion+delta collision
  pi = 3.1415926f;
  xs = 0;
  // C include contribution from each resonance
  FEM_DO_SAFE(ir, 1, 19) {
    // Cbz11/25/98
    if (ir <= 8) {
      // C       if(lb1*lb2.eq.27.OR.LB1*LB2.EQ.25*2)branch=0.
      // C       if(lb1*lb2.eq.26.OR.LB1*LB2.EQ.26*2)branch=1./3.
      // C       if(lb1*lb2.eq.27*2.OR.LB1*LB2.EQ.25)branch=2./3.
      // C       ELSE
      // C       if(lb1*lb2.eq.27.OR.LB1*LB2.EQ.25*2)branch=1.
      // C       if(lb1*lb2.eq.26.OR.LB1*LB2.EQ.26*2)branch=2./3.
      // C       if(lb1*lb2.eq.27*2.OR.LB1*LB2.EQ.25)branch=1./3.
      // C       ENDIF
      if (((lb1 * lb2 == 27 && (lb1 == 1 || lb2 == 1)) ||
           (lb1 * lb2 == 25 * 2 && (lb1 == 2 || lb2 == 2))) ||
          ((lb1 * lb2 == -25 && (lb1 == -1 || lb2 == -1)) ||
           (lb1 * lb2 == -27 * 2 && (lb1 == -2 || lb2 == -2)))) {
        branch = 0.f;
      }
      if ((fem::iabs(lb1 * lb2) == 26 &&
           (fem::iabs(lb1) == 1 || fem::iabs(lb2) == 1)) ||
          (fem::iabs(lb1 * lb2) == 26 * 2 &&
           (fem::iabs(lb1) == 2 || fem::iabs(lb2) == 2))) {
        branch = 1.f / 3.f;
      }
      if (((lb1 * lb2 == 27 * 2 && (lb1 == 2 || lb2 == 2)) ||
           (lb1 * lb2 == 25 && (lb1 == 1 || lb2 == 1))) ||
          ((lb1 * lb2 == -25 * 2 && (lb1 == -2 || lb2 == -2)) ||
           (lb1 * lb2 == -27 && (lb1 == -1 || lb2 == -1)))) {
        branch = 2.f / 3.f;
      }
    } else {
      if (((lb1 * lb2 == 27 && (lb1 == 1 || lb2 == 1)) ||
           (lb1 * lb2 == 25 * 2 && (lb1 == 2 || lb2 == 2))) ||
          ((lb1 * lb2 == -25 && (lb1 == -1 || lb2 == -1)) ||
           (lb1 * lb2 == -27 * 2 && (lb1 == -2 || lb2 == -2)))) {
        branch = 1.f;
      }
      if ((fem::iabs(lb1 * lb2) == 26 &&
           (fem::iabs(lb1) == 1 || fem::iabs(lb2) == 1)) ||
          (fem::iabs(lb1 * lb2) == 26 * 2 &&
           (fem::iabs(lb1) == 2 || fem::iabs(lb2) == 2))) {
        branch = 2.f / 3.f;
      }
      if (((lb1 * lb2 == 27 * 2 && (lb1 == 2 || lb2 == 2)) ||
           (lb1 * lb2 == 25 && (lb1 == 1 || lb2 == 1))) ||
          ((lb1 * lb2 == -25 * 2 && (lb1 == -2 || lb2 == -2)) ||
           (lb1 * lb2 == -27 && (lb1 == -1 || lb2 == -1)))) {
        branch = 1.f / 3.f;
      }
    }
    // Cbz11/25/98end
    xs0 = fdr(cmn, arraym(ir), arrayj(ir), arrayl(ir), arrayw(ir), arrayb(ir),
              srt, em1, em2);
    xs += 1.3f * pi * branch * xs0 * fem::pow2((0.1973f));
  }
  return_value = xs;
  return return_value;
}

struct fd1_save {
  float ak02;
  float ak2;
  float amd;
  float amn;
  float amp;
  float b;
  float q;
  float q0;

  fd1_save()
      : ak02(fem::float0),
        ak2(fem::float0),
        amd(fem::float0),
        amn(fem::float0),
        amp(fem::float0),
        b(fem::float0),
        q(fem::float0),
        q0(fem::float0) {}
};

// C**************************8
// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
// CKITAZOE'S FORMULA
// C        REAL*4 FUNCTION FD1(DMASS,aj,al,width,widb0,srt)
float fd1(common& cmn, float const& dmass, float const& aj, float const& al,
          float const& width, float const& widb0, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fd1);
  // SAVE
  float& ak02 = sve.ak02;
  float& ak2 = sve.ak2;
  float& amd = sve.amd;
  float& amn = sve.amn;
  float& amp = sve.amp;
  float& b = sve.b;
  float& q = sve.q;
  float& q0 = sve.q0;
  //
  amn = 0.938f;
  amp = 0.138f;
  amd = amn;
  ak02 =
      0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(amd) - fem::pow2(amp))) -
      fem::pow2((amp * amd));
  if (ak02 > 0.f) {
    q0 = fem::sqrt(ak02 / dmass);
  } else {
    q0 = 0.0f;
    return_value = 0;
    return return_value;
  }
  ak2 = 0.25f * fem::pow2((fem::pow2(srt) - fem::pow2(amd) - fem::pow2(amp))) -
        fem::pow2((amp * amd));
  if (ak2 > 0.f) {
    q = fem::sqrt(ak2 / dmass);
  } else {
    q = 0.00f;
    return_value = 0;
    return return_value;
  }
  b = widb0 * 1.2f * dmass / srt * fem::pow((q / q0), (2.f * al + 1)) /
      (1.f + 0.2f * fem::pow((q / q0), (2 * al)));
  return_value = (2.f * aj + 1) * fem::pow2(width) * b /
                 (fem::pow2((srt - dmass)) + 0.25f * fem::pow2(width)) /
                 (2.f * fem::pow2(q));
  return return_value;
}

struct dirct3_save {
  float amn;
  float amp;
  arr<float> arrayb;
  arr<float> arrayj;
  arr<float> arrayl;
  arr<float> arraym;
  arr<float> arrayw;
  float branch;
  int ir;
  float pi;
  float xs;
  float xs0;

  dirct3_save()
      : amn(fem::float0),
        amp(fem::float0),
        arrayb(dimension(17), fem::fill0),
        arrayj(dimension(17), fem::fill0),
        arrayl(dimension(17), fem::fill0),
        arraym(dimension(17), fem::fill0),
        arrayw(dimension(17), fem::fill0),
        branch(fem::float0),
        ir(fem::int0),
        pi(fem::float0),
        xs(fem::float0),
        xs0(fem::float0) {}
};

// C*****************************
// C this program calculates the elastic cross section for pion+delta
// C through higher resonances
// C       REAL*4 FUNCTION DIRCT3(SRT)
float dirct3(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dirct3);
  // SAVE
  arr_ref<float> arrayb(sve.arrayb, dimension(17));
  arr_ref<float> arrayj(sve.arrayj, dimension(17));
  arr_ref<float> arrayl(sve.arrayl, dimension(17));
  arr_ref<float> arraym(sve.arraym, dimension(17));
  arr_ref<float> arrayw(sve.arrayw, dimension(17));
  float& branch = sve.branch;
  int& ir = sve.ir;
  float& pi = sve.pi;
  float& xs = sve.xs;
  float& xs0 = sve.xs0;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {1.5f, 0.5f, 2.5f, 2.5f, 1.5f, 0.5f,
                                     1.5f, 3.5f, 1.5f, 0.5f, 1.5f, 0.5f,
                                     2.5f, 0.5f, 1.5f, 2.5f, 3.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayj;
    }
    {
      static const int values[] = {2, 0, 2, 3, 2, 1, 1, 3, 1,
                                   0, 2, 0, 3, 1, 1, 2, 3};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), arrayl;
    }
    {
      static const float values[] = {
          1.52f, 1.65f, 1.675f, 1.68f,  1.70f,  1.71f, 1.72f, 1.99f, 1.60f,
          1.62f, 1.70f, 1.90f,  1.905f, 1.910f, 1.86f, 1.93f, 1.95f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arraym;
    }
    {
      static const float values[] = {
          0.125f, 0.15f, 0.155f, 0.125f, 0.1f,  0.11f, 0.2f,  0.29f, 0.25f,
          0.16f,  0.28f, 0.15f,  0.3f,   0.22f, 0.25f, 0.25f, 0.24f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayw;
    }
    {
      static const float values[] = {0.55f, 0.6f,  0.375f, 0.6f,  0.1f,  0.15f,
                                     0.15f, 0.05f, 0.35f,  0.3f,  0.15f, 0.1f,
                                     0.1f,  0.22f, 0.2f,   0.09f, 0.4f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayb;
    }
  }
  // C date : Dec. 19, 1994
  // C ****************************
  // C     implicit real*4 (a-h,o-z)
  // C
  // C the minimum energy for pion+delta collision
  pi = 3.1415926f;
  sve.amn = 0.938f;
  sve.amp = 0.138f;
  xs = 0;
  // C include contribution from each resonance
  branch = 1.f / 3.f;
  FEM_DO_SAFE(ir, 1, 17) {
    if (ir > 8) {
      branch = 2.f / 3.f;
    }
    xs0 = fd1(cmn, arraym(ir), arrayj(ir), arrayl(ir), arrayw(ir), arrayb(ir),
              srt);
    xs += 1.3f * pi * branch * xs0 * fem::pow2((0.1973f));
  }
  return_value = xs;
  return return_value;
}

struct fd2_save {
  float ak02;
  float ak2;
  float amd;
  float amp;
  float b;
  float q;
  float q0;

  fd2_save()
      : ak02(fem::float0),
        ak2(fem::float0),
        amd(fem::float0),
        amp(fem::float0),
        b(fem::float0),
        q(fem::float0),
        q0(fem::float0) {}
};

// C**************************8
// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
// CKITAZOE'S FORMULA
// C        REAL*4 FUNCTION FD2(DMASS,aj,al,width,widb0,EM1,EM2,srt)
float fd2(common& cmn, float const& dmass, float const& aj, float const& al,
          float const& width, float const& widb0, float const& em1,
          float const& em2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fd2);
  // SAVE
  float& ak02 = sve.ak02;
  float& ak2 = sve.ak2;
  float& amd = sve.amd;
  float& amp = sve.amp;
  float& b = sve.b;
  float& q = sve.q;
  float& q0 = sve.q0;
  //
  amp = em1;
  amd = em2;
  ak02 =
      0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(amd) - fem::pow2(amp))) -
      fem::pow2((amp * amd));
  if (ak02 > 0.f) {
    q0 = fem::sqrt(ak02 / dmass);
  } else {
    q0 = 0.0f;
    return_value = 0;
    return return_value;
  }
  ak2 = 0.25f * fem::pow2((fem::pow2(srt) - fem::pow2(amd) - fem::pow2(amp))) -
        fem::pow2((amp * amd));
  if (ak2 > 0.f) {
    q = fem::sqrt(ak2 / dmass);
  } else {
    q = 0.00f;
    return_value = 0;
    return return_value;
  }
  b = widb0 * 1.2f * dmass / srt * fem::pow((q / q0), (2.f * al + 1)) /
      (1.f + 0.2f * fem::pow((q / q0), (2 * al)));
  return_value = (2.f * aj + 1) * fem::pow2(width) * b /
                 (fem::pow2((srt - dmass)) + 0.25f * fem::pow2(width)) /
                 (4.f * fem::pow2(q));
  return return_value;
}

struct dpion_save {
  float amn;
  float amp;
  arr<float> arrayb;
  arr<float> arrayj;
  arr<float> arrayl;
  arr<float> arraym;
  arr<float> arrayw;
  float branch;
  int ir;
  float pi;
  float xs;
  float xs0;

  dpion_save()
      : amn(fem::float0),
        amp(fem::float0),
        arrayb(dimension(19), fem::fill0),
        arrayj(dimension(19), fem::fill0),
        arrayl(dimension(19), fem::fill0),
        arraym(dimension(19), fem::fill0),
        arrayw(dimension(19), fem::fill0),
        branch(fem::float0),
        ir(fem::int0),
        pi(fem::float0),
        xs(fem::float0),
        xs0(fem::float0) {}
};

// C*****************************
// C this program calculates the elastic cross section for pion+delta
// C through higher resonances
// C       REAL*4 FUNCTION DPION(EM1,EM2,LB1,LB2,SRT)
float dpion(common& cmn, float const& em1, float const& em2, int const& lb1,
            int const& lb2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dpion);
  // SAVE
  arr_ref<float> arrayb(sve.arrayb, dimension(19));
  arr_ref<float> arrayj(sve.arrayj, dimension(19));
  arr_ref<float> arrayl(sve.arrayl, dimension(19));
  arr_ref<float> arraym(sve.arraym, dimension(19));
  arr_ref<float> arrayw(sve.arrayw, dimension(19));
  float& branch = sve.branch;
  int& ir = sve.ir;
  float& pi = sve.pi;
  float& xs = sve.xs;
  float& xs0 = sve.xs0;
  //
  if (is_called_first_time) {
    {
      static const float values[] = {0.5f, 1.5f, 0.5f, 0.5f, 2.5f, 2.5f, 1.5f,
                                     0.5f, 1.5f, 3.5f, 1.5f, 0.5f, 1.5f, 0.5f,
                                     2.5f, 0.5f, 1.5f, 2.5f, 3.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayj;
    }
    {
      static const int values[] = {1, 2, 0, 0, 2, 3, 2, 1, 1, 3,
                                   1, 0, 2, 0, 3, 1, 1, 2, 3};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), arrayl;
    }
    {
      static const float values[] = {1.44f,  1.52f, 1.535f, 1.65f, 1.675f,
                                     1.68f,  1.70f, 1.71f,  1.72f, 1.99f,
                                     1.60f,  1.62f, 1.70f,  1.90f, 1.905f,
                                     1.910f, 1.86f, 1.93f,  1.95f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arraym;
    }
    {
      static const float values[] = {0.2f,   0.125f, 0.15f, 0.15f, 0.155f,
                                     0.125f, 0.1f,   0.11f, 0.2f,  0.29f,
                                     0.25f,  0.16f,  0.28f, 0.15f, 0.3f,
                                     0.22f,  0.25f,  0.25f, 0.24f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayw;
    }
    {
      static const float values[] = {0.15f,  0.25f,  0.f,     0.05f, 0.575f,
                                     0.125f, 0.379f, 0.10f,   0.10f, 0.062f,
                                     0.45f,  0.60f,  0.6984f, 0.05f, 0.25f,
                                     0.089f, 0.19f,  0.2f,    0.13f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayb;
    }
  }
  // C date : Dec. 19, 1994
  // C ****************************
  // C     implicit real*4 (a-h,o-z)
  // C
  // C the minimum energy for pion+delta collision
  pi = 3.1415926f;
  sve.amn = 0.94f;
  sve.amp = 0.14f;
  xs = 0;
  // C include contribution from each resonance
  FEM_DO_SAFE(ir, 1, 19) {
    branch = 0.f;
    // Cbz11/25/98
    if (ir <= 8) {
      // C       IF(LB1*LB2.EQ.5*7.OR.LB1*LB2.EQ.3*8)branch=1./6.
      // C       IF(LB1*LB2.EQ.4*7.OR.LB1*LB2.EQ.4*8)branch=1./3.
      // C       IF(LB1*LB2.EQ.5*6.OR.LB1*LB2.EQ.3*9)branch=1./2.
      // C       ELSE
      // C       IF(LB1*LB2.EQ.5*8.OR.LB1*LB2.EQ.5*6)branch=2./5.
      // C       IF(LB1*LB2.EQ.3*9.OR.LB1*LB2.EQ.3*7)branch=2./5.
      // C       IF(LB1*LB2.EQ.5*7.OR.LB1*LB2.EQ.3*8)branch=8./15.
      // C       IF(LB1*LB2.EQ.4*7.OR.LB1*LB2.EQ.4*8)branch=1./15.
      // C       IF(LB1*LB2.EQ.4*9.OR.LB1*LB2.EQ.4*6)branch=3./5.
      // C       ENDIF
      if (((lb1 * lb2 == 5 * 7 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 3 * 8 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -3 * 7 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -5 * 8 && (lb1 == 5 || lb2 == 5)))) {
        branch = 1.f / 6.f;
      }
      if ((fem::iabs(lb1 * lb2) == 4 * 7 && (lb1 == 4 || lb2 == 4)) ||
          (fem::iabs(lb1 * lb2) == 4 * 8 && (lb1 == 4 || lb2 == 4))) {
        branch = 1.f / 3.f;
      }
      if (((lb1 * lb2 == 5 * 6 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 3 * 9 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -3 * 6 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -5 * 9 && (lb1 == 5 || lb2 == 5)))) {
        branch = 1.f / 2.f;
      }
    } else {
      if (((lb1 * lb2 == 5 * 8 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 5 * 6 && (lb1 == 5 || lb2 == 5))) ||
          ((lb1 * lb2 == -3 * 8 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -3 * 6 && (lb1 == 3 || lb2 == 3)))) {
        branch = 2.f / 5.f;
      }
      if (((lb1 * lb2 == 3 * 9 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == 3 * 7 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -5 * 9 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == -5 * 7 && (lb1 == 5 || lb2 == 5)))) {
        branch = 2.f / 5.f;
      }
      if (((lb1 * lb2 == 5 * 7 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 3 * 8 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -3 * 7 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -5 * 8 && (lb1 == 5 || lb2 == 5)))) {
        branch = 8.f / 15.f;
      }
      if ((fem::iabs(lb1 * lb2) == 4 * 7 && (lb1 == 4 || lb2 == 4)) ||
          (fem::iabs(lb1 * lb2) == 4 * 8 && (lb1 == 4 || lb2 == 4))) {
        branch = 1.f / 15.f;
      }
      if ((fem::iabs(lb1 * lb2) == 4 * 9 && (lb1 == 4 || lb2 == 4)) ||
          (fem::iabs(lb1 * lb2) == 4 * 6 && (lb1 == 4 || lb2 == 4))) {
        branch = 3.f / 5.f;
      }
    }
    // Cbz11/25/98end
    xs0 = fd2(cmn, arraym(ir), arrayj(ir), arrayl(ir), arrayw(ir), arrayb(ir),
              em1, em2, srt);
    xs += 1.3f * pi * branch * xs0 * fem::pow2((0.1973f));
  }
  return_value = xs;
  return return_value;
}

struct xppbar_save {
  float plab;
  float plab2;

  xppbar_save() : plab(fem::float0), plab2(fem::float0) {}
};

// Cbali1/16/99
// C*******************************************
// C Purpose: pp_bar annihilation cross section as a functon of their cms energy
// C      real*4 function xppbar(srt)
float xppbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xppbar);
  // SAVE
  float& plab = sve.plab;
  float& plab2 = sve.plab2;
  //
  // C  srt    = DSQRT(s) in GeV * C  xppbar = pp_bar annihilation cross section
  // in mb                           *
  // C
  // C  Reference: G.J. Wang, R. Bellwied, C. Pruneau and G. Welke
  // C             Proc. of the 14th Winter Workshop on Nuclear Dynamics,
  // C             Snowbird, Utah 31, Eds. W. Bauer and H.G. Ritter
  // C             (Plenum Publishing, 1998)                             *
  // C
  // C*****************************************
  // C Note:
  // C (1) we introduce a new parameter xmax=400 mb:
  // C     the maximum annihilation xsection
  // C there are shadowing effects in pp_bar annihilation, with this parameter
  // C we can probably look at these effects
  // C (2) Calculate p(lab) from srt [GeV], since the formular in the
  // C reference applies only to the case of a p_bar on a proton at rest
  // C Formula used: srt**2=2.*pmass*(pmass+sqrt(pmass**2+plab**2))
  return_value = 1.e-06f;
  const float pmass = 0.9383f;
  plab2 =
      fem::pow2((fem::pow2(srt) / (2.f * pmass) - pmass)) - fem::pow2(pmass);
  const float xmax = 400.f;
  if (plab2 > 0) {
    plab = fem::sqrt(plab2);
    return_value = 67.f / (fem::pow(plab, 0.7f));
    if (return_value > xmax) {
      return_value = xmax;
    }
  }
  return return_value;
}

struct xphib_save {
  float srrt;
  float xsk6;

  xphib_save() : srrt(fem::float0), xsk6(fem::float0) {}
};

// Cbz3/9/99 kkbar end
// C
// C****************************
// C purpose: Xsection for Phi + B
void xphib(common& cmn, int const& lb1, int const& lb2, float const& em1,
           float const& em2, float const& srt, float& xsk1, float& xsk2,
           float& xsk3, float& xsk4, float& xsk5, float& sigp) {
  FEM_CMN_SVE(xphib);
  // SAVE
  float& srrt = sve.srrt;
  float& xsk6 = sve.xsk6;
  //
  // C
  // C ***************************
  // C
  sigp = 1.e-08f;
  xsk1 = 0.0f;
  xsk2 = 0.0f;
  xsk3 = 0.0f;
  xsk4 = 0.0f;
  xsk5 = 0.0f;
  xsk6 = 0.0f;
  srrt = srt - (em1 + em2);
  // C
  // C* phi + N(D) -> elastic scattering
  // C            XSK1 = 0.56  !! mb
  // C  !! mb  (photo-production xsecn used)
  xsk1 = 8.00f;
  // C
  // C* phi + N(D) -> pi + N
  const float ap1 = 0.13496f;
  const float amn = 0.939457f;
  if (srt > (ap1 + amn)) {
    xsk2 = 0.0235f * fem::pow(srrt, (-0.519f));
  }
  // C
  // C* phi + N(D) -> pi + D
  const float am0 = 1.232f;
  if (srt > (ap1 + am0)) {
    if (srrt < 0.7f) {
      xsk3 = 0.0119f * fem::pow(srrt, (-0.534f));
    } else {
      xsk3 = 0.0130f * fem::pow(srrt, (-0.304f));
    }
  }
  // C
  // C* phi + N(D) -> rho + N
  const float arho = 0.77f;
  if (srt > (arho + amn)) {
    if (srrt < 0.7f) {
      xsk4 = 0.0166f * fem::pow(srrt, (-0.786f));
    } else {
      xsk4 = 0.0189f * fem::pow(srrt, (-0.277f));
    }
  }
  // C
  // C* phi + N(D) -> rho + D   (same as pi + D)
  if (srt > (arho + am0)) {
    if (srrt < 0.7f) {
      xsk5 = 0.0119f * fem::pow(srrt, (-0.534f));
    } else {
      xsk5 = 0.0130f * fem::pow(srrt, (-0.304f));
    }
  }
  // C
  // C* phi + N -> K+ + La
  const float aka = 0.498f;
  const float ala = 1.1157f;
  if ((lb1 >= 1 && lb1 <= 2) || (lb2 >= 1 && lb2 <= 2)) {
    if (srt > (aka + ala)) {
      xsk6 = 1.715f / (fem::pow2((srrt + 3.508f)) - 12.138f);
    }
  }
  sigp = xsk1 + xsk2 + xsk3 + xsk4 + xsk5 + xsk6;
}

struct crphib_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;
  float x1;

  crphib_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0) {}
};

// C
// C*********************************
// C
void crphib(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, float const& xsk1, float& xsk2,
            float& xsk3, float& xsk4, float& xsk5, float const& sigp,
            int& iblock) {
  FEM_CMN_SVE(crphib);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  const float ap1 = 0.13496f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float arho = 0.77f;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float pi = 3.1415926f;
  // C
  // C     PURPOSE:                                                         *
  // C             DEALING WITH PHI + N(D) --> pi+N(D), rho+N(D),  K+ + La
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - INFORMATION about the reaction channel          *
  // C
  // C             iblock   - 20  elastic
  // C             iblock   - 221  K+ formation
  // C             iblock   - 223  others
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 223;
  // C
  x1 = ranart(nseed) * sigp;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  xsk5 += xsk4;
  // C
  // C  !! elastic scatt.
  if (x1 <= xsk1) {
    iblock = 20;
    goto statement_100;
  } else if (x1 <= xsk2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = ap1;
    e(i2) = amn;
    goto statement_100;
  } else if (x1 <= xsk3) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = ap1;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xsk4) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = arho;
    e(i2) = amn;
    goto statement_100;
  } else if (x1 <= xsk5) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = arho;
    e(i2) = am0;
    goto statement_100;
  } else {
    lb(i1) = 23;
    lb(i2) = 14;
    e(i1) = aka;
    e(i2) = ala;
    iblock = 221;
  }
statement_100:
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct pibphi_save {
  float sig;
  float srrt;
  float xphid;

  pibphi_save() : sig(fem::float0), srrt(fem::float0), xphid(fem::float0) {}
};

// C
// C****************************
// C purpose: Xsection for Phi + B
// C!! in fm^2
void pibphi(common& cmn, float const& srt, int const& lb1, int const& lb2,
            float const& em1, float const& em2, float& xphi, float& xphin) {
  FEM_CMN_SVE(pibphi);
  // SAVE
  float& sig = sve.sig;
  float& srrt = sve.srrt;
  float& xphid = sve.xphid;
  //
  // C
  // C      phi + N(D) <- pi + N
  // C      phi + N(D) <- pi + D
  // C      phi + N(D) <- rho + N
  // C      phi + N(D) <- rho + D   (same as pi + D)
  // C
  // C ***************************
  // C
  xphi = 0.0f;
  xphin = 0.0f;
  xphid = 0.0f;
  // C
  const float aphi = 1.02f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  if ((lb1 >= 3 && lb1 <= 5) || (lb2 >= 3 && lb2 <= 5)) {
    // C
    if ((fem::iabs(lb1) >= 1 && fem::iabs(lb1) <= 2) ||
        (fem::iabs(lb2) >= 1 && fem::iabs(lb2) <= 2)) {
      // C* phi + N <- pi + N
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        sig = 0.0235f * fem::pow(srrt, (-0.519f));
        xphin = sig * 1.f * (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      // C* phi + D <- pi + N
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        sig = 0.0235f * fem::pow(srrt, (-0.519f));
        xphid = sig * 4.f * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    } else {
      // C* phi + N <- pi + D
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphin = sig * (1.f / 4.f) * (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      // C* phi + D <- pi + D
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphid = sig * 1.f * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    }
    // C
    // C** for rho + N(D) colln
    // C
  } else {
    // C
    if ((fem::iabs(lb1) >= 1 && fem::iabs(lb1) <= 2) ||
        (fem::iabs(lb2) >= 1 && fem::iabs(lb2) <= 2)) {
      // C
      // C* phi + N <- rho + N
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        if (srrt < 0.7f) {
          sig = 0.0166f * fem::pow(srrt, (-0.786f));
        } else {
          sig = 0.0189f * fem::pow(srrt, (-0.277f));
        }
        xphin = sig * (1.f / 3.f) * (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      // C* phi + D <- rho + N
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        if (srrt < 0.7f) {
          sig = 0.0166f * fem::pow(srrt, (-0.786f));
        } else {
          sig = 0.0189f * fem::pow(srrt, (-0.277f));
        }
        xphid = sig * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    } else {
      // C* phi + N <- rho + D  (same as pi+D->phi+N)
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphin = sig * (1.f / 12.f) *
                (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      // C* phi + D <- rho + D  (same as pi+D->phi+D)
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphid = sig * (1.f / 3.f) * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    }
  }
  // C   !! in fm^2
  xphin = xphin / 10.f;
  // C   !! in fm^2
  xphid = xphid / 10.f;
  xphi = xphin + xphid;
  // C
}

struct phimes_save {
  float akap;
  float em1;
  float em2;
  int lb1;
  int lb2;
  float pff;
  float pii;
  float s;
  float scheck;
  float srr;
  float srr1;
  float srr2;
  float srrt;

  phimes_save()
      : akap(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pff(fem::float0),
        pii(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        srr(fem::float0),
        srr1(fem::float0),
        srr2(fem::float0),
        srrt(fem::float0) {}
};

// C
// C****************************
// C purpose: Xsection for phi +M to K+K etc
void phimes(common& cmn, int const& i1, int const& i2, float const& srt,
            float& xsk1, float& xsk2, float& xsk3, float& xsk4, float& xsk5,
            float& xsk6, float& xsk7, float& sigphi) {
  FEM_CMN_SVE(phimes);
  common_write write(cmn);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& akap = sve.akap;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pff = sve.pff;
  float& pii = sve.pii;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& srr = sve.srr;
  float& srr1 = sve.srr1;
  float& srr2 = sve.srr2;
  float& srrt = sve.srrt;
  //
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      223 --> phi destruction
  // C                      20 -->  elastic
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /EE/
  // C
  s = fem::pow2(srt);
  sigphi = 1.e-08f;
  xsk1 = 0.0f;
  xsk2 = 0.0f;
  xsk3 = 0.0f;
  xsk4 = 0.0f;
  xsk5 = 0.0f;
  xsk6 = 0.0f;
  xsk7 = 0.0f;
  em1 = e(i1);
  em2 = e(i2);
  lb1 = lb(i1);
  lb2 = lb(i2);
  const float aka = 0.498f;
  akap = aka;
  // C******
  // C
  // C   !! mb, elastic
  xsk1 = 5.0f;
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
  if (scheck <= 0) {
    write(99, star), "scheck48: ", scheck;
    FEM_STOP(0);
  }
  pii = fem::sqrt(scheck);
  // C           pii = sqrt((S-(em1+em2)**2)*(S-(em1-em2)**2))
  // C
  // C phi + K(-bar) channel
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  const float arho = 0.77f;
  const float aomega = 0.7819f;
  const float aks = 0.895f;
  if (lb1 == 23 || lb2 == 23 || lb1 == 21 || lb2 == 21) {
    if (srt > (ap1 + akap)) {
      // C             XSK2 = 2.5
      pff = fem::sqrt((s - fem::pow2((ap1 + akap))) *
                      (s - fem::pow2((ap1 - akap))));
      xsk2 = 195.639f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + akap)) {
      // C              XSK3 = 3.5
      pff = fem::sqrt((s - fem::pow2((arho + akap))) *
                      (s - fem::pow2((arho - akap))));
      xsk3 = 526.702f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + akap)) {
      // C               XSK4 = 3.5
      pff = fem::sqrt((s - fem::pow2((aomega + akap))) *
                      (s - fem::pow2((aomega - akap))));
      xsk4 = 355.429f * pff / pii / 32.f / pi / s;
    }
    if (srt > (ap1 + aks)) {
      // C           XSK5 = 15.0
      pff = fem::sqrt((s - fem::pow2((ap1 + aks))) *
                      (s - fem::pow2((ap1 - aks))));
      xsk5 = 2047.042f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + aks)) {
      // C            XSK6 = 3.5
      pff = fem::sqrt((s - fem::pow2((arho + aks))) *
                      (s - fem::pow2((arho - aks))));
      xsk6 = 1371.257f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + aks)) {
      // C            XSK7 = 3.5
      pff = fem::sqrt((s - fem::pow2((aomega + aks))) *
                      (s - fem::pow2((aomega - aks))));
      xsk7 = 482.292f * pff / pii / 32.f / pi / s;
    }
    // C
  } else if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
    // C phi + K*(-bar) channel
    // C
    if (srt > (ap1 + akap)) {
      // C             XSK2 = 3.5
      pff = fem::sqrt((s - fem::pow2((ap1 + akap))) *
                      (s - fem::pow2((ap1 - akap))));
      xsk2 = 372.378f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + akap)) {
      // C              XSK3 = 9.0
      pff = fem::sqrt((s - fem::pow2((arho + akap))) *
                      (s - fem::pow2((arho - akap))));
      xsk3 = 1313.960f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + akap)) {
      // C               XSK4 = 6.5
      pff = fem::sqrt((s - fem::pow2((aomega + akap))) *
                      (s - fem::pow2((aomega - akap))));
      xsk4 = 440.558f * pff / pii / 32.f / pi / s;
    }
    if (srt > (ap1 + aks)) {
      // C           XSK5 = 30.0 !wrong
      pff = fem::sqrt((s - fem::pow2((ap1 + aks))) *
                      (s - fem::pow2((ap1 - aks))));
      xsk5 = 1496.692f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + aks)) {
      // C            XSK6 = 9.0
      pff = fem::sqrt((s - fem::pow2((arho + aks))) *
                      (s - fem::pow2((arho - aks))));
      xsk6 = 6999.840f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + aks)) {
      // C            XSK7 = 15.0
      pff = fem::sqrt((s - fem::pow2((aomega + aks))) *
                      (s - fem::pow2((aomega - aks))));
      xsk7 = 1698.903f * pff / pii / 32.f / pi / s;
    }
  } else {
    // C
    // C phi + rho(pi,omega) channel
    // C
    srr1 = em1 + em2;
    if (srt > (akap + akap)) {
      srrt = srt - srr1;
      // Cc          if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        xsk2 = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        xsk2 = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
    }
    if (srt > (akap + aks)) {
      srr2 = akap + aks;
      srr = fem::amax1(srr1, srr2);
      srrt = srt - srr;
      // Cc          if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        xsk3 = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        xsk3 = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
    }
    if (srt > (aks + aks)) {
      srr2 = aks + aks;
      srr = fem::amax1(srr1, srr2);
      srrt = srt - srr;
      // Cc          if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        xsk4 = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        xsk4 = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
    }
    // C          xsk2 = amin1(20.,xsk2)
    // C          xsk3 = amin1(20.,xsk3)
    // C          xsk4 = amin1(20.,xsk4)
  }
  // C
  sigphi = xsk1 + xsk2 + xsk3 + xsk4 + xsk5 + xsk6 + xsk7;
  // C
}

struct crphim_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int iad1;
  int iad2;
  int lb1;
  int lb2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;
  float x1;

  crphim_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        iad1(fem::int0),
        iad2(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0) {}
};

// C
// C*********************************
// C     PURPOSE:                                                         *
// C             DEALING WITH phi+M  scatt.
// C
void crphim(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, float const& xsk1, float& xsk2,
            float& xsk3, float& xsk4, float& xsk5, float& xsk6,
            float const& sigphi, int& ikkg, int& ikkl, int& iblock) {
  FEM_CMN_SVE(crphim);
  const int maxstr = 150001;
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& iad1 = sve.iad1;
  int& iad2 = sve.iad2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  const float ap1 = 0.13496f;
  const float aka = 0.498f;
  const float arho = 0.77f;
  const float aomega = 0.7819f;
  const float aks = 0.895f;
  const float pi = 3.1415926f;
  // C
  // C     QUANTITIES:                                                      *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                      20 -->  elastic
  // C                      223 --> phi + pi(rho,omega)
  // C                      224 --> phi + K -> K + pi(rho,omega)
  // C                      225 --> phi + K -> K* + pi(rho,omega)
  // C                      226 --> phi + K* -> K + pi(rho,omega)
  // C                      227 --> phi + K* -> K* + pi(rho,omega)
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  lb1 = lb(i1);
  lb2 = lb(i2);
  // C
  x1 = ranart(nseed) * sigphi;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  xsk5 += xsk4;
  xsk6 += xsk5;
  if (x1 <= xsk1) {
    // C        !! elastic scatt
    iblock = 20;
    goto statement_100;
  } else {
    // C
    // Cphi + (K,K*)-bar
    if (lb1 == 23 || lb1 == 21 || fem::iabs(lb1) == 30 || lb2 == 23 ||
        lb2 == 21 || fem::iabs(lb2) == 30) {
      // C
      if (lb1 == 23 || lb2 == 23) {
        ikkl = 1;
        iblock = 224;
        iad1 = 23;
        iad2 = 30;
      } else if (lb1 == 30 || lb2 == 30) {
        ikkl = 0;
        iblock = 226;
        iad1 = 23;
        iad2 = 30;
      } else if (lb1 == 21 || lb2 == 21) {
        ikkl = 1;
        iblock = 124;
        iad1 = 21;
        iad2 = -30;
        // C         !! -30
      } else {
        ikkl = 0;
        iblock = 126;
        iad1 = 21;
        iad2 = -30;
      }
      if (x1 <= xsk2) {
        lb(i1) = 3 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad1;
        e(i1) = ap1;
        e(i2) = aka;
        ikkg = 1;
        goto statement_100;
      } else if (x1 <= xsk3) {
        lb(i1) = 25 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad1;
        e(i1) = arho;
        e(i2) = aka;
        ikkg = 1;
        goto statement_100;
      } else if (x1 <= xsk4) {
        lb(i1) = 28;
        lb(i2) = iad1;
        e(i1) = aomega;
        e(i2) = aka;
        ikkg = 1;
        goto statement_100;
      } else if (x1 <= xsk5) {
        lb(i1) = 3 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad2;
        e(i1) = ap1;
        e(i2) = aks;
        ikkg = 0;
        iblock++;
        goto statement_100;
      } else if (x1 <= xsk6) {
        lb(i1) = 25 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad2;
        e(i1) = arho;
        e(i2) = aks;
        ikkg = 0;
        iblock++;
        goto statement_100;
      } else {
        lb(i1) = 28;
        lb(i2) = iad2;
        e(i1) = aomega;
        e(i2) = aks;
        ikkg = 0;
        iblock++;
        goto statement_100;
      }
    } else {
      // C      !! phi destruction via (pi,rho,omega)
      iblock = 223;
      // Cphi + pi(rho,omega)
      if (x1 <= xsk2) {
        lb(i1) = 23;
        lb(i2) = 21;
        e(i1) = aka;
        e(i2) = aka;
        ikkg = 2;
        ikkl = 0;
        goto statement_100;
      } else if (x1 <= xsk3) {
        lb(i1) = 23;
        // C           LB(I2) = 30
        lb(i2) = -30;
        // Clin-2/10/03 currently take XSK3 to be the sum of KK*bar & KbarK*:
        if (ranart(nseed) <= 0.5f) {
          lb(i1) = 21;
          lb(i2) = 30;
        }
        // C
        e(i1) = aka;
        e(i2) = aks;
        ikkg = 1;
        ikkl = 0;
        goto statement_100;
      } else if (x1 <= xsk4) {
        lb(i1) = 30;
        // C           LB(I2) = 30
        lb(i2) = -30;
        e(i1) = aks;
        e(i2) = aks;
        ikkg = 0;
        ikkl = 0;
        goto statement_100;
      }
    }
  }
// C
statement_100:
  em1 = e(i1);
  em2 = e(i2);
  // C
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct xkhype_save {
  float ddf;
  int lb1;
  int lb2;
  float pf2;
  float pi2;
  float s;
  float sig;
  float srrt;
  float xkaon0;
  float xm1;
  float xm2;

  xkhype_save()
      : ddf(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pf2(fem::float0),
        pi2(fem::float0),
        s(fem::float0),
        sig(fem::float0),
        srrt(fem::float0),
        xkaon0(fem::float0),
        xm1(fem::float0),
        xm2(fem::float0) {}
};

// C*********************************
// Cbz3/9/99 khyperon
// C************************************
// C purpose: Xsection for K+Y ->  piN                                       *
// C          Xsection for K+Y-bar ->  piN-bar   !! sp03/29/01               *
// C
void xkhype(common& cmn, int const& i1, int const& i2, float const& srt,
            float& xky1, float& xky2, float& xky3, float& xky4, float& xky5,
            float& xky6, float& xky7, float& xky8, float& xky9, float& xky10,
            float& xky11, float& xky12, float& xky13, float& xky14,
            float& xky15, float& xky16, float& xky17, float& sigk) {
  FEM_CMN_SVE(xkhype);
  // COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& ddf = sve.ddf;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s = sve.s;
  float& sig = sve.sig;
  float& srrt = sve.srrt;
  float& xkaon0 = sve.xkaon0;
  float& xm1 = sve.xm1;
  float& xm2 = sve.xm2;
  //
  // C      subroutine xkhype(i1, i2, srt, sigk)
  // C  srt    = DSQRT(s) in GeV                                               *
  // C  xkkpi   = xsection in mb obtained from                                 *
  // C           the detailed balance                                          *
  // C ***********************************
  // Cc      SAVE /EE/
  // C
  s = fem::pow2(srt);
  sigk = 1.e-08f;
  xky1 = 0.0f;
  xky2 = 0.0f;
  xky3 = 0.0f;
  xky4 = 0.0f;
  xky5 = 0.0f;
  xky6 = 0.0f;
  xky7 = 0.0f;
  xky8 = 0.0f;
  xky9 = 0.0f;
  xky10 = 0.0f;
  xky11 = 0.0f;
  xky12 = 0.0f;
  xky13 = 0.0f;
  xky14 = 0.0f;
  xky15 = 0.0f;
  xky16 = 0.0f;
  xky17 = 0.0f;
  // C
  lb1 = lb(i1);
  lb2 = lb(i2);
  const float aml = 1.116f;
  const float aka = 0.498f;
  const float ams = 1.193f;
  if (fem::iabs(lb1) == 14 || fem::iabs(lb2) == 14) {
    xkaon0 = pnlka(cmn, srt);
    xkaon0 = 2.0f * xkaon0;
    pi2 = (s - fem::pow2((aml + aka))) * (s - fem::pow2((aml - aka)));
  } else {
    xkaon0 = pnska(cmn, srt);
    xkaon0 = 2.0f * xkaon0;
    pi2 = (s - fem::pow2((ams + aka))) * (s - fem::pow2((ams - aka)));
  }
  if (pi2 <= 0.0f) {
    return;
  }
  // C
  const float pimass = 0.140f;
  xm1 = pimass;
  const float amp = 0.93828f;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky1 = 3.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = pimass;
  const float am0 = 1.232f;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky2 = 12.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = pimass;
  const float am1440 = 1.44f;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky3 = 3.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = pimass;
  const float am1535 = 1.535f;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky4 = 3.0f * pf2 / pi2 * xkaon0;
  }
  // C
  const float amrho = 0.769f;
  xm1 = amrho;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky5 = 9.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = amrho;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky6 = 36.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = amrho;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky7 = 9.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = amrho;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky8 = 9.0f * pf2 / pi2 * xkaon0;
  }
  // C
  const float amomga = 0.782f;
  xm1 = amomga;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky9 = 3.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = amomga;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky10 = 12.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = amomga;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky11 = 3.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = amomga;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky12 = 3.0f * pf2 / pi2 * xkaon0;
  }
  // C
  const float ameta = 0.5473f;
  xm1 = ameta;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky13 = 1.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = ameta;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky14 = 4.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = ameta;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky15 = 1.0f * pf2 / pi2 * xkaon0;
  }
  // C
  xm1 = ameta;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky16 = 1.0f * pf2 / pi2 * xkaon0;
  }
  // C
  // Csp11/21/01  K+ + La --> phi + N
  const float aphi = 1.02f;
  const float amn = 0.939457f;
  if (lb1 == 14 || lb2 == 14) {
    if (srt > (aphi + amn)) {
      srrt = srt - (aphi + amn);
      sig = 1.715f / (fem::pow2((srrt + 3.508f)) - 12.138f);
      xm1 = amn;
      xm2 = aphi;
      pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
      // C     ! fm^-1
      xky17 = 3.0f * pf2 / pi2 * sig / 10.f;
    }
  }
  // Csp11/21/01  end
  // C
  if ((fem::iabs(lb1) >= 15 && fem::iabs(lb1) <= 17) ||
      (fem::iabs(lb2) >= 15 && fem::iabs(lb2) <= 17)) {
    ddf = 3.0f;
    xky1 = xky1 / ddf;
    xky2 = xky2 / ddf;
    xky3 = xky3 / ddf;
    xky4 = xky4 / ddf;
    xky5 = xky5 / ddf;
    xky6 = xky6 / ddf;
    xky7 = xky7 / ddf;
    xky8 = xky8 / ddf;
    xky9 = xky9 / ddf;
    xky10 = xky10 / ddf;
    xky11 = xky11 / ddf;
    xky12 = xky12 / ddf;
    xky13 = xky13 / ddf;
    xky14 = xky14 / ddf;
    xky15 = xky15 / ddf;
    xky16 = xky16 / ddf;
  }
  // C
  sigk = xky1 + xky2 + xky3 + xky4 + xky5 + xky6 + xky7 + xky8 + xky9 + xky10 +
         xky11 + xky12 + xky13 + xky14 + xky15 + xky16 + xky17;
  // C
}

struct getnst_save {
  int i;
  float pf2;

  getnst_save() : i(fem::int0), pf2(fem::float0) {}
};

// C
// C****************************************
// C get the number of BbarB states available for mm collisions of energy srt
void getnst(common& cmn, float const& srt) {
  FEM_CMN_SVE(getnst);
  // COMMON ppbmas
  arr_cref<int> niso(cmn.niso, dimension(15));
  int& nstate = cmn.nstate;
  arr_cref<float, 2> ppbm(cmn.ppbm, dimension(15, 2));
  arr_cref<float> thresh(cmn.thresh, dimension(15));
  arr_ref<float> weight(cmn.weight, dimension(15));
  // COMMON ppb1
  float& ene = cmn.ene;
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  float& wtot = cmn.wtot;
  //
  // SAVE
  int& i = sve.i;
  float& pf2 = sve.pf2;
  //
  // C  srt    = DSQRT(s) in GeV * C**************************************** Cc
  // SAVE /ppbmas/ Cc      SAVE /ppb1/ Cc      SAVE /ppmm/
  // C
  s = fem::pow2(srt);
  nstate = 0;
  wtot = 0.f;
  if (srt <= thresh(1)) {
    return;
  }
  FEM_DO_SAFE(i, 1, 15) {
    weight(i) = 0.f;
    if (srt > thresh(i)) {
      nstate = i;
    }
  }
  FEM_DO_SAFE(i, 1, nstate) {
    pf2 = (s - fem::pow2((ppbm(i, 1) + ppbm(i, 2)))) *
          (s - fem::pow2((ppbm(i, 1) - ppbm(i, 2)))) / 4 / s;
    weight(i) = pf2 * niso(i);
    wtot += weight(i);
  }
  const float pimass = 0.140f;
  const float pi = 3.1415926f;
  ene = fem::pow3((srt / pimass)) / (6.f * fem::pow2(pi));
  cmn.fsum = factr2(2) + factr2(3) * ene + factr2(4) * fem::pow2(ene) +
             factr2(5) * fem::pow3(ene) + factr2(6) * fem::pow4(ene);
  // C
}

struct ppbbar_save {
  float pi2;
  float sppb2p;

  ppbbar_save() : pi2(fem::float0), sppb2p(fem::float0) {}
};

// C
// C****************************************
// C for pion+pion-->Bbar B * C      real*4 function ppbbar(srt)
float ppbbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppbbar);
  // COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  //
  // SAVE
  float& pi2 = sve.pi2;
  float& sppb2p = sve.sppb2p;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  sppb2p = xppbar(cmn, srt) * factr2(2) / cmn.fsum;
  const float pimass = 0.140f;
  pi2 = (cmn.s - 4 * fem::pow2(pimass)) / 4;
  return_value = 4.f / 9.f * sppb2p / pi2 * cmn.wtot;
  // C
  return return_value;
}

struct prbbar_save {
  float pi2;
  float sppb3p;

  prbbar_save() : pi2(fem::float0), sppb3p(fem::float0) {}
};

// C
// C****************************************
// C for pion+rho-->Bbar B * C      real*4 function prbbar(srt)
float prbbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(prbbar);
  // COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  //
  // SAVE
  float& pi2 = sve.pi2;
  float& sppb3p = sve.sppb3p;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  sppb3p = xppbar(cmn, srt) * factr2(3) * cmn.ene / cmn.fsum;
  const float pimass = 0.140f;
  const float arho = 0.77f;
  pi2 = (s - fem::pow2((pimass + arho))) * (s - fem::pow2((pimass - arho))) /
        4 / s;
  return_value = 4.f / 27.f * sppb3p / pi2 * cmn.wtot;
  // C
  return return_value;
}

struct rrbbar_save {
  float pi2;
  float sppb4p;

  rrbbar_save() : pi2(fem::float0), sppb4p(fem::float0) {}
};

// C
// C****************************************
// C for rho+rho-->Bbar B                                                      *
// C      real*4 function rrbbar(srt)
float rrbbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rrbbar);
  // COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  //
  // SAVE
  float& pi2 = sve.pi2;
  float& sppb4p = sve.sppb4p;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  sppb4p = xppbar(cmn, srt) * factr2(4) * fem::pow2(cmn.ene) / cmn.fsum;
  const float arho = 0.77f;
  pi2 = (cmn.s - 4 * fem::pow2(arho)) / 4;
  return_value = 4.f / 81.f * (sppb4p / 2) / pi2 * cmn.wtot;
  // C
  return return_value;
}

struct pobbar_save {
  float pi2;
  float sppb4p;

  pobbar_save() : pi2(fem::float0), sppb4p(fem::float0) {}
};

// C
// C****************************************
// C for pi+omega-->Bbar B * C      real*4 function pobbar(srt)
float pobbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pobbar);
  // COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  //
  // SAVE
  float& pi2 = sve.pi2;
  float& sppb4p = sve.sppb4p;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  sppb4p = xppbar(cmn, srt) * factr2(4) * fem::pow2(cmn.ene) / cmn.fsum;
  const float pimass = 0.140f;
  const float aomega = 0.782f;
  pi2 = (s - fem::pow2((pimass + aomega))) *
        (s - fem::pow2((pimass - aomega))) / 4 / s;
  return_value = 4.f / 9.f * (sppb4p / 2) / pi2 * cmn.wtot;
  // C
  return return_value;
}

struct robbar_save {
  float pi2;
  float sppb5p;

  robbar_save() : pi2(fem::float0), sppb5p(fem::float0) {}
};

// C
// C****************************************
// C for rho+omega-->Bbar B * C      real*4 function robbar(srt)
float robbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(robbar);
  // COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  //
  // SAVE
  float& pi2 = sve.pi2;
  float& sppb5p = sve.sppb5p;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  sppb5p = xppbar(cmn, srt) * factr2(5) * fem::pow3(cmn.ene) / cmn.fsum;
  const float arho = 0.77f;
  const float aomega = 0.782f;
  pi2 = (s - fem::pow2((arho + aomega))) * (s - fem::pow2((arho - aomega))) /
        4 / s;
  return_value = 4.f / 27.f * sppb5p / pi2 * cmn.wtot;
  // C
  return return_value;
}

struct oobbar_save {
  float pi2;
  float sppb6p;

  oobbar_save() : pi2(fem::float0), sppb6p(fem::float0) {}
};

// C
// C****************************************
// C for omega+omega-->Bbar B * C      real*4 function oobbar(srt)
float oobbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(oobbar);
  // COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  //
  // SAVE
  float& pi2 = sve.pi2;
  float& sppb6p = sve.sppb6p;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  sppb6p = xppbar(cmn, srt) * factr2(6) * fem::pow4(cmn.ene) / cmn.fsum;
  const float aomega = 0.782f;
  pi2 = (cmn.s - 4 * fem::pow2(aomega)) / 4;
  return_value = 4.f / 9.f * sppb6p / pi2 * cmn.wtot;
  // C
  return return_value;
}

// C
// C****************************************
// C for rho rho -> pi pi, assumed a constant cross section (in mb)
float rtop(float const& /* srt */) {
  float return_value = fem::float0;
  // C****************************************
  return_value = 5.f;
  return return_value;
}

struct ptor_save {
  float s2;

  ptor_save() : s2(fem::float0) {}
};

// C
// C****************************************
// C for pi pi -> rho rho, determined from detailed balance
float ptor(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptor);
  // SAVE
  float& s2 = sve.s2;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  s2 = fem::pow2(srt);
  const float arho = 0.77f;
  const float pimass = 0.140f;
  return_value =
      9 * (s2 - 4 * fem::pow2(arho)) / (s2 - 4 * fem::pow2(pimass)) * rtop(srt);
  // C
  return return_value;
}

// C
// C****************************************
// C for pi pi <-> rho rho cross sections
void spprr(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  // COMMON ppmm
  float& pprr = cmn.pprr;
  //
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  pprr = 0.f;
  const float arho = 0.77f;
  if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
    // C     for now, rho mass taken to be the central value in these two
    // processes
    if (srt > (2 * arho)) {
      pprr = ptor(cmn, srt);
    }
  } else if ((lb1 >= 25 && lb1 <= 27) && (lb2 >= 25 && lb2 <= 27)) {
    pprr = rtop(srt);
  }
  // C
}

// C****************************************
// C for eta eta -> pi pi, assumed a constant cross section (in mb)
float etop(float const& /* srt */) {
  float return_value = fem::float0;
  // C****************************************
  // C
  // C     eta equilibration:
  // C     most important channel is found to be pi pi <-> pi eta, then
  // C     rho pi <-> rho eta.
  return_value = 5.f;
  return return_value;
}

struct ptoe_save {
  float s2;

  ptoe_save() : s2(fem::float0) {}
};

// C
// C****************************************
// C for pi pi -> eta eta, determined from detailed balance, spin-isospin
// averaged
float ptoe(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptoe);
  // SAVE
  float& s2 = sve.s2;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  s2 = fem::pow2(srt);
  const float etam = 0.5475f;
  const float pimass = 0.140f;
  return_value = 1.f / 9.f * (s2 - 4 * fem::pow2(etam)) /
                 (s2 - 4 * fem::pow2(pimass)) * etop(srt);
  // C
  return return_value;
}

// C
// C****************************************
// C for pi pi <-> eta eta cross sections
void sppee(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  // COMMON ppmm
  float& ppee = cmn.ppee;
  //
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  ppee = 0.f;
  const float etam = 0.5475f;
  if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
    if (srt > (2 * etam)) {
      ppee = ptoe(cmn, srt);
    }
  } else if (lb1 == 0 && lb2 == 0) {
    ppee = etop(srt);
  }
  // C
}

// C****************************************
// C for pi eta -> pi pi, assumed a constant cross section (in mb)
float petopp(float const& /* srt */) {
  float return_value = fem::float0;
  // C****************************************
  // C
  // C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct pptope_save {
  float pf2;
  float pi2;
  float s2;

  pptope_save() : pf2(fem::float0), pi2(fem::float0), s2(fem::float0) {}
};

// C
// C****************************************
// C for pi pi -> pi eta, determined from detailed balance, spin-isospin
// averaged
float pptope(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pptope);
  // SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s2 = sve.s2;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  s2 = fem::pow2(srt);
  const float pimass = 0.140f;
  const float etam = 0.5475f;
  pf2 = (s2 - fem::pow2((pimass + etam))) * (s2 - fem::pow2((pimass - etam))) /
        2 / fem::sqrt(s2);
  pi2 = (s2 - 4 * fem::pow2(pimass)) * s2 / 2 / fem::sqrt(s2);
  return_value = 1.f / 3.f * pf2 / pi2 * petopp(srt);
  // C
  return return_value;
}

// C
// C****************************************
// C for pi pi <-> pi eta cross sections
void spppe(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  // COMMON ppmm
  float& pppe = cmn.pppe;
  //
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  pppe = 0.f;
  const float etam = 0.5475f;
  const float pimass = 0.140f;
  if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
    if (srt > (etam + pimass)) {
      pppe = pptope(cmn, srt);
    }
  } else if ((lb1 >= 3 && lb1 <= 5) && lb2 == 0) {
    pppe = petopp(srt);
  } else if ((lb2 >= 3 && lb2 <= 5) && lb1 == 0) {
    pppe = petopp(srt);
  }
  // C
}

// C****************************************
// C for rho eta -> rho pi, assumed a constant cross section (in mb)
float retorp(float const& /* srt */) {
  float return_value = fem::float0;
  // C****************************************
  // C
  // C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct rptore_save {
  float pf2;
  float pi2;
  float s2;

  rptore_save() : pf2(fem::float0), pi2(fem::float0), s2(fem::float0) {}
};

// C
// C****************************************
// C for rho pi->rho eta, determined from detailed balance, spin-isospin
// averaged
float rptore(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rptore);
  // SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s2 = sve.s2;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  s2 = fem::pow2(srt);
  const float arho = 0.77f;
  const float etam = 0.5475f;
  pf2 = (s2 - fem::pow2((arho + etam))) * (s2 - fem::pow2((arho - etam))) / 2 /
        fem::sqrt(s2);
  const float pimass = 0.140f;
  pi2 = (s2 - fem::pow2((arho + pimass))) * (s2 - fem::pow2((arho - pimass))) /
        2 / fem::sqrt(s2);
  return_value = 1.f / 3.f * pf2 / pi2 * retorp(srt);
  // C
  return return_value;
}

// C
// C****************************************
// C for rho pi <-> rho eta cross sections
void srpre(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  // COMMON ppmm
  float& rpre = cmn.rpre;
  //
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  rpre = 0.f;
  const float etam = 0.5475f;
  const float arho = 0.77f;
  const float pimass = 0.140f;
  if (lb1 >= 25 && lb1 <= 27 && lb2 >= 3 && lb2 <= 5) {
    if (srt > (etam + arho)) {
      rpre = rptore(cmn, srt);
    }
  } else if (lb2 >= 25 && lb2 <= 27 && lb1 >= 3 && lb1 <= 5) {
    if (srt > (etam + arho)) {
      rpre = rptore(cmn, srt);
    }
  } else if (lb1 >= 25 && lb1 <= 27 && lb2 == 0) {
    if (srt > (pimass + arho)) {
      rpre = retorp(srt);
    }
  } else if (lb2 >= 25 && lb2 <= 27 && lb1 == 0) {
    if (srt > (pimass + arho)) {
      rpre = retorp(srt);
    }
  }
  // C
}

// C****************************************
// C for omega eta -> omega pi, assumed a constant cross section (in mb)
float xoe2op(float const& /* srt */) {
  float return_value = fem::float0;
  // C****************************************
  // C
  // C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct xop2oe_save {
  float pf2;
  float pi2;
  float s2;

  xop2oe_save() : pf2(fem::float0), pi2(fem::float0), s2(fem::float0) {}
};

// C
// C****************************************
// C for omega pi -> omega eta,
// C     determined from detailed balance, spin-isospin averaged
float xop2oe(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xop2oe);
  // SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s2 = sve.s2;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  s2 = fem::pow2(srt);
  const float aomega = 0.782f;
  const float etam = 0.5475f;
  pf2 = (s2 - fem::pow2((aomega + etam))) * (s2 - fem::pow2((aomega - etam))) /
        2 / fem::sqrt(s2);
  const float pimass = 0.140f;
  pi2 = (s2 - fem::pow2((aomega + pimass))) *
        (s2 - fem::pow2((aomega - pimass))) / 2 / fem::sqrt(s2);
  return_value = 1.f / 3.f * pf2 / pi2 * xoe2op(srt);
  // C
  return return_value;
}

// C
// C****************************************
// C for omega pi <-> omega eta cross sections
void sopoe(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  // COMMON ppmm
  float& xopoe = cmn.xopoe;
  //
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  xopoe = 0.f;
  const float aomega = 0.782f;
  const float etam = 0.5475f;
  if ((lb1 == 28 && lb2 >= 3 && lb2 <= 5) ||
      (lb2 == 28 && lb1 >= 3 && lb1 <= 5)) {
    if (srt > (aomega + etam)) {
      xopoe = xop2oe(cmn, srt);
    }
  } else if ((lb1 == 28 && lb2 == 0) || (lb1 == 0 && lb2 == 28)) {
    if (srt > (aomega + etam)) {
      xopoe = xoe2op(srt);
    }
  }
  // C
}

// C****************************************
// C for rho rho -> eta eta, assumed a constant cross section (in mb)
float rrtoee(float const& /* srt */) {
  float return_value = fem::float0;
  // C****************************************
  // C
  // C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct eetorr_save {
  float s2;

  eetorr_save() : s2(fem::float0) {}
};

// C
// C****************************************
// C for eta eta -> rho rho
// C     determined from detailed balance, spin-isospin averaged
float eetorr(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(eetorr);
  // SAVE
  float& s2 = sve.s2;
  //
  // C****************************************
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  s2 = fem::pow2(srt);
  const float arho = 0.77f;
  const float etam = 0.5475f;
  return_value = 81.f * (s2 - 4 * fem::pow2(arho)) /
                 (s2 - 4 * fem::pow2(etam)) * rrtoee(srt);
  // C
  return return_value;
}

// C
// C****************************************
// C for rho rho <-> eta eta cross sections
void srree(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  // COMMON ppmm
  float& rree = cmn.rree;
  //
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C
  rree = 0.f;
  const float etam = 0.5475f;
  const float arho = 0.77f;
  if (lb1 >= 25 && lb1 <= 27 && lb2 >= 25 && lb2 <= 27) {
    if (srt > (2 * etam)) {
      rree = rrtoee(srt);
    }
  } else if (lb1 == 0 && lb2 == 0) {
    if (srt > (2 * arho)) {
      rree = eetorr(cmn, srt);
    }
  }
  // C
}

struct ksreso_save {
  float dm;
  double e10;
  double e20;
  int i;
  double p1;
  double p2;
  double p3;
  double scheck;

  ksreso_save()
      : dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        i(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0) {}
};

// C
// C---------------------------------------------------------------------------
// C PURPOSE : CALCULATE THE MASS AND MOMENTUM OF K* RESONANCE
// C           AFTER PION + KAON COLLISION
// Cclin only here the K* mass may be different from aks=0.895
void ksreso(common& cmn, int const& i1, int const& i2) {
  FEM_CMN_SVE(ksreso);
  common_write write(cmn);
  // COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON cc
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  int& i = sve.i;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  //
  // Clin-9/2012: improve precision for argument in sqrt():
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // C 1. DETERMINE THE MOMENTUM COMPONENT OF THE K* IN THE CMS OF PI-K FRAME
  // C    WE LET I1 TO BE THE K* AND ABSORB I2
  // C
  // Clin-9/2012: improve precision for argument in sqrt():
  // C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  // C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  // C
  if (lb(i2) == 21 || lb(i2) == 23) {
    e(i1) = 0.f;
    i = i2;
  } else {
    e(i2) = 0.f;
    i = i1;
  }
  if (lb(i) == 23) {
    lb(i) = 30;
  } else if (lb(i) == 21) {
    lb(i) = -30;
  }
  p(1, i) = p(1, i1) + p(1, i2);
  p(2, i) = p(2, i1) + p(2, i2);
  p(3, i) = p(3, i1) + p(3, i2);
  // C 2. DETERMINE THE MASS OF K* BY USING THE REACTION KINEMATICS
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck49: ", scheck;
    write(99, star), "scheck49", scheck, e10, e20, p(1, i), p(2, i), p(3, i);
    write(99, star), "scheck49-1", e(i1), p(1, i1), p(2, i1), p(3, i1);
    write(99, star), "scheck49-2", e(i2), p(1, i2), p(2, i2), p(3, i2);
  }
  dm = fem::sqrt(fem::sngl(scheck));
  // C        DM=SQRT((E10+E20)**2-P(1,I)**2-P(2,I)**2-P(3,I)**2)
  // C
  e(i) = dm;
}

struct pertur_save {
  float acap;
  float akal;
  float akap;
  float alas;
  float ames;
  float aomp;
  float app;
  float asap;
  float brpp;
  float c1;
  float cmat;
  float ct1;
  float dfr;
  float ds;
  float dsr;
  float e1cm;
  float e2cm;
  float ec;
  float em1;
  float em2;
  float empp1;
  float empp2;
  int ic;
  int icsbel;
  int idn;
  int idp;
  int lb1;
  int lb2;
  int lbpp1;
  int lbpp2;
  float p1beta;
  float pff;
  float pii;
  float pkaon;
  float ppt11;
  float ppt12;
  float ppt13;
  float ppt21;
  float ppt22;
  float ppt23;
  float pr;
  float pr2;
  float prob1;
  float prob2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float sig;
  float sigca;
  float sigcal;
  float sigcas;
  float sigeta;
  float sigom;
  float sigomm;
  float sigpe;
  float sigpi;
  float srrt;
  float st1;
  float t1;
  float transf;
  float x1;
  float x2;
  float xpt;
  float xrand;
  float y1;
  float y2;
  float ypt;
  float z1;
  float z2;
  float zpt;

  pertur_save()
      : acap(fem::float0),
        akal(fem::float0),
        akap(fem::float0),
        alas(fem::float0),
        ames(fem::float0),
        aomp(fem::float0),
        app(fem::float0),
        asap(fem::float0),
        brpp(fem::float0),
        c1(fem::float0),
        cmat(fem::float0),
        ct1(fem::float0),
        dfr(fem::float0),
        ds(fem::float0),
        dsr(fem::float0),
        e1cm(fem::float0),
        e2cm(fem::float0),
        ec(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        empp1(fem::float0),
        empp2(fem::float0),
        ic(fem::int0),
        icsbel(fem::int0),
        idn(fem::int0),
        idp(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        lbpp1(fem::int0),
        lbpp2(fem::int0),
        p1beta(fem::float0),
        pff(fem::float0),
        pii(fem::float0),
        pkaon(fem::float0),
        ppt11(fem::float0),
        ppt12(fem::float0),
        ppt13(fem::float0),
        ppt21(fem::float0),
        ppt22(fem::float0),
        ppt23(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        prob1(fem::float0),
        prob2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        sig(fem::float0),
        sigca(fem::float0),
        sigcal(fem::float0),
        sigcas(fem::float0),
        sigeta(fem::float0),
        sigom(fem::float0),
        sigomm(fem::float0),
        sigpe(fem::float0),
        sigpi(fem::float0),
        srrt(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        transf(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xpt(fem::float0),
        xrand(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        ypt(fem::float0),
        z1(fem::float0),
        z2(fem::float0),
        zpt(fem::float0) {}
};

// C
// C--------------------------------------------------------
// C************************************
// C                                                                         *
void pertur(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& irun, int const& i1, int const& i2, int const& /* nt */,
            int const& /* kp */, int& icont) {
  FEM_CMN_SVE(pertur);
  const int maxstr = 150001;
  arr_cref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  arr_ref<float> proper(cmn.proper, dimension(maxstr));
  int& nnn = cmn.nnn;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  arr_ref<float, 2> propi(cmn.propi, dimension(maxstr, maxr));
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  float& dt = cmn.dt;
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  //
  float& acap = sve.acap;
  float& akal = sve.akal;
  float& akap = sve.akap;
  float& alas = sve.alas;
  float& ames = sve.ames;
  float& aomp = sve.aomp;
  float& app = sve.app;
  float& asap = sve.asap;
  float& brpp = sve.brpp;
  float& c1 = sve.c1;
  float& cmat = sve.cmat;
  float& ct1 = sve.ct1;
  float& dfr = sve.dfr;
  float& ds = sve.ds;
  float& dsr = sve.dsr;
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& ec = sve.ec;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& empp1 = sve.empp1;
  float& empp2 = sve.empp2;
  int& ic = sve.ic;
  int& icsbel = sve.icsbel;
  int& idn = sve.idn;
  int& idp = sve.idp;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  int& lbpp1 = sve.lbpp1;
  int& lbpp2 = sve.lbpp2;
  float& p1beta = sve.p1beta;
  float& pff = sve.pff;
  float& pii = sve.pii;
  float& pkaon = sve.pkaon;
  float& ppt11 = sve.ppt11;
  float& ppt12 = sve.ppt12;
  float& ppt13 = sve.ppt13;
  float& ppt21 = sve.ppt21;
  float& ppt22 = sve.ppt22;
  float& ppt23 = sve.ppt23;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& sig = sve.sig;
  float& sigca = sve.sigca;
  float& sigcal = sve.sigcal;
  float& sigcas = sve.sigcas;
  float& sigeta = sve.sigeta;
  float& sigom = sve.sigom;
  float& sigomm = sve.sigomm;
  float& sigpe = sve.sigpe;
  float& sigpi = sve.sigpi;
  float& srrt = sve.srrt;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& transf = sve.transf;
  float& x1 = sve.x1;
  float& xpt = sve.xpt;
  float& xrand = sve.xrand;
  float& y1 = sve.y1;
  float& ypt = sve.ypt;
  float& z1 = sve.z1;
  float& zpt = sve.zpt;
  const float acas = 1.3213f;
  const float amn = 0.939457f;
  const float aeta = 0.548f;
  const float aome = 1.6724f;
  const float asa = 1.1974f;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float pi = 3.1415926f;
  // C                                                                         *
  // C       PURPOSE:   TO PRODUCE CASCADE AND OMEGA PERTURBATIVELY            *
  // C sp 01/03/01
  // C                   40 cascade-
  // C                  -40 cascade-(bar)
  // C                   41 cascade0
  // C                  -41 cascade0(bar)
  // C                   45 Omega baryon
  // C                  -45 Omega baryon(bar)
  // C                   44 Di-Omega
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /HH/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /PE/
  // Cc      SAVE /RR/
  // Cc      SAVE /BG/
  // Cc      SAVE /input1/
  // C     perturbative method is disabled:
  // C      common /imulst/ iperts
  // C
  // Cc      SAVE /RNDF77/
  // C
  px0 = px;
  py0 = py;
  pz0 = pz;
  lb1 = lb(i1);
  em1 = e(i1);
  x1 = r(1, i1);
  y1 = r(2, i1);
  z1 = r(3, i1);
  sve.prob1 = proper(i1);
  // C
  lb2 = lb(i2);
  em2 = e(i2);
  sve.x2 = r(1, i2);
  sve.y2 = r(2, i2);
  sve.z2 = r(3, i2);
  sve.prob2 = proper(i2);
  // C
  // C                 !! flag for real 2-body process (1/0=no/yes)
  icont = 1;
  // C                !! flag for elastic scatt only (-1=no)
  icsbel = -1;
  // C
  // C K-/K*0bar + La/Si --> cascade + pi
  // C K+/K*0 + La/Si (bar) --> cascade-bar + pi
  if ((lb1 == 21 || lb1 == 23 || fem::iabs(lb1) == 30) &&
      (fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17)) {
    goto statement_60;
  }
  if ((lb2 == 21 || lb2 == 23 || fem::iabs(lb2) == 30) &&
      (fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17)) {
    goto statement_60;
  }
  // C K-/K*0bar + cascade --> omega + pi
  // C K+/K*0 + cascade-bar --> omega-bar + pi
  if ((lb1 == 21 || lb1 == 23 || fem::iabs(lb1) == 30) &&
      (fem::iabs(lb2) == 40 || fem::iabs(lb2) == 41)) {
    goto statement_70;
  }
  if ((lb2 == 21 || lb2 == 23 || fem::iabs(lb2) == 30) &&
      (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41)) {
    goto statement_70;
  }
  // C
  // C annhilation of cascade,cascade-bar, omega,omega-bar
  // C
  // C K- + La/Si <-- cascade + pi(eta,rho,omega)
  // C K+ + La/Si(bar) <-- cascade-bar + pi(eta,rho,omega)
  if ((((lb1 >= 3 && lb1 <= 5) || lb1 == 0) &&
       (fem::iabs(lb2) == 40 || fem::iabs(lb2) == 41)) ||
      (((lb2 >= 3 && lb2 <= 5) || lb2 == 0) &&
       (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41))) {
    goto statement_90;
  }
  // C K- + cascade <-- omega + pi
  // C K+ + cascade-bar <-- omega-bar + pi
  // C         if( (lb1.eq.0.and.iabs(lb2).eq.45)
  // C    &    .OR. (lb2.eq.0.and.iabs(lb1).eq.45) ) go to 110
  if (((lb1 >= 3 && lb1 <= 5) && fem::iabs(lb2) == 45) ||
      ((lb2 >= 3 && lb2 <= 5) && fem::iabs(lb1) == 45)) {
    goto statement_110;
  }
// C
// C----------------------------------------------------
// C  for process:  K-bar + L(S) --> Ca + pi
// C
statement_60:
  if (fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) {
    asap = e(i1);
    akap = e(i2);
    idp = i1;
  } else {
    asap = e(i2);
    akap = e(i1);
    idp = i2;
  }
  app = 0.138f;
  if (srt < (acas + app)) {
    return;
  }
  srrt = srt - (acas + app) + (amn + akap);
  pkaon = fem::sqrt(
      fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(akap))) / 2.f /
                 amn)) -
      fem::pow2(akap));
  sigca = 1.5f * (aknpsg(pkaon) + aknpsg(pkaon));
  // Clin pii & pff should be each divided by (4*srt**2),
  // C     but these two factors cancel out in the ratio pii/pff:
  pii = fem::sqrt((fem::pow2(srt) - fem::pow2((amn + akap))) *
                  (fem::pow2(srt) - fem::pow2((amn - akap))));
  pff = fem::sqrt((fem::pow2(srt) - fem::pow2((asap + app))) *
                  (fem::pow2(srt) - fem::pow2((asap - app))));
  cmat = sigca * pii / pff;
  sigpi = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((acas + app))) *
                    (fem::pow2(srt) - fem::pow2((acas - app)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((asap + akap))) *
                    (fem::pow2(srt) - fem::pow2((asap - akap))));
  // C
  sigeta = 0.f;
  if (srt > (acas + aeta)) {
    srrt = srt - (acas + aeta) + (amn + akap);
    pkaon = fem::sqrt(
        fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(akap))) /
                   2.f / amn)) -
        fem::pow2(akap));
    sigca = 1.5f * (aknpsg(pkaon) + aknpsg(pkaon));
    cmat = sigca * pii / pff;
    sigeta = cmat *
             fem::sqrt((fem::pow2(srt) - fem::pow2((acas + aeta))) *
                       (fem::pow2(srt) - fem::pow2((acas - aeta)))) /
             fem::sqrt((fem::pow2(srt) - fem::pow2((asap + akap))) *
                       (fem::pow2(srt) - fem::pow2((asap - akap))));
  }
  // C
  sigca = sigpi + sigeta;
  sigpe = 0.f;
  // Clin-2/25/03 disable the perturb option:
  // C        if(iperts .eq. 1) sigpe = 40.   !! perturbative xsecn
  sig = fem::amax1(sigpe, sigca);
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  brpp = sigca / sig;
  // C
  // C else particle production
  if ((lb1 >= 14 && lb1 <= 17) || (lb2 >= 14 && lb2 <= 17)) {
    // C   !! cascade- or cascde0
    lbpp1 = 40 + fem::fint(2 * ranart(nseed));
  } else {
    // C elseif(lb1 .eq. -14 .or. lb2 .eq. -14)
    // C     !! cascade-bar- or cascde0 -bar
    lbpp1 = -40 - fem::fint(2 * ranart(nseed));
  }
  empp1 = acas;
  if (ranart(nseed) < sigpi / sigca) {
    // C    !! pion
    lbpp2 = 3 + fem::fint(3 * ranart(nseed));
    empp2 = 0.138f;
  } else {
    // C    !! eta
    lbpp2 = 0;
    empp2 = aeta;
  }
  // C* check real process of cascade(bar) and pion formation
  if (ranart(nseed) < brpp) {
    // C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    // C  !! cascade formed with prob Gam
    proper(i1) = brpp;
    lb(i2) = lbpp2;
    e(i2) = empp2;
    // C         !! pion/eta formed with prob 1.
    proper(i2) = 1.f;
  }
  // C else only cascade(bar) formed perturbatively
  goto statement_700;
// C
// C----------------------------------------------------
// C  for process:  Cas(bar) + K_bar(K) --> Om(bar) + pi  !! eta
// C
statement_70:
  if (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41) {
    acap = e(i1);
    akap = e(i2);
    idp = i1;
  } else {
    acap = e(i2);
    akap = e(i1);
    idp = i2;
  }
  app = 0.138f;
  // C         ames = aeta
  // C  !! only pion
  ames = 0.138f;
  if (srt < (aome + ames)) {
    return;
  }
  srrt = srt - (aome + ames) + (amn + akap);
  pkaon = fem::sqrt(
      fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(akap))) / 2.f /
                 amn)) -
      fem::pow2(akap));
  // C use K(bar) + Ca --> Om + eta  xsecn same as  K(bar) + N --> Si + Pi
  // C  as Omega have no resonances
  // C** using same matrix elements as K-bar + N -> Si + pi
  sigomm = 1.5f * (aknpsg(pkaon) + aknpsg(pkaon));
  cmat = sigomm *
         fem::sqrt((fem::pow2(srt) - fem::pow2((amn + akap))) *
                   (fem::pow2(srt) - fem::pow2((amn - akap)))) /
         fem::sqrt((fem::pow2(srt) - fem::pow2((asa + app))) *
                   (fem::pow2(srt) - fem::pow2((asa - app))));
  sigom = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((aome + ames))) *
                    (fem::pow2(srt) - fem::pow2((aome - ames)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((acap + akap))) *
                    (fem::pow2(srt) - fem::pow2((acap - akap))));
  sigpe = 0.f;
  // Clin-2/25/03 disable the perturb option:
  // C         if(iperts .eq. 1) sigpe = 40.   !! perturbative xsecn
  sig = fem::amax1(sigpe, sigom);
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  brpp = sigom / sig;
  // C
  // C else particle production
  if ((lb1 >= 40 && lb1 <= 41) || (lb2 >= 40 && lb2 <= 41)) {
    // C    !! omega
    lbpp1 = 45;
  } else {
    // C elseif(lb1 .eq. -40 .or. lb2 .eq. -40)
    // C    !! omega-bar
    lbpp1 = -45;
  }
  empp1 = aome;
  // C           lbpp2 = 0    !! eta
  // C    !! pion
  lbpp2 = 3 + fem::fint(3 * ranart(nseed));
  empp2 = ames;
  // C
  // C* check real process of omega(bar) and pion formation
  xrand = ranart(nseed);
  if (xrand < (proper(idp) * brpp)) {
    // C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    // C  !! P_Om = P_Cas*Gam
    proper(i1) = proper(idp) * brpp;
    lb(i2) = lbpp2;
    e(i2) = empp2;
    // C   !! pion formed with prob 1.
    proper(i2) = 1.f;
  } else if (xrand < brpp) {
    // C else omega(bar) formed perturbatively and cascade destroyed
    e(idp) = 0.f;
  }
  goto statement_700;
// C
// C-----------------------------------------------------------
// C  for process:  Ca + pi/eta --> K-bar + L(S)
// C
statement_90:
  if (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41) {
    acap = e(i1);
    app = e(i2);
    idp = i1;
    idn = i2;
  } else {
    acap = e(i2);
    app = e(i1);
    idp = i2;
    idn = i1;
  }
  // C            akal = (aka+aks)/2.  !! average of K and K* taken
  // C  !! using K only
  akal = aka;
  // C
  alas = ala;
  if (srt <= (alas + aka)) {
    return;
  }
  srrt = srt - (acap + app) + (amn + aka);
  pkaon = fem::sqrt(
      fem::pow2(
          ((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(aka))) / 2.f / amn)) -
      fem::pow2(aka));
  // C** using same matrix elements as K-bar + N -> La/Si + pi
  sigca = 1.5f * (aknpsg(pkaon) + aknpsg(pkaon));
  cmat = sigca *
         fem::sqrt((fem::pow2(srt) - fem::pow2((amn + aka))) *
                   (fem::pow2(srt) - fem::pow2((amn - aka)))) /
         fem::sqrt((fem::pow2(srt) - fem::pow2((alas + 0.138f))) *
                   (fem::pow2(srt) - fem::pow2((alas - 0.138f))));
  sigca = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((acap + app))) *
                    (fem::pow2(srt) - fem::pow2((acap - app)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((alas + aka))) *
                    (fem::pow2(srt) - fem::pow2((alas - aka))));
  // C    !! pi
  dfr = 1.f / 3.f;
  // C       !! eta
  if (lb(idn) == 0) {
    dfr = 1.f;
  }
  sigcal = sigca * dfr * (fem::pow2(srt) - fem::pow2((alas + aka))) *
           (fem::pow2(srt) - fem::pow2((alas - aka))) /
           (fem::pow2(srt) - fem::pow2((acap + app))) /
           (fem::pow2(srt) - fem::pow2((acap - app)));
  // C
  alas = asa;
  if (srt <= (alas + aka)) {
    sigcas = 0.f;
  } else {
    srrt = srt - (acap + app) + (amn + aka);
    pkaon = fem::sqrt(
        fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(aka))) / 2.f /
                   amn)) -
        fem::pow2(aka));
    // C use K(bar) + La/Si --> Ca + Pi  xsecn same as  K(bar) + N --> Si + Pi
    // C** using same matrix elements as K-bar + N -> La/Si + pi
    sigca = 1.5f * (aknpsg(pkaon) + aknpsg(pkaon));
    cmat = sigca *
           fem::sqrt((fem::pow2(srt) - fem::pow2((amn + aka))) *
                     (fem::pow2(srt) - fem::pow2((amn - aka)))) /
           fem::sqrt((fem::pow2(srt) - fem::pow2((alas + 0.138f))) *
                     (fem::pow2(srt) - fem::pow2((alas - 0.138f))));
    sigca = cmat *
            fem::sqrt((fem::pow2(srt) - fem::pow2((acap + app))) *
                      (fem::pow2(srt) - fem::pow2((acap - app)))) /
            fem::sqrt((fem::pow2(srt) - fem::pow2((alas + aka))) *
                      (fem::pow2(srt) - fem::pow2((alas - aka))));
    // C    !! pi
    dfr = 1.f;
    // C    !! eta
    if (lb(idn) == 0) {
      dfr = 3.f;
    }
    sigcas = sigca * dfr * (fem::pow2(srt) - fem::pow2((alas + aka))) *
             (fem::pow2(srt) - fem::pow2((alas - aka))) /
             (fem::pow2(srt) - fem::pow2((acap + app))) /
             (fem::pow2(srt) - fem::pow2((acap - app)));
  }
  // C
  sig = sigcal + sigcas;
  brpp = 1.f;
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  // C
  // Clin-2/25/03: checking elastic scatt after failure of inelastic scatt gives
  // C     conditional probability (in general incorrect), tell Pal to correct:
  if (ic == -1) {
    // C check for elastic scatt, no particle annhilation
    // C  !! elastic cross section of 20 mb
    ds = fem::sqrt(20.0f / 31.4f);
    dsr = ds + 0.1f;
    distce(cmn, i1, i2, dsr, ds, dt, ec, srt, icsbel, px, py, pz);
    if (icsbel == -1) {
      return;
    }
    empp1 = em1;
    empp2 = em2;
    goto statement_700;
  }
  // C
  // C else pert. produced cascade(bar) is annhilated OR real process
  // C
  // C DECIDE LAMBDA OR SIGMA PRODUCTION
  // C
  if (sigcal / sig > ranart(nseed)) {
    if (lb1 == 40 || lb1 == 41 || lb2 == 40 || lb2 == 41) {
      lbpp1 = 21;
      lbpp2 = 14;
    } else {
      lbpp1 = 23;
      lbpp2 = -14;
    }
    alas = ala;
  } else {
    if (lb1 == 40 || lb1 == 41 || lb2 == 40 || lb2 == 41) {
      lbpp1 = 21;
      lbpp2 = 15 + fem::fint(3 * ranart(nseed));
    } else {
      lbpp1 = 23;
      lbpp2 = -15 - fem::fint(3 * ranart(nseed));
    }
    alas = asa;
  }
  empp1 = aka;
  empp2 = alas;
  // C
  // C check for real process for L/S(bar) and K(bar) formation
  if (ranart(nseed) < proper(idp)) {
    // C real process
    // C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    // C   !! K(bar) formed with prob 1.
    proper(i1) = 1.f;
    lb(i2) = lbpp2;
    e(i2) = empp2;
    // C   !! L/S(bar) formed with prob 1.
    proper(i2) = 1.f;
    goto statement_700;
  } else {
    // C else only cascade(bar) annhilation & go out
    e(idp) = 0.f;
  }
  return;
// C
// C----------------------------------------------------
// C  for process:  Om(bar) + pi --> Cas(bar) + K_bar(K)
// C
statement_110:
  if (lb1 == 45 || lb1 == -45) {
    aomp = e(i1);
    app = e(i2);
    idp = i1;
    idn = i2;
  } else {
    aomp = e(i2);
    app = e(i1);
    idp = i2;
    idn = i1;
  }
  // C            akal = (aka+aks)/2.  !! average of K and K* taken
  // C  !! using K only
  akal = aka;
  if (srt <= (acas + aka)) {
    return;
  }
  srrt = srt - (aome + app) + (amn + aka);
  pkaon = fem::sqrt(
      fem::pow2(
          ((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(aka))) / 2.f / amn)) -
      fem::pow2(aka));
  // C use K(bar) + Ca --> Om + eta  xsecn same as  K(bar) + N --> Si + Pi
  // C** using same matrix elements as K-bar + N -> La/Si + pi
  sigca = 1.5f * (aknpsg(pkaon) + aknpsg(pkaon));
  cmat = sigca *
         fem::sqrt((fem::pow2(srt) - fem::pow2((amn + aka))) *
                   (fem::pow2(srt) - fem::pow2((amn - aka)))) /
         fem::sqrt((fem::pow2(srt) - fem::pow2((asa + 0.138f))) *
                   (fem::pow2(srt) - fem::pow2((asa - 0.138f))));
  sigom = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((aomp + app))) *
                    (fem::pow2(srt) - fem::pow2((aomp - app)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((acas + aka))) *
                    (fem::pow2(srt) - fem::pow2((acas - aka))));
  // C            dfr = 2.    !! eta
  // C    !! pion
  dfr = 2.f / 3.f;
  sigom = sigom * dfr * (fem::pow2(srt) - fem::pow2((acas + aka))) *
          (fem::pow2(srt) - fem::pow2((acas - aka))) /
          (fem::pow2(srt) - fem::pow2((aomp + app))) /
          (fem::pow2(srt) - fem::pow2((aomp - app)));
  // C
  brpp = 1.f;
  ds = fem::sqrt(sigom / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  // C
  // Clin-2/25/03: checking elastic scatt after failure of inelastic scatt gives
  // C     conditional probability (in general incorrect), tell Pal to correct:
  if (ic == -1) {
    // C check for elastic scatt, no particle annhilation
    // C  !! elastic cross section of 20 mb
    ds = fem::sqrt(20.0f / 31.4f);
    dsr = ds + 0.1f;
    distce(cmn, i1, i2, dsr, ds, dt, ec, srt, icsbel, px, py, pz);
    if (icsbel == -1) {
      return;
    }
    empp1 = em1;
    empp2 = em2;
    goto statement_700;
  }
  // C
  // C else pert. produced omega(bar) annhilated  OR real process
  // C annhilate only pert. omega, rest from hijing go out WITHOUT annhil.
  if (lb1 == 45 || lb2 == 45) {
    // C  !! Ca
    lbpp1 = 40 + fem::fint(2 * ranart(nseed));
    // C   !! K-
    lbpp2 = 21;
  } else {
    // C elseif(lb1 .eq. -45 .or. lb2 .eq. -45)
    // C    !! Ca-bar
    lbpp1 = -40 - fem::fint(2 * ranart(nseed));
    // C      !! K+
    lbpp2 = 23;
  }
  empp1 = acas;
  empp2 = aka;
  // C
  // C check for real process for Cas(bar) and K(bar) formation
  if (ranart(nseed) < proper(idp)) {
    // C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    // C   !! P_Cas(bar) = P_Om(bar)
    proper(i1) = proper(idp);
    lb(i2) = lbpp2;
    e(i2) = empp2;
    // C   !! K(bar) formed with prob 1.
    proper(i2) = 1.f;
    // C
  } else {
    // C else Cascade(bar)  produced and Omega(bar) annhilated
    e(idp) = 0.f;
  }
  // C   !! for produced particles
  goto statement_700;
// C
// C-----------------------------------------------------------
statement_700:
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(empp1) - fem::pow2(empp2))) -
        4.0f * fem::pow2((empp1 * empp2));
  if (pr2 <= 0.f) {
    pr2 = 0.00000001f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  // C using isotropic
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  // C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
  if (icont == 0) {
    return;
  }
  // C
  // C LORENTZ-TRANSFORMATION INTO CMS FRAME
  e1cm = fem::sqrt(fem::pow2(empp1) + fem::pow2(px) + fem::pow2(py) +
                   fem::pow2(pz));
  p1beta = px * betax + py * betay + pz * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  ppt11 = betax * transf + px;
  ppt12 = betay * transf + py;
  ppt13 = betaz * transf + pz;
  // C
  // Cc** for elastic scattering update the momentum of pertb particles
  if (icsbel != -1) {
    // C            if(EMpp1 .gt. 0.9)then
    p(1, i1) = ppt11;
    p(2, i1) = ppt12;
    p(3, i1) = ppt13;
    // C            else
    e2cm = fem::sqrt(fem::pow2(empp2) + fem::pow2(px) + fem::pow2(py) +
                     fem::pow2(pz));
    transf = gamma * (-gamma * p1beta / (gamma + 1) + e2cm);
    ppt21 = betax * transf - px;
    ppt22 = betay * transf - py;
    ppt23 = betaz * transf - pz;
    p(1, i2) = ppt21;
    p(2, i2) = ppt22;
    p(3, i2) = ppt23;
    // C            endif
    return;
  }
  // Clin-5/2008:
  // C2008        X01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  // C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  // C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2008
  // C                Xpt=X1+0.5*x01
  // C                Ypt=Y1+0.5*y01
  // C                Zpt=Z1+0.5*z01
  xpt = x1;
  ypt = y1;
  zpt = z1;
  // C
  // C          if(lbpp1 .eq. 45)then
  // C           write(*,*)'II lb1,lb2,lbpp1,empp1,proper(idp),brpp'
  // C           write(*,*)lb1,lb2,lbpp1,empp1,proper(idp),brpp
  // C          endif
  // C
  nnn++;
  propi(nnn, irun) = proper(idp) * brpp;
  lpion(nnn, irun) = lbpp1;
  epion(nnn, irun) = empp1;
  rpion(1, nnn, irun) = xpt;
  rpion(2, nnn, irun) = ypt;
  rpion(3, nnn, irun) = zpt;
  ppion(1, nnn, irun) = ppt11;
  ppion(2, nnn, irun) = ppt12;
  ppion(3, nnn, irun) = ppt13;
  // Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
}

struct crhb_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crhb_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C*********************************
// C  sp 12/08/00                                                         *
void crhb(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crhb);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     PURPOSE:                                                         *
  // C        DEALING WITH hyperon+N(D,N*)->hyp+N(D,N*) elastic PROCESS     *
  // C     NOTE   :                                                         *
  // C
  // C     QUANTITIES:                                                 *
  // C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  // C           SRT      - SQRT OF S                                       *
  // C           IBLOCK   - THE INFORMATION BACK                            *
  // C                     144-> hyp+N(D,N*)->hyp+N(D,N*)
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /input1/
  // Cc      SAVE /RNDF77/
  // C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  // C-----------------------------------------------------------------------
  iblock = 144;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  // C-----------------------------------------------------------------------
  // C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  // C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
}

struct lambar_save {
  float emb;
  float eml;
  float plab;
  float plab2;
  float pthr;

  lambar_save()
      : emb(fem::float0),
        eml(fem::float0),
        plab(fem::float0),
        plab2(fem::float0),
        pthr(fem::float0) {}
};

// C***************************************
// C sp 04/05/01
// C Purpose: lambda-baryon elastic xsection as a functon of their cms energy
void lambar(common& cmn, int const& i1, int const& i2, float const& srt,
            float& siglab) {
  FEM_CMN_SVE(lambar);
  // COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  //
  // SAVE
  float& emb = sve.emb;
  float& eml = sve.eml;
  float& plab = sve.plab;
  float& plab2 = sve.plab2;
  float& pthr = sve.pthr;
  //
  // C  srt    = DSQRT(s) in GeV                                               *
  // C  siglab = lambda-nuclar elastic cross section in mb
  // C         = 12 + 0.43/p_lab**3.3 (mb)
  // C
  // C (2) Calculate p(lab) from srt [GeV], since the formular in the
  // C reference applies only to the case of a p_bar on a proton at rest
  // C Formula used: srt**2=2.*pmass*(pmass+sqrt(pmass**2+plab**2))
  // C****************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // C
  siglab = 1.e-06f;
  if (fem::iabs(lb(i1)) >= 14 && fem::iabs(lb(i1)) <= 17) {
    eml = e(i1);
    emb = e(i2);
  } else {
    eml = e(i2);
    emb = e(i1);
  }
  pthr = fem::pow2(srt) - fem::pow2(eml) - fem::pow2(emb);
  if (pthr > 0.f) {
    plab2 = fem::pow2((pthr / 2.f / emb)) - fem::pow2(eml);
    if (plab2 > 0) {
      plab = fem::sqrt(plab2);
      siglab = 12.f + 0.43f / (fem::pow(plab, 3.3f));
      if (siglab > 200.f) {
        siglab = 200.f;
      }
    }
  }
}

struct distc0_save {
  float bbb;
  float ddd;
  float drbeta;
  float drcm;
  float dxcm;
  float dycm;
  float dzcm;
  float dzz;
  float e1;
  float e2;
  float p1beta;
  float prcm;
  float relvel;
  float transf;

  distc0_save()
      : bbb(fem::float0),
        ddd(fem::float0),
        drbeta(fem::float0),
        drcm(fem::float0),
        dxcm(fem::float0),
        dycm(fem::float0),
        dzcm(fem::float0),
        dzz(fem::float0),
        e1(fem::float0),
        e2(fem::float0),
        p1beta(fem::float0),
        prcm(fem::float0),
        relvel(fem::float0),
        transf(fem::float0) {}
};

// C------------------------------------------------------------------
// Clin-7/26/03 improve speed
// C**************************************
void distc0(common& cmn, float const& drmax, float const& /* deltr0 */,
            float const& dt, int& ifirst, float const& px1cm,
            float const& py1cm, float const& pz1cm, float const& x1,
            float const& y1, float const& z1, float const& px1,
            float const& py1, float const& pz1, float const& em1,
            float const& x2, float const& y2, float const& z2, float const& px2,
            float const& py2, float const& pz2, float const& em2) {
  FEM_CMN_SVE(distc0);
  // COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  //
  // SAVE
  float& bbb = sve.bbb;
  float& ddd = sve.ddd;
  float& drbeta = sve.drbeta;
  float& drcm = sve.drcm;
  float& dxcm = sve.dxcm;
  float& dycm = sve.dycm;
  float& dzcm = sve.dzcm;
  float& dzz = sve.dzz;
  float& e1 = sve.e1;
  float& e2 = sve.e2;
  float& p1beta = sve.p1beta;
  float& prcm = sve.prcm;
  float& relvel = sve.relvel;
  float& transf = sve.transf;
  //
  // C PURPOSE : CHECK IF THE COLLISION BETWEEN TWO PARTICLES CAN HAPPEN
  // C           BY CHECKING
  // C                      (2) IF PARTICLE WILL PASS EACH OTHER WITHIN
  // C           TWO HARD CORE RADIUS.
  // C                      (3) IF PARTICLES WILL GET CLOSER.
  // C VARIABLES :
  // C           Ifirst=1 COLLISION may HAPPENED
  // C           Ifirst=-1 COLLISION CAN NOT HAPPEN
  // C****************************************
  // Cc      SAVE /BG/
  ifirst = -1;
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  // CNOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
  e2 = fem::sqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                 fem::pow2(pz2));
  // CNOW THERE IS ENOUGH ENERGY AVAILABLE !
  // CLORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
  // C BETAX, BETAY, BETAZ AND GAMMA HAVE BEEN GIVEN IN THE SUBROUTINE CMS
  // CTRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
  p1beta = px1 * betax + py1 * betay + pz1 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) - e1);
  prcm = fem::sqrt(fem::pow2(px1cm) + fem::pow2(py1cm) + fem::pow2(pz1cm));
  if (prcm <= 0.00001f) {
    return;
  }
  // CTRANSFORMATION OF SPATIAL DISTANCE
  drbeta = betax * (x1 - x2) + betay * (y1 - y2) + betaz * (z1 - z2);
  transf = gamma * gamma * drbeta / (gamma + 1);
  dxcm = betax * transf + x1 - x2;
  dycm = betay * transf + y1 - y2;
  dzcm = betaz * transf + z1 - z2;
  // CDETERMINING IF THIS IS THE POINT OF CLOSEST APPROACH
  drcm = fem::sqrt(fem::pow2(dxcm) + fem::pow2(dycm) + fem::pow2(dzcm));
  dzz = (px1cm * dxcm + py1cm * dycm + pz1cm * dzcm) / prcm;
  if ((fem::pow2(drcm) - fem::pow2(dzz)) <= 0.f) {
    bbb = 0.f;
  } else {
    bbb = fem::sqrt(fem::pow2(drcm) - fem::pow2(dzz));
  }
  // CWILL PARTICLE PASS EACH OTHER WITHIN 2 * HARD CORE RADIUS ?
  if (bbb > drmax) {
    return;
  }
  relvel = prcm * (1.0f / e1 + 1.0f / e2);
  ddd = relvel * dt * 0.5f;
  // CWILL PARTICLES GET CLOSER ?
  if (fem::abs(ddd) < fem::abs(dzz)) {
    return;
  }
  ifirst = 1;
}

// C
// C     Cross section of Deuteron+Pi elastic (in mb):
float fdpiel(float const& s) {
  float return_value = fem::float0;
  const float srt0 = 2.012f;
  if (s <= fem::pow2(srt0)) {
    return_value = 0.f;
  } else {
    return_value = 63.f * fem::exp(-fem::pow2((s - 4.67f)) / 0.15f) +
                   15.f * fem::exp(-fem::pow2((s - 6.25f)) / 0.3f);
  }
  return return_value;
}

struct sdmbb_save {
  float fs;
  float pfinal;
  float pinitial;
  float s;
  float snew;
  float threshold;
  float xnnfactor;

  sdmbb_save()
      : fs(fem::float0),
        pfinal(fem::float0),
        pinitial(fem::float0),
        s(fem::float0),
        snew(fem::float0),
        threshold(fem::float0),
        xnnfactor(fem::float0) {}
};

// C
// C     Deuteron+Meson->B+B cross section (in mb)
void sdmbb(common& cmn, float const& srt, float& sdm, int const& ianti) {
  FEM_CMN_SVE(sdmbb);
  // COMMON leadng
  int& lb1 = cmn.lb1;
  float& em1 = cmn.em1;
  // COMMON dpi
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  // COMMON dpifsl
  int& lbnn1 = cmn.lbnn1;
  int& lbnn2 = cmn.lbnn2;
  int& lbnd1 = cmn.lbnd1;
  int& lbnd2 = cmn.lbnd2;
  int& lbns1 = cmn.lbns1;
  int& lbns2 = cmn.lbns2;
  int& lbnp1 = cmn.lbnp1;
  int& lbnp2 = cmn.lbnp2;
  int& lbdd1 = cmn.lbdd1;
  int& lbdd2 = cmn.lbdd2;
  int& lbds1 = cmn.lbds1;
  int& lbds2 = cmn.lbds2;
  int& lbdp1 = cmn.lbdp1;
  int& lbdp2 = cmn.lbdp2;
  int& lbss1 = cmn.lbss1;
  int& lbss2 = cmn.lbss2;
  int& lbsp1 = cmn.lbsp1;
  int& lbsp2 = cmn.lbsp2;
  int& lbpp1 = cmn.lbpp1;
  int& lbpp2 = cmn.lbpp2;
  // COMMON dpifsm
  float& xmnn1 = cmn.xmnn1;
  float& xmnn2 = cmn.xmnn2;
  float& xmnd1 = cmn.xmnd1;
  float& xmnd2 = cmn.xmnd2;
  float& xmns1 = cmn.xmns1;
  float& xmns2 = cmn.xmns2;
  float& xmnp1 = cmn.xmnp1;
  float& xmnp2 = cmn.xmnp2;
  float& xmdd1 = cmn.xmdd1;
  float& xmdd2 = cmn.xmdd2;
  float& xmds1 = cmn.xmds1;
  float& xmds2 = cmn.xmds2;
  float& xmdp1 = cmn.xmdp1;
  float& xmdp2 = cmn.xmdp2;
  float& xmss1 = cmn.xmss1;
  float& xmss2 = cmn.xmss2;
  float& xmsp1 = cmn.xmsp1;
  float& xmsp2 = cmn.xmsp2;
  float& xmpp1 = cmn.xmpp1;
  float& xmpp2 = cmn.xmpp2;
  // COMMON dpisig
  float& sdmel = cmn.sdmel;
  float& sdmnn = cmn.sdmnn;
  float& sdmnd = cmn.sdmnd;
  float& sdmns = cmn.sdmns;
  float& sdmnp = cmn.sdmnp;
  float& sdmdd = cmn.sdmdd;
  float& sdmds = cmn.sdmds;
  float& sdmdp = cmn.sdmdp;
  float& sdmss = cmn.sdmss;
  float& sdmsp = cmn.sdmsp;
  float& sdmpp = cmn.sdmpp;
  // COMMON para8
  int& idxsec = cmn.idxsec;
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& fs = sve.fs;
  float& pfinal = sve.pfinal;
  float& pinitial = sve.pinitial;
  float& s = sve.s;
  float& snew = sve.snew;
  float& threshold = sve.threshold;
  float& xnnfactor = sve.xnnfactor;
  //
  // C
  sdm = 0.f;
  sdmel = 0.f;
  sdmnn = 0.f;
  sdmnd = 0.f;
  sdmns = 0.f;
  sdmnp = 0.f;
  sdmdd = 0.f;
  sdmds = 0.f;
  sdmdp = 0.f;
  sdmss = 0.f;
  sdmsp = 0.f;
  sdmpp = 0.f;
  // Ctest off check Xsec using fixed mass for resonances:
  // C      if(lb1.ge.25.and.lb1.le.27) then
  // C         em1=0.776
  // C      elseif(lb1.eq.28) then
  // C         em1=0.783
  // C      elseif(lb1.eq.0) then
  // C         em1=0.548
  // C      endif
  // C      if(lb2.ge.25.and.lb2.le.27) then
  // C         em2=0.776
  // C      elseif(lb2.eq.28) then
  // C         em2=0.783
  // C      elseif(lb2.eq.0) then
  // C         em2=0.548
  // C      endif
  // C
  if (srt <= (em1 + em2)) {
    return;
  }
  s = fem::pow2(srt);
  pinitial =
      fem::sqrt((s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)))) /
      2.f / srt;
  fs = fnndpi(s);
  // C     Determine isospin and spin factors for the ratio between
  // C     Deuteron+Meson->BB and BB->Deuteron+Meson cross sections:
  if (idxsec == 1 || idxsec == 2) {
    // C     Assume B+B -> d+Meson has the same cross sections as N+N -> d+pi,
    // C     then determine d+Meson -> B+B cross sections:
    if ((lb1 >= 3 && lb1 <= 5) || (lb2 >= 3 && lb2 <= 5)) {
      xnnfactor = 8.f / 9.f;
    } else if ((lb1 >= 25 && lb1 <= 27) || (lb2 >= 25 && lb2 <= 27)) {
      xnnfactor = 8.f / 27.f;
    } else if (lb1 == 28 || lb2 == 28) {
      xnnfactor = 8.f / 9.f;
    } else if (lb1 == 0 || lb2 == 0) {
      xnnfactor = 8.f / 3.f;
    }
  } else {
    // C     Assume d+Meson -> B+B has the same cross sections as d+pi -> N+N:
  }
  // Clin-9/2008 For elastic collisions:
  const float srt0 = 2.012f;
  if (idxsec == 1 || idxsec == 3) {
    // C     1/3: assume the same |matrix element|**2/s (after averaging over
    // initial C     spins and isospins) for d+Meson elastic at the same sqrt(s);
    sdmel = fdpiel(s);
  } else if (idxsec == 2 || idxsec == 4) {
    // C     2/4: assume the same |matrix element|**2/s (after averaging over
    // initial C     spins and isospins) for d+Meson elastic at the same
    // sqrt(s)-threshold:
    threshold = em1 + em2;
    snew = fem::pow2((srt - threshold + srt0));
    sdmel = fdpiel(snew);
  }
  // C
  // C     NN: DETERMINE THE CHARGE STATES OF PARTICLESIN THE FINAL STATE
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  if (((lb1 == 5 || lb2 == 5 || lb1 == 27 || lb2 == 27) && ianti == 0) ||
      ((lb1 == 3 || lb2 == 3 || lb1 == 25 || lb2 == 25) && ianti == 1)) {
    // C     (1) FOR Deuteron+(pi+,rho+) -> P+P or DeuteronBar+(pi-,rho-)->
    // PBar+PBar:
    lbnn1 = 1;
    lbnn2 = 1;
    xmnn1 = amp;
    xmnn2 = amp;
  } else if (lb1 == 3 || lb2 == 3 || lb1 == 26 || lb2 == 26 || lb1 == 28 ||
             lb2 == 28 || lb1 == 0 || lb2 == 0) {
    // C     (2) FOR Deuteron+(pi0,rho0,omega,eta) -> N+P
    // C     or DeuteronBar+(pi0,rho0,omega,eta) ->NBar+PBar:
    lbnn1 = 2;
    lbnn2 = 1;
    xmnn1 = amn;
    xmnn2 = amp;
  } else {
    // C     (3) FOR Deuteron+(pi-,rho-) -> N+N or DeuteronBar+(pi+,rho+)->
    // NBar+NBar:
    lbnn1 = 2;
    lbnn2 = 2;
    xmnn1 = amn;
    xmnn2 = amn;
  }
  if (srt > (xmnn1 + xmnn2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmnn1 + xmnn2))) *
                       (s - fem::pow2((xmnn1 - xmnn2)))) /
             2.f / srt;
    if (idxsec == 1) {
      // C     1: assume the same |matrix element|**2/s (after averaging over
      // initial C     spins and isospins) for B+B -> deuteron+meson at the same
      // sqrt(s);
      sdmnn = fs * pfinal / pinitial * 3.f / 16.f * xnnfactor;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmnn1 + xmnn2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        // C     2: assume the same |matrix element|**2/s for B+B ->
        // deuteron+meson C     at the same sqrt(s)-threshold:
        sdmnn = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * xnnfactor;
      } else if (idxsec == 4) {
        // C     4: assume the same |matrix element|**2/s for B+B <-
        // deuteron+meson C     at the same sqrt(s)-threshold:
        sdmnn = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      // C     3: assume the same |matrix element|**2/s for B+B <-
      // deuteron+meson C     at the same sqrt(s):
      sdmnn = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     ND: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbnd1 = 1 + fem::fint(2 * ranart(nseed));
  lbnd2 = 6 + fem::fint(4 * ranart(nseed));
  if (lbnd1 == 1) {
    xmnd1 = amp;
  } else if (lbnd1 == 2) {
    xmnd1 = amn;
  }
  const float am0 = 1.232f;
  xmnd2 = am0;
  if (srt > (xmnd1 + xmnd2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmnd1 + xmnd2))) *
                       (s - fem::pow2((xmnd1 - xmnd2)))) /
             2.f / srt;
    if (idxsec == 1) {
      // C     The spin- and isospin-averaged factor is 8-times larger for ND:
      sdmnd = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmnd1 + xmnd2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmnd =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
      } else if (idxsec == 4) {
        sdmnd = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmnd = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     NS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbns1 = 1 + fem::fint(2 * ranart(nseed));
  lbns2 = 10 + fem::fint(2 * ranart(nseed));
  if (lbns1 == 1) {
    xmns1 = amp;
  } else if (lbns1 == 2) {
    xmns1 = amn;
  }
  const float am1440 = 1.44f;
  xmns2 = am1440;
  if (srt > (xmns1 + xmns2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmns1 + xmns2))) *
                       (s - fem::pow2((xmns1 - xmns2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmns = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmns1 + xmns2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmns =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
      } else if (idxsec == 4) {
        sdmns = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmns = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     NP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbnp1 = 1 + fem::fint(2 * ranart(nseed));
  lbnp2 = 12 + fem::fint(2 * ranart(nseed));
  if (lbnp1 == 1) {
    xmnp1 = amp;
  } else if (lbnp1 == 2) {
    xmnp1 = amn;
  }
  const float am1535 = 1.535f;
  xmnp2 = am1535;
  if (srt > (xmnp1 + xmnp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmnp1 + xmnp2))) *
                       (s - fem::pow2((xmnp1 - xmnp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmnp = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmnp1 + xmnp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmnp =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
      } else if (idxsec == 4) {
        sdmnp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmnp = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     DD: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbdd1 = 6 + fem::fint(4 * ranart(nseed));
  lbdd2 = 6 + fem::fint(4 * ranart(nseed));
  xmdd1 = am0;
  xmdd2 = am0;
  if (srt > (xmdd1 + xmdd2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmdd1 + xmdd2))) *
                       (s - fem::pow2((xmdd1 - xmdd2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmdd = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 16.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmdd1 + xmdd2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmdd =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 16.f);
      } else if (idxsec == 4) {
        sdmdd = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmdd = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     DS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbds1 = 6 + fem::fint(4 * ranart(nseed));
  lbds2 = 10 + fem::fint(2 * ranart(nseed));
  xmds1 = am0;
  xmds2 = am1440;
  if (srt > (xmds1 + xmds2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmds1 + xmds2))) *
                       (s - fem::pow2((xmds1 - xmds2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmds = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmds1 + xmds2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmds =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
      } else if (idxsec == 4) {
        sdmds = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmds = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     DP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbdp1 = 6 + fem::fint(4 * ranart(nseed));
  lbdp2 = 12 + fem::fint(2 * ranart(nseed));
  xmdp1 = am0;
  xmdp2 = am1535;
  if (srt > (xmdp1 + xmdp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmdp1 + xmdp2))) *
                       (s - fem::pow2((xmdp1 - xmdp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmdp = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmdp1 + xmdp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmdp =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
      } else if (idxsec == 4) {
        sdmdp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmdp = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     SS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbss1 = 10 + fem::fint(2 * ranart(nseed));
  lbss2 = 10 + fem::fint(2 * ranart(nseed));
  xmss1 = am1440;
  xmss2 = am1440;
  if (srt > (xmss1 + xmss2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmss1 + xmss2))) *
                       (s - fem::pow2((xmss1 - xmss2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmss = fs * pfinal / pinitial * 3.f / 16.f * xnnfactor;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmss1 + xmss2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmss = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * xnnfactor;
      } else if (idxsec == 4) {
        sdmss = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmns = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     SP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbsp1 = 10 + fem::fint(2 * ranart(nseed));
  lbsp2 = 12 + fem::fint(2 * ranart(nseed));
  xmsp1 = am1440;
  xmsp2 = am1535;
  if (srt > (xmsp1 + xmsp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmsp1 + xmsp2))) *
                       (s - fem::pow2((xmsp1 - xmsp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmsp = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmsp1 + xmsp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmsp =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
      } else if (idxsec == 4) {
        sdmsp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmsp = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  // C     PP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbpp1 = 12 + fem::fint(2 * ranart(nseed));
  lbpp2 = 12 + fem::fint(2 * ranart(nseed));
  xmpp1 = am1535;
  xmpp2 = am1535;
  if (srt > (xmpp1 + xmpp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmpp1 + xmpp2))) *
                       (s - fem::pow2((xmpp1 - xmpp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmpp = fs * pfinal / pinitial * 3.f / 16.f * xnnfactor;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmpp1 + xmpp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmpp = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * xnnfactor;
      } else if (idxsec == 4) {
        sdmpp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmpp = fs * pfinal / pinitial / 6.f;
    }
  }
  // C
  sdm = sdmel + sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp + sdmss +
        sdmsp + sdmpp;
  if (ianti == 1) {
    lbnn1 = -lbnn1;
    lbnn2 = -lbnn2;
    lbnd1 = -lbnd1;
    lbnd2 = -lbnd2;
    lbns1 = -lbns1;
    lbns2 = -lbns2;
    lbnp1 = -lbnp1;
    lbnp2 = -lbnp2;
    lbdd1 = -lbdd1;
    lbdd2 = -lbdd2;
    lbds1 = -lbds1;
    lbds2 = -lbds2;
    lbdp1 = -lbdp1;
    lbdp2 = -lbdp2;
    lbss1 = -lbss1;
    lbss2 = -lbss2;
    lbsp1 = -lbsp1;
    lbsp2 = -lbsp2;
    lbpp1 = -lbpp1;
    lbpp2 = -lbpp2;
  }
  // Ctest off
  // C      write(98,100) srt,sdmnn,sdmnd,sdmns,sdmnp,sdmdd,sdmds,sdmdp,
  // C     1     sdmss,sdmsp,sdmpp,sdm
  // C 100  format(f5.2,11(1x,f5.1))
  // C
}

struct dmangle_save {
  float c1;
  float ct1;
  float s1;
  float st1;
  float t1;

  dmangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C
// C     Generate angular distribution of BB from d+meson in the CMS frame:
void dmangle(common& cmn, float& pxn, float& pyn, float& pzn, int const& nt,
             int const& ianti, float const& pfinal, int const& lbm) {
  FEM_CMN_SVE(dmangle);
  common_write write(cmn);
  // COMMON leadng
  int& lb1 = cmn.lb1;
  // COMMON dpi
  int& lb2 = cmn.lb2;
  // COMMON arevt
  int& iaevt = cmn.iaevt;
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzn = pfinal * c1;
  pxn = pfinal * s1 * ct1;
  pyn = pfinal * s1 * st1;
  // Clin-5/2008 track the number of regularly-destructed deuterons:
  if (ianti == 0) {
    write(91, star), " d+", lbm, " ->BB (regular d destrn) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  } else {
    write(91, star), " d+", lbm, " ->BB (regular dbar destrn) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  }
  // C
}

struct dmelangle_save {
  float c1;
  float ct1;
  float s1;
  float st1;
  float t1;

  dmelangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C
// C     Angular distribution of d+meson elastic collisions in the CMS frame:
void dmelangle(common& cmn, float& pxn, float& pyn, float& pzn,
               float const& pfinal) {
  FEM_CMN_SVE(dmelangle);
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzn = pfinal * c1;
  pxn = pfinal * s1 * ct1;
  pyn = pfinal * s1 * st1;
}

struct crdmbb_save {
  float e1cm;
  float e2cm;
  float edcm;
  int ideut;
  int idm;
  int lbb1;
  int lbb2;
  int lbm;
  float p1beta;
  float p2beta;
  float pdbeta;
  float pfinal;
  float pt1d;
  float pt1i1;
  float pt1i2;
  float pt2d;
  float pt2i1;
  float pt2i2;
  float pt3d;
  float pt3i1;
  float pt3i2;
  float pxn;
  float pyn;
  float pzn;
  float s;
  float scheck;
  float transf;
  float x1;
  float xmb1;
  float xmb2;

  crdmbb_save()
      : e1cm(fem::float0),
        e2cm(fem::float0),
        edcm(fem::float0),
        ideut(fem::int0),
        idm(fem::int0),
        lbb1(fem::int0),
        lbb2(fem::int0),
        lbm(fem::int0),
        p1beta(fem::float0),
        p2beta(fem::float0),
        pdbeta(fem::float0),
        pfinal(fem::float0),
        pt1d(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2d(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3d(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        pxn(fem::float0),
        pyn(fem::float0),
        pzn(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        transf(fem::float0),
        x1(fem::float0),
        xmb1(fem::float0),
        xmb2(fem::float0) {}
};

// C
// Clin-9/2008 Deuteron+Meson ->B+B and elastic collisions
void crdmbb(common& cmn, float const& px, float const& py, float const& pz,
            float const& srt, int const& i1, int const& i2, int& iblock,
            int& ntag, float const& sig, int const& nt, int const& ianti) {
  FEM_CMN_SVE(crdmbb);
  common_write write(cmn);
  // COMMON aa
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  // COMMON bb
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  // COMMON cc
  arr_ref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  // COMMON arevt
  int& iaevt = cmn.iaevt;
  // COMMON leadng
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  // COMMON dpi
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  // COMMON para8
  int& idpert = cmn.idpert;
  // COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  // COMMON dpisig
  float& sdmnn = cmn.sdmnn;
  float& sdmnd = cmn.sdmnd;
  float& sdmns = cmn.sdmns;
  float& sdmnp = cmn.sdmnp;
  float& sdmdd = cmn.sdmdd;
  float& sdmds = cmn.sdmds;
  float& sdmdp = cmn.sdmdp;
  float& sdmss = cmn.sdmss;
  float& sdmsp = cmn.sdmsp;
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& edcm = sve.edcm;
  int& ideut = sve.ideut;
  int& idm = sve.idm;
  int& lbb1 = sve.lbb1;
  int& lbb2 = sve.lbb2;
  int& lbm = sve.lbm;
  float& p1beta = sve.p1beta;
  float& p2beta = sve.p2beta;
  float& pdbeta = sve.pdbeta;
  float& pfinal = sve.pfinal;
  float& pt1d = sve.pt1d;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2d = sve.pt2d;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3d = sve.pt3d;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxn = sve.pxn;
  float& pyn = sve.pyn;
  float& pzn = sve.pzn;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& transf = sve.transf;
  float& x1 = sve.x1;
  float& xmb1 = sve.xmb1;
  float& xmb2 = sve.xmb2;
  //
  // C-----------------------------------------------------------------------
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  s = fem::pow2(srt);
  if (sig <= 0) {
    return;
  }
  // C
  if (fem::iabs(lb1) == 42) {
    ideut = i1;
    lbm = lb2;
    idm = i2;
  } else {
    ideut = i2;
    lbm = lb1;
    idm = i1;
  }
  // Cccc  Elastic collision or destruction of perturbatively-produced
  // deuterons:
  if ((idpert == 1 || idpert == 2) && dpertp(ideut) != 1.f) {
    // C     choose reaction channels:
    x1 = ranart(nseed);
    if (x1 <= cmn.sdmel / sig) {
      // C     Elastic collisions:
      if (ianti == 0) {
        write(91, star), "  d+", lbm, " (pert d M elastic) @nt=", nt,
            " @prob=", dpertp(ideut);
      } else {
        write(91, star), "  d+", lbm, " (pert dbar M elastic) @nt=", nt,
            " @prob=", dpertp(ideut);
      }
      // C
      // Clin-9/2012: check argument in sqrt():
      scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
      if (scheck < 0) {
        write(99, star), "scheck51: ", scheck;
        scheck = 0.f;
      }
      pfinal = fem::sqrt(scheck) / 2.f / srt;
      // C            pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
      // C
      dmelangle(cmn, pxn, pyn, pzn, pfinal);
      rotate(cmn, px, py, pz, pxn, pyn, pzn);
      edcm = fem::sqrt(fem::pow2(e(ideut)) + fem::pow2(pxn) + fem::pow2(pyn) +
                       fem::pow2(pzn));
      pdbeta = pxn * betax + pyn * betay + pzn * betaz;
      transf = gamma * (gamma * pdbeta / (gamma + 1.f) + edcm);
      pt1d = betax * transf + pxn;
      pt2d = betay * transf + pyn;
      pt3d = betaz * transf + pzn;
      p(1, ideut) = pt1d;
      p(2, ideut) = pt2d;
      p(3, ideut) = pt3d;
      iblock = 504;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      id(i1) = 2;
      id(i2) = 2;
      // C     Change the position of the perturbative deuteron to that of
      // C     the meson to avoid consecutive collisions between them:
      r(1, ideut) = r(1, idm);
      r(2, ideut) = r(2, idm);
      r(3, ideut) = r(3, idm);
    } else {
      // C     Destruction of deuterons:
      if (ianti == 0) {
        write(91, star), "  d+", lbm, " ->BB (pert d destrn) @nt=", nt,
            " @prob=", dpertp(ideut);
      } else {
        write(91, star), "  d+", lbm, " ->BB (pert dbar destrn) @nt=", nt,
            " @prob=", dpertp(ideut);
      }
      e(ideut) = 0.f;
      iblock = 502;
    }
    return;
  }
  // C
  // Cccc  Destruction of regularly-produced deuterons:
  iblock = 502;
  // C     choose final state and assign masses here:
  x1 = ranart(nseed);
  if (x1 <= sdmnn / sig) {
    lbb1 = cmn.lbnn1;
    lbb2 = cmn.lbnn2;
    xmb1 = cmn.xmnn1;
    xmb2 = cmn.xmnn2;
  } else if (x1 <= (sdmnn + sdmnd) / sig) {
    lbb1 = cmn.lbnd1;
    lbb2 = cmn.lbnd2;
    xmb1 = cmn.xmnd1;
    xmb2 = cmn.xmnd2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns) / sig) {
    lbb1 = cmn.lbns1;
    lbb2 = cmn.lbns2;
    xmb1 = cmn.xmns1;
    xmb2 = cmn.xmns2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp) / sig) {
    lbb1 = cmn.lbnp1;
    lbb2 = cmn.lbnp2;
    xmb1 = cmn.xmnp1;
    xmb2 = cmn.xmnp2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd) / sig) {
    lbb1 = cmn.lbdd1;
    lbb2 = cmn.lbdd2;
    xmb1 = cmn.xmdd1;
    xmb2 = cmn.xmdd2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds) / sig) {
    lbb1 = cmn.lbds1;
    lbb2 = cmn.lbds2;
    xmb1 = cmn.xmds1;
    xmb2 = cmn.xmds2;
  } else if (x1 <=
             (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp) / sig) {
    lbb1 = cmn.lbdp1;
    lbb2 = cmn.lbdp2;
    xmb1 = cmn.xmdp1;
    xmb2 = cmn.xmdp2;
  } else if (x1 <=
             (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp + sdmss) /
                 sig) {
    lbb1 = cmn.lbss1;
    lbb2 = cmn.lbss2;
    xmb1 = cmn.xmss1;
    xmb2 = cmn.xmss2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp +
                    sdmss + sdmsp) /
                       sig) {
    lbb1 = cmn.lbsp1;
    lbb2 = cmn.lbsp2;
    xmb1 = cmn.xmsp1;
    xmb2 = cmn.xmsp2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp +
                    sdmss + sdmsp + cmn.sdmpp) /
                       sig) {
    lbb1 = cmn.lbpp1;
    lbb2 = cmn.lbpp2;
    xmb1 = cmn.xmpp1;
    xmb2 = cmn.xmpp2;
  } else {
    // C     Elastic collision:
    lbb1 = lb1;
    lbb2 = lb2;
    xmb1 = em1;
    xmb2 = em2;
    iblock = 504;
  }
  lb(i1) = lbb1;
  e(i1) = xmb1;
  lb(i2) = lbb2;
  e(i2) = xmb2;
  lb1 = lb(i1);
  lb2 = lb(i2);
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((xmb1 + xmb2))) * (s - fem::pow2((xmb1 - xmb2)));
  if (scheck < 0) {
    write(99, star), "scheck52: ", scheck;
    scheck = 0.f;
  }
  pfinal = fem::sqrt(scheck) / 2.f / srt;
  // C      pfinal=sqrt((s-(xmb1+xmb2)**2)*(s-(xmb1-xmb2)**2))/2./srt
  // C
  if (iblock == 502) {
    dmangle(cmn, pxn, pyn, pzn, nt, ianti, pfinal, lbm);
  } else if (iblock == 504) {
    if (ianti == 0) {
      write(91, star), " d+", lbm, " (regular d M elastic) @evt#", iaevt,
          " @nt=", nt, " lb1,2=", lb1, lb2;
    } else {
      write(91, star), " d+", lbm, " (regular dbar M elastic) @evt#", iaevt,
          " @nt=", nt, " lb1,2=", lb1, lb2;
    }
    dmelangle(cmn, pxn, pyn, pzn, pfinal);
  } else {
    write(6, star), "Wrong iblock number in crdmbb()";
    FEM_STOP(0);
  }
  // C     ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  // C     (This is not needed for isotropic distributions)
  rotate(cmn, px, py, pz, pxn, pyn, pzn);
  // C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
  // STATE C     FROM THE NUCLEUS-NUCLEUS CMS. FRAME INTO LAB FRAME: C     For
  // the 1st baryon:
  e1cm = fem::sqrt(fem::pow2(e(i1)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p1beta = pxn * betax + pyn * betay + pzn * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1.f) + e1cm);
  pt1i1 = betax * transf + pxn;
  pt2i1 = betay * transf + pyn;
  pt3i1 = betaz * transf + pzn;
  // C
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  // C     For the 2nd baryon:
  e2cm = fem::sqrt(fem::pow2(e(i2)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p2beta = -pxn * betax - pyn * betay - pzn * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf - pxn;
  pt2i2 = betay * transf - pyn;
  pt3i2 = betaz * transf - pzn;
  // C
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  // C
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  em2 = e(i2);
  id(i1) = 2;
  id(i2) = 2;
}

// C
// C     Cross section of Deuteron+N elastic (in mb):
float fdbel(float const& s) {
  float return_value = fem::float0;
  const float srt0 = 2.012f;
  if (s <= fem::pow2(srt0)) {
    return_value = 0.f;
  } else {
    return_value = 2500.f * fem::exp(-fem::pow2((s - 7.93f)) / 0.003f) +
                   300.f * fem::exp(-fem::pow2((s - 7.93f)) / 0.1f) + 10.f;
  }
  return return_value;
}

struct sdbelastic_save {
  float s;
  float sdbel;
  float snew;
  float threshold;

  sdbelastic_save()
      : s(fem::float0),
        sdbel(fem::float0),
        snew(fem::float0),
        threshold(fem::float0) {}
};

// C
// Clin-9/2008 Deuteron+Baryon elastic cross section (in mb)
void sdbelastic(common& cmn, float const& srt, float& sdb) {
  FEM_CMN_SVE(sdbelastic);
  // COMMON leadng
  float& em1 = cmn.em1;
  // COMMON dpi
  float& em2 = cmn.em2;
  // COMMON para8
  int& idxsec = cmn.idxsec;
  //
  // SAVE
  float& s = sve.s;
  float& sdbel = sve.sdbel;
  float& snew = sve.snew;
  float& threshold = sve.threshold;
  //
  // C
  sdb = 0.f;
  sdbel = 0.f;
  if (srt <= (em1 + em2)) {
    return;
  }
  s = fem::pow2(srt);
  // C     For elastic collisions:
  const float srt0 = 2.012f;
  if (idxsec == 1 || idxsec == 3) {
    // C     1/3: assume the same |matrix element|**2/s (after averaging over
    // initial C     spins and isospins) for d+Baryon elastic at the same
    // sqrt(s);
    sdbel = fdbel(s);
  } else if (idxsec == 2 || idxsec == 4) {
    // C     2/4: assume the same |matrix element|**2/s (after averaging over
    // initial C     spins and isospins) for d+Baryon elastic at the same
    // sqrt(s)-threshold:
    threshold = em1 + em2;
    snew = fem::pow2((srt - threshold + srt0));
    sdbel = fdbel(snew);
  }
  sdb = sdbel;
}

struct dbelangle_save {
  float c1;
  float ct1;
  float s1;
  float st1;
  float t1;

  dbelangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

// C
// C     Angular distribution of d+baryon elastic collisions in the CMS frame:
void dbelangle(common& cmn, float& pxn, float& pyn, float& pzn,
               float const& pfinal) {
  FEM_CMN_SVE(dbelangle);
  // COMMON rndf77
  int& nseed = cmn.nseed;
  //
  // SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  //
  // C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  // C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzn = pfinal * c1;
  pxn = pfinal * s1 * ct1;
  pyn = pfinal * s1 * st1;
}

struct crdbel_save {
  float e1cm;
  float e2cm;
  float edcm;
  int idb;
  int ideut;
  int lbb;
  float p1beta;
  float p2beta;
  float pdbeta;
  float pfinal;
  float pt1d;
  float pt1i1;
  float pt1i2;
  float pt2d;
  float pt2i1;
  float pt2i2;
  float pt3d;
  float pt3i1;
  float pt3i2;
  float pxn;
  float pyn;
  float pzn;
  float s;
  float scheck;
  float transf;

  crdbel_save()
      : e1cm(fem::float0),
        e2cm(fem::float0),
        edcm(fem::float0),
        idb(fem::int0),
        ideut(fem::int0),
        lbb(fem::int0),
        p1beta(fem::float0),
        p2beta(fem::float0),
        pdbeta(fem::float0),
        pfinal(fem::float0),
        pt1d(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2d(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3d(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        pxn(fem::float0),
        pyn(fem::float0),
        pzn(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        transf(fem::float0) {}
};

// Clin-9/2008 Deuteron+Baryon elastic collisions
void crdbel(common& cmn, float const& px, float const& py, float const& pz,
            float const& srt, int const& i1, int const& i2, int& iblock,
            int& ntag, float const& sig, int const& nt, int const& ianti) {
  FEM_CMN_SVE(crdbel);
  common_write write(cmn);
  // COMMON aa
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  // COMMON bb
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  // COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  // COMMON cc
  arr_cref<float> e(cmn.e, dimension(maxstr));
  // COMMON ee
  arr_ref<int> id(cmn.id, dimension(maxstr));
  // COMMON arevt
  int& iaevt = cmn.iaevt;
  // COMMON leadng
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  // COMMON dpi
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  // COMMON para8
  int& idpert = cmn.idpert;
  // COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  //
  // SAVE
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& edcm = sve.edcm;
  int& idb = sve.idb;
  int& ideut = sve.ideut;
  int& lbb = sve.lbb;
  float& p1beta = sve.p1beta;
  float& p2beta = sve.p2beta;
  float& pdbeta = sve.pdbeta;
  float& pfinal = sve.pfinal;
  float& pt1d = sve.pt1d;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2d = sve.pt2d;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3d = sve.pt3d;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxn = sve.pxn;
  float& pyn = sve.pyn;
  float& pzn = sve.pzn;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& transf = sve.transf;
  //
  // C-----------------------------------------------------------------------
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  s = fem::pow2(srt);
  if (sig <= 0) {
    return;
  }
  iblock = 503;
  // C
  if (fem::iabs(lb1) == 42) {
    ideut = i1;
    lbb = lb2;
    idb = i2;
  } else {
    ideut = i2;
    lbb = lb1;
    idb = i1;
  }
  // Cccc  Elastic collision of perturbatively-produced deuterons:
  if ((idpert == 1 || idpert == 2) && dpertp(ideut) != 1.f) {
    if (ianti == 0) {
      write(91, star), "  d+", lbb, " (pert d B elastic) @nt=", nt,
          " @prob=", dpertp(ideut), p(1, idb), p(2, idb), p(1, ideut),
          p(2, ideut);
    } else {
      write(91, star), "  d+", lbb, " (pert dbar Bbar elastic) @nt=", nt,
          " @prob=", dpertp(ideut), p(1, idb), p(2, idb), p(1, ideut),
          p(2, ideut);
    }
    // C
    // Clin-9/2012: check argument in sqrt():
    scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
    if (scheck < 0) {
      write(99, star), "scheck53: ", scheck;
      scheck = 0.f;
    }
    pfinal = fem::sqrt(scheck) / 2.f / srt;
    // C         pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
    // C
    dbelangle(cmn, pxn, pyn, pzn, pfinal);
    rotate(cmn, px, py, pz, pxn, pyn, pzn);
    edcm = fem::sqrt(fem::pow2(e(ideut)) + fem::pow2(pxn) + fem::pow2(pyn) +
                     fem::pow2(pzn));
    pdbeta = pxn * betax + pyn * betay + pzn * betaz;
    transf = gamma * (gamma * pdbeta / (gamma + 1.f) + edcm);
    pt1d = betax * transf + pxn;
    pt2d = betay * transf + pyn;
    pt3d = betaz * transf + pzn;
    p(1, ideut) = pt1d;
    p(2, ideut) = pt2d;
    p(3, ideut) = pt3d;
    px1 = p(1, i1);
    py1 = p(2, i1);
    pz1 = p(3, i1);
    id(i1) = 2;
    id(i2) = 2;
    // C     Change the position of the perturbative deuteron to that of
    // C     the baryon to avoid consecutive collisions between them:
    r(1, ideut) = r(1, idb);
    r(2, ideut) = r(2, idb);
    r(3, ideut) = r(3, idb);
    return;
  }
  // C
  // C     Elastic collision of regularly-produced deuterons:
  if (ianti == 0) {
    write(91, star), " d+", lbb, " (regular d B elastic) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  } else {
    write(91, star), " d+", lbb, " (regular dbar Bbar elastic) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  }
  // Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
  if (scheck < 0) {
    write(99, star), "scheck54: ", scheck;
    scheck = 0.f;
  }
  pfinal = fem::sqrt(scheck) / 2.f / srt;
  // C      pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
  // C
  dbelangle(cmn, pxn, pyn, pzn, pfinal);
  // C     ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  // C     (This is not needed for isotropic distributions)
  rotate(cmn, px, py, pz, pxn, pyn, pzn);
  // C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
  // STATE C     FROM THE NUCLEUS-NUCLEUS CMS. FRAME INTO LAB FRAME: C     For
  // the 1st baryon:
  e1cm = fem::sqrt(fem::pow2(e(i1)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p1beta = pxn * betax + pyn * betay + pzn * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1.f) + e1cm);
  pt1i1 = betax * transf + pxn;
  pt2i1 = betay * transf + pyn;
  pt3i1 = betaz * transf + pzn;
  // C
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  // C     For the 2nd baryon:
  e2cm = fem::sqrt(fem::pow2(e(i2)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p2beta = -pxn * betax - pyn * betay - pzn * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf - pxn;
  pt2i2 = betay * transf - pyn;
  pt3i2 = betaz * transf - pzn;
  // C
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  // C
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  em2 = e(i2);
  id(i1) = 2;
  id(i2) = 2;
}

struct relcol_save {
  static const int maxstr = 150001;
  static const int maxr = 1;

  float am1;
  float am2;
  float bmass;
  float brel;
  float brsgm;
  float brsig;
  float cutoff;
  float deltar;
  float deltr0;
  float deltre;
  arr<float> dptemp;
  float dr0max;
  float drmax;
  float ds;
  float dse;
  float dshn;
  float dshnr;
  float dskk;
  float dskk0;
  float dskn;
  float dsknr;
  float dspert;
  float dspp;
  float dsppb;
  float dsppbr;
  float dsppr;
  float dsr;
  float dsrpert;
  float e1cm;
  float e2;
  float e2cm;
  float ec;
  float ec0;
  float ece;
  float eini;
  float em1i;
  float em2i;
  float emm1;
  float emm2;
  float er1;
  float er2;
  float ert;
  arr<float> et;
  arr<float, 2> ftpisv;
  arr<float> fttemp;
  float gfactr;
  int i;
  int i0;
  int i1;
  int i2;
  int ia;
  int ianti;
  int ib;
  int iblock;
  int ic;
  int icase;
  int ichann;
  int icheck;
  int icontp;
  int ictrl;
  int id1;
  int id2;
  int idecay;
  int ie;
  int ifirst;
  int ig;
  int ikk;
  int ikkg;
  int ikkl;
  int ikmp;
  int il;
  int ilb1;
  int ilb2;
  int im;
  int in;
  int inewka;
  int ipdflag;
  int ipert1;
  int ipion;
  int ipp;
  int ipx1;
  int ipx2;
  int ipy1;
  int ipy2;
  int ipz1;
  int ipz2;
  int irun;
  int is;
  int iss;
  int ix1;
  int ix2;
  int iy1;
  int iy2;
  int iz1;
  int iz2;
  int j;
  int j1;
  int j10;
  int j2;
  int kp;
  int lb1i;
  int lb2i;
  int lbm;
  int lbp1;
  int lbp2;
  int lomgar;
  int lpdr;
  int lrhor;
  arr<int> lt;
  int mass;
  arr<int> massrn;
  int msum;
  int n;
  int n0;
  int nchrg;
  int nnnini;
  int nodelt;
  int ntag;
  float p1beta;
  float pcx;
  float pcy;
  float pcz;
  float pdecay;
  float pfinal;
  float pk0;
  float pkaon;
  float pnstar;
  float ppel;
  float ppin;
  float ppink;
  float ppsig;
  arr<float> prot;
  arr<float, 2> pt;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px1cm;
  float px1i;
  float px2;
  float px2i;
  float pxini;
  float py1cm;
  float py1i;
  float py2;
  float py2i;
  float pyini;
  float pz1cm;
  float pz1i;
  float pz2;
  float pz2i;
  float pzini;
  float pzrt;
  float resona;
  float rhomp;
  float rppmax;
  float rsqare;
  arr<float, 2> rt;
  float sdb;
  float sdm;
  float sdprod;
  float sig;
  float sigela;
  float sigk;
  float sigkp;
  float siglab;
  float sigma0;
  float signn;
  float signn0;
  float sigp;
  float sigphi;
  float sigr0;
  float sigsgm;
  float spika;
  float spipi;
  float spprho;
  float srt;
  float sumsrt;
  float t0;
  float transf;
  float wid;
  float x1;
  float x2;
  float xdecay;
  float xdirct;
  float xelstc;
  float xeta;
  float xinel;
  float xkaon;
  float xkaon0;
  float xky1;
  float xky10;
  float xky11;
  float xky12;
  float xky13;
  float xky14;
  float xky15;
  float xky16;
  float xky17;
  float xky2;
  float xky3;
  float xky4;
  float xky5;
  float xky6;
  float xky7;
  float xky8;
  float xky9;
  float xmax;
  float xmaxn;
  float xmaxn1;
  float xmm;
  float xnelas;
  float xnpid;
  float xnpin;
  float xnpin1;
  float xphi;
  float xphin;
  float xreab;
  float xres;
  float xsk1;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;
  float xsk6;
  float xsk7;
  float xx;
  float xx0;
  float y1;
  float y2;
  float yy;
  float z1;
  float z2;
  arr<float> zet;

  relcol_save()
      : am1(fem::float0),
        am2(fem::float0),
        bmass(fem::float0),
        brel(fem::float0),
        brsgm(fem::float0),
        brsig(fem::float0),
        cutoff(fem::float0),
        deltar(fem::float0),
        deltr0(fem::float0),
        deltre(fem::float0),
        dptemp(dimension(maxstr), fem::fill0),
        dr0max(fem::float0),
        drmax(fem::float0),
        ds(fem::float0),
        dse(fem::float0),
        dshn(fem::float0),
        dshnr(fem::float0),
        dskk(fem::float0),
        dskk0(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        dspert(fem::float0),
        dspp(fem::float0),
        dsppb(fem::float0),
        dsppbr(fem::float0),
        dsppr(fem::float0),
        dsr(fem::float0),
        dsrpert(fem::float0),
        e1cm(fem::float0),
        e2(fem::float0),
        e2cm(fem::float0),
        ec(fem::float0),
        ec0(fem::float0),
        ece(fem::float0),
        eini(fem::float0),
        em1i(fem::float0),
        em2i(fem::float0),
        emm1(fem::float0),
        emm2(fem::float0),
        er1(fem::float0),
        er2(fem::float0),
        ert(fem::float0),
        et(dimension(maxstr), fem::fill0),
        ftpisv(dimension(maxstr, maxr), fem::fill0),
        fttemp(dimension(maxstr), fem::fill0),
        gfactr(fem::float0),
        i(fem::int0),
        i0(fem::int0),
        i1(fem::int0),
        i2(fem::int0),
        ia(fem::int0),
        ianti(fem::int0),
        ib(fem::int0),
        iblock(fem::int0),
        ic(fem::int0),
        icase(fem::int0),
        ichann(fem::int0),
        icheck(fem::int0),
        icontp(fem::int0),
        ictrl(fem::int0),
        id1(fem::int0),
        id2(fem::int0),
        idecay(fem::int0),
        ie(fem::int0),
        ifirst(fem::int0),
        ig(fem::int0),
        ikk(fem::int0),
        ikkg(fem::int0),
        ikkl(fem::int0),
        ikmp(fem::int0),
        il(fem::int0),
        ilb1(fem::int0),
        ilb2(fem::int0),
        im(fem::int0),
        in(fem::int0),
        inewka(fem::int0),
        ipdflag(fem::int0),
        ipert1(fem::int0),
        ipion(fem::int0),
        ipp(fem::int0),
        ipx1(fem::int0),
        ipx2(fem::int0),
        ipy1(fem::int0),
        ipy2(fem::int0),
        ipz1(fem::int0),
        ipz2(fem::int0),
        irun(fem::int0),
        is(fem::int0),
        iss(fem::int0),
        ix1(fem::int0),
        ix2(fem::int0),
        iy1(fem::int0),
        iy2(fem::int0),
        iz1(fem::int0),
        iz2(fem::int0),
        j(fem::int0),
        j1(fem::int0),
        j10(fem::int0),
        j2(fem::int0),
        kp(fem::int0),
        lb1i(fem::int0),
        lb2i(fem::int0),
        lbm(fem::int0),
        lbp1(fem::int0),
        lbp2(fem::int0),
        lomgar(fem::int0),
        lpdr(fem::int0),
        lrhor(fem::int0),
        lt(dimension(maxstr), fem::fill0),
        mass(fem::int0),
        massrn(dim1(0, maxr), fem::fill0),
        msum(fem::int0),
        n(fem::int0),
        n0(fem::int0),
        nchrg(fem::int0),
        nnnini(fem::int0),
        nodelt(fem::int0),
        ntag(fem::int0),
        p1beta(fem::float0),
        pcx(fem::float0),
        pcy(fem::float0),
        pcz(fem::float0),
        pdecay(fem::float0),
        pfinal(fem::float0),
        pk0(fem::float0),
        pkaon(fem::float0),
        pnstar(fem::float0),
        ppel(fem::float0),
        ppin(fem::float0),
        ppink(fem::float0),
        ppsig(fem::float0),
        prot(dimension(maxstr), fem::fill0),
        pt(dimension(3, maxstr), fem::fill0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px1cm(fem::float0),
        px1i(fem::float0),
        px2(fem::float0),
        px2i(fem::float0),
        pxini(fem::float0),
        py1cm(fem::float0),
        py1i(fem::float0),
        py2(fem::float0),
        py2i(fem::float0),
        pyini(fem::float0),
        pz1cm(fem::float0),
        pz1i(fem::float0),
        pz2(fem::float0),
        pz2i(fem::float0),
        pzini(fem::float0),
        pzrt(fem::float0),
        resona(fem::float0),
        rhomp(fem::float0),
        rppmax(fem::float0),
        rsqare(fem::float0),
        rt(dimension(3, maxstr), fem::fill0),
        sdb(fem::float0),
        sdm(fem::float0),
        sdprod(fem::float0),
        sig(fem::float0),
        sigela(fem::float0),
        sigk(fem::float0),
        sigkp(fem::float0),
        siglab(fem::float0),
        sigma0(fem::float0),
        signn(fem::float0),
        signn0(fem::float0),
        sigp(fem::float0),
        sigphi(fem::float0),
        sigr0(fem::float0),
        sigsgm(fem::float0),
        spika(fem::float0),
        spipi(fem::float0),
        spprho(fem::float0),
        srt(fem::float0),
        sumsrt(fem::float0),
        t0(fem::float0),
        transf(fem::float0),
        wid(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xdecay(fem::float0),
        xdirct(fem::float0),
        xelstc(fem::float0),
        xeta(fem::float0),
        xinel(fem::float0),
        xkaon(fem::float0),
        xkaon0(fem::float0),
        xky1(fem::float0),
        xky10(fem::float0),
        xky11(fem::float0),
        xky12(fem::float0),
        xky13(fem::float0),
        xky14(fem::float0),
        xky15(fem::float0),
        xky16(fem::float0),
        xky17(fem::float0),
        xky2(fem::float0),
        xky3(fem::float0),
        xky4(fem::float0),
        xky5(fem::float0),
        xky6(fem::float0),
        xky7(fem::float0),
        xky8(fem::float0),
        xky9(fem::float0),
        xmax(fem::float0),
        xmaxn(fem::float0),
        xmaxn1(fem::float0),
        xmm(fem::float0),
        xnelas(fem::float0),
        xnpid(fem::float0),
        xnpin(fem::float0),
        xnpin1(fem::float0),
        xphi(fem::float0),
        xphin(fem::float0),
        xreab(fem::float0),
        xres(fem::float0),
        xsk1(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0),
        xsk6(fem::float0),
        xsk7(fem::float0),
        xx(fem::float0),
        xx0(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        yy(fem::float0),
        z1(fem::float0),
        z2(fem::float0),
        zet(dim1(-45, 45), fem::fill0) {}
};

const int relcol_save::maxstr;
const int relcol_save::maxr;

// C*********************************
// C                                                                      *
void relcol(common& cmn, int& lcoll, int& lbloc, int& lcnne, int& ldd, int& lpp,
            int& lppk, int& lpn, int& lpd, int& lrho, int& lomega, int& lkn,
            int& lnnk, int& lddk, int& lndk, int& lcnnd, int& lcndn, int& ldirt,
            int& ldecay, int& lres, int& ldou, int& lddrho, int& lnnrho,
            int& lnnom, int const& nt, int const& ntmax, float& sp,
            float& akaon, float& sk) {
  FEM_CMN_SVE(relcol);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  arr_ref<float> proper(cmn.proper, dimension(maxstr));
  float& dx = cmn.dx;
  float& dy = cmn.dy;
  float& dz = cmn.dz;
  float& dpx = cmn.dpx;
  float& dpy = cmn.dpy;
  float& dpz = cmn.dpz;
  int& nnn = cmn.nnn;
  const int maxr = 1;
  arr_ref<int> massr(cmn.massr, dim1(0, maxr));
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  int& num = cmn.num;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  arr_ref<float, 2> propi(cmn.propi, dimension(maxstr, maxr));
  arr_ref<float> tkaon(cmn.tkaon, dimension(7));
  arr_ref<float, 2> ekaon(cmn.ekaon, dim1(7).dim2(0, 2000));
  int& iseed = cmn.iseed;
  float& dt = cmn.dt;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  float& px1n = cmn.px1n;
  float& py1n = cmn.py1n;
  float& pz1n = cmn.pz1n;
  float& dp1n = cmn.dp1n;
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  arr_ref<float> tft(cmn.tft, dimension(maxstr));
  arr_cref<float> thresh(cmn.thresh, dimension(15));
  float& ppinnb = cmn.ppinnb;
  int& iksdcy = cmn.iksdcy;
  int& nseed = cmn.nseed;
  arr_ref<float> ftsv(cmn.ftsv, dimension(maxstr));
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  int& ipi0dcy = cmn.ipi0dcy;
  int& idpert = cmn.idpert;
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  //
  float& am1 = sve.am1;
  float& am2 = sve.am2;
  float& bmass = sve.bmass;
  float& brel = sve.brel;
  float& brsgm = sve.brsgm;
  float& brsig = sve.brsig;
  float& cutoff = sve.cutoff;
  float& deltar = sve.deltar;
  float& deltr0 = sve.deltr0;
  float& deltre = sve.deltre;
  arr_ref<float> dptemp(sve.dptemp, dimension(maxstr));
  float& dr0max = sve.dr0max;
  float& drmax = sve.drmax;
  float& ds = sve.ds;
  float& dse = sve.dse;
  float& dshn = sve.dshn;
  float& dshnr = sve.dshnr;
  float& dskk = sve.dskk;
  float& dskk0 = sve.dskk0;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  float& dspert = sve.dspert;
  float& dspp = sve.dspp;
  float& dsppb = sve.dsppb;
  float& dsppbr = sve.dsppbr;
  float& dsppr = sve.dsppr;
  float& dsr = sve.dsr;
  float& dsrpert = sve.dsrpert;
  float& e1cm = sve.e1cm;
  float& e2 = sve.e2;
  float& e2cm = sve.e2cm;
  float& ec = sve.ec;
  float& ec0 = sve.ec0;
  float& ece = sve.ece;
  float& emm1 = sve.emm1;
  float& emm2 = sve.emm2;
  float& er1 = sve.er1;
  float& er2 = sve.er2;
  float& ert = sve.ert;
  arr_ref<float> et(sve.et, dimension(maxstr));
  arr_ref<float, 2> ftpisv(sve.ftpisv, dimension(maxstr, maxr));
  arr_ref<float> fttemp(sve.fttemp, dimension(maxstr));
  float& gfactr = sve.gfactr;
  int& i = sve.i;
  int& i0 = sve.i0;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ia = sve.ia;
  int& ianti = sve.ianti;
  int& ib = sve.ib;
  int& iblock = sve.iblock;
  int& ic = sve.ic;
  int& icase = sve.icase;
  int& ichann = sve.ichann;
  int& icheck = sve.icheck;
  int& icontp = sve.icontp;
  int& ictrl = sve.ictrl;
  int& id1 = sve.id1;
  int& idecay = sve.idecay;
  int& ie = sve.ie;
  int& ifirst = sve.ifirst;
  int& ig = sve.ig;
  int& ikkg = sve.ikkg;
  int& ikkl = sve.ikkl;
  int& ikmp = sve.ikmp;
  int& il = sve.il;
  int& ilb1 = sve.ilb1;
  int& ilb2 = sve.ilb2;
  int& im = sve.im;
  int& in = sve.in;
  int& inewka = sve.inewka;
  int& ipdflag = sve.ipdflag;
  int& ipert1 = sve.ipert1;
  int& ipion = sve.ipion;
  int& ipp = sve.ipp;
  int& irun = sve.irun;
  int& is = sve.is;
  int& iss = sve.iss;
  int& j = sve.j;
  int& j1 = sve.j1;
  int& j10 = sve.j10;
  int& j2 = sve.j2;
  int& kp = sve.kp;
  int& lbm = sve.lbm;
  int& lbp1 = sve.lbp1;
  int& lbp2 = sve.lbp2;
  int& lomgar = sve.lomgar;
  int& lpdr = sve.lpdr;
  int& lrhor = sve.lrhor;
  arr_ref<int> lt(sve.lt, dimension(maxstr));
  int& mass = sve.mass;
  arr_ref<int> massrn(sve.massrn, dim1(0, maxr));
  int& msum = sve.msum;
  int& n = sve.n;
  int& n0 = sve.n0;
  int& nchrg = sve.nchrg;
  int& ntag = sve.ntag;
  float& p1beta = sve.p1beta;
  float& pcx = sve.pcx;
  float& pcy = sve.pcy;
  float& pcz = sve.pcz;
  float& pdecay = sve.pdecay;
  float& pfinal = sve.pfinal;
  float& pk0 = sve.pk0;
  float& pkaon = sve.pkaon;
  float& pnstar = sve.pnstar;
  float& ppel = sve.ppel;
  float& ppin = sve.ppin;
  float& ppink = sve.ppink;
  float& ppsig = sve.ppsig;
  arr_ref<float> prot(sve.prot, dimension(maxstr));
  arr_ref<float, 2> pt(sve.pt, dimension(3, maxstr));
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px1cm = sve.px1cm;
  float& px2 = sve.px2;
  float& py1cm = sve.py1cm;
  float& py2 = sve.py2;
  float& pz1cm = sve.pz1cm;
  float& pz2 = sve.pz2;
  float& pzrt = sve.pzrt;
  float& resona = sve.resona;
  float& rppmax = sve.rppmax;
  float& rsqare = sve.rsqare;
  arr_ref<float, 2> rt(sve.rt, dimension(3, maxstr));
  float& sdb = sve.sdb;
  float& sdm = sve.sdm;
  float& sdprod = sve.sdprod;
  float& sig = sve.sig;
  float& sigela = sve.sigela;
  float& sigk = sve.sigk;
  float& sigkp = sve.sigkp;
  float& siglab = sve.siglab;
  float& sigma0 = sve.sigma0;
  float& signn = sve.signn;
  float& signn0 = sve.signn0;
  float& sigp = sve.sigp;
  float& sigphi = sve.sigphi;
  float& sigr0 = sve.sigr0;
  float& sigsgm = sve.sigsgm;
  float& spika = sve.spika;
  float& spipi = sve.spipi;
  float& spprho = sve.spprho;
  float& srt = sve.srt;
  float& t0 = sve.t0;
  float& transf = sve.transf;
  float& wid = sve.wid;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xdecay = sve.xdecay;
  float& xdirct = sve.xdirct;
  float& xelstc = sve.xelstc;
  float& xeta = sve.xeta;
  float& xinel = sve.xinel;
  float& xkaon = sve.xkaon;
  float& xkaon0 = sve.xkaon0;
  float& xky1 = sve.xky1;
  float& xky10 = sve.xky10;
  float& xky11 = sve.xky11;
  float& xky12 = sve.xky12;
  float& xky13 = sve.xky13;
  float& xky14 = sve.xky14;
  float& xky15 = sve.xky15;
  float& xky16 = sve.xky16;
  float& xky17 = sve.xky17;
  float& xky2 = sve.xky2;
  float& xky3 = sve.xky3;
  float& xky4 = sve.xky4;
  float& xky5 = sve.xky5;
  float& xky6 = sve.xky6;
  float& xky7 = sve.xky7;
  float& xky8 = sve.xky8;
  float& xky9 = sve.xky9;
  float& xmax = sve.xmax;
  float& xmaxn = sve.xmaxn;
  float& xmaxn1 = sve.xmaxn1;
  float& xmm = sve.xmm;
  float& xnelas = sve.xnelas;
  float& xnpid = sve.xnpid;
  float& xnpin = sve.xnpin;
  float& xnpin1 = sve.xnpin1;
  float& xphi = sve.xphi;
  float& xphin = sve.xphin;
  float& xreab = sve.xreab;
  float& xres = sve.xres;
  float& xsk1 = sve.xsk1;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  float& xsk6 = sve.xsk6;
  float& xx = sve.xx;
  float& xx0 = sve.xx0;
  float& y1 = sve.y1;
  float& y2 = sve.y2;
  float& yy = sve.yy;
  float& z1 = sve.z1;
  float& z2 = sve.z2;
  arr_ref<float> zet(sve.zet, dim1(-45, 45));
  if (is_called_first_time) {
    static const float values[] = {
        1.f,  0.f,  0.f, 0.f,  0.f,  1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, -1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, 0.f,  -1.f, 0.f, 1.f,  0.f, -1.f, 0.f, -1.f, 0.f,
        -2.f, -1.f, 0.f, 1.f,  0.f,  0.f, 0.f,  0.f, -1.f, 0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, -1.f, 0.f,  1.f, 2.f,  0.f, 1.f,  0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, 0.f,  0.f,  0.f, -1.f, 0.f, 1.f,  0.f, -1.f, 0.f,
        1.f,  0.f,  0.f, 1.f,  0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  -1.f, 0.f, 0.f,  0.f,  0.f, -1.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), zet;
  }
  const float esbin = 0.04f;
  const float aka = 0.498f;
  const float pi = 3.1415926f;
  const float srhoks = 5.f;
  const float rrkk = 0.6f;
  const float aks = 0.895f;
  const float prkk = 0.3f;
  // C                                                                      *
  // C       PURPOSE:    CHECK CONDITIONS AND CALCULATE THE KINEMATICS      *
  // C                   FOR BINARY COLLISIONS AMONG PARTICLES              *
  // C                                 - RELATIVISTIC FORMULA USED          *
  // C                                                                      *
  // C       REFERENCES: HAGEDORN, RELATIVISTIC KINEMATICS (1963)           *
  // C                                                                      *
  // C       VARIABLES:                                                     *
  // C         MASSPR  - NUMBER OF NUCLEONS IN PROJECTILE   (INTEGER,INPUT) *
  // C         MASSTA  - NUMBER OF NUCLEONS IN TARGET       (INTEGER,INPUT) *
  // C         NUM     - NUMBER OF TESTPARTICLES PER NUCLEON(INTEGER,INPUT) *
  // C         ISEED   - SEED FOR RANDOM NUMBER GENERATOR   (INTEGER,INPUT) *
  // C         IAVOID  - (= 1 => AVOID FIRST CLLISIONS WITHIN THE SAME      *
  // C                   NUCLEUS, ELSE ALL COLLISIONS)      (INTEGER,INPUT) *
  // C         DELTAR  - MAXIMUM SPATIAL DISTANCE FOR WHICH A COLLISION     *
  // C                   STILL CAN OCCUR                       (REAL,INPUT) *
  // C         DT      - TIME STEP SIZE                        (REAL,INPUT) *
  // C         LCOLL   - NUMBER OF COLLISIONS              (INTEGER,OUTPUT) *
  // C         LBLOC   - NUMBER OF PULI-BLOCKED COLLISIONS (INTEGER,OUTPUT) *
  // C         LCNNE   - NUMBER OF ELASTIC COLLISION       (INTEGER,OUTPUT) *
  // C         LCNND   - NUMBER OF N+N->N+DELTA REACTION   (INTEGER,OUTPUT) *
  // C         LCNDN   - NUMBER OF N+DELTA->N+N REACTION   (INTEGER,OUTPUT) *
  // C         LDD     - NUMBER OF RESONANCE+RESONANCE COLLISIONS
  // C         LPP     - NUMBER OF PION+PION elastic COLIISIONS
  // C         lppk    - number of pion(RHO,OMEGA)+pion(RHO,OMEGA)
  // C                   -->K+K- collisions
  // C         LPN     - NUMBER OF PION+N-->KAON+X
  // C         lpd     - number of pion+n-->delta+pion
  // C         lrho    - number of pion+n-->Delta+rho
  // C         lomega  - number of pion+n-->Delta+omega
  // C         LKN     - NUMBER OF KAON RESCATTERINGS
  // C         LNNK    - NUMBER OF bb-->kAON PROCESS
  // C         LDDK    - NUMBER OF DD-->KAON PROCESS
  // C         LNDK    - NUMBER OF ND-->KAON PROCESS
  // C         LB(I) IS USED TO LABEL PARTICLE'S CHARGE STATE
  // C         LB(I)   =
  // Cbali2/7/99
  // C                 -45 Omega baryon(bar)
  // C                 -41 cascade0(bar)
  // C                 -40 cascade-(bar)
  // Clin-11/07/00:
  // C                 -30 K*-
  // C                 -17 sigma+(bar)
  // C                 -16 sigma0(bar)
  // C                 -15 sigma-(bar)
  // C                 -14 LAMBDA(bar)
  // Clin-8/29/00
  // C                 -13 anti-N*(+1)(1535),s_11
  // C                 -12 anti-N*0(1535),s_11
  // C                 -11 anti-N*(+1)(1440),p_11
  // C                 -10 anti-N*0(1440), p_11
  // C                  -9 anti-DELTA+2
  // C                  -8 anti-DELTA+1
  // C                  -7 anti-DELTA0
  // C                  -6 anti-DELTA-1
  // C
  // C                  -2 antineutron
  // C                  -1 antiproton
  // Cbali2/7/99end
  // C                   0 eta
  // C                   1 PROTON
  // C                   2 NUETRON
  // C                   3 PION-
  // C                   4 PION0
  // C                   5 PION+
  // C                   6 DELTA-1
  // C                   7 DELTA0
  // C                   8 DELTA+1
  // C                   9 DELTA+2
  // C                   10 N*0(1440), p_11
  // C                   11 N*(+1)(1440),p_11
  // C                  12 N*0(1535),s_11
  // C                  13 N*(+1)(1535),s_11
  // C                  14 LAMBDA
  // C                   15 sigma-
  // C                   16 sigma0
  // C                   17 sigma+
  // C                   21 kaon-
  // Clin-2/23/03        22 Kaon0Long (converted at the last timestep)
  // C                   23 KAON+
  // C                   24 Kaon0short (converted at the last timestep then
  // decay) C                   25 rho- C                   26 rho0 C 27 rho+ C
  // 28 omega meson C                   29 phi C                   30 K*+ C
  // sp01/03/01 C                   31 eta-prime C                   40 cascade-
  // C                   41 cascade0
  // C                   45 Omega baryon
  // C sp01/03/01 end
  // C
  // C                   ++  ------- SEE NOTE BOOK
  // C         NSTAR=1 INCLUDING N* RESORANCE
  // C         ELSE DELTA RESORANCE ONLY
  // C         NDIRCT=1 INCLUDING DIRECT PROCESS,ELSE NOT
  // C         DIR - PERCENTAGE OF DIRECT PION PRODUCTION PROCESS
  // C*********************************
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /EE/
  // Cc      SAVE /HH/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /NN/
  // Cc      SAVE /RR/
  // Cc      SAVE /ss/
  // Cc      SAVE /BG/
  // Cc      SAVE /RUN/
  // Cc      SAVE /PA/
  // Cc      SAVE /PB/
  // Cc      SAVE /PC/
  // Cc      SAVE /PD/
  // Cc      SAVE /PE/
  // Cc      SAVE /KKK/
  // Cc      SAVE /KAON/
  // Cc      SAVE /TABLE/
  // Cc      SAVE /input1/
  // Cc      SAVE /leadng/
  // Cc      SAVE /tdecay/
  // Cc      SAVE /lastt/
  // C
  // Cc      SAVE /ppbmas/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // Cc      SAVE /hbt/
  // Cc      SAVE /resdcy/
  // Cc      SAVE /RNDF77/
  // Clin-5/2008:
  // C
  // Clin-2/19/03 initialize n and nsav for resonance decay at each timestep
  // C     in order to prevent integer overflow:
  inidcy();
  // C
  // C OFF skip ART collisions to reproduce HJ:
  // Cc       if(nt.ne.ntmax) return
  // C
  // Clin-11/07/00 rrkk is assumed to be 0.6mb(default) for mm->KKbar
  // C     with m=rho or omega, estimated from Ko's paper:
  // C      rrkk=0.6
  // C prkk: cross section of pi (rho or omega) -> K* Kbar (AND) K*bar K:
  // C      prkk=0.3
  // C     cross section in mb for (rho or omega) K* -> pi K:
  // C      srhoks=5.
  // Clin-11/07/00-end
  // C      ESBIN=0.04
  resona = 5.f;
  // C-----------------------------------------------------------------------
  // C     INITIALIZATION OF COUNTING VARIABLES
  sve.nodelt = 0;
  sve.sumsrt = 0.f;
  lcoll = 0;
  lbloc = 0;
  lcnne = 0;
  ldd = 0;
  lpp = 0;
  lpd = 0;
  lpdr = 0;
  lrho = 0;
  lrhor = 0;
  lomega = 0;
  lomgar = 0;
  lpn = 0;
  lkn = 0;
  lnnk = 0;
  lddk = 0;
  lndk = 0;
  lppk = 0;
  lcnnd = 0;
  lcndn = 0;
  ldirt = 0;
  ldecay = 0;
  lres = 0;
  ldou = 0;
  lddrho = 0;
  lnnrho = 0;
  lnnom = 0;
  msum = 0;
  massrn(0) = 0;
  // C COM: MSUM IS USED TO COUNT THE TOTAL NO. OF PARTICLES
  // C      IN PREVIOUS IRUN-1 RUNS
  // C KAON COUNTERS
  FEM_DO_SAFE(il, 1, 5) {
    tkaon(il) = 0;
    FEM_DO_SAFE(is, 1, 2000) { ekaon(il, is) = 0; }
  }
  // C sp 12/19/00
  FEM_DO_SAFE(i, 1, num) {
    FEM_DO_SAFE(j, 1, maxstr) { propi(j, i) = 1.f; }
  }
  // C
  FEM_DO_SAFE(i, 1, maxstr) {
    fttemp(i) = 0.f;
    FEM_DO_SAFE(irun, 1, maxr) { ftpisv(i, irun) = 0.f; }
  }
  // C
  // C sp 12/19/00 end
  sp = 0;
  // C antikaon counters
  akaon = 0;
  sk = 0;
  // C-----------------------------------------------------------------------
  // C     LOOP OVER ALL PARALLEL RUNS
  // Cbz11/17/98
  // C      MASS=MASSPR+MASSTA
  mass = 0;
  // Cbz11/17/98end
  FEM_DO_SAFE(irun, 1, num) {
    nnn = 0;
    msum += massr(irun - 1);
    // C     LOOP OVER ALL PSEUDOPARTICLES 1 IN THE SAME RUN
    j10 = 2;
    if (nt == ntmax) {
      j10 = 1;
    }
    // C
    // Ctest off skips the check of energy conservation after each timestep:
    // C         enetot=0.
    // C         do ip=1,MASSR(IRUN)
    // C            if(e(ip).ne.0.or.lb(ip).eq.10022) enetot=enetot
    // C     1           +sqrt(p(1,ip)**2+p(2,ip)**2+p(3,ip)**2+e(ip)**2)
    // C         enddo
    // C         write(91,*) 'A:',nt,enetot,massr(irun),bimp
    // C
    FEM_DO_SAFE(j1, j10, massr(irun)) {
      i1 = j1 + msum;
      // C E(I)=0 are for pions having been absorbed or photons which do not
      // enter here: Clin-4/2012 option of pi0 decays: C IF(E(I1).EQ.0.)GO TO 800
      if (e(i1) == 0.f) {
        goto statement_798;
      }
      // C     To include anti-(Delta,N*1440 and N*1535):
      // C          IF ((LB(I1) .LT. -13 .OR. LB(I1) .GT. 28)
      // C     1         .and.iabs(LB(I1)) .ne. 30 ) GOTO 800
      // Clin-4/2012 option of pi0 decays:
      // C            IF (LB(I1) .LT. -45 .OR. LB(I1) .GT. 45) GOTO 800
      if (lb(i1) < -45 || lb(i1) > 45) {
        goto statement_798;
      }
      x1 = r(1, i1);
      y1 = r(2, i1);
      z1 = r(3, i1);
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      am1 = em1;
      e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                     fem::pow2(pz1));
      id1 = id(i1);
      lb1 = lb(i1);
      // C
      // C     generate k0short and k0long from K+ and K- at the last timestep:
      if (nt == ntmax && (lb1 == 21 || lb1 == 23)) {
        pk0 = ranart(nseed);
        if (pk0 < 0.25f) {
          lb(i1) = 22;
        } else if (pk0 < 0.50f) {
          lb(i1) = 24;
        }
        lb1 = lb(i1);
      }
      // C
      // Clin-8/07/02 these particles don't decay strongly, so skip decay
      // routines: C            IF( (lb1.ge.-2.and.lb1.le.5) .OR. lb1.eq.31 .OR.
      // C     &           (iabs(lb1).ge.14.and.iabs(lb1).le.24) .OR.
      // C     &           (iabs(lb1).ge.40.and.iabs(lb1).le.45) .or.
      // C     &           lb1.eq.31)GO TO 1
      // C     only decay K0short when iksdcy=1:
      if (lb1 == 0 || lb1 == 25 || lb1 == 26 || lb1 == 27 || lb1 == 28 ||
          lb1 == 29 || fem::iabs(lb1) == 30 ||
          (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13) ||
          (iksdcy == 1 && lb1 == 24) || fem::iabs(lb1) == 16 ||
          (ipi0dcy == 1 && nt == ntmax && lb1 == 4)) {
        // Clin-4/2012-above for option of pi0 decay:
        // C     &           .or.iabs(lb1).eq.16) then
      } else {
        goto statement_1;
      }
      // C IF I1 IS A RESONANCE, CHECK WHETHER IT DECAYS DURING THIS TIME STEP
      if (lb1 >= 25 && lb1 <= 27) {
        wid = 0.151f;
      } else if (lb1 == 28) {
        wid = 0.00841f;
      } else if (lb1 == 29) {
        wid = 0.00443f;
      } else if (fem::iabs(lb1) == 30) {
        wid = 0.051f;
      } else if (lb1 == 0) {
        wid = 1.18e-6f;
        // C     to give K0short ct0=2.676cm:
      } else if (iksdcy == 1 && lb1 == 24) {
        wid = 7.36e-15f;
        // Clin-4/29/03 add Sigma0 decay to Lambda, ct0=2.22E-11m:
      } else if (fem::iabs(lb1) == 16) {
        wid = 8.87e-6f;
        // Csp-07/25/01 test a1 resonance:
        // Cc          ELSEIF(LB1.EQ.32) then
        // Cc             WID=0.40
      } else if (lb1 == 32) {
        wida1(cmn, em1, sve.rhomp, wid, iseed);
      } else if (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) {
        wid = width(cmn, em1);
      } else if ((fem::iabs(lb1) == 10) || (fem::iabs(lb1) == 11)) {
        wid = w1440(cmn, em1);
      } else if ((fem::iabs(lb1) == 12) || (fem::iabs(lb1) == 13)) {
        wid = w1535(cmn, em1);
        // Clin-4/2012 for option of pi0 decay:
      } else if (ipi0dcy == 1 && nt == ntmax && lb1 == 4) {
        wid = 7.85e-9f;
      }
      // C
      // C if it is the last time step, FORCE all resonance to strong-decay
      // C and go out of the loop
      if (nt == ntmax) {
        pdecay = 1.1f;
        // Clin-5b/2008 forbid phi decay at the end of hadronic cascade:
        if (cmn.iphidcy == 0 && fem::iabs(lb1) == 29) {
          pdecay = 0.f;
        }
        // Ctest off clin-9/2012 forbid long-time decays (eta,omega,K*,Sigma0)
        // C     at the end of hadronic cascade to analyze freezeout time:
        // C             if(LB1.eq.0.or.LB1.eq.28.or.iabs(LB1).eq.30
        // C     1            .or.iabs(LB1).eq.16) pdecay=0.
      } else {
        t0 = 0.19733f / wid;
        gfactr = e1 / em1;
        t0 = t0 * gfactr;
        if (t0 > 0.f) {
          pdecay = 1.f - fem::exp(-dt / t0);
        } else {
          pdecay = 0.f;
        }
      }
      xdecay = ranart(nseed);
      // C
      // Cc dilepton production from rho0, omega, phi decay
      // Cc        if(lb1.eq.26 .or. lb1.eq.28 .or. lb1.eq.29)
      // Cc     &   call dec_ceres(nt,ntmax,irun,i1)
      // Cc
      if (xdecay < pdecay) {
        // Clin-10/25/02 get rid of argument usage mismatch in rhocay():
        idecay = irun;
        tfnl = nt * dt;
        // Clin-10/28/03 keep formation time of hadrons unformed at nt=ntmax-1:
        if (nt == ntmax && ftsv(i1) > ((ntmax - 1) * dt)) {
          tfnl = ftsv(i1);
        }
        xfnl = x1;
        yfnl = y1;
        zfnl = z1;
        // C use PYTHIA to perform decays of eta,rho,omega,phi,K*,(K0s) and
        // Delta:
        if (lb1 == 0 || lb1 == 25 || lb1 == 26 || lb1 == 27 || lb1 == 28 ||
            lb1 == 29 || fem::iabs(lb1) == 30 ||
            (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) ||
            (iksdcy == 1 && lb1 == 24) || fem::iabs(lb1) == 16 ||
            (ipi0dcy == 1 && nt == ntmax && lb1 == 4)) {
          // Clin-4/2012 Above for option of pi0 decay:
          // C     &           .or.iabs(lb1).eq.16) then
          // C     previous rho decay performed in rhodecay():
          // C                nnn=nnn+1
          // C                call rhodecay(idecay,i1,nnn,iseed)
          // C
          // Ctest off record decays of phi,K*,Lambda(1520) resonances:
          // C                if(lb1.eq.29.or.iabs(lb1).eq.30)
          // C     1               write(18,112) 'decay',lb1,px1,py1,pz1,am1,nt
          // C
          // Clin-4/2012 option of pi0 decays:
          // C                call resdec(i1,nt,nnn,wid,idecay)
          resdec(i1, nt, nnn, wid, idecay, 0);
          p(1, i1) = px1n;
          p(2, i1) = py1n;
          p(3, i1) = pz1n;
          // Clin-5/2008:
          dpertp(i1) = dp1n;
          // C     add decay time to freezeout positions & time at the last
          // timestep:
          if (nt == ntmax) {
            r(1, i1) = xfnl;
            r(2, i1) = yfnl;
            r(3, i1) = zfnl;
            tfdcy(i1) = tfnl;
          }
          // C
          // C decay number for baryon resonance or L/S decay
          if (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) {
            ldecay++;
          }
          // C
          // C for a1 decay
          // C             elseif(lb1.eq.32)then
          // C                NNN=NNN+1
          // C                call a1decay(idecay,i1,nnn,iseed,rhomp)
          // C
          // C FOR N*(1440)
        } else if (fem::iabs(lb1) == 10 || fem::iabs(lb1) == 11) {
          nnn++;
          ldecay++;
          pnstar = 1.f;
          if (e(i1) > 1.22f) {
            pnstar = 0.6f;
          }
          if (ranart(nseed) <= pnstar) {
            // C (1) DECAY TO SINGLE PION+NUCLEON
            decay(cmn, idecay, i1, nnn, iseed, wid, nt);
          } else {
            // C (2) DECAY TO TWO PIONS + NUCLEON
            decay2(cmn, idecay, i1, nnn, iseed, wid, nt);
            nnn++;
          }
          // C for N*(1535) decay
        } else if (fem::iabs(lb1) == 12 || fem::iabs(lb1) == 13) {
          nnn++;
          decay(cmn, idecay, i1, nnn, iseed, wid, nt);
          ldecay++;
        }
        // C
        // CCOM: AT HIGH ENERGIES WE USE VERY SHORT TIME STEPS,
        // C     IN ORDER TO TAKE INTO ACCOUNT THE FINITE FORMATIOM TIME, WE
        // C     DO NOT ALLOW PARTICLES FROM THE DECAY OF RESONANCE TO INTERACT
        // C     WITH OTHERS IN THE SAME TIME STEP. CHANGE 9000 TO REVERSE THIS
        // C     ASSUMPTION. EFFECTS OF THIS ASSUMPTION CAN BE STUDIED BY
        // CHANGING C     THE STATEMENT OF 9000. See notebook for discussions on
        // effects of C     changing statement 9000.
        // C
        // C     kaons from K* decay are converted to k0short (and k0long),
        // C     phi decay may produce rho, K0S or eta, N*(1535) decay may
        // produce eta, C     and these decay daughters need to decay again if at
        // the last timestep: C     (note: these daughters have been assigned to
        // lb(i1) only, not to lpion) C
        // if(nt.eq.ntmax.and.(lb1.eq.29.or.iabs(lb1).eq.30 C     1
        // .iabs(lb1).eq.12.or.iabs(lb1).eq.13)) then
        if (nt == ntmax) {
          if (lb(i1) == 25 || lb(i1) == 26 || lb(i1) == 27) {
            wid = 0.151f;
          } else if (lb(i1) == 0) {
            wid = 1.18e-6f;
          } else if (lb(i1) == 24 && iksdcy == 1) {
            // Clin-4/2012 corrected K0s decay width:
            // C                   wid=7.36e-17
            wid = 7.36e-15f;
            // Clin-4/2012 option of pi0 decays:
          } else if (ipi0dcy == 1 && lb(i1) == 4) {
            wid = 7.85e-9f;
          } else {
            goto statement_9000;
          }
          lb1 = lb(i1);
          px1 = p(1, i1);
          py1 = p(2, i1);
          pz1 = p(3, i1);
          em1 = e(i1);
          e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                         fem::pow2(pz1));
          // Clin-4/2012 option of pi0 decays:
          // C                call resdec(i1,nt,nnn,wid,idecay)
          resdec(i1, nt, nnn, wid, idecay, 0);
          p(1, i1) = px1n;
          p(2, i1) = py1n;
          p(3, i1) = pz1n;
          r(1, i1) = xfnl;
          r(2, i1) = yfnl;
          r(3, i1) = zfnl;
          tfdcy(i1) = tfnl;
          // Clin-5/2008:
          dpertp(i1) = dp1n;
        }
        // C
        // C     Decay daughter of the above decay in lb(i1) may be a pi0:
        if (nt == ntmax && ipi0dcy == 1 && lb(i1) == 4) {
          wid = 7.85e-9f;
          lb1 = lb(i1);
          px1 = p(1, i1);
          py1 = p(2, i1);
          pz1 = p(3, i1);
          em1 = e(i1);
          e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                         fem::pow2(pz1));
          resdec(i1, nt, nnn, wid, idecay, 0);
          p(1, i1) = px1n;
          p(2, i1) = py1n;
          p(3, i1) = pz1n;
          r(1, i1) = xfnl;
          r(2, i1) = yfnl;
          r(3, i1) = zfnl;
          tfdcy(i1) = tfnl;
          dpertp(i1) = dp1n;
        }
      // C
      // C negelecting the Pauli blocking at high energies
      // Clin-4/2012 option of pi0 decays:
      // C 9000        go to 800
      statement_9000:
        goto statement_798;
        // C
      }
    // C LOOP OVER ALL PSEUDOPARTICLES 2 IN THE SAME RUN
    // C SAVE ALL THE COORDINATES FOR POSSIBLE CHANGE IN THE FOLLOWING COLLISION
    // Clin-4/2012 option of pi0 decays:
    // C 1        if(nt.eq.ntmax)go to 800
    statement_1:
      if (nt == ntmax) {
        goto statement_798;
      }
      // C
      x1 = r(1, i1);
      y1 = r(2, i1);
      z1 = r(3, i1);
      // C
      FEM_DO_SAFE(j2, 1, j1 - 1) {
        i2 = j2 + msum;
        // C IF I2 IS A MESON BEING ABSORBED, THEN GO OUT OF THE LOOP
        if (e(i2) == 0.f) {
          goto statement_600;
        }
        // Clin-5/2008 in case the first particle is already destroyed:
        if (e(i1) == 0.f) {
          goto statement_800;
        }
        // Clin-4/2012 option of pi0 decays:
        if (lb(i2) < -45 || lb(i2) > 45) {
          goto statement_600;
        }
        // Clin-7/26/03 improve speed
        x2 = r(1, i2);
        y2 = r(2, i2);
        z2 = r(3, i2);
        dr0max = 5.f;
        // Clin-9/2008 deuteron+nucleon elastic cross sections could reach
        // ~2810mb:
        ilb1 = fem::iabs(lb(i1));
        ilb2 = fem::iabs(lb(i2));
        if (ilb1 == 42 || ilb2 == 42) {
          if ((ilb1 >= 1 && ilb1 <= 2) || (ilb1 >= 6 && ilb1 <= 13) ||
              (ilb2 >= 1 && ilb2 <= 2) || (ilb2 >= 6 && ilb2 <= 13)) {
            if ((lb(i1) * lb(i2)) > 0) {
              dr0max = 10.f;
            }
          }
        }
        // C
        if ((fem::pow2((x1 - x2)) + fem::pow2((y1 - y2)) +
             fem::pow2((z1 - z2))) > fem::pow2(dr0max)) {
          goto statement_600;
        }
        if (id(i1) * id(i2) == cmn.iavoid) {
          goto statement_400;
        }
        id1 = id(i1);
        sve.id2 = id(i2);
        // C
        sve.ix1 = fem::nint(x1 / dx);
        sve.iy1 = fem::nint(y1 / dy);
        sve.iz1 = fem::nint(z1 / dz);
        px1 = p(1, i1);
        py1 = p(2, i1);
        pz1 = p(3, i1);
        em1 = e(i1);
        am1 = em1;
        lb1 = lb(i1);
        e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                       fem::pow2(pz1));
        sve.ipx1 = fem::nint(px1 / dpx);
        sve.ipy1 = fem::nint(py1 / dpy);
        sve.ipz1 = fem::nint(pz1 / dpz);
        lb2 = lb(i2);
        px2 = p(1, i2);
        py2 = p(2, i2);
        pz2 = p(3, i2);
        em2 = e(i2);
        am2 = em2;
        sve.lb1i = lb(i1);
        sve.lb2i = lb(i2);
        sve.px1i = p(1, i1);
        sve.py1i = p(2, i1);
        sve.pz1i = p(3, i1);
        sve.em1i = e(i1);
        sve.px2i = p(1, i2);
        sve.py2i = p(2, i2);
        sve.pz2i = p(3, i2);
        sve.em2i = e(i2);
        // Clin-2/26/03 ctest off check energy conservation after each binary
        // search:
        sve.eini = fem::sqrt(fem::pow2(e(i1)) + fem::pow2(p(1, i1)) +
                             fem::pow2(p(2, i1)) + fem::pow2(p(3, i1))) +
                   fem::sqrt(fem::pow2(e(i2)) + fem::pow2(p(1, i2)) +
                             fem::pow2(p(2, i2)) + fem::pow2(p(3, i2)));
        sve.pxini = p(1, i1) + p(1, i2);
        sve.pyini = p(2, i1) + p(2, i2);
        sve.pzini = p(3, i1) + p(3, i2);
        sve.nnnini = nnn;
        // C
        // Clin-4/30/03 initialize value:
        iblock = 0;
        // C
        // C TO SAVE COMPUTING TIME we do the following
        // C (1) make a ROUGH estimate to see whether particle i2 will collide
        // with C particle I1, and (2) skip the particle pairs for which
        // collisions are C not modeled in the code. C FOR MESON-BARYON AND
        // MESON-MESON COLLISIONS, we use a maximum C interaction distance
        // DELTR0=2.6 C for ppbar production from meson (pi rho omega)
        // interactions:
        // C
        deltr0 = 3.f;
        if ((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
            (fem::iabs(lb1) >= 30 && fem::iabs(lb1) <= 45)) {
          deltr0 = 5.0f;
        }
        if ((fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17) ||
            (fem::iabs(lb2) >= 30 && fem::iabs(lb2) <= 45)) {
          deltr0 = 5.0f;
        }
        // C
        if (lb1 == 28 && lb2 == 28) {
          deltr0 = 4.84f;
        }
        // Clin-10/08/00 to include pi pi -> rho rho:
        if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
          e2 = fem::sqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                         fem::pow2(pz2));
          spipi = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
                  fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
          if (spipi >= (4 * fem::pow2(0.77f))) {
            deltr0 = 3.5f;
          }
        }
        // C
        // C khyperon
        if (lb1 == 23 && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_3699;
        }
        if (lb2 == 23 && (lb1 >= 14 && lb1 <= 17)) {
          goto statement_3699;
        }
        // C
        // C K(K*) + Kbar(K*bar) scattering including
        // C     K(K*) + Kbar(K*bar) --> phi + pi(rho,omega) and pi
        // pi(rho,omega)
        if (lb1 == 21 && lb2 == 23) {
          goto statement_3699;
        }
        if (lb2 == 21 && lb1 == 23) {
          goto statement_3699;
        }
        if (lb1 == 30 && lb2 == 21) {
          goto statement_3699;
        }
        if (lb2 == 30 && lb1 == 21) {
          goto statement_3699;
        }
        if (lb1 == -30 && lb2 == 23) {
          goto statement_3699;
        }
        if (lb2 == -30 && lb1 == 23) {
          goto statement_3699;
        }
        if (lb1 == -30 && lb2 == 30) {
          goto statement_3699;
        }
        if (lb2 == -30 && lb1 == 30) {
          goto statement_3699;
        }
        // C
        // Clin-12/15/00
        // C     kaon+rho(omega,eta) collisions:
        if (lb1 == 21 || lb1 == 23) {
          if (lb2 == 0 || (lb2 >= 25 && lb2 <= 28)) {
            goto statement_3699;
          }
        } else if (lb2 == 21 || lb2 == 23) {
          if (lb1 == 0 || (lb1 >= 25 && lb1 <= 28)) {
            goto statement_3699;
          }
        }
        // C
        // Clin-8/14/02 K* (pi, rho, omega, eta) collisions:
        if (fem::iabs(lb1) == 30 &&
            (lb2 == 0 || (lb2 >= 25 && lb2 <= 28) || (lb2 >= 3 && lb2 <= 5))) {
          goto statement_3699;
        } else if (fem::iabs(lb2) == 30 &&
                   (lb1 == 0 || (lb1 >= 25 && lb1 <= 28) ||
                    (lb1 >= 3 && lb1 <= 5))) {
          goto statement_3699;
          // Clin-8/14/02-end
          // C K*/K*-bar + baryon/antibaryon collisions:
        } else if (fem::iabs(lb1) == 30 &&
                   (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
                    (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_3699;
        }
        if (fem::iabs(lb2) == 30 &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_3699;
        }
        // C K^+ baryons and antibaryons:
        // C** K+ + B-bar  --> La(Si)-bar + pi
        // C K^- and antibaryons, note K^- and baryons are included in newka():
        // C note that we fail to satisfy charge conjugation for these cross
        // sections:
        if ((lb1 == 23 || lb1 == 21) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
             (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_3699;
        } else if ((lb2 == 23 || lb2 == 21) &&
                   (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
                    (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_3699;
        }
        // C
        // C For anti-nucleons annihilations:
        // C Assumptions:
        // C (1) for collisions involving a p_bar or n_bar,
        // C we allow only collisions between a p_bar and a baryon or a baryon
        // C resonance (as well as a n_bar and a baryon or a baryon resonance),
        // C we skip all other reactions involving a p_bar or n_bar,
        // C such as collisions between p_bar (n_bar) and mesons,
        // C and collisions between two p_bar's (n_bar's).
        // C (2) we introduce a new parameter rppmax: the maximum interaction
        // C distance to make the quick collision check,rppmax=3.57 fm
        // C corresponding to a cutoff of annihilation xsection= 400mb which is
        // C also used consistently in the actual annihilation xsection to be
        // C used in the following as given in the subroutine xppbar(srt)
        rppmax = 3.57f;
        // C anti-baryon on baryons
        if ((lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)) &&
            (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13))) {
          deltr0 = rppmax;
          goto statement_2699;
        } else if ((lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6)) &&
                   (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 13))) {
          deltr0 = rppmax;
          goto statement_2699;
        }
        // C
        // C*  ((anti) lambda, cascade, omega  should not be rejected)
        if ((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
            (fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17)) {
          goto statement_3699;
        }
        // C
        // Clin-9/2008 maximum sigma~2810mb for deuteron+nucleon elastic
        // collisions:
        if (fem::iabs(lb1) == 42 || fem::iabs(lb2) == 42) {
          ilb1 = fem::iabs(lb1);
          ilb2 = fem::iabs(lb2);
          if ((ilb1 >= 1 && ilb1 <= 2) || (ilb1 >= 6 && ilb1 <= 13) ||
              (ilb2 >= 1 && ilb2 <= 2) || (ilb2 >= 6 && ilb2 <= 13)) {
            if ((lb1 * lb2) > 0) {
              deltr0 = 9.5f;
            }
          }
        }
        // C
        if ((fem::iabs(lb1) >= 40 && fem::iabs(lb1) <= 45) ||
            (fem::iabs(lb2) >= 40 && fem::iabs(lb2) <= 45)) {
          goto statement_3699;
        }
        // C
        // C* phi channel --> elastic + inelastic scatt.
        if ((lb1 == 29 && ((lb2 >= 1 && lb2 <= 13) ||
                           (lb2 >= 21 && lb2 <= 28) || fem::iabs(lb2) == 30)) ||
            (lb2 == 29 && ((lb1 >= 1 && lb1 <= 13) ||
                           (lb1 >= 21 && lb1 <= 28) || fem::iabs(lb1) == 30))) {
          deltr0 = 3.0f;
          goto statement_3699;
        }
        // C
        // C  La/Si, Cas, Om (bar)-meson elastic colln
        // C pion vs. La & Ca (bar) coll. are treated in resp. subroutines
        // C
        // C SKIP all other K* RESCATTERINGS
        if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
          goto statement_400;
        }
        // C SKIP KAON(+) RESCATTERINGS WITH particles other than pions and
        // baryons
        if (lb1 == 23 && (lb2 < 1 || lb2 > 17)) {
          goto statement_400;
        }
        if (lb2 == 23 && (lb1 < 1 || lb1 > 17)) {
          goto statement_400;
        }
        // C
        // C anti-baryon proccess: B-bar+M, N-bar+R-bar, N-bar+N-bar,
        // R-bar+R-bar C  R = (D,N*)
        if (((lb1 <= -1 && lb1 >= -13) && (lb2 == 0 || (lb2 >= 3 && lb2 <= 5) ||
                                           (lb2 >= 25 && lb2 <= 28))) ||
            ((lb2 <= -1 && lb2 >= -13) && (lb1 == 0 || (lb1 >= 3 && lb1 <= 5) ||
                                           (lb1 >= 25 && lb1 <= 28)))) {
        } else if (((lb1 == -1 || lb1 == -2) && (lb2 < -5 && lb2 >= -13)) ||
                   ((lb2 == -1 || lb2 == -2) && (lb1 < -5 && lb1 >= -13))) {
        } else if ((lb1 == -1 || lb1 == -2) && (lb2 == -1 || lb2 == -2)) {
        } else if ((lb1 < -5 && lb1 >= -13) && (lb2 < -5 && lb2 >= -13)) {
          // C        elseif((lb1.lt.0).or.(lb2.lt.0)) then
          // C         go to 400
        }
      // C
      statement_2699:
        // C for baryon-baryon collisions
        if (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 17)) {
          if (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 17)) {
            deltr0 = 2.f;
          }
        }
      // C
      statement_3699:
        rsqare =
            fem::pow2((x1 - x2)) + fem::pow2((y1 - y2)) + fem::pow2((z1 - z2));
        if (rsqare > fem::pow2(deltr0)) {
          goto statement_400;
        }
        // CNOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
        // C KEEP ALL COORDINATES FOR POSSIBLE PHASE SPACE CHANGE
        sve.ix2 = fem::nint(x2 / dx);
        sve.iy2 = fem::nint(y2 / dy);
        sve.iz2 = fem::nint(z2 / dz);
        sve.ipx2 = fem::nint(px2 / dpx);
        sve.ipy2 = fem::nint(py2 / dpy);
        sve.ipz2 = fem::nint(pz2 / dpz);
        // C FIND MOMENTA OF PARTICLES IN THE CMS OF THE TWO COLLIDING PARTICLES
        // C AND THE CMS ENERGY SRT
        cms(cmn, i1, i2, pcx, pcy, pcz, srt);
        // C
        // Clin-7/26/03 improve speed
        drmax = dr0max;
        distc0(cmn, drmax, deltr0, dt, ifirst, pcx, pcy, pcz, x1, y1, z1, px1,
               py1, pz1, em1, x2, y2, z2, px2, py2, pz2, em2);
        if (ifirst == -1) {
          goto statement_400;
        }
        // C
        iss = fem::nint(srt / esbin);
        // Clin-4/2008 use last bin if ISS is out of EKAON's upper bound of
        // 2000:
        if (iss > 2000) {
          iss = 2000;
        }
        // CSort collisions
        // C
        // Clin-8/2008 Deuteron+Meson->B+B;
        // C     meson=(pi,rho,omega,eta), B=(n,p,Delta,N*1440,N*1535):
        if (fem::iabs(lb1) == 42 || fem::iabs(lb2) == 42) {
          ilb1 = fem::iabs(lb1);
          ilb2 = fem::iabs(lb2);
          if (lb1 == 0 || (lb1 >= 3 && lb1 <= 5) || (lb1 >= 25 && lb1 <= 28) ||
              lb2 == 0 || (lb2 >= 3 && lb2 <= 5) || (lb2 >= 25 && lb2 <= 28)) {
            goto statement_505;
            // Clin-9/2008 Deuteron+Baryon or antiDeuteron+antiBaryon elastic
            // collisions:
          } else if (((ilb1 >= 1 && ilb1 <= 2) || (ilb1 >= 6 && ilb1 <= 13) ||
                      (ilb2 >= 1 && ilb2 <= 2) || (ilb2 >= 6 && ilb2 <= 13)) &&
                     (lb1 * lb2) > 0) {
            goto statement_506;
          } else {
            goto statement_400;
          }
        }
        // C
        // C K+ + (N,N*,D)-bar --> L/S-bar + pi
        if (((lb1 == 23 || lb1 == 30) &&
             (lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6))) ||
            ((lb2 == 23 || lb2 == 30) &&
             (lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)))) {
          bmass = 0.938f;
          if (srt <= (bmass + aka)) {
            pkaon = 0.f;
          } else {
            pkaon = fem::sqrt(fem::pow2(((fem::pow2(srt) -
                                          (fem::pow2(aka) + fem::pow2(bmass))) /
                                         2.f / bmass)) -
                              fem::pow2(aka));
          }
          // Clin-10/31/02 cross sections are isospin-averaged, same as those in
          // newka C     for K- + (N,N*,D) --> L/S + pi:
          sigela = 0.5f * (akpel(pkaon) + aknel(pkaon));
          sigsgm = 1.5f * akpsgm(pkaon) + aknsgm(pkaon);
          sig = sigela + sigsgm + akplam(pkaon);
          if (sig > 1.e-7f) {
            // C     ! K+ + N-bar reactions
            icase = 3;
            brel = sigela / sig;
            brsgm = sigsgm / sig;
            brsig = sig;
            nchrg = 1;
            goto statement_3555;
          }
          goto statement_400;
        }
        // C
        // C  meson + hyperon-bar -> K+ + N-bar
        if (((lb1 >= -17 && lb1 <= -14) && (lb2 >= 3 && lb2 <= 5)) ||
            ((lb2 >= -17 && lb2 <= -14) && (lb1 >= 3 && lb1 <= 5))) {
          nchrg = -100;
          // C
          // C*       first classify the reactions due to total charge.
          if ((lb1 == -15 && (lb2 == 5 || lb2 == 27)) ||
              (lb2 == -15 && (lb1 == 5 || lb1 == 27))) {
            nchrg = -2;
            // C     ! D-(bar)
            bmass = 1.232f;
            goto statement_110;
          }
          if ((lb1 == -15 &&
               (lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28)) ||
              (lb2 == -15 &&
               (lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28)) ||
              ((lb1 == -14 || lb1 == -16) && (lb2 == 5 || lb2 == 27)) ||
              ((lb2 == -14 || lb2 == -16) && (lb1 == 5 || lb1 == 27))) {
            nchrg = -1;
            // C     ! n-bar
            bmass = 0.938f;
            goto statement_110;
          }
          if ((lb1 == -15 && (lb2 == 3 || lb2 == 25)) ||
              (lb2 == -15 && (lb1 == 3 || lb1 == 25)) ||
              (lb1 == -17 && (lb2 == 5 || lb2 == 27)) ||
              (lb2 == -17 && (lb1 == 5 || lb1 == 27)) ||
              ((lb1 == -14 || lb1 == -16) &&
               (lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28)) ||
              ((lb2 == -14 || lb2 == -16) &&
               (lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28))) {
            nchrg = 0;
            // C     ! p-bar
            bmass = 0.938f;
            goto statement_110;
          }
          if ((lb1 == -17 &&
               (lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28)) ||
              (lb2 == -17 &&
               (lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28)) ||
              ((lb1 == -14 || lb1 == -16) && (lb2 == 3 || lb2 == 25)) ||
              ((lb2 == -14 || lb2 == -16) && (lb1 == 3 || lb1 == 25))) {
            nchrg = 1;
            // C     ! D++(bar)
            bmass = 1.232f;
          }
        // C
        // C 110     if(nchrg.ne.-100.and.srt.ge.(aka+bmass))then !! for elastic
        statement_110:
          sig = 0.f;
          // C !! for elastic
          if (nchrg != -100 && srt >= (aka + bmass)) {
            // Cc110        if(nchrg.eq.-100.or.srt.lt.(aka+bmass)) go to 400
            // C             ! PI + La(Si)-bar => K+ + N-bar reactions
            icase = 4;
            // Cc pkaon=sqrt(((srt**2-(aka**2+bmass**2))/2./bmass)**2-aka**2)
            pkaon =
                fem::sqrt(fem::pow2(((fem::pow2(srt) -
                                      (fem::pow2(aka) + fem::pow2(0.938f))) /
                                     2.f / 0.938f)) -
                          fem::pow2(aka));
            // C ! lambda-bar + Pi
            if (lb1 == -14 || lb2 == -14) {
              if (nchrg >= 0) {
                sigma0 = akplam(pkaon);
              }
              if (nchrg < 0) {
                sigma0 = aknlam(pkaon);
              }
              // C                ! sigma-bar + pi
            } else {
              // C !K-p or K-D++
              if (nchrg >= 0) {
                sigma0 = akpsgm(pkaon);
              }
              // C !K-n or K-D-
              if (nchrg < 0) {
                sigma0 = aknsgm(pkaon);
              }
              sigma0 = 1.5f * akpsgm(pkaon) + aknsgm(pkaon);
            }
            sig = (fem::pow2(srt) - fem::pow2((aka + bmass))) *
                  (fem::pow2(srt) - fem::pow2((aka - bmass))) /
                  (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                  (fem::pow2(srt) - fem::pow2((em1 - em2))) * sigma0;
            // C ! K0barD++, K-D-
            if (nchrg == -2 || nchrg == 2) {
              sig = 2.f * sig;
            }
            // C*     the factor 2 comes from spin of delta, which is 3/2
            // C*     detailed balance. copy from Page 423 of N.P. A614 1997
            if (lb1 == -14 || lb2 == -14) {
              sig = 4.0f / 3.0f * sig;
            } else if (nchrg == -2 || nchrg == 2) {
              sig = 8.0f / 9.0f * sig;
            } else {
              sig = 4.0f / 9.0f * sig;
            }
            // Cc        brel=0.
            // Cc        brsgm=0.
            // Cc        brsig = sig
            // Cc          if(sig.lt.1.e-7) go to 400
            // C-
          }
          // C                ! PI + La(Si)-bar => elastic included
          icase = 4;
          sigela = 10.f;
          sig += sigela;
          brel = sigela / sig;
          brsgm = 0.f;
          brsig = sig;
          // C-
          goto statement_3555;
        }
        // C
        // C* MULTISTRANGE PARTICLE (Cas,Omega -bar) PRODUCTION -
        // (NON)PERTURBATIVE
        // C
        // C K-/K*0bar + La/Si --> cascade + pi/eta
        if (((lb1 == 21 || lb1 == -30) && (lb2 >= 14 && lb2 <= 17)) ||
            ((lb2 == 21 || lb2 == -30) && (lb1 >= 14 && lb1 <= 17))) {
          kp = 0;
          goto statement_3455;
        }
        // C K+/K*0 + La/Si(bar) --> cascade-bar + pi/eta
        if (((lb1 == 23 || lb1 == 30) && (lb2 <= -14 && lb2 >= -17)) ||
            ((lb2 == 23 || lb2 == 30) && (lb1 <= -14 && lb1 >= -17))) {
          kp = 1;
          goto statement_3455;
        }
        // C K-/K*0bar + cascade --> omega + pi
        if (((lb1 == 21 || lb1 == -30) && (lb2 == 40 || lb2 == 41)) ||
            ((lb2 == 21 || lb2 == -30) && (lb1 == 40 || lb1 == 41))) {
          kp = 0;
          goto statement_3455;
        }
        // C K+/K*0 + cascade-bar --> omega-bar + pi
        if (((lb1 == 23 || lb1 == 30) && (lb2 == -40 || lb2 == -41)) ||
            ((lb2 == 23 || lb2 == 30) && (lb1 == -40 || lb1 == -41))) {
          kp = 1;
          goto statement_3455;
        }
        // C Omega + Omega --> Di-Omega + photon(eta)
        // Cc        if( lb1.eq.45.and.lb2.eq.45 ) go to 3455
        // C
        // C annhilation of cascade(bar), omega(bar)
        kp = 3;
        // C K- + L/S <-- cascade(bar) + pi/eta
        if ((((lb1 >= 3 && lb1 <= 5) || lb1 == 0) &&
             (fem::iabs(lb2) == 40 || fem::iabs(lb2) == 41)) ||
            (((lb2 >= 3 && lb2 <= 5) || lb2 == 0) &&
             (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41))) {
          goto statement_3455;
        }
        // C K- + cascade(bar) <-- omega(bar) + pi
        // C         if(  (lb1.eq.0.and.iabs(lb2).eq.45)
        // C    &       .OR. (lb2.eq.0.and.iabs(lb1).eq.45) )go to 3455
        if (((lb1 >= 3 && lb1 <= 5) && fem::iabs(lb2) == 45) ||
            ((lb2 >= 3 && lb2 <= 5) && fem::iabs(lb1) == 45)) {
          goto statement_3455;
        }
        // C
        // C**  MULTISTRANGE PARTICLE PRODUCTION  (END)
        // C
        // C* K+ + La(Si) --> Meson + B
        if (lb1 == 23 && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_5699;
        }
        if (lb2 == 23 && (lb1 >= 14 && lb1 <= 17)) {
          goto statement_5699;
        }
        // C* K- + La(Si)-bar --> Meson + B-bar
        if (lb1 == 21 && (lb2 >= -17 && lb2 <= -14)) {
          goto statement_5699;
        }
        if (lb2 == 21 && (lb1 >= -17 && lb1 <= -14)) {
          goto statement_5699;
        }
        // C
        // C La/Si-bar + B --> pi + K+
        if ((((lb1 == 1 || lb1 == 2) || (lb1 >= 6 && lb1 <= 13)) &&
             (lb2 >= -17 && lb2 <= -14)) ||
            (((lb2 == 1 || lb2 == 2) || (lb2 >= 6 && lb2 <= 13)) &&
             (lb1 >= -17 && lb1 <= -14))) {
          goto statement_5999;
        }
        // C La/Si + B-bar --> pi + K-
        if ((((lb1 == -1 || lb1 == -2) || (lb1 <= -6 && lb1 >= -13)) &&
             (lb2 >= 14 && lb2 <= 17)) ||
            (((lb2 == -1 || lb2 == -2) || (lb2 <= -6 && lb2 >= -13)) &&
             (lb1 >= 14 && lb1 <= 17))) {
          goto statement_5999;
        }
        // C
        // C K(K*) + Kbar(K*bar) --> phi + pi(rho,omega), M + M
        // (M=pi,rho,omega,eta)
        if (lb1 == 21 && lb2 == 23) {
          goto statement_8699;
        }
        if (lb2 == 21 && lb1 == 23) {
          goto statement_8699;
        }
        if (lb1 == 30 && lb2 == 21) {
          goto statement_8699;
        }
        if (lb2 == 30 && lb1 == 21) {
          goto statement_8699;
        }
        if (lb1 == -30 && lb2 == 23) {
          goto statement_8699;
        }
        if (lb2 == -30 && lb1 == 23) {
          goto statement_8699;
        }
        if (lb1 == -30 && lb2 == 30) {
          goto statement_8699;
        }
        if (lb2 == -30 && lb1 == 30) {
          goto statement_8699;
        }
        // C* (K,K*)-bar + rho(omega) --> phi +(K,K*)-bar, piK and elastic
        if (((lb1 == 23 || lb1 == 21 || fem::iabs(lb1) == 30) &&
             (lb2 >= 25 && lb2 <= 28)) ||
            ((lb2 == 23 || lb2 == 21 || fem::iabs(lb2) == 30) &&
             (lb1 >= 25 && lb1 <= 28))) {
          goto statement_8799;
        }
        // C
        // C* K*(-bar) + pi --> phi + (K,K*)-bar
        if ((fem::iabs(lb1) == 30 && (lb2 >= 3 && lb2 <= 5)) ||
            (fem::iabs(lb2) == 30 && (lb1 >= 3 && lb1 <= 5))) {
          goto statement_8799;
        }
        // C
        // C* phi + N --> pi+N(D),  rho+N(D),  K+ +La
        // C* phi + D --> pi+N(D),  rho+N(D)
        if ((lb1 == 29 && (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 9))) ||
            (lb2 == 29 && (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 9)))) {
          goto statement_7222;
        }
        // C
        // C* phi + (pi,rho,ome,K,K*-bar) --> K+K, K+K*, K*+K*,
        // (pi,rho,omega)+(K,K*-bar)
        if ((lb1 == 29 && ((lb2 >= 3 && lb2 <= 5) || (lb2 >= 21 && lb2 <= 28) ||
                           fem::iabs(lb2) == 30)) ||
            (lb2 == 29 && ((lb1 >= 3 && lb1 <= 5) || (lb1 >= 21 && lb1 <= 28) ||
                           fem::iabs(lb1) == 30))) {
          goto statement_7444;
        }
        // C
        // C La/Si, Cas, Om (bar)-(rho,omega,phi) elastic colln
        // C pion vs. La, Ca, Omega-(bar) elastic coll. treated in resp.
        // subroutines
        if (((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
             fem::iabs(lb1) >= 40) &&
            ((lb2 >= 25 && lb2 <= 29) || lb2 == 0)) {
          goto statement_888;
        }
        if (((fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17) ||
             fem::iabs(lb2) >= 40) &&
            ((lb1 >= 25 && lb1 <= 29) || lb1 == 0)) {
          goto statement_888;
        }
        // C
        // C K+/K* (N,R)  OR   K-/K*- (N,R)-bar  elastic scatt
        if (((lb1 == 23 || lb1 == 30) &&
             (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13))) ||
            ((lb2 == 23 || lb2 == 30) &&
             (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 13)))) {
          goto statement_888;
        }
        if (((lb1 == 21 || lb1 == -30) &&
             (lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6))) ||
            ((lb2 == 21 || lb2 == -30) &&
             (lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)))) {
          goto statement_888;
        }
        // C
        // C L/S-baryon elastic collision
        if (((lb1 >= 14 && lb1 <= 17) && (lb2 >= 6 && lb2 <= 13)) ||
            ((lb2 >= 14 && lb2 <= 17) && (lb1 >= 6 && lb1 <= 13))) {
          goto statement_7799;
        }
        if (((lb1 <= -14 && lb1 >= -17) && (lb2 <= -6 && lb2 >= -13)) ||
            ((lb2 <= -14 && lb2 >= -17) && (lb1 <= -6 && lb1 >= -13))) {
          goto statement_7799;
        }
        // C
        // C skip other collns with perturbative particles or hyperon-bar
        if (fem::iabs(lb1) >= 40 || fem::iabs(lb2) >= 40 ||
            (lb1 <= -14 && lb1 >= -17) || (lb2 <= -14 && lb2 >= -17)) {
          goto statement_400;
        }
        // C
        // C anti-baryon on baryon resonaces
        if ((lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)) &&
            (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13))) {
          goto statement_2799;
        } else if ((lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6)) &&
                   (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 13))) {
          goto statement_2799;
        }
        // C
        // Clin-10/25/02 get rid of argument usage mismatch in newka():
        inewka = irun;
        // C        call newka(icase,irun,iseed,dt,nt,
        // Clin-5/01/03 set iblock value in art1f.f, necessary for resonance
        // studies: C        call newka(icase,inewka,iseed,dt,nt, C     &
        // ictrl,i1,i2,srt,pcx,pcy,pcz)
        newka(icase, inewka, iseed, dt, nt, ictrl, i1, i2, srt, pcx, pcy, pcz,
              iblock);
        // C
        // Clin-10/25/02-end
        if (ictrl == 1) {
          goto statement_400;
        }
        // C
        // C SEPARATE NUCLEON+NUCLEON( BARYON RESONANCE+ BARYON RESONANCE
        // ELASTIC C COLLISION), BARYON RESONANCE+NUCLEON AND BARYON-PION C
        // COLLISIONS INTO THREE PARTS TO CHECK IF THEY ARE GOING TO SCATTER, C
        // WE only allow L/S to COLLIDE elastically with a nucleon and meson
        if ((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
            (fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17)) {
          goto statement_400;
        }
        // C IF PION+PION COLLISIONS GO TO 777
        // C if pion+eta, eta+eta to create kaons go to 777
        if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_777;
        }
        if (lb1 == 0 && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_777;
        }
        if (lb2 == 0 && (lb1 >= 3 && lb1 <= 5)) {
          goto statement_777;
        }
        if (lb1 == 0 && lb2 == 0) {
          goto statement_777;
        }
        // C we assume that rho and omega behave the same way as pions in
        // C kaon production
        // C (1) rho(omega)+rho(omega)
        if ((lb1 >= 25 && lb1 <= 28) && (lb2 >= 25 && lb2 <= 28)) {
          goto statement_777;
        }
        // C (2) rho(omega)+pion
        if ((lb1 >= 25 && lb1 <= 28) && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_777;
        }
        if ((lb2 >= 25 && lb2 <= 28) && (lb1 >= 3 && lb1 <= 5)) {
          goto statement_777;
        }
        // C (3) rho(omega)+eta
        if ((lb1 >= 25 && lb1 <= 28) && lb2 == 0) {
          goto statement_777;
        }
        if ((lb2 >= 25 && lb2 <= 28) && lb1 == 0) {
          goto statement_777;
        }
        // C
        // C if kaon+pion collisions go to 889
        if ((lb1 == 23 || lb1 == 21) && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_889;
        }
        if ((lb2 == 23 || lb2 == 21) && (lb1 >= 3 && lb1 <= 5)) {
          goto statement_889;
        }
        // C
        // Clin-2/06/03 skip all other (K K* Kbar K*bar) channels:
        // C SKIP all other K and K* RESCATTERINGS
        if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
          goto statement_400;
        }
        if (lb1 == 21 || lb2 == 21) {
          goto statement_400;
        }
        if (lb1 == 23 || lb2 == 23) {
          goto statement_400;
        }
        // C
        // C IF PION+baryon COLLISION GO TO 3
        if ((lb1 >= 3 && lb1 <= 5) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
             (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_3;
        }
        if ((lb2 >= 3 && lb2 <= 5) &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_3;
        }
        // C
        // C IF rho(omega)+NUCLEON (baryon resonance) COLLISION GO TO 33
        if ((lb1 >= 25 && lb1 <= 28) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
             (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_33;
        }
        if ((lb2 >= 25 && lb2 <= 28) &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_33;
        }
        // C
        // C IF ETA+NUCLEON (baryon resonance) COLLISIONS GO TO 547
        if (lb1 == 0 && (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
                         (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_547;
        }
        if (lb2 == 0 && (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
                         (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_547;
        }
        // C
        // C IF NUCLEON+BARYON RESONANCE COLLISION GO TO 44
        if ((lb1 == 1 || lb1 == 2) && (lb2 > 5 && lb2 <= 13)) {
          goto statement_44;
        }
        if ((lb2 == 1 || lb2 == 2) && (lb1 > 5 && lb1 <= 13)) {
          goto statement_44;
        }
        if ((lb1 == -1 || lb1 == -2) && (lb2 < -5 && lb2 >= -13)) {
          goto statement_44;
        }
        if ((lb2 == -1 || lb2 == -2) && (lb1 < -5 && lb1 >= -13)) {
          goto statement_44;
        }
        // C
        // C IF NUCLEON+NUCLEON COLLISION GO TO 4
        if ((lb1 == 1 || lb1 == 2) && (lb2 == 1 || lb2 == 2)) {
          goto statement_4;
        }
        if ((lb1 == -1 || lb1 == -2) && (lb2 == -1 || lb2 == -2)) {
          goto statement_4;
        }
        // C
        // C IF BARYON RESONANCE+BARYON RESONANCE COLLISION GO TO 444
        if ((lb1 > 5 && lb1 <= 13) && (lb2 > 5 && lb2 <= 13)) {
          goto statement_444;
        }
        if ((lb1 < -5 && lb1 >= -13) && (lb2 < -5 && lb2 >= -13)) {
          goto statement_444;
        }
        // C
        // C if L/S+L/S or L/s+nucleon go to 400
        // C otherwise, develop a model for their collisions
        if ((lb1 < 3) && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_400;
        }
        if ((lb2 < 3) && (lb1 >= 14 && lb1 <= 17)) {
          goto statement_400;
        }
        if ((lb1 >= 14 && lb1 <= 17) && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_400;
        }
        // C
        // C otherwise, go out of the loop
        goto statement_400;
      // C
      statement_547:
        if (lb1 * lb2 == 0) {
          // C (1) FOR ETA+NUCLEON SYSTEM, we allow both elastic collision,
          // C     i.e. N*(1535) formation and kaon production
          // C     the total kaon production cross section is
          // C     ASSUMED to be THE SAME AS PION+NUCLEON COLLISIONS
          // C (2) for eta+baryon resonance we only allow kaon production
          ece = fem::pow2((em1 + em2 + 0.02f));
          xkaon0 = 0.f;
          if (srt >= 1.63f && srt <= 1.7f) {
            xkaon0 = pnlka(cmn, srt);
          }
          if (srt > 1.7f) {
            xkaon0 = pnlka(cmn, srt) + pnska(cmn, srt);
          }
          // Cbz3/7/99 neutralk
          xkaon0 = 2.0f * xkaon0;
          // Cbz3/7/99 neutralk end
          // C
          // C Here we negelect eta+n inelastic collisions other than the
          // C kaon production, therefore the total inelastic cross section
          // C xkaon equals to the xkaon0 (kaon production cross section)
          xkaon = xkaon0;
          // C note here the xkaon is in unit of fm**2
          xeta = xn1535(cmn, i1, i2, 0);
          if ((fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13) ||
              (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
            xeta = 0.f;
          }
          if ((xeta + xkaon) <= 1.e-06f) {
            goto statement_400;
          }
          dse = fem::sqrt((xeta + xkaon) / pi);
          deltre = dse + 0.1f;
          px1cm = pcx;
          py1cm = pcy;
          pz1cm = pcz;
          // C CHECK IF N*(1535) resonance CAN BE FORMED
          distce(cmn, i1, i2, deltre, dse, dt, ece, srt, ic, pcx, pcy, pcz);
          if (ic == -1) {
            goto statement_400;
          }
          ekaon(4, iss)++;
          if (xkaon0 / (xkaon + xeta) > ranart(nseed)) {
            // C kaon production, USE CREN TO CALCULATE THE MOMENTUM OF L/S K+
            cren(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
            // C kaon production
            if (iblock == 7) {
              lpn++;
            } else if (iblock == -7) {
            }
            // C
            em1 = e(i1);
            em2 = e(i2);
            goto statement_440;
          }
          // C N*(1535) FORMATION
          resona = 1.f;
          goto statement_98;
        }
      // CIF PION+NUCLEON (baryon resonance) COLLISION THEN
      statement_3:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C the total kaon production cross section for pion+baryon (resonance)
        // is C assumed to be the same as in pion+nucleon
        xkaon0 = 0.f;
        if (srt >= 1.63f && srt <= 1.7f) {
          xkaon0 = pnlka(cmn, srt);
        }
        if (srt > 1.7f) {
          xkaon0 = pnlka(cmn, srt) + pnska(cmn, srt);
        }
        xkaon0 = 2.0f * xkaon0;
        // C
        // C sp11/21/01  phi production: pi +N(D) -> phi + N(D)
        xphi = 0.f;
        if ((((lb1 >= 1 && lb1 <= 2) || (lb1 >= 6 && lb1 <= 9)) ||
             ((lb2 >= 1 && lb2 <= 2) || (lb2 >= 6 && lb2 <= 9))) &&
            srt > 1.958f) {
          pibphi(cmn, srt, lb1, lb2, em1, em2, xphi, xphin);
        }
        // C !! in fm^2 above
        // C
        // C if a pion collide with a baryon resonance,
        // C we only allow kaon production AND the reabsorption
        // C processes: Delta+pion-->N+pion, N*+pion-->N+pion
        // C Later put in pion+baryon resonance elastic
        // C cross through forming higher resonances implicitly.
        // C          If(em1.gt.1.or.em2.gt.1.)go to 31
        if ((fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13) ||
            (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
          goto statement_31;
        }
        // C For pion+nucleon collisions:
        // C using the experimental pion+nucleon inelastic cross section, we
        // assume it C is exhausted by the Delta+pion, Delta+rho and Delta+omega
        // production C and kaon production. In the following we first check
        // whether C inelastic pion+n collision can happen or not, then determine
        // in C crpn whether it is through pion production or through kaon
        // production C note that the xkaon0 is the kaon production cross section
        // C Note in particular that:
        // C xkaon in the following is the total pion+nucleon inelastic cross
        // section C note here the xkaon is in unit of fm**2, xnpi is also in
        // unit of fm**2 C FOR PION+NUCLEON SYSTEM, THE MINIMUM S IS 1.2056 the
        // minimum srt for C elastic scattering, and it is 1.60 for pion
        // production, 1.63 for LAMBDA+kaon C production and 1.7 FOR SIGMA+KAON
        // C (EC = PION MASS+NUCLEON MASS+20MEV)**2
        ec = fem::pow2((em1 + em2 + 0.02f));
        xkaon = 0.f;
        if (srt > 1.23f) {
          xkaon = (pionpp(cmn, srt) + pipp1(cmn, srt)) / 2.f;
        }
        // C pion+nucleon elastic cross section is divided into two parts:
        // C (1) forming D(1232)+N*(1440) +N*(1535)
        // C (2) cross sections forming higher resonances are calculated as
        // C     the difference between the total elastic and (1), this part is
        // C     treated as direct process since we do not explicitLY include
        // C     higher resonances.
        // C the following is the resonance formation cross sections.
        // C1. PION(+)+PROTON-->DELTA++,PION(-)+NEUTRON-->DELTA(-)
        if ((lb1 * lb2 == 5 || ((lb1 * lb2 == 6) && (lb1 == 3 || lb2 == 3))) ||
            (lb1 * lb2 == -3 ||
             ((lb1 * lb2 == -10) && (lb1 == 5 || lb2 == 5)))) {
          xmax = 190.f;
          xmaxn = 0;
          xmaxn1 = 0;
          xdirct = dirct1(cmn, srt);
          goto statement_678;
        }
        // C2. PION(-)+PROTON-->DELTA0,PION(+)+NEUTRON-->DELTA+
        // C   or N*(+)(1440) or N*(+)(1535)
        // C note the factor 2/3 is from the isospin consideration and
        // C the factor 0.6 or 0.5 is the branching ratio for the resonance to
        // decay C into pion+nucleon
        if ((lb1 * lb2 == 3 || ((lb1 * lb2 == 10) && (lb1 == 5 || lb2 == 5))) ||
            (lb1 * lb2 == -5 ||
             ((lb1 * lb2 == -6) && (lb1 == 3 || lb2 == 3)))) {
          xmax = 27.f;
          xmaxn = 2.f / 3.f * 25.f * 0.6f;
          xmaxn1 = 2.f / 3.f * 40.f * 0.5f;
          xdirct = dirct2(cmn, srt);
          goto statement_678;
        }
        // C3. PION0+PROTON-->DELTA+,PION0+NEUTRON-->DELTA0, or N*(0)(1440) or
        // N*(0)(1535)
        if ((lb1 == 4 || lb2 == 4) &&
            (fem::iabs(lb1 * lb2) == 4 || fem::iabs(lb1 * lb2) == 8)) {
          xmax = 50.f;
          xmaxn = 1.f / 3.f * 25 * 0.6f;
          xmaxn1 = 1 / 3.f * 40.f * 0.5f;
          xdirct = dirct3(cmn, srt);
          goto statement_678;
        }
      statement_678:
        xnpin1 = 0;
        xnpin = 0;
        xnpid = xnpi(cmn, i1, i2, 1, xmax);
        if (xmaxn1 != 0) {
          xnpin1 = xnpi(cmn, i1, i2, 2, xmaxn1);
        }
        if (xmaxn != 0) {
          xnpin = xnpi(cmn, i1, i2, 0, xmaxn);
        }
        // C the following
        xres = xnpid + xnpin + xnpin1;
        xnelas = xres + xdirct;
        icheck = 1;
        goto statement_34;
      // C For pion + baryon resonance the reabsorption
      // C cross section is calculated from the detailed balance
      // C using reab(i1,i2,srt,ictrl), ictrl=1, 2 and 3
      // C for pion, rho and omega + baryon resonance
      statement_31:
        ec = fem::pow2((em1 + em2 + 0.02f));
        xreab = reab(cmn, i1, i2, srt, 1);
        // C
        // Clin-12/02/00 to satisfy detailed balance, forbid N* absorptions:
        if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
            (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
          xreab = 0.f;
        }
        // C
        xkaon = xkaon0 + xreab;
        // C a constant of 10 mb IS USED FOR PION + N* RESONANCE,
        if ((fem::iabs(lb1) > 9 && fem::iabs(lb1) <= 13) ||
            (fem::iabs(lb2) > 9 && fem::iabs(lb2) <= 13)) {
          xnelas = 1.0f;
        } else {
          xnelas = dpion(cmn, em1, em2, lb1, lb2, srt);
        }
        icheck = 2;
      statement_34:
        if ((xnelas + xkaon + xphi) <= 0.000001f) {
          goto statement_400;
        }
        ds = fem::sqrt((xnelas + xkaon + xphi) / pi);
        // Csp09/20/01
        // C           totcr = xnelas+xkaon
        // C           if(srt .gt. 3.5)totcr = max1(totcr,3.)
        // C           DS=SQRT(totcr/PI)
        // Csp09/20/01 end
        // C
        deltar = ds + 0.1f;
        distce(cmn, i1, i2, deltar, ds, dt, ec, srt, ic, pcx, pcy, pcz);
        if (ic == -1) {
          goto statement_400;
        }
        ekaon(4, iss)++;
        // C***
        // C check what kind of collision has happened
        // C (1) pion+baryon resonance
        // C if direct elastic process
        if (icheck == 2) {
          // C  !!sp11/21/01
          if (xnelas / (xnelas + xkaon + xphi) >= ranart(nseed)) {
            // C               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2)
            crdir(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
            goto statement_440;
          } else {
            // C for inelastic process, go to 96 to check
            // C kaon production and pion reabsorption : pion+D(N*)-->pion+N
            goto statement_96;
          }
        }
        // C(2) pion+n
        // C CHECK IF inELASTIC COLLISION IS POSSIBLE FOR PION+N COLLISIONS
        // Clin-8/17/00 typo corrected, many other occurences:
        // C        IF(XKAON/(XKAON+Xnelas).GT.RANART(NSEED))GO TO 95
        if ((xkaon + xphi) / (xkaon + xphi + xnelas) > ranart(nseed)) {
          goto statement_95;
        }
        // C
        // C direct process
        if (xdirct / xnelas >= ranart(nseed)) {
          // C               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2)
          crdir(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
          goto statement_440;
        }
        // C now resonance formation or direct process (higher resonances)
        if ((lb1 * lb2 == 5 || ((lb1 * lb2 == 6) && (lb1 == 3 || lb2 == 3))) ||
            (lb1 * lb2 == -3 ||
             ((lb1 * lb2 == -10) && (lb1 == 5 || lb2 == 5)))) {
          // C
          // C ONLY DELTA RESONANCE IS POSSIBLE, go to 99
          goto statement_99;
        } else {
          // C NOW BOTH DELTA AND N* RESORANCE ARE POSSIBLE
          // C DETERMINE THE RESORANT STATE BY USING THE MONTRE CARLO METHOD
          xx = (xnpin + xnpin1) / xres;
          if (ranart(nseed) < xx) {
            // C N* RESONANCE IS SELECTED
            // C decide N*(1440) or N*(1535) formation
            xx0 = xnpin / (xnpin + xnpin1);
            if (ranart(nseed) < xx0) {
              resona = 0.f;
              // C N*(1440) formation
              goto statement_97;
            } else {
              // C N*(1535) formation
              resona = 1.f;
              goto statement_98;
            }
          } else {
            // C DELTA RESONANCE IS SELECTED
            goto statement_99;
          }
        }
      statement_97:
        if (resona == 0.f) {
          // CN*(1440) IS PRODUCED,WE DETERMINE THE CHARGE STATE OF THE PRODUCED
          // N*
          i = i1;
          if (em1 < 0.6f) {
            i = i2;
          }
          // C (0.1) n+pion(+)-->N*(+)
          if ((lb1 * lb2 == 10 && (lb1 == 5 || lb2 == 5)) ||
              (lb1 * lb2 == -6 && (lb1 == 3 || lb2 == 3))) {
            lb(i) = 11;
            goto statement_303;
          }
          // C (0.2) p+pion(0)-->N*(+)
          // C IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 4 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 11;
            goto statement_303;
          }
          // C (0.3) n+pion(0)-->N*(0)
          // C IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 8 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 10;
            goto statement_303;
          }
          // C (0.4) p+pion(-)-->N*(0)
          // C            IF(LB(I1)*LB(I2).EQ.3)THEN
          if ((lb(i1) * lb(i2) == 3) || (lb(i1) * lb(i2) == -5)) {
            lb(i) = 10;
          }
        statement_303:
          dreson(cmn, i1, i2);
          if (lb1 < 0 || lb2 < 0) {
            lb(i) = -lb(i);
          }
          lres++;
          goto statement_101;
          // CCOM: GO TO 101 TO CHANGE THE PHASE SPACE DENSITY OF THE NUCLEON
        }
      statement_98:
        if (resona == 1.f) {
          // CN*(1535) IS PRODUCED, WE DETERMINE THE CHARGE STATE OF THE
          // PRODUCED N*
          i = i1;
          if (em1 < 0.6f) {
            i = i2;
          }
          // C note: this condition applies to both eta and pion
          // C (0.1) n+pion(+)-->N*(+)
          // C            IF(LB1*LB2.EQ.10.AND.(LB1.EQ.2.OR.LB2.EQ.2))THEN
          if ((lb1 * lb2 == 10 && (lb1 == 5 || lb2 == 5)) ||
              (lb1 * lb2 == -6 && (lb1 == 3 || lb2 == 3))) {
            lb(i) = 13;
            goto statement_304;
          }
          // C (0.2) p+pion(0)-->N*(+)
          // C IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 4 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 13;
            goto statement_304;
          }
          // C (0.3) n+pion(0)-->N*(0)
          // C IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 8 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 12;
            goto statement_304;
          }
          // C (0.4) p+pion(-)-->N*(0)
          // C            IF(LB(I1)*LB(I2).EQ.3)THEN
          if ((lb(i1) * lb(i2) == 3) || (lb(i1) * lb(i2) == -5)) {
            lb(i) = 12;
            goto statement_304;
          }
          // C (0.5) p+eta-->N*(+)(1535),n+eta-->N*(0)(1535)
          if (lb(i1) * lb(i2) == 0) {
            // C            if((lb(i1).eq.1).or.(lb(i2).eq.1))then
            if (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1) {
              lb(i) = 13;
              goto statement_304;
            } else {
              lb(i) = 12;
            }
          }
        statement_304:
          dreson(cmn, i1, i2);
          if (lb1 < 0 || lb2 < 0) {
            lb(i) = -lb(i);
          }
          lres++;
          goto statement_101;
          // CCOM: GO TO 101 TO CHANGE THE PHASE SPACE DENSITY OF THE NUCLEON
        }
      // CDELTA IS PRODUCED,IN THE FOLLOWING WE DETERMINE THE
      // CCHARGE STATE OF THE PRODUCED DELTA
      statement_99:
        lres++;
        i = i1;
        if (em1 <= 0.6f) {
          i = i2;
        }
        // C (1) p+pion(+)-->DELTA(++)
        // C        IF(LB(I1)*LB(I2).EQ.5)THEN
        if ((lb(i1) * lb(i2) == 5) || (lb(i1) * lb(i2) == -3)) {
          lb(i) = 9;
          goto statement_305;
        }
        // C (2) p+pion(0)-->delta(+)
        // C        IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))then
        if (fem::iabs(lb(i1) * lb(i2)) == 4 && (lb(i1) == 4 || lb(i2) == 4)) {
          lb(i) = 8;
          goto statement_305;
        }
        // C (3) n+pion(+)-->delta(+)
        // C        IF(LB(I1)*LB(I2).EQ.10.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
        if ((lb(i1) * lb(i2) == 10 && (lb(i1) == 5 || lb(i2) == 5)) ||
            (lb(i1) * lb(i2) == -6 && (lb(i1) == 3 || lb(i2) == 3))) {
          lb(i) = 8;
          goto statement_305;
        }
        // C (4) n+pion(0)-->delta(0)
        // C        IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
        if (fem::iabs(lb(i1) * lb(i2)) == 8 && (lb(i1) == 4 || lb(i2) == 4)) {
          lb(i) = 7;
          goto statement_305;
        }
        // C (5) p+pion(-)-->delta(0)
        // C        IF(LB(I1)*LB(I2).EQ.3)THEN
        if ((lb(i1) * lb(i2) == 3) || (lb(i1) * lb(i2) == -5)) {
          lb(i) = 7;
          goto statement_305;
        }
        // C (6) n+pion(-)-->delta(-)
        // C        IF(LB(I1)*LB(I2).EQ.6.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
        if ((lb(i1) * lb(i2) == 6 && (lb(i1) == 3 || lb(i2) == 3)) ||
            (lb(i1) * lb(i2) == -10 && (lb(i1) == 5 || lb(i2) == 5))) {
          lb(i) = 6;
        }
      statement_305:
        dreson(cmn, i1, i2);
        if (lb1 < 0 || lb2 < 0) {
          lb(i) = -lb(i);
        }
        goto statement_101;
      // C
      // Csp-11/08/01 K*
      // C FOR kaON+pion COLLISIONS, form K* (bar) or
      // C La/Si-bar + N <-- pi + K+
      // C La/Si + N-bar <-- pi + K-
      // C phi + K <-- pi + K
      // Clin (rho,omega) + K* <-- pi + K
      statement_889:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        // C the cross section is from C.M. Ko, PRC 23, 2760 (1981).
        spika =
            60.f / (1.f + 4.f * fem::pow2((srt - 0.895f)) / fem::pow2((0.05f)));
        // C
        // Cc       if(lb(i1).eq.23.or.lb(i2).eq.23)then   !! block  K- + pi->La
        // + B-bar
        // C
        crkpla(cmn, px1cm, py1cm, pz1cm, ec, srt, spika, emm1, emm2, lbp1, lbp2,
               i1, i2, icase, srhoks);
        // Cc
        // C* only K* or K*bar formation
        // C       else
        // C      DSkn=SQRT(spika/PI/10.)
        // C      dsknr=dskn+0.1
        // C      CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
        // C    1     PX1CM,PY1CM,PZ1CM)
        // C        IF(IC.EQ.-1) GO TO 400
        // C       icase = 1
        // C      endif
        // C
        if (icase == 0) {
          iblock = 0;
          goto statement_400;
        }
        // C
        if (icase == 1) {
          ksreso(cmn, i1, i2);
          // Clin-4/30/03 give non-zero iblock for resonance selections:
          iblock = 171;
          // Ctest off for resonance (phi, K*) studies:
          // C             if(iabs(lb(i1)).eq.30) then
          // C             write(17,112)
          // 'ks',lb(i1),p(1,i1),p(2,i1),p(3,i1),e(i1),nt C
          // elseif(iabs(lb(i2)).eq.30) then C             write(17,112)
          // 'ks',lb(i2),p(1,i2),p(2,i2),p(3,i2),e(i2),nt C             endif
          // C
          lres++;
          goto statement_101;
        } else if (icase == 2) {
          iblock = 71;
          // C
          // C La/Si (bar) formation
          // C
        } else if (fem::iabs(icase) == 5) {
          iblock = 88;
          // C
        } else {
          // C
          // C phi formation
          iblock = 222;
        }
        lb(i1) = lbp1;
        lb(i2) = lbp2;
        e(i1) = emm1;
        e(i2) = emm2;
        em1 = e(i1);
        em2 = e(i2);
        ntag = 0;
        goto statement_440;
      // C
      statement_33:
        em1 = e(i1);
        em2 = e(i2);
        // C (1) if rho or omega collide with a nucleon we allow both elastic
        // C     scattering and kaon production to happen if collision
        // conditions C     are satisfied. C (2) if rho or omega collide with a
        // baryon resonance we allow C     kaon production, pion reabsorption:
        // rho(omega)+D(N*)-->pion+N C     and NO elastic scattering to happen
        xelstc = 0;
        if ((lb1 >= 25 && lb1 <= 28) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2)) {
          xelstc = erhon(cmn, em1, em2, lb1, lb2, srt);
        }
        if ((lb2 >= 25 && lb2 <= 28) &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2)) {
          xelstc = erhon(cmn, em1, em2, lb1, lb2, srt);
        }
        ec = fem::pow2((em1 + em2 + 0.02f));
        // C the kaon production cross section is
        xkaon0 = 0;
        if (srt >= 1.63f && srt <= 1.7f) {
          xkaon0 = pnlka(cmn, srt);
        }
        if (srt > 1.7f) {
          xkaon0 = pnlka(cmn, srt) + pnska(cmn, srt);
        }
        if (xkaon0 < 0) {
          xkaon0 = 0;
        }
        // C
        // Cbz3/7/99 neutralk
        xkaon0 = 2.0f * xkaon0;
        // Cbz3/7/99 neutralk end
        // C
        // C the total inelastic cross section for rho(omega)+N is
        xkaon = xkaon0;
        ichann = 0;
        // C the total inelastic cross section for rho (omega)+D(N*) is
        // C xkaon=xkaon0+reab(**)
        // C
        // C sp11/21/01  phi production: rho + N(D) -> phi + N(D)
        xphi = 0.f;
        if (((((lb1 >= 1 && lb1 <= 2) || (lb1 >= 6 && lb1 <= 9)) &&
              (lb2 >= 25 && lb2 <= 27)) ||
             (((lb2 >= 1 && lb2 <= 2) || (lb2 >= 6 && lb2 <= 9)) &&
              (lb1 >= 25 && lb1 <= 27))) &&
            srt > 1.958f) {
          pibphi(cmn, srt, lb1, lb2, em1, em2, xphi, xphin);
        }
        // C !! in fm^2 above
        // C
        if ((fem::iabs(lb1) >= 6 && lb2 >= 25) ||
            (lb1 >= 25 && fem::iabs(lb2) >= 6)) {
          ichann = 1;
          ictrl = 2;
          if (lb1 == 28 || lb2 == 28) {
            ictrl = 3;
          }
          xreab = reab(cmn, i1, i2, srt, ictrl);
          // C
          // Clin-12/02/00 to satisfy detailed balance, forbid N* absorptions:
          if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
              (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
            xreab = 0.f;
          }
          // C
          if (xreab < 0) {
            xreab = 1.e-06f;
          }
          xkaon = xkaon0 + xreab;
          xelstc = 1.0f;
        }
        ds = fem::sqrt((xkaon + xphi + xelstc) / pi);
        // C
        // Csp09/20/01
        // C           totcr = xelstc+xkaon
        // C           if(srt .gt. 3.5)totcr = max1(totcr,3.)
        // C           DS=SQRT(totcr/PI)
        // Csp09/20/01 end
        // C
        deltar = ds + 0.1f;
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C CHECK IF the collision can happen
        distce(cmn, i1, i2, deltar, ds, dt, ec, srt, ic, pcx, pcy, pcz);
        if (ic == -1) {
          goto statement_400;
        }
        ekaon(4, iss)++;
        // C*
        // C NOW rho(omega)+N or D(N*) COLLISION IS POSSIBLE
        // C (1) check elastic collision
        if (xelstc / (xelstc + xkaon + xphi) > ranart(nseed)) {
          // C       call crdir(px1CM,py1CM,pz1CM,srt,I1,i2)
          crdir(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
          goto statement_440;
        }
        // C (2) check pion absorption or kaon production
        crrd(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, xkaon0, xkaon, xphi,
             xphin);
        // C
        // C kaon production
        // Csp05/16/01
        if (iblock == 7) {
          lpn++;
        } else if (iblock == -7) {
        }
        // Csp05/16/01 end
        // C rho obsorption
        if (iblock == 81) {
          lrhor++;
        }
        // C omega obsorption
        if (iblock == 82) {
          lomgar++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C for pion+n now using the subroutine crpn to change
      // C the particle label and set the new momentum of L/S+K final state
      statement_95:
        // C NOW PION+N INELASTIC COLLISION IS POSSIBLE
        // C check pion production or kaon production
        crpn(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, xkaon0, xkaon, xphi,
             xphin);
        // C
        // C kaon production
        // Csp05/16/01
        if (iblock == 7) {
          lpn++;
        } else if (iblock == -7) {
        }
        // Csp05/16/01 end
        // C pion production
        if (iblock == 77) {
          lpd++;
        }
        // C rho production
        if (iblock == 78) {
          lrho++;
        }
        // C omega production
        if (iblock == 79) {
          lomega++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C for pion+D(N*) now using the subroutine crpd to
      // C (1) check kaon production or pion reabsorption
      // C (2) change the particle label and set the new
      // C     momentum of L/S+K final state
      statement_96:
        crpd(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, xkaon0, xkaon, xphi,
             xphin);
        // C
        // C kaon production
        // Csp05/16/01
        if (iblock == 7) {
          lpn++;
        } else if (iblock == -7) {
        }
        // Csp05/16/01 end
        // C pion obserption
        if (iblock == 80) {
          lpdr++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C CALCULATE KAON PRODUCTION PROBABILITY FROM PION + N COLLISIONS
      // C        IF(SRT.GT.1.615)THEN
      // C        CALL PKAON(SRT,XXp,PK)
      // C        TKAON(7)=TKAON(7)+PK
      // C        EKAON(7,ISS)=EKAON(7,ISS)+1
      // C        CALL KSPEC1(SRT,PK)
      // C        call LK(3,srt,iseed,pk)
      // C        ENDIF
      // C negelecting the pauli blocking at high energies
      // C
      statement_101:
        if (e(i2) == 0.f) {
          goto statement_600;
        }
        if (e(i1) == 0.f) {
          goto statement_800;
        }
      // C IF NUCLEON+BARYON RESONANCE COLLISIONS
      statement_44:
        // C CALCULATE THE TOTAL CROSS SECTION OF NUCLEON+ BARYON RESONANCE
        // COLLISION C WE ASSUME THAT THE ELASTIC CROSS SECTION IS THE SAME AS
        // NUCLEON+NUCLEON C COM: WE USE THE PARAMETERISATION BY CUGNON FOR LOW
        // ENERGIES C      AND THE PARAMETERIZATIONS FROM CERN DATA BOOK FOR
        // HIGHER C      ENERGIES. THE CUTOFF FOR THE TOTAL CROSS SECTION IS 55
        // MB
        cutoff = em1 + em2 + 0.02f;
        if (srt <= cutoff) {
          goto statement_400;
        }
        if (srt > 2.245f) {
          signn = pp2(cmn, srt);
        } else {
          signn = 35.0f / (1.f + (srt - cutoff) * 100.0f) + 20.0f;
        }
        xnd(cmn, pcx, pcy, pcz, srt, i1, i2, xinel, sigk, xsk1, xsk2, xsk3,
            xsk4, xsk5);
        sig = signn + xinel;
        // C For nucleon+baryon resonance collision, the minimum cms**2 energy
        // is
        ec = fem::pow2((em1 + em2 + 0.02f));
        // C CHECK THE DISTENCE BETWEEN THE TWO PARTICLES
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C
        // Clin-6/2008 Deuteron production:
        ianti = 0;
        if (lb(i1) < 0 && lb(i2) < 0) {
          ianti = 1;
        }
        sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
        sig += sdprod;
        // Clin-6/2008 perturbative treatment of deuterons:
        ipdflag = 0;
        if (idpert == 1) {
          ipert1 = 1;
          sigr0 = sig;
          dspert = fem::sqrt(sigr0 / pi / 10.f);
          dsrpert = dspert + 0.1f;
          distce(cmn, i1, i2, dsrpert, dspert, dt, ec, srt, ic, px1cm, py1cm,
                 pz1cm);
          if (ic == -1) {
            goto statement_363;
          }
          signn0 = 0.f;
          crnd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, signn0,
               sigr0, sigk, xsk1, xsk2, xsk3, xsk4, xsk5, nt, ipert1);
          // C     &  IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
          ipdflag = 1;
        statement_363:
          ipert1 = 0;
        }
        if (idpert == 2) {
          ipert1 = 1;
        }
        // C
        ds = fem::sqrt(sig / (10.f * pi));
        deltar = ds + 0.1f;
        distce(cmn, i1, i2, deltar, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        // C        IF(IC.EQ.-1)GO TO 400
        if (ic == -1) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        // C
        ekaon(3, iss)++;
        // C CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON + BARYON
        // RESONANCE C COLLISIONS
        goto statement_361;
      // C
      // C CHECK WHAT KIND OF COLLISION HAS HAPPENED
      statement_361:
        crnd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, signn, sig,
             sigk, xsk1, xsk2, xsk3, xsk4, xsk5, nt, ipert1);
        // C     &  IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
        if (iblock == 0 && ipdflag == 1) {
          iblock = 501;
        }
        if (iblock == 11) {
          lndk++;
          goto statement_400;
          // C        elseIF(IBLOCK.EQ.-11) then
        } else if (iblock == -11 || iblock == 501) {
          goto statement_400;
        }
        if (iblock == 222) {
          // C    !! sp12/17/01
          goto statement_400;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C IF NUCLEON+NUCLEON OR BARYON RESONANCE+BARYON RESONANCE COLLISIONS
      statement_4:
        // C PREPARE THE EALSTIC CROSS SECTION FOR BARYON+BARYON COLLISIONS
        // C COM: WE USE THE PARAMETERISATION BY CUGNON FOR SRT LEQ 2.0 GEV
        // C      AND THE PARAMETERIZATIONS FROM CERN DATA BOOK FOR HIGHER
        // C      ENERGIES. THE CUTOFF FOR THE TOTAL CROSS SECTION IS 55 MB
        // C      WITH LOW-ENERGY-CUTOFF
        cutoff = em1 + em2 + 0.14f;
        // C AT HIGH ENERGIES THE ISOSPIN DEPENDENCE IS NEGLIGIBLE
        // C THE TOTAL CROSS SECTION IS TAKEN AS THAT OF THE PP
        // C ABOVE E_KIN=800 MEV, WE USE THE ISOSPIN INDEPENDNET XSECTION
        if (srt > 2.245f) {
          sig = ppt(cmn, srt);
          signn = sig - pp1(cmn, srt);
        } else {
          // C AT LOW ENERGIES THE ISOSPIN DEPENDENCE FOR NN COLLISION IS STRONG
          sig = xpp(cmn, srt);
          if (zet(lb(i1)) * zet(lb(i2)) <= 0) {
            sig = xnp(cmn, srt);
          }
          if (zet(lb(i1)) * zet(lb(i2)) > 0) {
            sig = xpp(cmn, srt);
          }
          if (zet(lb(i1)) == 0 && zet(lb(i2)) == 0) {
            sig = xpp(cmn, srt);
          }
          if ((lb(i1) == -1 && lb(i2) == -2) ||
              (lb(i2) == -1 && lb(i1) == -2)) {
            sig = xnp(cmn, srt);
          }
          // C     WITH LOW-ENERGY-CUTOFF
          if (srt < 1.897f) {
            signn = sig;
          } else {
            signn = 35.0f / (1.f + (srt - 1.897f) * 100.0f) + 20.0f;
          }
        }
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // Clin-5/2008 Deuteron production cross sections were not included
        // C     in the previous parameterized inelastic cross section of NN
        // collisions C     (SIGinel=SIG-SIGNN), so they are added here:
        ianti = 0;
        if (lb(i1) < 0 && lb(i2) < 0) {
          ianti = 1;
        }
        sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
        sig += sdprod;
        // C
        // Clin-5/2008 perturbative treatment of deuterons:
        ipdflag = 0;
        if (idpert == 1) {
          // C     For idpert=1: ipert1=1 means we will first treat deuteron
          // perturbatively, C     then we set ipert1=0 to treat regular NN or
          // NbarNbar collisions including C     the regular deuteron
          // productions. C     ipdflag=1 means perturbative deuterons are
          // produced here:
          ipert1 = 1;
          ec = fem::pow2(2.012f);
          // C     Use the same cross section for NN/NNBAR collisions
          // C     to trigger perturbative production
          sigr0 = sig;
          // C     One can also trigger with X*sbbdm() so the weight will not be
          // too small; C     but make sure to limit the maximum trigger Xsec: C
          // sigr0=sdprod*25. C           if(sigr0.ge.100.) sigr0=100.
          dspert = fem::sqrt(sigr0 / pi / 10.f);
          dsrpert = dspert + 0.1f;
          distce(cmn, i1, i2, dsrpert, dspert, dt, ec, srt, ic, px1cm, py1cm,
                 pz1cm);
          if (ic == -1) {
            goto statement_365;
          }
          signn0 = 0.f;
          crnn(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag,
               signn0, sigr0, nt, ipert1);
          ipdflag = 1;
        statement_365:
          ipert1 = 0;
        }
        if (idpert == 2) {
          ipert1 = 1;
        }
        // C
        // Clin-5/2008 in case perturbative deuterons are produced for idpert=1:
        // C        IF(SIGNN.LE.0)GO TO 400
        if (signn <= 0) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        // C
        ec = 3.59709f;
        ds = fem::sqrt(sig / pi / 10.f);
        dsr = ds + 0.1f;
        if ((e(i1) >= 1.f) && (e(i2) >= 1.f)) {
          ec = 4.75f;
        }
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        // Clin-5/2008 in case perturbative deuterons are produced above:
        // C        IF(IC.EQ.-1) GO TO 400
        if (ic == -1) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        // C
        // C CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON+NUCLEON OR
        // C RESONANCE+RESONANCE COLLISIONS
        goto statement_362;
      // C
      // C CHECK WHAT KIND OF COLLISION HAS HAPPENED
      statement_362:
        ekaon(1, iss)++;
        crnn(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, signn,
             sig, nt, ipert1);
        // Clin-5/2008 give iblock # in case pert deuterons are produced for
        // idpert=1:
        if (iblock == 0 && ipdflag == 1) {
          iblock = 501;
        }
        // Clin-5/2008 add iblock # for deuteron formation:
        // C IF(IBLOCK.EQ.4.OR.IBLOCK.Eq.9.or.iblock.ge.44.OR.IBLOCK.EQ.-9 C &
        // .or.iblock.eq.222)THEN
        if (iblock == 4 || iblock == 9 || iblock >= 44 || iblock == -9 ||
            iblock == 222 || iblock == 501) {
          // C
          // C     !! sp12/17/01 above
          // C momentum of the three particles in the final state have been
          // calculated C in the crnn, go out of the loop
          lcoll++;
          if (iblock == 4) {
            ldirt++;
          } else if (iblock == 44) {
            lddrho++;
          } else if (iblock == 45) {
            lnnrho++;
          } else if (iblock == 46) {
            lnnom++;
          } else if (iblock == 222) {
          } else if (iblock == 9) {
            lnnk++;
          } else if (iblock == -9) {
          }
          goto statement_400;
        }
        // C
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // Clin-8/2008 B+B->Deuteron+Meson over
      // C
      // Clin-8/2008 Deuteron+Meson->B+B collisions:
      statement_505:
        ianti = 0;
        if (lb(i1) < 0 || lb(i2) < 0) {
          ianti = 1;
        }
        sdmbb(cmn, srt, sdm, ianti);
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C     minimum srt**2, note a 2.012GeV lower cutoff is used in
        // N+N->Deuteron+pi:
        ec = fem::pow2(2.012f);
        ds = fem::sqrt(sdm / 31.4f);
        dsr = ds + 0.1f;
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crdmbb(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, sdm, nt,
               ianti);
        lcoll++;
        goto statement_400;
      // Clin-8/2008 Deuteron+Meson->B+B collisions over
      // C
      // Clin-9/2008 Deuteron+Baryon elastic collisions:
      statement_506:
        ianti = 0;
        if (lb(i1) < 0 || lb(i2) < 0) {
          ianti = 1;
        }
        sdbelastic(cmn, srt, sdb);
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C     minimum srt**2, note a 2.012GeV lower cutoff is used in
        // N+N->Deuteron+pi:
        ec = fem::pow2(2.012f);
        ds = fem::sqrt(sdb / 31.4f);
        dsr = ds + 0.1f;
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crdbel(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, sdb, nt,
               ianti);
        lcoll++;
        goto statement_400;
      // Clin-9/2008 Deuteron+Baryon elastic collisions over
      // C
      // C IF BARYON RESONANCE+BARYON RESONANCE COLLISIONS
      statement_444:
        // C PREPARE THE EALSTIC CROSS SECTION FOR BARYON+BARYON COLLISIONS
        cutoff = em1 + em2 + 0.02f;
        // C AT HIGH ENERGIES THE ISOSPIN DEPENDENCE IS NEGLIGIBLE
        // C THE TOTAL CROSS SECTION IS TAKEN AS THAT OF THE PP
        if (srt <= cutoff) {
          goto statement_400;
        }
        if (srt > 2.245f) {
          signn = pp2(cmn, srt);
        } else {
          signn = 35.0f / (1.f + (srt - cutoff) * 100.0f) + 20.0f;
        }
        if (signn <= 0) {
          goto statement_400;
        }
        xddin(cmn, pcx, pcy, pcz, srt, i1, i2, xinel, sigk, xsk1, xsk2, xsk3,
              xsk4, xsk5);
        sig = signn + xinel;
        ec = fem::pow2((em1 + em2 + 0.02f));
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C
        // Clin-6/2008 Deuteron production:
        ianti = 0;
        if (lb(i1) < 0 && lb(i2) < 0) {
          ianti = 1;
        }
        sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
        sig += sdprod;
        // Clin-6/2008 perturbative treatment of deuterons:
        ipdflag = 0;
        if (idpert == 1) {
          ipert1 = 1;
          sigr0 = sig;
          dspert = fem::sqrt(sigr0 / pi / 10.f);
          dsrpert = dspert + 0.1f;
          distce(cmn, i1, i2, dsrpert, dspert, dt, ec, srt, ic, px1cm, py1cm,
                 pz1cm);
          if (ic == -1) {
            goto statement_367;
          }
          signn0 = 0.f;
          crdd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag,
               signn0, sigr0, nt, ipert1);
          // C     1          IBLOCK,NTAG,SIGNN,SIG)
          ipdflag = 1;
        statement_367:
          ipert1 = 0;
        }
        if (idpert == 2) {
          ipert1 = 1;
        }
        // C
        ds = fem::sqrt(sig / 31.4f);
        dsr = ds + 0.1f;
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        // C        IF(IC.EQ.-1) GO TO 400
        if (ic == -1) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        // C
        // C CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON+NUCLEON OR
        // C RESONANCE+RESONANCE COLLISIONS
        goto statement_364;
      // C
      // C CHECK WHAT KIND OF COLLISION HAS HAPPENED
      statement_364:
        ekaon(2, iss)++;
        // C for resonance+resonance
        // Clin-6/2008:
        crdd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, signn,
             sig, nt, ipert1);
        // C     1  IBLOCK,NTAG,SIGNN,SIG)
        if (iblock == 0 && ipdflag == 1) {
          iblock = 501;
        }
        // C
        if (fem::iabs(iblock) == 10) {
          // C momentum of the three particles in the final state have been
          // calculated C in the crnn, go out of the loop
          lcoll++;
          if (iblock == 10) {
            lddk++;
          } else if (iblock == -10) {
          }
          goto statement_400;
        }
        // Clin-6/2008
        // C        if(iblock .eq. 222)then
        if (iblock == 222 || iblock == 501) {
          // C    !! sp12/17/01
          goto statement_400;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C FOR PION+PION,pion+eta, eta+eta and rho(omega)+pion(rho,omega) or eta
      statement_777:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        // C energy thresh for collisions
        ec0 = em1 + em2 + 0.02f;
        if (srt <= ec0) {
          goto statement_400;
        }
        ec = fem::pow2((em1 + em2 + 0.02f));
        // C we negelect the elastic collision between mesons except that betwen
        // C two pions because of the lack of information about these collisions
        // C However, we do let them to collide inelastically to produce kaons
        // Clin-8/15/02       ppel=1.e-09
        ppel = 20.f;
        ipp = 1;
        if (lb1 < 3 || lb1 > 5 || lb2 < 3 || lb2 > 5) {
          goto statement_778;
        }
        ppxs(cmn, lb1, lb2, srt, ppsig, spprho, ipp);
        ppel = ppsig;
      statement_778:
        ppink = pipik(cmn, srt);
        // C
        // C pi+eta and eta+eta are assumed to be the same as pipik( for pi+pi
        // -> K+K-) C estimated from Ko's paper:
        ppink = 2.0f * ppink;
        if (lb1 >= 25 && lb2 >= 25) {
          ppink = rrkk;
        }
        // C
        // Clin-2/13/03 include omega the same as rho, eta the same as pi:
        // C        if(((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.25.and.lb2.le.27))
        // C     1  .or.((lb2.ge.3.and.lb2.le.5).and.(lb1.ge.25.and.lb1.le.27)))
        if (((lb1 == 0 || (lb1 >= 3 && lb1 <= 5)) &&
             (lb2 >= 25 && lb2 <= 28)) ||
            ((lb2 == 0 || (lb2 >= 3 && lb2 <= 5)) &&
             (lb1 >= 25 && lb1 <= 28))) {
          ppink = 0.f;
          if (srt >= (aka + aks)) {
            ppink = prkk;
          }
        }
        // C
        // C pi pi <-> rho rho:
        spprr(cmn, lb1, lb2, srt);
        // Clin-4/03/02 pi pi <-> eta eta:
        sppee(cmn, lb1, lb2, srt);
        // Clin-4/03/02 pi pi <-> pi eta:
        spppe(cmn, lb1, lb2, srt);
        // Clin-4/03/02 rho pi <-> rho eta:
        srpre(cmn, lb1, lb2, srt);
        // Clin-4/03/02 omega pi <-> omega eta:
        sopoe(cmn, lb1, lb2, srt);
        // Clin-4/03/02 rho rho <-> eta eta:
        srree(cmn, lb1, lb2, srt);
        // C
        ppinnb = 0.f;
        if (srt > thresh(1)) {
          getnst(cmn, srt);
          if (lb1 >= 3 && lb1 <= 5 && lb2 >= 3 && lb2 <= 5) {
            ppinnb = ppbbar(cmn, srt);
          } else if ((lb1 >= 3 && lb1 <= 5 && lb2 >= 25 && lb2 <= 27) ||
                     (lb2 >= 3 && lb2 <= 5 && lb1 >= 25 && lb1 <= 27)) {
            ppinnb = prbbar(cmn, srt);
          } else if (lb1 >= 25 && lb1 <= 27 && lb2 >= 25 && lb2 <= 27) {
            ppinnb = rrbbar(cmn, srt);
          } else if ((lb1 >= 3 && lb1 <= 5 && lb2 == 28) ||
                     (lb2 >= 3 && lb2 <= 5 && lb1 == 28)) {
            ppinnb = pobbar(cmn, srt);
          } else if ((lb1 >= 25 && lb1 <= 27 && lb2 == 28) ||
                     (lb2 >= 25 && lb2 <= 27 && lb1 == 28)) {
            ppinnb = robbar(cmn, srt);
          } else if (lb1 == 28 && lb2 == 28) {
            ppinnb = oobbar(cmn, srt);
          } else {
            if (lb1 != 0 && lb2 != 0) {
              write(6, star), "missed MM lb1,lb2=", lb1, lb2;
            }
          }
        }
        ppin = ppink + ppinnb + cmn.pprr + cmn.ppee + cmn.pppe + cmn.rpre +
               cmn.xopoe + cmn.rree;
        // C
        // C check if a collision can happen
        if ((ppel + ppin) <= 0.01f) {
          goto statement_400;
        }
        dspp = fem::sqrt((ppel + ppin) / 31.4f);
        dsppr = dspp + 0.1f;
        distce(cmn, i1, i2, dsppr, dspp, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        if (ppel == 0) {
          goto statement_400;
        }
        // C the collision can happen
        // C check what kind collision has happened
        ekaon(5, iss)++;
        crpp(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ppel, ppin, spprho,
             ipp);
        // C
        // C rho formation, go to 400
        // C       if(iblock.eq.666)go to 600
        if (iblock == 666) {
          goto statement_555;
        }
        if (iblock == 6) {
          lpp++;
        }
        if (iblock == 66) {
          lppk++;
        } else if (iblock == 366) {
          lppk++;
        } else if (iblock == 367) {
          lppk++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C In this block we treat annihilations of
      // Clin-9/28/00* an anti-nucleon and a baryon or baryon resonance
      // C an anti-baryon and a baryon (including resonances)
      statement_2799:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        // Clin assume the same cross section (as a function of sqrt s) as for
        // PPbar:
        // C
        // Clin-ctest annih maximum
        // C        DSppb=SQRT(amin1(xppbar(srt),30.)/PI/10.)
        dsppb = fem::sqrt(xppbar(cmn, srt) / pi / 10.f);
        dsppbr = dsppb + 0.1f;
        distce(cmn, i1, i2, dsppbr, dsppb, dt, ec, srt, ic, px1cm, py1cm,
               pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crppba(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      statement_3555:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        dskk = fem::sqrt(sig / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crlaba(cmn, px1cm, py1cm, pz1cm, srt, brel, brsgm, i1, i2, nt, iblock,
               nchrg, icase);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C perturbative production of cascade and omega
      statement_3455:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        pertur(cmn, px1cm, py1cm, pz1cm, srt, irun, i1, i2, nt, kp, icontp);
        if (icontp == 0) {
          // C     inelastic collisions:
          em1 = e(i1);
          em2 = e(i2);
          iblock = 727;
          goto statement_440;
        }
        // C     elastic collisions:
        if (e(i1) == 0.f) {
          goto statement_800;
        }
        if (e(i2) == 0.f) {
          goto statement_600;
        }
        goto statement_400;
      // C
      // C* phi + N --> pi+N(D),  N(D,N*)+N(D,N*),  K+ +La
      // C* phi + D --> pi+N(D)
      statement_7222:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        xphib(cmn, lb1, lb2, em1, em2, srt, xsk1, xsk2, xsk3, xsk4, xsk5, sigp);
        dskk = fem::sqrt(sigp / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crphib(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, xsk1, xsk2, xsk3, xsk4,
               xsk5, sigp, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C* phi + M --> K+ + K* .....
      statement_7444:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        phimes(cmn, i1, i2, srt, xsk1, xsk2, xsk3, xsk4, xsk5, xsk6, sve.xsk7,
               sigphi);
        dskk = fem::sqrt(sigphi / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        // C*---
        pzrt = p(3, i1) + p(3, i2);
        er1 = fem::sqrt(fem::pow2(p(1, i1)) + fem::pow2(p(2, i1)) +
                        fem::pow2(p(3, i1)) + fem::pow2(e(i1)));
        er2 = fem::sqrt(fem::pow2(p(1, i2)) + fem::pow2(p(2, i2)) +
                        fem::pow2(p(3, i2)) + fem::pow2(e(i2)));
        ert = er1 + er2;
        yy = 0.5f * fem::log((ert + pzrt) / (ert - pzrt));
        // C*------
        crphim(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, xsk1, xsk2, xsk3, xsk4,
               xsk5, xsk6, sigphi, ikkg, ikkl, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C lambda-N elastic xsection, Li & Ko, PRC 54(1996)1897.
      statement_7799:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        lambar(cmn, i1, i2, srt, siglab);
        dshn = fem::sqrt(siglab / pi / 10.f);
        dshnr = dshn + 0.1f;
        distce(cmn, i1, i2, dshnr, dshn, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crhb(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C* K+ + La(Si) --> Meson + B
      // C* K- + La(Si)-bar --> Meson + B-bar
      statement_5699:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        xkhype(cmn, i1, i2, srt, xky1, xky2, xky3, xky4, xky5, xky6, xky7, xky8,
               xky9, xky10, xky11, xky12, xky13, xky14, xky15, xky16, xky17,
               sigk);
        dskk = fem::sqrt(sigk / pi);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        // C
        if (lb(i1) == 23 || lb(i2) == 23) {
          ikmp = 1;
        } else {
          ikmp = -1;
        }
        crkhyp(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, xky1, xky2, xky3, xky4,
               xky5, xky6, xky7, xky8, xky9, xky10, xky11, xky12, xky13, xky14,
               xky15, xky16, xky17, sigk, ikmp, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C khyperon end
      // C
      // Csp11/03/01 La/Si-bar + N --> pi + K+
      // C  La/Si + N-bar --> pi + K-
      statement_5999:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        sigkp = 15.f;
        // C      if((lb1.ge.14.and.lb1.le.17)
        // C     &    .or.(lb2.ge.14.and.lb2.le.17))sigkp=10.
        dskk = fem::sqrt(sigkp / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        // C
        crlan(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C*
      // C K(K*) + K(K*) --> phi + pi(rho,omega)
      statement_8699:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        // C  CALL CROSSKKPHI(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)  used for
        // KK*->phi+rho
        // C
        crkphi(cmn, px1cm, py1cm, pz1cm, ec, srt, iblock, emm1, emm2, lbp1,
               lbp2, i1, i2, sve.ikk, icase, rrkk, prkk);
        if (icase == 0) {
          iblock = 0;
          goto statement_400;
        }
        // C
        // C*---
        if (lbp1 == 29 || lbp2 == 29) {
          pzrt = p(3, i1) + p(3, i2);
          er1 = fem::sqrt(fem::pow2(p(1, i1)) + fem::pow2(p(2, i1)) +
                          fem::pow2(p(3, i1)) + fem::pow2(e(i1)));
          er2 = fem::sqrt(fem::pow2(p(1, i2)) + fem::pow2(p(2, i2)) +
                          fem::pow2(p(3, i2)) + fem::pow2(e(i2)));
          ert = er1 + er2;
          yy = 0.5f * fem::log((ert + pzrt) / (ert - pzrt));
          // C*------
          iblock = 222;
          ntag = 0;
        }
        // C
        lb(i1) = lbp1;
        lb(i2) = lbp2;
        e(i1) = emm1;
        e(i2) = emm2;
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C*
      // C rho(omega) + K(K*)  --> phi + K(K*)
      statement_8799:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        // C  CALL CROSSKKPHI(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)  used for
        // KK*->phi+rho
        crksph(cmn, px1cm, py1cm, pz1cm, ec, srt, emm1, emm2, lbp1, lbp2, i1,
               i2, ikkg, ikkl, iblock, icase, srhoks);
        if (icase == 0) {
          iblock = 0;
          goto statement_400;
        }
        // C
        if (lbp1 == 29 || lbp2 == 20) {
          // C*---
          pzrt = p(3, i1) + p(3, i2);
          er1 = fem::sqrt(fem::pow2(p(1, i1)) + fem::pow2(p(2, i1)) +
                          fem::pow2(p(3, i1)) + fem::pow2(e(i1)));
          er2 = fem::sqrt(fem::pow2(p(1, i2)) + fem::pow2(p(2, i2)) +
                          fem::pow2(p(3, i2)) + fem::pow2(e(i2)));
          ert = er1 + er2;
          yy = 0.5f * fem::log((ert + pzrt) / (ert - pzrt));
        }
        // C
        lb(i1) = lbp1;
        lb(i2) = lbp2;
        e(i1) = emm1;
        e(i2) = emm2;
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C
      // C for kaon+baryon scattering, using a constant xsection of 10 mb.
      statement_888:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        sig = 10.f;
        if (fem::iabs(lb1) == 14 || fem::iabs(lb2) == 14 ||
            fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
          sig = 20.f;
        }
        if (lb1 == 29 || lb2 == 29) {
          sig = 5.0f;
        }
        // C
        dskn = fem::sqrt(sig / pi / 10.f);
        dsknr = dskn + 0.1f;
        distce(cmn, i1, i2, dsknr, dskn, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crkn(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      // C**
      // C
      statement_440:
        // C                IBLOCK = 0 ; NOTHING HAS HAPPENED
        // C                IBLOCK = 1 ; ELASTIC N-N COLLISION
        // C                IBLOCK = 2 ; N + N -> N + DELTA
        // C                IBLOCK = 3 ; N + DELTA -> N + N
        // C                IBLOCK = 4 ; N + N -> d + d + PION,DIRECT PROCESS
        // C               IBLOCK = 5 ; D(N*)+D(N*) COLLISIONS
        // C                IBLOCK = 6 ; PION+PION COLLISIONS
        // C                iblock = 7 ; pion+nucleon-->l/s+kaon
        // C               iblock =77;  pion+nucleon-->delta+pion
        // C               iblock = 8 ; kaon+baryon rescattering
        // C                IBLOCK = 9 ; NN-->KAON+X
        // C                IBLOCK = 10; DD-->KAON+X
        // C               IBLOCK = 11; ND-->KAON+X
        // Cbali2/1/99
        // C
        // C           iblock   - 1902 annihilation-->pion(+)+pion(-)   (2 pion)
        // C           iblock   - 1903 annihilation-->pion(+)+rho(-)    (3 pion)
        // C           iblock   - 1904 annihilation-->rho(+)+rho(-)     (4 pion)
        // C           iblock   - 1905 annihilation-->rho(0)+omega      (5 pion)
        // C           iblock   - 1906 annihilation-->omega+omega       (6 pion)
        // Cbali3/5/99
        // C           iblock   - 1907 K+K- to pi+pi-
        // Cbali3/5/99 end
        // Cbz3/9/99 khyperon
        // C           iblock   - 1908 K+Y -> piN
        // Cbz3/9/99 khyperon end
        // Cbali2/1/99end
        // C
        // Clin-9/28/00 Processes: m(pi rho omega)+m(pi rho omega)
        // C     to anti-(p n D N*1 N*2)+(p n D N*1 N*2):
        // C           iblock   - 1801  mm -->pbar p
        // C           iblock   - 18021 mm -->pbar n
        // C           iblock   - 18022 mm -->nbar p
        // C           iblock   - 1803  mm -->nbar n
        // C           iblock   - 18041 mm -->pbar Delta
        // C           iblock   - 18042 mm -->anti-Delta p
        // C           iblock   - 18051 mm -->nbar Delta
        // C           iblock   - 18052 mm -->anti-Delta n
        // C           iblock   - 18061 mm -->pbar N*(1400)
        // C           iblock   - 18062 mm -->anti-N*(1400) p
        // C           iblock   - 18071 mm -->nbar N*(1400)
        // C           iblock   - 18072 mm -->anti-N*(1400) n
        // C           iblock   - 1808  mm -->anti-Delta Delta
        // C           iblock   - 18091 mm -->pbar N*(1535)
        // C           iblock   - 18092 mm -->anti-N*(1535) p
        // C           iblock   - 18101 mm -->nbar N*(1535)
        // C           iblock   - 18102 mm -->anti-N*(1535) n
        // C           iblock   - 18111 mm -->anti-Delta N*(1440)
        // C           iblock   - 18112 mm -->anti-N*(1440) Delta
        // C           iblock   - 18121 mm -->anti-Delta N*(1535)
        // C           iblock   - 18122 mm -->anti-N*(1535) Delta
        // C           iblock   - 1813  mm -->anti-N*(1440) N*(1440)
        // C           iblock   - 18141 mm -->anti-N*(1440) N*(1535)
        // C           iblock   - 18142 mm -->anti-N*(1535) N*(1440)
        // C           iblock   - 1815  mm -->anti-N*(1535) N*(1535)
        // Clin-9/28/00-end
        // C
        // Clin-10/08/00 Processes: pi pi <-> rho rho
        // C           iblock   - 1850  pi pi -> rho rho
        // C           iblock   - 1851  rho rho -> pi pi
        // Clin-10/08/00-end
        // C
        // Clin-08/14/02 Processes: pi pi <-> eta eta
        // C           iblock   - 1860  pi pi -> eta eta
        // C           iblock   - 1861  eta eta -> pi pi
        // C Processes: pi pi <-> pi eta
        // C           iblock   - 1870  pi pi -> pi eta
        // C           iblock   - 1871  pi eta -> pi pi
        // C Processes: rho pi <-> rho eta
        // C           iblock   - 1880  pi pi -> pi eta
        // C           iblock   - 1881  pi eta -> pi pi
        // C Processes: omega pi <-> omega eta
        // C           iblock   - 1890  pi pi -> pi eta
        // C           iblock   - 1891  pi eta -> pi pi
        // C Processes: rho rho <-> eta eta
        // C           iblock   - 1895  rho rho -> eta eta
        // C           iblock   - 1896  eta eta -> rho rho
        // Clin-08/14/02-end
        // C
        // Clin-11/07/00 Processes:
        // C           iblock   - 366  pi rho -> K* Kbar or K*bar K
        // C           iblock   - 466  pi rho <- K* Kbar or K*bar K
        // C
        // Clin-9/2008 Deuteron:
        // C           iblock   - 501  B+B -> Deuteron+Meson
        // C           iblock   - 502  Deuteron+Meson -> B+B
        // C           iblock   - 503  Deuteron+Baryon elastic
        // C           iblock   - 504  Deuteron+Meson elastic
        // C
        if (iblock == 0) {
          goto statement_400;
        }
        // CCOM: FOR DIRECT PROCESS WE HAVE TREATED THE PAULI BLOCKING AND FIND
        // C     THE MOMENTUM OF PARTICLES IN THE ''LAB'' FRAME. SO GO TO 400
        // C A COLLISION HAS TAKEN PLACE !!
        lcoll++;
        // C WAS COLLISION PAULI-FORBIDEN? IF YES, NTAG = -1
        ntag = 0;
        // C
        // C             LORENTZ-TRANSFORMATION INTO CMS FRAME
        e1cm = fem::sqrt(fem::pow2(em1) + fem::pow2(px1cm) + fem::pow2(py1cm) +
                         fem::pow2(pz1cm));
        p1beta = px1cm * betax + py1cm * betay + pz1cm * betaz;
        transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
        pt1i1 = betax * transf + px1cm;
        pt2i1 = betay * transf + py1cm;
        pt3i1 = betaz * transf + pz1cm;
        // C negelect the pauli blocking at high energies
        goto statement_90002;
      // C
      // Clin-10/25/02-comment out following, since there is no path to it:
      // C*CHECK IF PARTICLE #1 IS PAULI BLOCKED
      // C              CALL PAULat(I1,occup)
      // C              if (RANART(NSEED) .lt. occup) then
      // C                ntag = -1
      // C              else
      // C                ntag = 0
      // C              end if
      // Clin-10/25/02-end
      // C
      statement_90002:
        // CIF PARTICLE #1 IS NOT PAULI BLOCKED
        // C              IF (NTAG .NE. -1) THEN
        e2cm = fem::sqrt(fem::pow2(em2) + fem::pow2(px1cm) + fem::pow2(py1cm) +
                         fem::pow2(pz1cm));
        transf = gamma * (-gamma * p1beta / (gamma + 1.f) + e2cm);
        pt1i2 = betax * transf - px1cm;
        pt2i2 = betay * transf - py1cm;
        pt3i2 = betaz * transf - pz1cm;
        goto statement_90003;
      // C
      // Clin-10/25/02-comment out following, since there is no path to it:
      // C*CHECK IF PARTICLE #2 IS PAULI BLOCKED
      // C                CALL PAULat(I2,occup)
      // C                if (RANART(NSEED) .lt. occup) then
      // C                  ntag = -1
      // C                else
      // C                  ntag = 0
      // C                end if
      // Cc              END IF
      // C* IF COLLISION IS BLOCKED,RESTORE THE MOMENTUM,MASSES
      // C* AND LABELS OF I1 AND I2
      // Cc             IF (NTAG .EQ. -1) THEN
      // C                LBLOC  = LBLOC + 1
      // C                P(1,I1) = PX1
      // C                P(2,I1) = PY1
      // C                P(3,I1) = PZ1
      // C                P(1,I2) = PX2
      // C                P(2,I2) = PY2
      // C                P(3,I2) = PZ2
      // C                E(I1)   = EM1
      // C                E(I2)   = EM2
      // C                LB(I1)  = LB1
      // C                LB(I2)  = LB2
      // Cc              ELSE
      // Clin-10/25/02-end
      // C
      statement_90003:
        if (iblock == 1) {
          lcnne++;
        }
        if (iblock == 5) {
          ldd++;
        }
        if (iblock == 2) {
          lcnnd++;
        }
        if (iblock == 8) {
          lkn++;
        }
        if (iblock == 43) {
          ldou++;
        }
        // C                IF(IBLOCK.EQ.2) THEN
        // C CALCULATE THE AVERAGE SRT FOR N + N---> N + DELTA PROCESS
        // C                NODELT=NODELT+1
        // C                SUMSRT=SUMSRT+SRT
        // C                ENDIF
        if (iblock == 3) {
          lcndn++;
        }
        // C assign final momenta to particles while keep the leadng particle
        // C behaviour
        // C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
        p(1, i1) = pt1i1;
        p(2, i1) = pt2i1;
        p(3, i1) = pt3i1;
        p(1, i2) = pt1i2;
        p(2, i2) = pt2i2;
        p(3, i2) = pt3i2;
        // C              else
        // C              p(1,i1)=pt1i2
        // C              p(2,i1)=pt2i2
        // C              p(3,i1)=pt3i2
        // C              p(1,i2)=pt1i1
        // C              p(2,i2)=pt2i1
        // C              p(3,i2)=pt3i1
        // C              endif
        px1 = p(1, i1);
        py1 = p(2, i1);
        pz1 = p(3, i1);
        em1 = e(i1);
        em2 = e(i2);
        lb1 = lb(i1);
        lb2 = lb(i2);
        id(i1) = 2;
        id(i2) = 2;
        e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                       fem::pow2(pz1));
        id1 = id(i1);
        goto statement_90004;
      // Clin-10/25/02-comment out following, since there is no path to it:
      // C* change phase space density FOR NUCLEONS INVOLVED :
      // C* NOTE THAT f is the phase space distribution function for nucleons
      // only C                if ((abs(ix1).le.mx) .and. (abs(iy1).le.my) .and.
      // C     &              (abs(iz1).le.mz)) then
      // C                  ipx1p = nint(p(1,i1)/dpx)
      // C                  ipy1p = nint(p(2,i1)/dpy)
      // C                  ipz1p = nint(p(3,i1)/dpz)
      // C                  if ((ipx1p.ne.ipx1) .or. (ipy1p.ne.ipy1) .or.
      // C     &                (ipz1p.ne.ipz1)) then
      // C                    if ((abs(ipx1).le.mpx) .and. (abs(ipy1).le.my)
      // C     &                .and. (ipz1.ge.-mpz) .and. (ipz1.le.mpzp)
      // C     &                .AND. (AM1.LT.1.))
      // C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) =
      // C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) - 1.
      // C                    if ((abs(ipx1p).le.mpx) .and. (abs(ipy1p).le.my)
      // C     &                .and. (ipz1p.ge.-mpz).and. (ipz1p.le.mpzp)
      // C     &                .AND. (EM1.LT.1.))
      // C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) =
      // C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) + 1.
      // C                  end if
      // C                end if
      // C                if ((abs(ix2).le.mx) .and. (abs(iy2).le.my) .and.
      // C     &              (abs(iz2).le.mz)) then
      // C                  ipx2p = nint(p(1,i2)/dpx)
      // C                  ipy2p = nint(p(2,i2)/dpy)
      // C                  ipz2p = nint(p(3,i2)/dpz)
      // C                  if ((ipx2p.ne.ipx2) .or. (ipy2p.ne.ipy2) .or.
      // C     &                (ipz2p.ne.ipz2)) then
      // C                    if ((abs(ipx2).le.mpx) .and. (abs(ipy2).le.my)
      // C     &                .and. (ipz2.ge.-mpz) .and. (ipz2.le.mpzp)
      // C     &                .AND. (AM2.LT.1.))
      // C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) =
      // C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) - 1.
      // C                    if ((abs(ipx2p).le.mpx) .and. (abs(ipy2p).le.my)
      // C     &                .and. (ipz2p.ge.-mpz) .and. (ipz2p.le.mpzp)
      // C     &                .AND. (EM2.LT.1.))
      // C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) =
      // C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) + 1.
      // C                  end if
      // C                end if
      // Clin-10/25/02-end
      // C
      statement_90004:
        am1 = em1;
        am2 = em2;
      // C            END IF
      // C
      statement_400:
      // C
      // Clin-6/10/03 skips the info output on resonance creations:
      // C            goto 550
      // Cclin-4/30/03 study phi,K*,Lambda(1520) resonances at creation:
      // Cc     note that no decays give these particles, so don't need to
      // consider nnn: C if(iblock.ne.0.and.(lb(i1).eq.29.or.iabs(lb(i1)).eq.30
      // C     1           .or.lb(i2).eq.29.or.iabs(lb(i2)).eq.30
      // C     2           .or.lb1i.eq.29.or.iabs(lb1i).eq.30
      // C     3           .or.lb2i.eq.29.or.iabs(lb2i).eq.30)) then
      // C               lb1now=lb(i1)
      // C               lb2now=lb(i2)
      // Cc
      // C               nphi0=0
      // C               nksp0=0
      // C               nksm0=0
      // Cc               nlar0=0
      // Cc               nlarbar0=0
      // C               if(lb1i.eq.29) then
      // C                  nphi0=nphi0+1
      // C               elseif(lb1i.eq.30) then
      // C                  nksp0=nksp0+1
      // C               elseif(lb1i.eq.-30) then
      // C                  nksm0=nksm0+1
      // C               endif
      // C               if(lb2i.eq.29) then
      // C                  nphi0=nphi0+1
      // C               elseif(lb2i.eq.30) then
      // C                  nksp0=nksp0+1
      // C               elseif(lb2i.eq.-30) then
      // C                  nksm0=nksm0+1
      // C               endif
      // Cc
      // C               nphi=0
      // C               nksp=0
      // C               nksm=0
      // C               nlar=0
      // C               nlarbar=0
      // C               if(lb1now.eq.29) then
      // C                  nphi=nphi+1
      // C               elseif(lb1now.eq.30) then
      // C                  nksp=nksp+1
      // C               elseif(lb1now.eq.-30) then
      // C                  nksm=nksm+1
      // C               endif
      // C               if(lb2now.eq.29) then
      // C                  nphi=nphi+1
      // C               elseif(lb2now.eq.30) then
      // C                  nksp=nksp+1
      // C               elseif(lb2now.eq.-30) then
      // C                  nksm=nksm+1
      // C               endif
      // Cc
      // C               if(nphi.eq.2.or.nksp.eq.2.or.nksm.eq.2) then
      // C                  write(91,*) '2 same resonances in one reaction!'
      // C                  write(91,*) nphi,nksp,nksm,iblock
      // C               endif
      // C
      // Cc     All reactions create or destroy no more than 1 these resonance,
      // Cc     otherwise file "fort.91" warns us:
      // C               do 222 ires=1,3
      // C                  if(ires.eq.1.and.nphi.ne.nphi0) then
      // C                     idr=29
      // C                  elseif(ires.eq.2.and.nksp.ne.nksp0) then
      // C                     idr=30
      // C                  elseif(ires.eq.3.and.nksm.ne.nksm0) then
      // C                     idr=-30
      // C                  else
      // C                     goto 222
      // C                  endif
      // Cctest off for resonance (phi, K*) studies:
      // Cc               if(lb1now.eq.idr) then
      // Cc       write(17,112)
      // 'collision',lb1now,P(1,I1),P(2,I1),P(3,I1),e(I1),nt Cc
      // elseif(lb2now.eq.idr) then Cc       write(17,112)
      // 'collision',lb2now,P(1,I2),P(2,I2),P(3,I2),e(I2),nt Cc
      // elseif(lb1i.eq.idr) then Cc       write(18,112)
      // 'collision',lb1i,px1i,py1i,pz1i,em1i,nt Cc elseif(lb2i.eq.idr) then Cc
      // write(18,112) 'collision',lb2i,px2i,py2i,pz2i,em2i,nt Cc endif C 222
      // continue
      // C
      // C            else
      // C            endif
      // Cc 112        format(a10,I4,4(1x,f9.3),1x,I4)
      // C
      // Clin-2/26/03 skips the check of energy conservation after each binary
      // search: C 550        goto 555 C            pxfin=0 C            pyfin=0
      // C            pzfin=0
      // C            efin=0
      // C            if(e(i1).ne.0.or.lb(i1).eq.10022) then
      // C efin=efin+SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2) C
      // pxfin=pxfin+P(1,I1) C               pyfin=pyfin+P(2,I1) C
      // pzfin=pzfin+P(3,I1) C            endif C
      // if(e(i2).ne.0.or.lb(i2).eq.10022) then C
      // efin=efin+SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2) C
      // pxfin=pxfin+P(1,I2) C               pyfin=pyfin+P(2,I2) C
      // pzfin=pzfin+P(3,I2) C            endif C if((nnn-nnnini).ge.1) then C do
      // imore=nnnini+1,nnn C                  if(EPION(imore,IRUN).ne.0) then C
      // efin=efin+SQRT(EPION(imore,IRUN)**2 C     1
      // +PPION(1,imore,IRUN)**2+PPION(2,imore,IRUN)**2 C     2
      // +PPION(3,imore,IRUN)**2) C pxfin=pxfin+PPION(1,imore,IRUN) C
      // pyfin=pyfin+PPION(2,imore,IRUN) C pzfin=pzfin+PPION(3,imore,IRUN) C
      // endif C               enddo C            endif C
      // devio=sqrt((pxfin-pxini)**2+(pyfin-pyini)**2 C     1
      // +(pzfin-pzini)**2+(efin-eini)**2) Cc C            if(devio.ge.0.1) then
      // C               write(92,'a20,5(1x,i6),2(1x,f8.3)') 'iblock,lb,npi=',
      // C     1              iblock,lb1i,lb2i,lb(i1),lb(i2),e(i1),e(i2)
      // C               do imore=nnnini+1,nnn
      // C                  if(EPION(imore,IRUN).ne.0) then
      // C                     write(92,'a10,2(1x,i6)') 'ipi,lbm=',
      // C     1                    imore,LPION(imore,IRUN)
      // C                  endif
      // C               enddo
      // C               write(92,'a3,4(1x,f8.3)') 'I:',eini,pxini,pyini,pzini
      // C               write(92,'a3,5(1x,f8.3)')
      // C     1              'F:',efin,pxfin,pyfin,pzfin,devio
      // C            endif
      // C
      statement_555:
      // Ctest off only one collision for the same 2 particles in the same
      // timestep: C            if(iblock.ne.0) then C               goto 800 C
      // endif Ctest off collisions history: C            if(iblock.ne.0) then C
      // write(10,*) nt,i1,i2,iblock,x1,z1,x2,z2 C            endif
      // C
      statement_600:;
      }
    // C
    // Clin-4/2012 option of pi0 decays:
    // C     particles in lpion() may be a pi0, and when ipi0dcy=1
    // C     we need to decay them at nt=ntmax after all lb(i1) decays are done:
    statement_798:
      if (nt == ntmax && ipi0dcy == 1 && i1 == (massr(irun) + msum)) {
        FEM_DO_SAFE(ipion, 1, nnn) {
          if (lpion(ipion, irun) == 4) {
            wid = 7.85e-9f;
            resdec(i1, nt, nnn, wid, idecay, ipion);
          }
        }
      }
    // Ctest off
    // C          if(nt.eq.ntmax.and.i1.eq.(MASSR(IRUN)+MSUM)) then
    // C             do ip=1,i1
    // C                write(98,*) lb(ip),e(ip),ip
    // C             enddo
    // C          endif
    // C
    // Clin-4/2012 option of pi0 decays-end
    // C
    statement_800:;
    }
    // C RELABLE MESONS LEFT IN THIS RUN EXCLUDING THOSE BEING CREATED DURING
    // C THIS TIME STEP AND COUNT THE TOTAL NO. OF PARTICLES IN THIS RUN
    // C note that the first mass=mta+mpr particles are baryons
    // C        write(*,*)'I: NNN,massr ', nnn,massr(irun)
    n0 = mass + msum;
    FEM_DO_SAFE(n, n0 + 1, massr(irun) + msum) {
      // Cbz11/25/98
      // Clin-2/19/03 lb>5000: keep particles with no LB codes in
      // ART(photon,lepton,..): C        IF(E(N).GT.0.)THEN
      if (e(n) > 0.f || lb(n) > 5000) {
        // Cbz11/25/98end
        nnn++;
        rpion(1, nnn, irun) = r(1, n);
        rpion(2, nnn, irun) = r(2, n);
        rpion(3, nnn, irun) = r(3, n);
        // Clin-10/28/03:
        if (nt == ntmax) {
          ftpisv(nnn, irun) = ftsv(n);
          tfdpi(nnn, irun) = tfdcy(n);
        }
        // C
        ppion(1, nnn, irun) = p(1, n);
        ppion(2, nnn, irun) = p(2, n);
        ppion(3, nnn, irun) = p(3, n);
        epion(nnn, irun) = e(n);
        lpion(nnn, irun) = lb(n);
        // C       !! sp 12/19/00
        propi(nnn, irun) = proper(n);
        // Clin-5/2008:
        dppion(nnn, irun) = dpertp(n);
        // C        if(lb(n) .eq. 45)
        // C    &   write(*,*)'IN-1  NT,NNN,LB,P ',nt,NNN,lb(n),proper(n)
      }
    }
    massrn(irun) = nnn + mass;
    // C        write(*,*)'F: NNN,massrn ', nnn,massrn(irun)
  }
  // C CALCULATE THE AVERAGE SRT FOR N + N--->N +DELTA PROCESSES
  // C        IF(NODELT.NE.0)THEN
  // C        AVSRT=SUMSRT/FLOAT(NODELT)
  // C        ELSE
  // C        AVSRT=0.
  // C        ENDIF
  // C        WRITE(1097,'(F8.2,2X,E10.3)')FLOAT(NT)*DT,AVSRT
  // C RELABLE ALL THE PARTICLES EXISTING AFTER THIS TIME STEP
  ia = 0;
  ib = 0;
  FEM_DO_SAFE(irun, 1, num) {
    ia += massr(irun - 1);
    ib += massrn(irun - 1);
    FEM_DO_SAFE(ic, 1, massrn(irun)) {
      ie = ia + ic;
      ig = ib + ic;
      if (ic <= mass) {
        rt(1, ig) = r(1, ie);
        rt(2, ig) = r(2, ie);
        rt(3, ig) = r(3, ie);
        // Clin-10/28/03:
        if (nt == ntmax) {
          fttemp(ig) = ftsv(ie);
          tft(ig) = tfdcy(ie);
        }
        // C
        pt(1, ig) = p(1, ie);
        pt(2, ig) = p(2, ie);
        pt(3, ig) = p(3, ie);
        et(ig) = e(ie);
        lt(ig) = lb(ie);
        prot(ig) = proper(ie);
        // Clin-5/2008:
        dptemp(ig) = dpertp(ie);
      } else {
        i0 = ic - mass;
        rt(1, ig) = rpion(1, i0, irun);
        rt(2, ig) = rpion(2, i0, irun);
        rt(3, ig) = rpion(3, i0, irun);
        // Clin-10/28/03:
        if (nt == ntmax) {
          fttemp(ig) = ftpisv(i0, irun);
          tft(ig) = tfdpi(i0, irun);
        }
        // C
        pt(1, ig) = ppion(1, i0, irun);
        pt(2, ig) = ppion(2, i0, irun);
        pt(3, ig) = ppion(3, i0, irun);
        et(ig) = epion(i0, irun);
        lt(ig) = lpion(i0, irun);
        prot(ig) = propi(i0, irun);
        // Clin-5/2008:
        dptemp(ig) = dppion(i0, irun);
      }
    }
  }
  // C
  il = 0;
  // Clin-10/26/01-hbt:
  // C        DO 10002 IRUN=1,NUM
  FEM_DO_SAFE(irun, 1, num) {
    // C
    massr(irun) = massrn(irun);
    il += massr(irun - 1);
    FEM_DO_SAFE(im, 1, massr(irun)) {
      in = il + im;
      r(1, in) = rt(1, in);
      r(2, in) = rt(2, in);
      r(3, in) = rt(3, in);
      // Clin-10/28/03:
      if (nt == ntmax) {
        ftsv(in) = fttemp(in);
        tfdcy(in) = tft(in);
      }
      p(1, in) = pt(1, in);
      p(2, in) = pt(2, in);
      p(3, in) = pt(3, in);
      e(in) = et(in);
      lb(in) = lt(in);
      proper(in) = prot(in);
      // Clin-5/2008:
      dpertp(in) = dptemp(in);
      if (lb(in) < 1 || lb(in) > 2) {
        id(in) = 0;
      }
    }
    // Clin-ctest off check energy conservation after each timestep
    // C         enetot=0.
    // C         do ip=1,MASSR(IRUN)
    // C            if(e(ip).ne.0.or.lb(ip).eq.10022) enetot=enetot
    // C     1           +sqrt(p(1,ip)**2+p(2,ip)**2+p(3,ip)**2+e(ip)**2)
    // C         enddo
    // C         write(91,*) 'B:',nt,enetot,massr(irun),bimp
    // Clin-3/2009 move to the end of a timestep to take care of freezeout
    // spacetime: C        call hbtout(MASSR(IRUN),nt,ntmax)
  }
  // C
}

struct init_save {
  float beta;
  float epart;
  int i;
  int idir;
  int idnum;
  int irun;
  int npart;
  float pfermi;
  arr<float> ptot;
  float px;
  float py;
  float pz;
  float rdist;
  float rhow0;
  float rhows;
  float scheck;
  float sign;
  float x;
  float y;
  float z;

  init_save()
      : beta(fem::float0),
        epart(fem::float0),
        i(fem::int0),
        idir(fem::int0),
        idnum(fem::int0),
        irun(fem::int0),
        npart(fem::int0),
        pfermi(fem::float0),
        ptot(dimension(3), fem::fill0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        rdist(fem::float0),
        rhow0(fem::float0),
        rhows(fem::float0),
        scheck(fem::float0),
        sign(fem::float0),
        x(fem::float0),
        y(fem::float0),
        z(fem::float0) {}
};

// C*********************************
// C                                                                      *
void init(common& cmn, int const& minnum, int const& maxnum, int const& num,
          float const& radius, float const& x0, float const& z0,
          float const& p0, float const& gamma, int const& /* iseed */,
          int const& mass, int const& iopt) {
  FEM_CMN_SVE(init);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  int& nseed = cmn.nseed;
  //
  float& beta = sve.beta;
  float& epart = sve.epart;
  int& i = sve.i;
  int& idir = sve.idir;
  int& idnum = sve.idnum;
  int& irun = sve.irun;
  int& npart = sve.npart;
  float& pfermi = sve.pfermi;
  arr_ref<float> ptot(sve.ptot, dimension(3));
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& rdist = sve.rdist;
  float& rhow0 = sve.rhow0;
  float& rhows = sve.rhows;
  float& scheck = sve.scheck;
  float& sign = sve.sign;
  float& x = sve.x;
  float& y = sve.y;
  float& z = sve.z;
  const float amu = 0.9383f;
  const float pi = 3.1415926f;
  // C                                                                      *
  // C       PURPOSE:     PROVIDING INITIAL CONDITIONS FOR PHASE-SPACE      *
  // C                    DISTRIBUTION OF TESTPARTICLES                     *
  // C       VARIABLES:   (ALL INPUT)                                       *
  // C         MINNUM  - FIRST TESTPARTICLE TREATED IN ONE RUN    (INTEGER) *
  // C         MAXNUM  - LAST TESTPARTICLE TREATED IN ONE RUN     (INTEGER) *
  // C         NUM     - NUMBER OF TESTPARTICLES PER NUCLEON      (INTEGER) *
  // C         RADIUS  - RADIUS OF NUCLEUS "FM"                      (REAL) *
  // C         X0,Z0   - DISPLACEMENT OF CENTER OF NUCLEUS IN X,Z-          *
  // C                   DIRECTION "FM"                              (REAL) *
  // C         P0      - MOMENTUM-BOOST IN C.M. FRAME "GEV/C"        (REAL) *
  // C         GAMMA   - RELATIVISTIC GAMMA-FACTOR                   (REAL) *
  // C         ISEED   - SEED FOR RANDOM-NUMBER GENERATOR         (INTEGER) *
  // C         MASS    - TOTAL MASS OF THE SYSTEM                 (INTEGER) *
  // C         IOPT    - OPTION FOR DIFFERENT OCCUPATION OF MOMENTUM        *
  // C                   SPACE                                    (INTEGER) *
  // C                                                                      *
  // C*********************************
  // C
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /EE/
  // Cc      SAVE /ss/
  // Cc      SAVE /RNDF77/
  // C----------------------------------------------------------------------
  // C     PREPARATION FOR LORENTZ-TRANSFORMATIONS
  // C
  if (p0 != 0.f) {
    sign = p0 / fem::abs(p0);
  } else {
    sign = 0.f;
  }
  // C
  // Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(gamma) - 1.f;
  if (scheck < 0) {
    write(99, star), "scheck10: ", scheck;
    scheck = 0.f;
  }
  beta = sign * fem::sqrt(scheck) / gamma;
  // C      BETA = SIGN * SQRT(GAMMA**2-1.)/GAMMA
  // C
  // C-----------------------------------------------------------------------
  // C     TARGET-ID = 1 AND PROJECTILE-ID = -1
  // C
  if (minnum == 1) {
    idnum = 1;
  } else {
    idnum = -1;
  }
  // C-----------------------------------------------------------------------
  // C     IDENTIFICATION OF TESTPARTICLES AND ASSIGMENT OF RESTMASS
  // C
  // C     LOOP OVER ALL PARALLEL RUNS:
  FEM_DO_SAFE(irun, 1, num) {
    FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
      id(i) = idnum;
      e(i) = amu;
    }
    // C-----------------------------------------------------------------------
    // C       OCCUPATION OF COORDINATE-SPACE
    // C
    FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
    statement_200:
      x = 1.0f - 2.0f * ranart(nseed);
      y = 1.0f - 2.0f * ranart(nseed);
      z = 1.0f - 2.0f * ranart(nseed);
      if ((x * x + y * y + z * z) > 1.0f) {
        goto statement_200;
      }
      r(1, i) = x * radius;
      r(2, i) = y * radius;
      r(3, i) = z * radius;
    }
  }
  // C=======================================================================
  if (iopt != 3) {
    // C-----
    // C     OPTION 1: USE WOODS-SAXON PARAMETRIZATION FOR DENSITY AND
    // C-----          CALCULATE LOCAL FERMI-MOMENTUM
    // C
    rhow0 = 0.168f;
    FEM_DO_SAFE(irun, 1, num) {
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
      statement_500:
        px = 1.0f - 2.0f * ranart(nseed);
        py = 1.0f - 2.0f * ranart(nseed);
        pz = 1.0f - 2.0f * ranart(nseed);
        if (px * px + py * py + pz * pz > 1.0f) {
          goto statement_500;
        }
        rdist = fem::sqrt(fem::pow2(r(1, i)) + fem::pow2(r(2, i)) +
                          fem::pow2(r(3, i)));
        rhows = rhow0 / (1.0f + fem::exp((rdist - radius) / 0.55f));
        pfermi = 0.197f * fem::pow((1.5f * pi * pi * rhows), (1.f / 3.f));
        // C-----
        // C     OPTION 2: NUCLEAR MATTER CASE
        if (iopt == 2) {
          pfermi = 0.27f;
        }
        if (iopt == 4) {
          pfermi = 0.f;
        }
        // C-----
        p(1, i) = pfermi * px;
        p(2, i) = pfermi * py;
        p(3, i) = pfermi * pz;
      }
      // C
      // C         SET TOTAL MOMENTUM TO 0 IN REST FRAME AND BOOST
      // C
      FEM_DO_SAFE(idir, 1, 3) { ptot(idir) = 0.0f; }
      npart = 0;
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
        npart++;
        FEM_DO_SAFE(idir, 1, 3) { ptot(idir) += p(idir, i); }
      }
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
        FEM_DO_SAFE(idir, 1, 3) {
          p(idir, i) = p(idir, i) - ptot(idir) / fem::ffloat(npart);
        }
        // C           BOOST
        if ((iopt == 1) || (iopt == 2)) {
          epart = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                            fem::pow2(p(3, i)) + fem::pow2(amu));
          p(3, i) = gamma * (p(3, i) + beta * epart);
        } else {
          p(3, i) += p0;
        }
      }
    }
    // C-----
  } else {
    // C-----
    // C     OPTION 3: GIVE ALL NUCLEONS JUST A Z-MOMENTUM ACCORDING TO
    // C               THE BOOST OF THE NUCLEI
    // C
    FEM_DO_SAFE(irun, 1, num) {
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
        p(1, i) = 0.0f;
        p(2, i) = 0.0f;
        p(3, i) = p0;
      }
    }
    // C-----
  }
  // C=======================================================================
  // C     PUT PARTICLES IN THEIR POSITION IN COORDINATE-SPACE
  // C     (SHIFT AND RELATIVISTIC CONTRACTION)
  // C
  FEM_DO_SAFE(irun, 1, num) {
    FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
      r(1, i) += x0;
      // C two nuclei in touch after contraction
      r(3, i) = (r(3, i) + z0) / gamma;
      // C two nuclei in touch before contraction
      // C          R(3,I) = R(3,I) / GAMMA + Z0
    }
  }
  // C
}

struct dens_save {
  static const int maxx = 20;
  static const int maxz = 24;

  float a;
  float b;
  float big;
  float denr;
  float gamma;
  int i;
  int irun;
  int ix;
  int iy;
  int iz;
  int j;
  int msum;
  arr<float, 3> pxl;
  arr<float, 3> pyl;
  arr<float, 3> pzl;
  float rho0;
  float s;
  float small;
  float smass;
  float smass2;
  float u;
  arr<float> zet;

  dens_save()
      : a(fem::float0),
        b(fem::float0),
        big(fem::float0),
        denr(fem::float0),
        gamma(fem::float0),
        i(fem::int0),
        irun(fem::int0),
        ix(fem::int0),
        iy(fem::int0),
        iz(fem::int0),
        j(fem::int0),
        msum(fem::int0),
        pxl(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        pyl(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        pzl(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rho0(fem::float0),
        s(fem::float0),
        small(fem::float0),
        smass(fem::float0),
        smass2(fem::float0),
        u(fem::float0),
        zet(dim1(-45, 45), fem::fill0) {}
};

const int dens_save::maxx;
const int dens_save::maxz;

// C*********************************
// C                                                                      *
void dens(common& cmn, int const& ipot, int const& mass, int const& num,
          int& nesc) {
  FEM_CMN_SVE(dens);
  const int maxstr = 150001;
  arr_cref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_cref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_cref<float> e(cmn.e, dimension(maxstr));
  const int maxx = 20;
  const int maxz = 24;
  arr_ref<float, 3> rho(cmn.rho,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> rhop(cmn.rhop,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> rhon(cmn.rhon,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> pirho(
      cmn.pirho, dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  const int maxr = 1;
  arr_cref<int> massr(cmn.massr, dim1(0, maxr));
  arr_ref<float, 3> pel(cmn.pel,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> bxx(cmn.bxx,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> byy(cmn.byy,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> bzz(cmn.bzz,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  //
  float& a = sve.a;
  float& b = sve.b;
  float& big = sve.big;
  float& denr = sve.denr;
  float& gamma = sve.gamma;
  int& i = sve.i;
  int& irun = sve.irun;
  int& ix = sve.ix;
  int& iy = sve.iy;
  int& iz = sve.iz;
  int& j = sve.j;
  int& msum = sve.msum;
  arr_ref<float, 3> pxl(sve.pxl,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> pyl(sve.pyl,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> pzl(sve.pzl,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  float& rho0 = sve.rho0;
  float& s = sve.s;
  float& small = sve.small;
  float& smass = sve.smass;
  float& smass2 = sve.smass2;
  float& u = sve.u;
  arr_ref<float> zet(sve.zet, dim1(-45, 45));
  if (is_called_first_time) {
    static const float values[] = {
        1.f,  0.f,  0.f, 0.f,  0.f,  1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, -1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, 0.f,  -1.f, 0.f, 1.f,  0.f, -1.f, 0.f, -1.f, 0.f,
        -2.f, -1.f, 0.f, 1.f,  0.f,  0.f, 0.f,  0.f, -1.f, 0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, -1.f, 0.f,  1.f, 2.f,  0.f, 1.f,  0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, 0.f,  0.f,  0.f, -1.f, 0.f, 1.f,  0.f, -1.f, 0.f,
        1.f,  0.f,  0.f, 1.f,  0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  -1.f, 0.f, 0.f,  0.f,  0.f, -1.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), zet;
  }
  // C                                                                      *
  // C       PURPOSE:     CALCULATION OF LOCAL BARYON, MESON AND ENERGY     *
  // C                    DENSITY FROM SPATIAL DISTRIBUTION OF TESTPARTICLES*
  // C                                                                      *
  // C       VARIABLES (ALL INPUT, ALL INTEGER)                             *
  // C         MASS    -  MASS NUMBER OF THE SYSTEM                         *
  // C         NUM     -  NUMBER OF TESTPARTICLES PER NUCLEON               *
  // C                                                                      *
  // C         NESC    -  NUMBER OF ESCAPED PARTICLES      (INTEGER,OUTPUT) *
  // C                                                                      *
  // C*********************************
  // C
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /DDpi/
  // Cc      SAVE /EE/
  // Cc      SAVE /ss/
  // Cc      SAVE /RR/
  // Cc      SAVE /tt/
  // C
  FEM_DO_SAFE(iz, -maxz, maxz) {
    FEM_DO_SAFE(iy, -maxx, maxx) {
      FEM_DO_SAFE(ix, -maxx, maxx) {
        rho(ix, iy, iz) = 0.0f;
        rhon(ix, iy, iz) = 0.0f;
        rhop(ix, iy, iz) = 0.0f;
        pirho(ix, iy, iz) = 0.0f;
        pxl(ix, iy, iz) = 0.0f;
        pyl(ix, iy, iz) = 0.0f;
        pzl(ix, iy, iz) = 0.0f;
        pel(ix, iy, iz) = 0.0f;
        bxx(ix, iy, iz) = 0.0f;
        byy(ix, iy, iz) = 0.0f;
        bzz(ix, iy, iz) = 0.0f;
      }
    }
  }
  // C
  nesc = 0;
  big = 1.0f / (3.0f * fem::ffloat(num));
  small = 1.0f / (9.0f * fem::ffloat(num));
  // C
  msum = 0;
  FEM_DO_SAFE(irun, 1, num) {
    msum += massr(irun - 1);
    FEM_DO_SAFE(j, 1, massr(irun)) {
      i = j + msum;
      ix = fem::nint(r(1, i));
      iy = fem::nint(r(2, i));
      iz = fem::nint(r(3, i));
      if (ix <= -maxx || ix >= maxx || iy <= -maxx || iy >= maxx ||
          iz <= -maxz || iz >= maxz) {
        nesc++;
      } else {
        // C
        // Csp01/04/02 include baryon density
        if (j > mass) {
          goto statement_30;
        }
        // C         if( (lb(i).eq.1.or.lb(i).eq.2) .or.
        // C    &    (lb(i).ge.6.and.lb(i).le.17) )then
        // C (1) baryon density
        rho(ix, iy, iz) += big;
        rho(ix + 1, iy, iz) += small;
        rho(ix - 1, iy, iz) += small;
        rho(ix, iy + 1, iz) += small;
        rho(ix, iy - 1, iz) += small;
        rho(ix, iy, iz + 1) += small;
        rho(ix, iy, iz - 1) += small;
        // C (2) CALCULATE THE PROTON DENSITY
        if (zet(lb(i)) != 0) {
          rhop(ix, iy, iz) += big;
          rhop(ix + 1, iy, iz) += small;
          rhop(ix - 1, iy, iz) += small;
          rhop(ix, iy + 1, iz) += small;
          rhop(ix, iy - 1, iz) += small;
          rhop(ix, iy, iz + 1) += small;
          rhop(ix, iy, iz - 1) += small;
          goto statement_40;
        }
        // C (3) CALCULATE THE NEUTRON DENSITY
        if (zet(lb(i)) == 0) {
          rhon(ix, iy, iz) += big;
          rhon(ix + 1, iy, iz) += small;
          rhon(ix - 1, iy, iz) += small;
          rhon(ix, iy + 1, iz) += small;
          rhon(ix, iy - 1, iz) += small;
          rhon(ix, iy, iz + 1) += small;
          rhon(ix, iy, iz - 1) += small;
          goto statement_40;
        }
      // C           else    !! sp01/04/02
      // C (4) meson density
      statement_30:
        pirho(ix, iy, iz) += big;
        pirho(ix + 1, iy, iz) += small;
        pirho(ix - 1, iy, iz) += small;
        pirho(ix, iy + 1, iz) += small;
        pirho(ix, iy - 1, iz) += small;
        pirho(ix, iy, iz + 1) += small;
        pirho(ix, iy, iz - 1) += small;
      // C           endif    !! sp01/04/02
      // C to calculate the Gamma factor in each cell
      // C(1) PX
      statement_40:
        pxl(ix, iy, iz) += p(1, i) * big;
        pxl(ix + 1, iy, iz) += p(1, i) * small;
        pxl(ix - 1, iy, iz) += p(1, i) * small;
        pxl(ix, iy + 1, iz) += p(1, i) * small;
        pxl(ix, iy - 1, iz) += p(1, i) * small;
        pxl(ix, iy, iz + 1) += p(1, i) * small;
        pxl(ix, iy, iz - 1) += p(1, i) * small;
        // C(2) PY
        pyl(ix, iy, iz) += p(2, i) * big;
        pyl(ix + 1, iy, iz) += p(2, i) * small;
        pyl(ix - 1, iy, iz) += p(2, i) * small;
        pyl(ix, iy + 1, iz) += p(2, i) * small;
        pyl(ix, iy - 1, iz) += p(2, i) * small;
        pyl(ix, iy, iz + 1) += p(2, i) * small;
        pyl(ix, iy, iz - 1) += p(2, i) * small;
        // C (3) PZ
        pzl(ix, iy, iz) += p(3, i) * big;
        pzl(ix + 1, iy, iz) += p(3, i) * small;
        pzl(ix - 1, iy, iz) += p(3, i) * small;
        pzl(ix, iy + 1, iz) += p(3, i) * small;
        pzl(ix, iy - 1, iz) += p(3, i) * small;
        pzl(ix, iy, iz + 1) += p(3, i) * small;
        pzl(ix, iy, iz - 1) += p(3, i) * small;
        // C (4) ENERGY
        pel(ix, iy, iz) += fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                                     fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
                           big;
        pel(ix + 1, iy, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix - 1, iy, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy + 1, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy - 1, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy, iz + 1) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy, iz - 1) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
      }
    }
  }
  // C
  FEM_DO_SAFE(iz, -maxz, maxz) {
    FEM_DO_SAFE(iy, -maxx, maxx) {
      FEM_DO_SAFE(ix, -maxx, maxx) {
        if ((rho(ix, iy, iz) == 0) || (pel(ix, iy, iz) == 0)) {
          goto statement_101;
        }
        smass2 = fem::pow2(pel(ix, iy, iz)) - fem::pow2(pxl(ix, iy, iz)) -
                 fem::pow2(pyl(ix, iy, iz)) - fem::pow2(pzl(ix, iy, iz));
        if (smass2 <= 0) {
          smass2 = 1.e-06f;
        }
        smass = fem::sqrt(smass2);
        if (smass == 0.f) {
          smass = 1.e-06f;
        }
        gamma = pel(ix, iy, iz) / smass;
        if (gamma == 0) {
          goto statement_101;
        }
        bxx(ix, iy, iz) = pxl(ix, iy, iz) / pel(ix, iy, iz);
        byy(ix, iy, iz) = pyl(ix, iy, iz) / pel(ix, iy, iz);
        bzz(ix, iy, iz) = pzl(ix, iy, iz) / pel(ix, iy, iz);
        rho(ix, iy, iz) = rho(ix, iy, iz) / gamma;
        rhon(ix, iy, iz) = rhon(ix, iy, iz) / gamma;
        rhop(ix, iy, iz) = rhop(ix, iy, iz) / gamma;
        pirho(ix, iy, iz) = pirho(ix, iy, iz) / gamma;
        pel(ix, iy, iz) = pel(ix, iy, iz) / (fem::pow2(gamma));
        rho0 = 0.163f;
        if (ipot == 0) {
          u = 0;
          goto statement_70;
        }
        if (ipot == 1 || ipot == 6) {
          a = -0.1236f;
          b = 0.0704f;
          s = 2;
          goto statement_60;
        }
        if (ipot == 2 || ipot == 7) {
          a = -0.218f;
          b = 0.164f;
          s = 4.f / 3.f;
        }
        if (ipot == 3) {
          a = -0.3581f;
          b = 0.3048f;
          s = 1.167f;
          goto statement_60;
        }
        if (ipot == 4) {
          denr = rho(ix, iy, iz) / rho0;
          b = 0.3048f;
          s = 1.167f;
          if (denr <= 4 || denr > 7) {
            a = -0.3581f;
          } else {
            a = -b * fem::pow(denr, (1.f / 6.f)) -
                2.f * 0.036f / 3.f * fem::pow(denr, (-0.333f));
          }
          goto statement_60;
        }
      statement_60:
        u = 0.5f * a * fem::pow2(rho(ix, iy, iz)) / rho0 +
            b / (1 + s) * fem::pow((rho(ix, iy, iz) / rho0), s) *
                rho(ix, iy, iz);
      statement_70:
        pel(ix, iy, iz) += u;
      statement_101:;
      }
    }
  }
}

struct gradu_save {
  float acoef;
  float acoef1;
  float acoef2;
  float cf0;
  float den0;
  float denr;
  float ef;
  float eh;
  float ene0;
  float eqgp;
  float expnt;
  float expnt2;
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  gradu_save()
      : acoef(fem::float0),
        acoef1(fem::float0),
        acoef2(fem::float0),
        cf0(fem::float0),
        den0(fem::float0),
        denr(fem::float0),
        ef(fem::float0),
        eh(fem::float0),
        ene0(fem::float0),
        eqgp(fem::float0),
        expnt(fem::float0),
        expnt2(fem::float0),
        rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

// C
// C*********************************
// C                                                                      *
void gradu(common& cmn, int const& iopt, int const& ix, int const& iy,
           int const& iz, float& gradx, float& grady, float& gradz) {
  FEM_CMN_SVE(gradu);
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rho(cmn.rho,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_cref<float, 3> pel(cmn.pel,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  //
  float& acoef = sve.acoef;
  float& acoef1 = sve.acoef1;
  float& acoef2 = sve.acoef2;
  float& cf0 = sve.cf0;
  float& den0 = sve.den0;
  float& denr = sve.denr;
  float& ef = sve.ef;
  float& eh = sve.eh;
  float& ene0 = sve.ene0;
  float& eqgp = sve.eqgp;
  float& expnt = sve.expnt;
  float& expnt2 = sve.expnt2;
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  const float rho0 = 0.167f;
  // C                                                                      *
  // C       PURPOSE:     DETERMINE GRAD(U(RHO(X,Y,Z)))                     *
  // C       VARIABLES:                                                     *
  // C         IOPT                - METHOD FOR EVALUATING THE GRADIENT     *
  // C                                                      (INTEGER,INPUT) *
  // C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
  // C         GRADX, GRADY, GRADZ - GRADIENT OF U            (REAL,OUTPUT) *
  // C                                                                      *
  // C*********************************
  // C
  // Cc      SAVE /DD/
  // Cc      SAVE /ss/
  // Cc      SAVE /tt/
  // C
  rxplus = rho(ix + 1, iy, iz) / rho0;
  rxmins = rho(ix - 1, iy, iz) / rho0;
  ryplus = rho(ix, iy + 1, iz) / rho0;
  rymins = rho(ix, iy - 1, iz) / rho0;
  rzplus = rho(ix, iy, iz + 1) / rho0;
  rzmins = rho(ix, iy, iz - 1) / rho0;
  den0 = rho(ix, iy, iz) / rho0;
  ene0 = pel(ix, iy, iz);
  // C-----------------------------------------------------------------------
  switch (iopt) {
    case 1:
      goto statement_1;
    case 2:
      goto statement_2;
    case 3:
      goto statement_3;
    case 4:
      goto statement_4;
    case 5:
      goto statement_5;
    default:
      break;
  }
  if (iopt == 6) {
    goto statement_6;
  }
  if (iopt == 7) {
    goto statement_7;
  }
// C
statement_1:
  // C       POTENTIAL USED IN 1) (STIFF):
  // C       U = -.124 * RHO/RHO0 + .0705 (RHO/RHO0)**2 GEV
  // C
  gradx = -0.062f * (rxplus - rxmins) +
          0.03525f * (fem::pow2(rxplus) - fem::pow2(rxmins));
  grady = -0.062f * (ryplus - rymins) +
          0.03525f * (fem::pow2(ryplus) - fem::pow2(rymins));
  gradz = -0.062f * (rzplus - rzmins) +
          0.03525f * (fem::pow2(rzplus) - fem::pow2(rzmins));
  return;
// C
statement_2:
  // C       POTENTIAL USED IN 2):
  // C       U = -.218 * RHO/RHO0 + .164 (RHO/RHO0)**(4/3) GEV
  // C
  expnt = 1.3333333f;
  gradx = -0.109f * (rxplus - rxmins) +
          0.082f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
  grady = -0.109f * (ryplus - rymins) +
          0.082f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
  gradz = -0.109f * (rzplus - rzmins) +
          0.082f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  return;
// C
statement_3:
  // C       POTENTIAL USED IN 3) (SOFT):
  // C       U = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
  // C
  expnt = 1.1666667f;
  acoef = 0.178f;
  gradx = -acoef * (rxplus - rxmins) +
          0.1515f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
  grady = -acoef * (ryplus - rymins) +
          0.1515f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
  gradz = -acoef * (rzplus - rzmins) +
          0.1515f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  return;
// C
statement_4:
  // C       POTENTIAL USED IN 4) (super-soft in the mixed phase of 4 < rho/rho
  // <7): C       U1 = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV C normal
  // phase, soft eos of iopt=3 C       U2 = -.02 * (RHO/RHO0)**(2/3) -0.0253 *
  // (RHO/RHO0)**(7/6)  GEV
  // C
  eh = 4.f;
  eqgp = 7.f;
  acoef = 0.178f;
  expnt = 1.1666667f;
  denr = rho(ix, iy, iz) / rho0;
  if (denr <= eh || denr >= eqgp) {
    gradx = -acoef * (rxplus - rxmins) +
            0.1515f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
    grady = -acoef * (ryplus - rymins) +
            0.1515f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
    gradz = -acoef * (rzplus - rzmins) +
            0.1515f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  } else {
    acoef1 = 0.178f;
    acoef2 = 0.0f;
    expnt2 = 2.f / 3.f;
    gradx = -acoef1 * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt)) -
            acoef2 * (fem::pow(rxplus, expnt2) - fem::pow(rxmins, expnt2));
    grady = -acoef1 * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt)) -
            acoef2 * (fem::pow(ryplus, expnt2) - fem::pow(rymins, expnt2));
    gradz = -acoef1 * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt)) -
            acoef2 * (fem::pow(rzplus, expnt2) - fem::pow(rzmins, expnt2));
  }
  return;
// C
statement_5:
  // C       POTENTIAL USED IN 5) (SUPER STIFF):
  // C       U = -.10322 * RHO/RHO0 + .04956 * (RHO/RHO0)**(2.77)  GEV
  // C
  expnt = 2.77f;
  gradx = -0.0516f * (rxplus - rxmins) +
          0.02498f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
  grady = -0.0516f * (ryplus - rymins) +
          0.02498f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
  gradz = -0.0516f * (rzplus - rzmins) +
          0.02498f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  return;
// C
statement_6:
  // C       POTENTIAL USED IN 6) (STIFF-qgp):
  // C       U = -.124 * RHO/RHO0 + .0705 (RHO/RHO0)**2 GEV
  // C
  if (ene0 <= 0.5f) {
    gradx = -0.062f * (rxplus - rxmins) +
            0.03525f * (fem::pow2(rxplus) - fem::pow2(rxmins));
    grady = -0.062f * (ryplus - rymins) +
            0.03525f * (fem::pow2(ryplus) - fem::pow2(rymins));
    gradz = -0.062f * (rzplus - rzmins) +
            0.03525f * (fem::pow2(rzplus) - fem::pow2(rzmins));
    return;
  }
  if (ene0 > 0.5f && ene0 <= 1.5f) {
    // C       U=c1-ef*rho/rho0**2/3
    ef = 36.f / 1000.f;
    gradx = -0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = -0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = -0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
  if (ene0 > 1.5f) {
    // C U=800*(rho/rho0)**1/3.-Ef*(rho/rho0)**2/3.-c2
    ef = 36.f / 1000.f;
    cf0 = 0.8f;
    gradx = 0.5f * cf0 * (fem::pow(rxplus, 0.333f) - fem::pow(rxmins, 0.333f)) -
            0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = 0.5f * cf0 * (fem::pow(ryplus, 0.333f) - fem::pow(rymins, 0.333f)) -
            0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = 0.5f * cf0 * (fem::pow(rzplus, 0.333f) - fem::pow(rzmins, 0.333f)) -
            0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
// C
statement_7:
  // C       POTENTIAL USED IN 7) (Soft-qgp):
  if (den0 <= 4.5f) {
    // C       POTENTIAL USED is the same as IN 3) (SOFT):
    // C       U = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
    // C
    expnt = 1.1666667f;
    acoef = 0.178f;
    gradx = -acoef * (rxplus - rxmins) +
            0.1515f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
    grady = -acoef * (ryplus - rymins) +
            0.1515f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
    gradz = -acoef * (rzplus - rzmins) +
            0.1515f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
    return;
  }
  if (den0 > 4.5f && den0 <= 5.1f) {
    // C       U=c1-ef*rho/rho0**2/3
    ef = 36.f / 1000.f;
    gradx = -0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = -0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = -0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
  if (den0 > 5.1f) {
    // C U=800*(rho/rho0)**1/3.-Ef*(rho/rho0)**2/3.-c2
    ef = 36.f / 1000.f;
    cf0 = 0.8f;
    gradx = 0.5f * cf0 * (fem::pow(rxplus, 0.333f) - fem::pow(rxmins, 0.333f)) -
            0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = 0.5f * cf0 * (fem::pow(ryplus, 0.333f) - fem::pow(rymins, 0.333f)) -
            0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = 0.5f * cf0 * (fem::pow(rzplus, 0.333f) - fem::pow(rzmins, 0.333f)) -
            0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
}

struct graduk_save {
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  graduk_save()
      : rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

// C*********************************
// C                                                                      *
void graduk(common& cmn, int const& ix, int const& iy, int const& iz,
            float& gradxk, float& gradyk, float& gradzk) {
  FEM_CMN_SVE(graduk);
  // COMMON dd
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rho(cmn.rho,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  //
  // SAVE
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  //
  // C                                                                      *
  // C       PURPOSE:     DETERMINE the baryon density gradient for         *
  // C                    proporgating kaons in a mean field caused by      *
  // C                    surrounding baryons                               *
  // C       VARIABLES:                                                     *
  // C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
  // C         GRADXk, GRADYk, GRADZk                       (REAL,OUTPUT)   *
  // C                                                                      *
  // C*********************************
  // C
  // Cc      SAVE /DD/
  // Cc      SAVE /ss/
  // C
  rxplus = rho(ix + 1, iy, iz);
  rxmins = rho(ix - 1, iy, iz);
  ryplus = rho(ix, iy + 1, iz);
  rymins = rho(ix, iy - 1, iz);
  rzplus = rho(ix, iy, iz + 1);
  rzmins = rho(ix, iy, iz - 1);
  gradxk = (rxplus - rxmins) / 2.f;
  gradyk = (ryplus - rymins) / 2.f;
  gradzk = (rzplus - rzmins) / 2.f;
}

struct gradup_save {
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  gradup_save()
      : rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

// C-----------------------------------------------------------------------
void gradup(common& cmn, int const& ix, int const& iy, int const& iz,
            float& gradxp, float& gradyp, float& gradzp) {
  FEM_CMN_SVE(gradup);
  // COMMON dd
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rhop(
      cmn.rhop, dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  //
  // SAVE
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  //
  // C                                                                      *
  // C       PURPOSE:     DETERMINE THE GRADIENT OF THE PROTON DENSITY      *
  // C       VARIABLES:                                                     *
  // C * C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT)
  // * C         GRADXP, GRADYP, GRADZP - GRADIENT OF THE PROTON              *
  // C                                  DENSITY(REAL,OUTPUT)                *
  // C                                                                      *
  // C*********************************
  // C
  // Cc      SAVE /DD/
  // Cc      SAVE /ss/
  // C
  const float rho0 = 0.168f;
  rxplus = rhop(ix + 1, iy, iz) / rho0;
  rxmins = rhop(ix - 1, iy, iz) / rho0;
  ryplus = rhop(ix, iy + 1, iz) / rho0;
  rymins = rhop(ix, iy - 1, iz) / rho0;
  rzplus = rhop(ix, iy, iz + 1) / rho0;
  rzmins = rhop(ix, iy, iz - 1) / rho0;
  // C-----------------------------------------------------------------------
  // C
  gradxp = (rxplus - rxmins) / 2.f;
  gradyp = (ryplus - rymins) / 2.f;
  gradzp = (rzplus - rzmins) / 2.f;
}

struct gradun_save {
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  gradun_save()
      : rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

// C-----------------------------------------------------------------------
void gradun(common& cmn, int const& ix, int const& iy, int const& iz,
            float& gradxn, float& gradyn, float& gradzn) {
  FEM_CMN_SVE(gradun);
  // COMMON dd
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rhon(
      cmn.rhon, dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  //
  // SAVE
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  //
  // C                                                                      *
  // C       PURPOSE:     DETERMINE THE GRADIENT OF THE NEUTRON DENSITY     *
  // C       VARIABLES:                                                     *
  // C * C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT)
  // * C         GRADXN, GRADYN, GRADZN - GRADIENT OF THE NEUTRON             *
  // C                                  DENSITY(REAL,OUTPUT)                *
  // C                                                                      *
  // C*********************************
  // C
  // Cc      SAVE /DD/
  // Cc      SAVE /ss/
  // C
  const float rho0 = 0.168f;
  rxplus = rhon(ix + 1, iy, iz) / rho0;
  rxmins = rhon(ix - 1, iy, iz) / rho0;
  ryplus = rhon(ix, iy + 1, iz) / rho0;
  rymins = rhon(ix, iy - 1, iz) / rho0;
  rzplus = rhon(ix, iy, iz + 1) / rho0;
  rzmins = rhon(ix, iy, iz - 1) / rho0;
  // C-----------------------------------------------------------------------
  // C
  gradxn = (rxplus - rxmins) / 2.f;
  gradyn = (ryplus - rymins) / 2.f;
  gradzn = (rzplus - rzmins) / 2.f;
}

struct tablem_save {
  float anorm;
  int l;
  float ptmax;
  float rr;
  float x;

  tablem_save()
      : anorm(fem::float0),
        l(fem::int0),
        ptmax(fem::float0),
        rr(fem::float0),
        x(fem::float0) {}
};

// C***************************************
// C generate a table for pt distribution for
void tablem(common& cmn) {
  FEM_CMN_SVE(tablem);
  // COMMON table
  arr_ref<float> xarray(cmn.xarray, dim1(0, 1000));
  arr_ref<float> earray(cmn.earray, dim1(0, 1000));
  //
  // SAVE
  float& anorm = sve.anorm;
  int& l = sve.l;
  float& ptmax = sve.ptmax;
  float& rr = sve.rr;
  float& x = sve.x;
  //
  // C THE PROCESS N+N--->N+N+PION
  // C       DATE : July 11, 1994
  // C****************************************
  // Cc      SAVE /TABLE/
  ptmax = 2.01f;
  anorm = ptdis(cmn, ptmax);
  FEM_DO_SAFE(l, 0, 200) {
    x = 0.01f * fem::ffloat(l + 1);
    rr = ptdis(cmn, x) / anorm;
    earray(l) = rr;
    xarray(l) = x;
  }
}

struct flow_save {
  float dnuc;
  float dnuck;
  float dnucp;
  float dy;
  float dykaon;
  float dypion;
  float dypr;
  float e00;
  int i;
  int is;
  int iy;
  int j;
  int kk;
  int ly;
  int m;
  int nkaon;
  int npion;
  int npr;
  int npt;
  int nrun;
  arr<float> pxkaon;
  arr<float> pxpion;
  arr<float> pxpro;
  float y00;
  float ycut1;
  float ycut2;
  arr<float> ykaon;
  arr<float> ypion;
  arr<float> ypr;

  flow_save()
      : dnuc(fem::float0),
        dnuck(fem::float0),
        dnucp(fem::float0),
        dy(fem::float0),
        dykaon(fem::float0),
        dypion(fem::float0),
        dypr(fem::float0),
        e00(fem::float0),
        i(fem::int0),
        is(fem::int0),
        iy(fem::int0),
        j(fem::int0),
        kk(fem::int0),
        ly(fem::int0),
        m(fem::int0),
        nkaon(fem::int0),
        npion(fem::int0),
        npr(fem::int0),
        npt(fem::int0),
        nrun(fem::int0),
        pxkaon(dim1(-80, 80), fem::fill0),
        pxpion(dim1(-80, 80), fem::fill0),
        pxpro(dim1(-80, 80), fem::fill0),
        y00(fem::float0),
        ycut1(fem::float0),
        ycut2(fem::float0),
        ykaon(dim1(-80, 80), fem::fill0),
        ypion(dim1(-80, 80), fem::fill0),
        ypr(dim1(-80, 80), fem::fill0) {}
};

// C*********************************
// C PURPOSE : flow analysis
// C DATE : Feb. 1, 1995
// C**********************************
void flow(common& cmn, int const& /* nt */) {
  FEM_CMN_SVE(flow);
  const int maxstr = 150001;
  arr_cref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_cref<float> e(cmn.e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  const int maxr = 1;
  arr_cref<int> massr(cmn.massr, dim1(0, maxr));
  //
  float& dy = sve.dy;
  float& dykaon = sve.dykaon;
  float& dypion = sve.dypion;
  float& dypr = sve.dypr;
  float& e00 = sve.e00;
  int& i = sve.i;
  int& is = sve.is;
  int& iy = sve.iy;
  int& j = sve.j;
  int& kk = sve.kk;
  int& ly = sve.ly;
  int& m = sve.m;
  int& nkaon = sve.nkaon;
  int& npion = sve.npion;
  int& npr = sve.npr;
  int& npt = sve.npt;
  int& nrun = sve.nrun;
  arr_ref<float> pxkaon(sve.pxkaon, dim1(-80, 80));
  arr_ref<float> pxpion(sve.pxpion, dim1(-80, 80));
  arr_ref<float> pxpro(sve.pxpro, dim1(-80, 80));
  float& y00 = sve.y00;
  float& ycut1 = sve.ycut1;
  float& ycut2 = sve.ycut2;
  arr_ref<float> ykaon(sve.ykaon, dim1(-80, 80));
  arr_ref<float> ypion(sve.ypion, dim1(-80, 80));
  arr_ref<float> ypr(sve.ypr, dim1(-80, 80));
  // C       IMPLICIT REAL*4 (A-H,O-Z)
  // C----------------------------------------------------------------------*
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /EE/
  // Cc      SAVE /RR/
  // Cc      SAVE /RUN/
  // Cc      SAVE /input1/
  // C----------------------------------------------------------------------*
  ycut1 = -2.6f;
  ycut2 = 2.6f;
  dy = 0.2f;
  ly = fem::nint((ycut2 - ycut1) / dy);
  // C**********************************
  // C initialize the transverse momentum counters
  FEM_DO_SAFE(kk, -80, 80) {
    pxpion(kk) = 0;
    pxpro(kk) = 0;
    pxkaon(kk) = 0;
  }
  FEM_DO_SAFE(j, -ly, ly) {
    ypion(j) = 0;
    ykaon(j) = 0;
    ypr(j) = 0;
  }
  nkaon = 0;
  npr = 0;
  npion = 0;
  is = 0;
  FEM_DO_SAFE(nrun, 1, cmn.num) {
    is += massr(nrun - 1);
    FEM_DO_SAFE(j, 1, massr(nrun)) {
      i = j + is;
      // C for protons go to 200 to calculate its rapidity and transvese
      // momentum C distributions
      e00 = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                      fem::pow2(p(3, i)) + fem::pow2(e(i)));
      y00 = 0.5f * fem::alog((e00 + p(3, i)) / (e00 - p(3, i)));
      if (fem::abs(y00) >= ycut2) {
        goto statement_20;
      }
      iy = fem::nint(y00 / dy);
      if (fem::abs(iy) >= 80) {
        goto statement_20;
      }
      if (e(i) == 0) {
        goto statement_20;
      }
      if (lb(i) >= 25) {
        goto statement_20;
      }
      if ((lb(i) <= 5) && (lb(i) >= 3)) {
        goto statement_50;
      }
      if (lb(i) == 1 || lb(i) == 2) {
        goto statement_200;
      }
      // Cbz3/10/99
      // C       if(lb(i).ge.6.and.lb(i).le.15)go to 200
      if (lb(i) >= 6 && lb(i) <= 17) {
        goto statement_200;
      }
      // Cbz3/10/99 end
      if (lb(i) == 23) {
        goto statement_400;
      }
      goto statement_20;
    // C calculate rapidity and transverse momentum distribution for pions
    statement_50:
      npion++;
      // C (2) rapidity distribution in the cms frame
      ypion(iy)++;
      pxpion(iy) += p(1, i) / e(i);
      goto statement_20;
    // C calculate rapidity and transverse energy distribution for baryons
    statement_200:
      npr++;
      pxpro(iy) += p(1, i) / e(i);
      ypr(iy) += 1.f;
      goto statement_20;
    statement_400:
      nkaon++;
      ykaon(iy) += 1.f;
      pxkaon(iy) += p(1, i) / e(i);
    statement_20:;
    }
  }
  // C PRINT OUT NUCLEON'S TRANSVERSE MOMENTUM distribution
  // C       write(1041,*)Nt
  // C       write(1042,*)Nt
  // C       write(1043,*)Nt
  // C       write(1090,*)Nt
  // C       write(1091,*)Nt
  // C       write(1092,*)Nt
  FEM_DO_SAFE(npt, -10, 10) {
    if (ypr(npt) == 0) {
      goto statement_101;
    }
    pxpro(npt) = -pxpro(npt) / ypr(npt);
    sve.dnuc = pxpro(npt) / fem::sqrt(ypr(npt));
  // C       WRITE(1041,*)NPT*DY,Pxpro(NPT),DNUC
  // C print pion's transverse momentum distribution
  statement_101:
    if (ypion(npt) == 0) {
      goto statement_102;
    }
    pxpion(npt) = -pxpion(npt) / ypion(npt);
    sve.dnucp = pxpion(npt) / fem::sqrt(ypion(npt));
  // C       WRITE(1042,*)NPT*DY,Pxpion(NPT),DNUCp
  // C kaons
  statement_102:
    if (ykaon(npt) == 0) {
      goto statement_3;
    }
    pxkaon(npt) = -pxkaon(npt) / ykaon(npt);
    sve.dnuck = pxkaon(npt) / fem::sqrt(ykaon(npt));
  // C       WRITE(1043,*)NPT*DY,Pxkaon(NPT),DNUCk
  statement_3:;
  }
  // C*******************************
  // C OUTPUT PION AND PROTON RAPIDITY DISTRIBUTIONS
  FEM_DO_SAFE(m, -ly, ly) {
    // C PROTONS
    dypr = 0;
    if (ypr(m) != 0) {
      dypr = fem::sqrt(ypr(m)) / fem::ffloat(nrun) / dy;
    }
    ypr(m) = ypr(m) / fem::ffloat(nrun) / dy;
    // C       WRITE(1090,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YPR(M),DYPR
    // C PIONS
    dypion = 0;
    if (ypion(m) != 0) {
      dypion = fem::sqrt(ypion(m)) / fem::ffloat(nrun) / dy;
    }
    ypion(m) = ypion(m) / fem::ffloat(nrun) / dy;
    // C       WRITE(1091,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YPION(M),DYPION
    // C KAONS
    dykaon = 0;
    if (ykaon(m) != 0) {
      dykaon = fem::sqrt(ykaon(m)) / fem::ffloat(nrun) / dy;
    }
    ykaon(m) = ykaon(m) / fem::ffloat(nrun) / dy;
    // C       WRITE(1092,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YKAON(M),DYKAON
  }
}

struct artmn_save {
  static const int maxstr = 150001;
  static const int maxr = 1;

  float acndn;
  float acnnd;
  float acoll;
  float add;
  float addk;
  float addrho;
  float adecay;
  float adirt;
  float adou;
  float akaon;
  float akg;
  float akn;
  float ald;
  float ale;
  float alkaon;
  float aln;
  float aln5;
  float alp;
  float andk;
  float annk;
  float annom;
  float annrho;
  float aom;
  float apd;
  float apn;
  float app;
  float appk;
  float ares;
  float arh;
  float asy;
  float atotal;
  float b;
  float b2;
  float betac;
  float betapr;
  float betata;
  float bkg;
  float bmax;
  float bx;
  float by;
  float cden;
  float ct;
  float ctlong;
  float ddx;
  float ddy;
  float ddz;
  float den;
  float denst;
  float drr;
  float ecms0;
  float ecor;
  float edenst;
  float ekin;
  float engs;
  float epr;
  float esbin;
  arr<float, 2> et;
  float eta;
  float etotal;
  float facl;
  float gammas;
  float gammc;
  float gammpr;
  float gammta;
  float gradx;
  float gradxk;
  float gradxn;
  float gradxp;
  float grady;
  float gradyk;
  float gradyn;
  float gradyp;
  float gradz;
  float gradzk;
  float gradzn;
  float gradzp;
  float grp;
  int i;
  int i0;
  int ia;
  int ib;
  int ic;
  int idir;
  int ie;
  int ii;
  int ikaon;
  int il;
  int imany;
  int ipart;
  int ir;
  int irun;
  int is;
  int iso;
  int iss;
  int ix;
  int iy;
  int iz;
  int j;
  int jl;
  int kkk;
  int l0;
  int lb1;
  int lbloc;
  int lcndn;
  int lcnnd;
  int lcnne;
  int lcoll;
  int ld;
  int ld1;
  int ld2;
  int ld3;
  int ld4;
  int ldd;
  int lddk;
  int lddrho;
  int ldecay;
  int ldirt;
  int ldou;
  int le;
  int lkaon;
  int lkaons;
  int lkn;
  int ln;
  int ln1;
  int ln2;
  int ln5;
  int lndk;
  int lnnk;
  int lnnom;
  int lnnrho;
  int lomega;
  int lp;
  int lp1;
  int lp2;
  int lp3;
  int lpd;
  int lpn;
  int lpp;
  int lppk;
  int lres;
  int lrho;
  int lrun;
  arr<int, 2> lt;
  int mass;
  int mean;
  int mrun;
  int nbaryn;
  int ncen;
  int nlost;
  int np;
  int np1;
  arr<int> npi;
  int nquark;
  int nsh;
  int nt;
  int ntotal;
  int numnt;
  int outpar;
  float pr0;
  float pr1;
  arr<float, 2> prot;
  float psqare;
  arr<float, 3> pt;
  float pzpr;
  float pzta;
  float radpr;
  float rads;
  float radta;
  float radut;
  float rbloc;
  float rcndn;
  float rcnnd;
  float rcnne;
  float rcoll;
  float rdd;
  float rddk;
  float rdecay;
  float rdiff;
  float rdirt;
  float rkn;
  float rndk;
  float rnnk;
  float rnsg;
  float rpd;
  float rpn;
  float rpp;
  float rppk;
  float rres;
  arr<float, 3> rt;
  float s;
  arr<float, 2> sekaon;
  float sk;
  float ska0;
  float ska1;
  arr<float> skaon;
  float sp;
  float spt;
  float spz;
  float sumene;
  arr<float, 2> temp;
  float tz;
  float udt;
  float vols;
  float xx1;
  float xx2;
  float zdist;
  arr<float> zet;
  float zras;

  artmn_save()
      : acndn(fem::float0),
        acnnd(fem::float0),
        acoll(fem::float0),
        add(fem::float0),
        addk(fem::float0),
        addrho(fem::float0),
        adecay(fem::float0),
        adirt(fem::float0),
        adou(fem::float0),
        akaon(fem::float0),
        akg(fem::float0),
        akn(fem::float0),
        ald(fem::float0),
        ale(fem::float0),
        alkaon(fem::float0),
        aln(fem::float0),
        aln5(fem::float0),
        alp(fem::float0),
        andk(fem::float0),
        annk(fem::float0),
        annom(fem::float0),
        annrho(fem::float0),
        aom(fem::float0),
        apd(fem::float0),
        apn(fem::float0),
        app(fem::float0),
        appk(fem::float0),
        ares(fem::float0),
        arh(fem::float0),
        asy(fem::float0),
        atotal(fem::float0),
        b(fem::float0),
        b2(fem::float0),
        betac(fem::float0),
        betapr(fem::float0),
        betata(fem::float0),
        bkg(fem::float0),
        bmax(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        cden(fem::float0),
        ct(fem::float0),
        ctlong(fem::float0),
        ddx(fem::float0),
        ddy(fem::float0),
        ddz(fem::float0),
        den(fem::float0),
        denst(fem::float0),
        drr(fem::float0),
        ecms0(fem::float0),
        ecor(fem::float0),
        edenst(fem::float0),
        ekin(fem::float0),
        engs(fem::float0),
        epr(fem::float0),
        esbin(fem::float0),
        et(dimension(maxstr, maxr), fem::fill0),
        eta(fem::float0),
        etotal(fem::float0),
        facl(fem::float0),
        gammas(fem::float0),
        gammc(fem::float0),
        gammpr(fem::float0),
        gammta(fem::float0),
        gradx(fem::float0),
        gradxk(fem::float0),
        gradxn(fem::float0),
        gradxp(fem::float0),
        grady(fem::float0),
        gradyk(fem::float0),
        gradyn(fem::float0),
        gradyp(fem::float0),
        gradz(fem::float0),
        gradzk(fem::float0),
        gradzn(fem::float0),
        gradzp(fem::float0),
        grp(fem::float0),
        i(fem::int0),
        i0(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        idir(fem::int0),
        ie(fem::int0),
        ii(fem::int0),
        ikaon(fem::int0),
        il(fem::int0),
        imany(fem::int0),
        ipart(fem::int0),
        ir(fem::int0),
        irun(fem::int0),
        is(fem::int0),
        iso(fem::int0),
        iss(fem::int0),
        ix(fem::int0),
        iy(fem::int0),
        iz(fem::int0),
        j(fem::int0),
        jl(fem::int0),
        kkk(fem::int0),
        l0(fem::int0),
        lb1(fem::int0),
        lbloc(fem::int0),
        lcndn(fem::int0),
        lcnnd(fem::int0),
        lcnne(fem::int0),
        lcoll(fem::int0),
        ld(fem::int0),
        ld1(fem::int0),
        ld2(fem::int0),
        ld3(fem::int0),
        ld4(fem::int0),
        ldd(fem::int0),
        lddk(fem::int0),
        lddrho(fem::int0),
        ldecay(fem::int0),
        ldirt(fem::int0),
        ldou(fem::int0),
        le(fem::int0),
        lkaon(fem::int0),
        lkaons(fem::int0),
        lkn(fem::int0),
        ln(fem::int0),
        ln1(fem::int0),
        ln2(fem::int0),
        ln5(fem::int0),
        lndk(fem::int0),
        lnnk(fem::int0),
        lnnom(fem::int0),
        lnnrho(fem::int0),
        lomega(fem::int0),
        lp(fem::int0),
        lp1(fem::int0),
        lp2(fem::int0),
        lp3(fem::int0),
        lpd(fem::int0),
        lpn(fem::int0),
        lpp(fem::int0),
        lppk(fem::int0),
        lres(fem::int0),
        lrho(fem::int0),
        lrun(fem::int0),
        lt(dimension(maxstr, maxr), fem::fill0),
        mass(fem::int0),
        mean(fem::int0),
        mrun(fem::int0),
        nbaryn(fem::int0),
        ncen(fem::int0),
        nlost(fem::int0),
        np(fem::int0),
        np1(fem::int0),
        npi(dimension(maxr), fem::fill0),
        nquark(fem::int0),
        nsh(fem::int0),
        nt(fem::int0),
        ntotal(fem::int0),
        numnt(fem::int0),
        outpar(fem::int0),
        pr0(fem::float0),
        pr1(fem::float0),
        prot(dimension(maxstr, maxr), fem::fill0),
        psqare(fem::float0),
        pt(dimension(3, maxstr, maxr), fem::fill0),
        pzpr(fem::float0),
        pzta(fem::float0),
        radpr(fem::float0),
        rads(fem::float0),
        radta(fem::float0),
        radut(fem::float0),
        rbloc(fem::float0),
        rcndn(fem::float0),
        rcnnd(fem::float0),
        rcnne(fem::float0),
        rcoll(fem::float0),
        rdd(fem::float0),
        rddk(fem::float0),
        rdecay(fem::float0),
        rdiff(fem::float0),
        rdirt(fem::float0),
        rkn(fem::float0),
        rndk(fem::float0),
        rnnk(fem::float0),
        rnsg(fem::float0),
        rpd(fem::float0),
        rpn(fem::float0),
        rpp(fem::float0),
        rppk(fem::float0),
        rres(fem::float0),
        rt(dimension(3, maxstr, maxr), fem::fill0),
        s(fem::float0),
        sekaon(dim1(7).dim2(0, 2000), fem::fill0),
        sk(fem::float0),
        ska0(fem::float0),
        ska1(fem::float0),
        skaon(dimension(7), fem::fill0),
        sp(fem::float0),
        spt(fem::float0),
        spz(fem::float0),
        sumene(fem::float0),
        temp(dimension(3, maxstr), fem::fill0),
        tz(fem::float0),
        udt(fem::float0),
        vols(fem::float0),
        xx1(fem::float0),
        xx2(fem::float0),
        zdist(fem::float0),
        zet(dim1(-45, 45), fem::fill0),
        zras(fem::float0) {}
};

const int artmn_save::maxstr;
const int artmn_save::maxr;

// C....................art1f.f
// C*************************************
// C
// C                           PROGRAM ART1.0
// C
// C        A relativistic transport (ART) model for heavy-ion collisions
// C
// C   sp/01/04/2002
// C   calculates K+K- from phi decay, dimuons from phi decay
// C   has finite baryon density & possibilites of varying Kaon
// C   in-medium mass in phiproduction-annhilation channel only.
// C
// C RELEASING DATE: JAN., 1997
// C**************************************
// C
// C Bao-An Li & Che Ming Ko
// C Cyclotron Institute, Texas A&M University.
// C Phone: (409) 845-1411
// C e-mail: Bali@comp.tamu.edu & Ko@comp.tamu.edu
// C http://wwwcyc.tamu.edu/~bali
// C**************************************
// C Speical notice on the limitation of the code:
// C
// C (1) ART is a hadronic transport model
// C
// C (2) E_beam/A <= 15 GeV
// C
// C (3) The mass of the colliding system is limited by the dimensions of arrays
// C    which can be extended purposely. Presently the dimensions are large
// enough C     for running Au+Au at 15 GeV/A.
// C
// C (4) The production and absorption of antiparticles (e.g., ki-,
// anti-nucleons, C     etc) are not fully included in this version of the model.
// They, however, C     have essentially no effect on the reaction dynamics and
// observables C     related to nucleons, pions and kaons (K+) at and below AGS
// energies.
// C
// C (5) Bose enhancement for mesons and Pauli blocking for fermions are
// C     turned off.
// C
// C********************************
// C
// C USEFUL REFERENCES ON PHYSICS AND NUMERICS OF NUCLEAR TRANSPORT MODELS:
// C     G.F. BERTSCH AND DAS GUPTA, PHYS. REP. 160 (1988) 189.
// C     B.A. LI AND W. BAUER, PHYS. REV. C44 (1991) 450.
// C     B.A. LI, W. BAUER AND G.F. BERTSCH, PHYS. REV. C44 (1991) 2095.
// C     P. DANIELEWICZ AND G.F. BERTSCH, NUCL. PHYS. A533 (1991) 712.
// C
// C MAIN REFERENCES ON THIS VERSION OF ART MODEL:
// C     B.A. LI AND C.M. KO, PHYS. REV. C52 (1995) 2037;
// C                          NUCL. PHYS. A601 (1996) 457.
// C
// C*********************************
// C  VARIABLES IN INPUT-SECTION: * C * C  1) TARGET-RELATED QUANTITIES * C
// MASSTA, ZTA -  TARGET MASS IN AMU, TARGET CHARGE  (INTEGER)    * C * C  2)
// PROJECTILE-RELATED QUANTITIES                                    * C MASSPR,
// ZPR -  PROJECTILE MASS IN AMU, PROJ. CHARGE(INTEGER)   * C       ELAB     -
// BEAM ENERGY IN [MEV/NUCLEON]               (REAL)  * C       ZEROPT   -
// DISPLACEMENT OF THE SYSTEM IN Z-DIREC. [FM](REAL)  * C       B        - IMPACT
// PARAMETER [FM]                      (REAL)  * C * C  3) PROGRAM-CONTROL
// PARAMETERS                                       * C       ISEED    -  SEED
// FOR RANDOM NUMBER GENERATOR        (INTEGER)  * C       DT       -
// TIME-STEP-SIZE [FM/C]                      (REAL)  * C       NTMAX    -  TOTAL
// NUMBER OF TIMESTEPS               (INTEGER)  * C       ICOLL    -  (= 1 ->
// MEAN FIELD ONLY,                           * C                -   =-1 ->
// CACADE ONLY, ELSE FULL ART)     (INTEGER)  * C       NUM      -  NUMBER OF
// TESTPARTICLES PER NUCLEON     (INTEGER)  * C       INSYS    -  (=0 ->
// LAB-SYSTEM, ELSE C.M. SYSTEM)    (INTEGER)  * C       IPOT     -  1 ->
// SIGMA=2; 2 -> SIGMA=4/3; 3 -> SIGMA=7/6       * C                   IN MEAN
// FIELD POTENTIAL                 (INTEGER)  * C       MODE     -  (=1 ->
// interpolation for pauli-blocking,           * C                    =2 -> local
// lookup, other -> unblocked)(integer)  * C       DX,DY,DZ -  widths of cell for
// paulat in coor. sp. [fm](real)  * C       DPX,DPY,DPZ-widths of cell for
// paulat in mom. sp.[GeV/c](real) * C       IAVOID   -  (=1 -> AVOID FIRST COLL.
// WITHIN SAME NUCL.         * C                    =0 -> ALLOW THEM) (INTEGER) *
// C       IMOMEN   -  FLAG FOR CHOICE OF INITIAL MOMENTUM DISTRIBUTION   *
// C                   (=1 -> WOODS-SAXON DENSITY AND LOCAL THOMAS-FERMI  *
// C                    =2 -> NUCLEAR MATTER DEN. AND LOCAL THOMAS-FERMI  *
// C                    =3 -> COHERENT BOOST IN Z-DIRECTION)   (INTEGER)  *
// C  4) CONTROL-PRINTOUT OPTIONS                                         *
// C       NFREQ    -  NUMBER OF TIMSTEPS AFTER WHICH PRINTOUT            *
// C                   IS REQUIRED OR ON-LINE ANALYSIS IS PERFORMED       *
// C       ICFLOW      =1 PERFORM ON-LINE FLOW ANALYSIS EVERY NFREQ STEPS *
// C       ICRHO       =1 PRINT OUT THE BARYON,PION AND ENERGY MATRIX IN  *
// C                      THE REACTION PLANE EVERY NFREQ TIME-STEPS       *
// C  5)
// C       CYCBOX   -  ne.0 => cyclic boundary conditions;boxsize CYCBOX  *
// C
// C*********************************
// C               Lables of particles used in this code                     *
// C*********************************
// C
// C         LB(I) IS USED TO LABEL PARTICLE'S CHARGE STATE
// C
// C         LB(I)   =
// Clin-11/07/00:
// C                -30 K*-
// Clin-8/29/00
// C                -13 anti-N*(+1)(1535),s_11
// C                -12 anti-N*0(1535),s_11
// C                 -11 anti-N*(+1)(1440),p_11
// C                 -10 anti-N*0(1440), p_11
// C                  -9 anti-DELTA+2
// C                  -8 anti-DELTA+1
// C                  -7 anti-DELTA0
// C                  -6 anti-DELTA-1
// Clin-8/29/00-end
// C
// Cbali2/7/99
// C                  -2 antineutron
// C                             -1       antiproton
// Cbali2/7/99 end
// C                   0 eta
// C                        1 PROTON
// C                   2 NUETRON
// C                   3 PION-
// C                   4 PION0
// C                   5 PION+
// C                   6 DELTA-1
// C                   7 DELTA0
// C                   8 DELTA+1
// C                   9 DELTA+2
// C                   10 N*0(1440), p_11
// C                   11 N*(+1)(1440),p_11
// C                  12 N*0(1535),s_11
// C                  13 N*(+1)(1535),s_11
// C                  14 LAMBDA
// C                   15 sigma-, since we used isospin averaged xsection for
// C                   16 sigma0  sigma associated K+ production, sigma0 and
// C                   17 sigma+  sigma+ are counted as sigma-
// C                   21 kaon-
// C                   23 KAON+
// C                   24 kaon0
// C                   25 rho-
// C                         26 rho0
// C                   27 rho+
// C                   28 omega meson
// C                   29 phi
// Clin-11/07/00:
// C                  30 K*+
// C sp01/03/01
// C                 -14 LAMBDA(bar)
// C                  -15 sigma-(bar)
// C                  -16 sigma0(bar)
// C                  -17 sigma+(bar)
// C                   31 eta-prime
// C                   40 cascade-
// C                  -40 cascade-(bar)
// C                   41 cascade0
// C                  -41 cascade0(bar)
// C                   45 Omega baryon
// C                  -45 Omega baryon(bar)
// C sp01/03/01 end
// Clin-5/2008:
// C                   42 Deuteron (same in ampt.dat)
// C                  -42 anti-Deuteron (same in ampt.dat)
// C
// C                   ++  ------- SEE BAO-AN LI'S NOTE BOOK
// C*********************************
// Cbz11/16/98
// C      PROGRAM ART
void artmn(common& cmn) {
  FEM_CMN_SVE(artmn);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(cmn.r, dimension(3, maxstr));
  arr_ref<float, 2> p(cmn.p, dimension(3, maxstr));
  arr_ref<float> e(cmn.e, dimension(maxstr));
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rho(cmn.rho,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  arr_ref<float> proper(cmn.proper, dimension(maxstr));
  const int maxr = 1;
  arr_ref<int> massr(cmn.massr, dim1(0, maxr));
  int& num = cmn.num;
  int& masspr = cmn.masspr;
  int& massta = cmn.massta;
  int& iseed = cmn.iseed;
  float& dt = cmn.dt;
  arr_cref<float, 3> pel(cmn.pel,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  int& manyb = cmn.manyb;
  int& ntmax = cmn.ntmax;
  int& icoll = cmn.icoll;
  int& ipot = cmn.ipot;
  int& imomen = cmn.imomen;
  int& nfreq = cmn.nfreq;
  int& icou = cmn.icou;
  int& kpoten = cmn.kpoten;
  float& zeropt = cmn.zeropt;
  float& bi = cmn.bi;
  float& cycbox = cmn.cycbox;
  arr_cref<int> iapar2(cmn.iapar2, dimension(50));
  arr_ref<float, 2> pro1(cmn.pro1, dimension(maxstr, maxr));
  arr_ref<int> multi1(cmn.multi1, dimension(maxr));
  arr_ref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
  arr_ref<float, 2> gx1(cmn.gx1, dimension(maxstr, maxr));
  arr_ref<float, 2> gy1(cmn.gy1, dimension(maxstr, maxr));
  arr_ref<float, 2> gz1(cmn.gz1, dimension(maxstr, maxr));
  arr_ref<float, 2> ft1(cmn.ft1, dimension(maxstr, maxr));
  arr_ref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
  arr_ref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
  arr_ref<int> lblast(cmn.lblast, dimension(maxstr));
  arr_ref<float, 2> xlast(cmn.xlast, dimension(4, maxstr));
  arr_ref<float, 2> plast(cmn.plast, dimension(4, maxstr));
  int& nseed = cmn.nseed;
  arr_ref<float> ftsv(cmn.ftsv, dimension(maxstr));
  arr_ref<float, 2> ftsvt(cmn.ftsvt, dimension(maxstr, maxr));
  arr_ref<float, 2> dpertt(cmn.dpertt, dimension(maxstr, maxr));
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dpp1(cmn.dpp1, dimension(maxstr, maxr));
  //
  float& akg = sve.akg;
  float& ald = sve.ald;
  float& aln = sve.aln;
  float& aln5 = sve.aln5;
  float& alp = sve.alp;
  float& asy = sve.asy;
  float& b = sve.b;
  float& b2 = sve.b2;
  float& betac = sve.betac;
  float& betapr = sve.betapr;
  float& betata = sve.betata;
  float& bkg = sve.bkg;
  float& bx = sve.bx;
  float& by = sve.by;
  float& ct = sve.ct;
  float& ctlong = sve.ctlong;
  float& ddx = sve.ddx;
  float& ddy = sve.ddy;
  float& ddz = sve.ddz;
  float& den = sve.den;
  float& denst = sve.denst;
  float& drr = sve.drr;
  float& ecor = sve.ecor;
  float& edenst = sve.edenst;
  float& ekin = sve.ekin;
  float& engs = sve.engs;
  float& epr = sve.epr;
  arr_ref<float, 2> et(sve.et, dimension(maxstr, maxr));
  float& eta = sve.eta;
  float& etotal = sve.etotal;
  float& facl = sve.facl;
  float& gammas = sve.gammas;
  float& gammpr = sve.gammpr;
  float& gammta = sve.gammta;
  float& gradx = sve.gradx;
  float& gradxk = sve.gradxk;
  float& gradxn = sve.gradxn;
  float& gradxp = sve.gradxp;
  float& grady = sve.grady;
  float& gradyk = sve.gradyk;
  float& gradyn = sve.gradyn;
  float& gradyp = sve.gradyp;
  float& gradz = sve.gradz;
  float& gradzk = sve.gradzk;
  float& gradzn = sve.gradzn;
  float& gradzp = sve.gradzp;
  float& grp = sve.grp;
  int& i = sve.i;
  int& i0 = sve.i0;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& idir = sve.idir;
  int& ie = sve.ie;
  int& ii = sve.ii;
  int& il = sve.il;
  int& ir = sve.ir;
  int& irun = sve.irun;
  int& is = sve.is;
  int& iso = sve.iso;
  int& iss = sve.iss;
  int& ix = sve.ix;
  int& iy = sve.iy;
  int& iz = sve.iz;
  int& j = sve.j;
  int& jl = sve.jl;
  int& kkk = sve.kkk;
  int& l0 = sve.l0;
  int& lb1 = sve.lb1;
  int& lbloc = sve.lbloc;
  int& lcndn = sve.lcndn;
  int& lcnnd = sve.lcnnd;
  int& lcnne = sve.lcnne;
  int& lcoll = sve.lcoll;
  int& ld = sve.ld;
  int& ld1 = sve.ld1;
  int& ld2 = sve.ld2;
  int& ld3 = sve.ld3;
  int& ld4 = sve.ld4;
  int& ldd = sve.ldd;
  int& lddk = sve.lddk;
  int& lddrho = sve.lddrho;
  int& ldecay = sve.ldecay;
  int& ldirt = sve.ldirt;
  int& ldou = sve.ldou;
  int& le = sve.le;
  int& lkaon = sve.lkaon;
  int& lkaons = sve.lkaons;
  int& lkn = sve.lkn;
  int& ln = sve.ln;
  int& ln1 = sve.ln1;
  int& ln2 = sve.ln2;
  int& ln5 = sve.ln5;
  int& lndk = sve.lndk;
  int& lnnk = sve.lnnk;
  int& lnnom = sve.lnnom;
  int& lnnrho = sve.lnnrho;
  int& lomega = sve.lomega;
  int& lp = sve.lp;
  int& lp1 = sve.lp1;
  int& lp2 = sve.lp2;
  int& lp3 = sve.lp3;
  int& lpd = sve.lpd;
  int& lpn = sve.lpn;
  int& lpp = sve.lpp;
  int& lppk = sve.lppk;
  int& lres = sve.lres;
  int& lrho = sve.lrho;
  int& lrun = sve.lrun;
  arr_ref<int, 2> lt(sve.lt, dimension(maxstr, maxr));
  int& mass = sve.mass;
  int& mean = sve.mean;
  int& mrun = sve.mrun;
  int& nbaryn = sve.nbaryn;
  int& ncen = sve.ncen;
  int& np = sve.np;
  int& np1 = sve.np1;
  arr_ref<int> npi(sve.npi, dimension(maxr));
  int& nquark = sve.nquark;
  int& nsh = sve.nsh;
  int& nt = sve.nt;
  int& ntotal = sve.ntotal;
  int& numnt = sve.numnt;
  int& outpar = sve.outpar;
  arr_ref<float, 2> prot(sve.prot, dimension(maxstr, maxr));
  float& psqare = sve.psqare;
  arr_ref<float, 3> pt(sve.pt, dimension(3, maxstr, maxr));
  float& pzpr = sve.pzpr;
  float& pzta = sve.pzta;
  float& radpr = sve.radpr;
  float& rads = sve.rads;
  float& radta = sve.radta;
  float& radut = sve.radut;
  float& rbloc = sve.rbloc;
  float& rcndn = sve.rcndn;
  float& rcnnd = sve.rcnnd;
  float& rcnne = sve.rcnne;
  float& rcoll = sve.rcoll;
  float& rdd = sve.rdd;
  float& rddk = sve.rddk;
  float& rdecay = sve.rdecay;
  float& rdiff = sve.rdiff;
  float& rdirt = sve.rdirt;
  float& rkn = sve.rkn;
  float& rndk = sve.rndk;
  float& rnnk = sve.rnnk;
  float& rnsg = sve.rnsg;
  float& rpd = sve.rpd;
  float& rpn = sve.rpn;
  float& rpp = sve.rpp;
  float& rppk = sve.rppk;
  float& rres = sve.rres;
  arr_ref<float, 3> rt(sve.rt, dimension(3, maxstr, maxr));
  float& s = sve.s;
  float& spt = sve.spt;
  float& spz = sve.spz;
  float& sumene = sve.sumene;
  arr_ref<float, 2> temp(sve.temp, dimension(3, maxstr));
  float& tz = sve.tz;
  float& udt = sve.udt;
  float& vols = sve.vols;
  float& xx1 = sve.xx1;
  float& xx2 = sve.xx2;
  float& zdist = sve.zdist;
  arr_ref<float> zet(sve.zet, dim1(-45, 45));
  float& zras = sve.zras;
  if (is_called_first_time) {
    static const float values[] = {
        1.f,  0.f,  0.f, 0.f,  0.f,  1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, -1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, 0.f,  -1.f, 0.f, 1.f,  0.f, -1.f, 0.f, -1.f, 0.f,
        -2.f, -1.f, 0.f, 1.f,  0.f,  0.f, 0.f,  0.f, -1.f, 0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, -1.f, 0.f,  1.f, 2.f,  0.f, 1.f,  0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, 0.f,  0.f,  0.f, -1.f, 0.f, 1.f,  0.f, -1.f, 0.f,
        1.f,  0.f,  0.f, 1.f,  0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  -1.f, 0.f, 0.f,  0.f,  0.f, -1.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), zet;
  }
  const float amu = 0.9383f;
  arr_ref<float> skaon(sve.skaon, dimension(7));
  arr_ref<float, 2> sekaon(sve.sekaon, dim1(7).dim2(0, 2000));
  // Cbz11/16/98end
  // C*********************************
  // C PARAMETERS:                                                           *
  // C  MAXPAR     - MAXIMUM NUMBER OF PARTICLES      PROGRAM CAN HANDLE     *
  // C  MAXP       - MAXIMUM NUMBER OF CREATED MESONS PROGRAM CAN HANDLE     *
  // C  MAXR       - MAXIMUM NUMBER OF EVENTS AT EACH IMPACT PARAMETER       *
  // C  MAXX       - NUMBER OF MESHPOINTS IN X AND Y DIRECTION = 2 MAXX + 1  *
  // C  MAXZ       - NUMBER OF MESHPOINTS IN Z DIRECTION       = 2 MAXZ + 1  *
  // C  AMU        - 1 ATOMIC MASS UNIT "GEV/C**2"                           *
  // C  MX,MY,MZ   - MESH SIZES IN COORDINATE SPACE [FM] FOR PAULI LATTICE   *
  // C  MPX,MPY,MPZ- MESH SIZES IN MOMENTUM SPACE [GEV/C] FOR PAULI LATTICE  *
  // C---------------------------------------------------------------------- *
  // Clin      PARAMETER     (maxpar=200000,MAXR=50,AMU= 0.9383,
  // Clin      PARAMETER (MAXP = 14000)
  // C----------------------------------------------------------------------*
  // Cc      SAVE /AA/
  // Cc      SAVE /BB/
  // Cc      SAVE /CC/
  // Cc      SAVE /DD/
  // Cc      SAVE /EE/
  // Cc      SAVE /HH/
  // Cc      SAVE /ff/
  // Cc      SAVE /gg/
  // Cc      SAVE /INPUT/
  // Cc      SAVE /RR/
  // Cc      SAVE /ss/
  // Cc      SAVE /zz/
  // Cc      SAVE /RUN/
  // Clin-4/2008:
  // C      COMMON  /KKK/     TKAON(7),EKAON(7,0:200)
  // Cc      SAVE /KKK/
  // Cc      SAVE /KAON/
  // Cc      SAVE /TABLE/
  // Cc      SAVE /input1/
  // Cc      SAVE /DDpi/
  // Cc      SAVE /tt/
  // Clin-4/2008:
  // C      DIMENSION TEMP(3,MAXSTR),SKAON(7),SEKAON(7,0:200)
  // Cbz12/2/98
  // Cc      SAVE /INPUT2/
  // Cc      SAVE /INPUT3/
  // Cbz12/2/98end
  // Cbz11/16/98
  // Cc      SAVE /ARPRNT/
  // C
  // C.....note in the below, since a common block in ART is called EE,
  // C.....the variable EE in /ARPRC/is changed to PEAR.
  // Clin-9/29/03 changed name in order to distinguish from /prec2/
  // C        COMMON /ARPRC/ ITYPAR(MAXSTR),
  // C     &       GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
  // C     &       PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
  // C     &       XMAR(MAXSTR)
  // Cc      SAVE /ARPRC/
  // Clin-9/29/03-end
  // Cc      SAVE /ARERCP/
  // Cc      SAVE /ARERC1/
  // Cc      SAVE /ARPRC1/
  // C
  // Cbz11/16/98end
  // Cc      SAVE /lastt/
  // Cc      SAVE /snn/
  // Cc      SAVE /hbt/
  // Cc      SAVE /resdcy/
  // Cc      SAVE /RNDF77/
  // Clin-4/2008 zet() expanded to avoid out-of-bound errors:
  // C
  cmn.nlast = 0;
  FEM_DO_SAFE(i, 1, maxstr) {
    ftsv(i) = 0.f;
    FEM_DO_SAFE(irun, 1, maxr) { ftsvt(i, irun) = 0.f; }
    lblast(i) = 999;
    FEM_DO_SAFE(j, 1, 4) {
      // Clin-4/2008 bugs pointed out by Vander Molen & Westfall:
      // C            xlast(i,j)=0.
      // C            plast(i,j)=0.
      xlast(j, i) = 0.f;
      plast(j, i) = 0.f;
    }
  }
  // C
  // C-------------------------------------------------------------------*
  // C Input information about the reaction system and contral parameters*
  // C-------------------------------------------------------------------*
  // C              input section starts here                           *
  // C-------------------------------------------------------------------*
  // C
  // Cbz12/2/98
  // C.....input section is moved to subroutine ARTSET
  // Cbz12/2/98end
  // C
  // C-----------------------------------------------------------------------*
  // C                   input section ends here                            *
  // C-----------------------------------------------------------------------*
  // C read in the table for gengrating the transverse momentum
  // C IN THE NN-->DDP PROCESS
  tablem(cmn);
  // C several control parameters, keep them fixed in this code.
  sve.ikaon = 1;
  cmn.nstar = 1;
  cmn.ndirct = 0;
  cmn.dir = 0.02f;
  asy = 0.032f;
  sve.esbin = 0.04f;
  cmn.mf = 36;
  // C----------------------------------------------------------------------*
  // C      CALL FRONT(12,MASSTA,MASSPR,ELAB)
  // C----------------------------------------------------------------------*
  radta = 1.124f * fem::pow(fem::ffloat(massta), (1.f / 3.f));
  radpr = 1.124f * fem::pow(fem::ffloat(masspr), (1.f / 3.f));
  zdist = radta + radpr;
  // C      if ( cycbox.ne.0 ) zdist=0
  sve.bmax = radta + radpr;
  mass = massta + masspr;
  ntotal = num * mass;
  // C
  if (ntotal > maxstr) {
    write(12, "(//10X,'**** FATAL ERROR: TOO MANY TEST PART. ****" +
                  str_cref(" ')"));
    FEM_STOP(0);
  }
  // C
  // C-----------------------------------------------------------------------
  // C       RELATIVISTIC KINEMATICS
  // C
  // C       1) LABSYSTEM
  // C
  eta = fem::ffloat(massta) * amu;
  pzta = 0.0f;
  betata = 0.0f;
  gammta = 1.0f;
  // C
  epr = fem::ffloat(masspr) * (amu + 0.001f * cmn.elab);
  pzpr = fem::sqrt(fem::pow2(epr) - fem::pow2((amu * fem::ffloat(masspr))));
  betapr = pzpr / epr;
  gammpr = 1.0f / fem::sqrt(1.0f - fem::pow2(betapr));
  // C
  // C BETAC AND GAMMAC OF THE C.M. OBSERVED IN THE LAB. FRAME
  betac = (pzpr + pzta) / (epr + eta);
  sve.gammc = 1.0f / fem::sqrt(1.f - fem::pow2(betac));
  // C
  // C      WRITE(12,'(/10x,''****    KINEMATICAL PARAMETERS    ****''/)')
  // C      WRITE(12,'(10x,''1) LAB-FRAME:        TARGET PROJECTILE'')')
  // C      WRITE(12,'(10x,''   ETOTAL "GEV" '',2F11.4)') ETA, EPR
  // C      WRITE(12,'(10x,''   P "GEV/C"    '',2F11.4)') PZTA, PZPR
  // C      WRITE(12,'(10x,''   BETA         '',2F11.4)') BETATA, BETAPR
  // C      WRITE(12,'(10x,''   GAMMA        '',2F11.4)') GAMMTA, GAMMPR
  if (cmn.insys != 0) {
    // C
    // C       2) C.M. SYSTEM
    // C
    s = fem::pow2((epr + eta)) - fem::pow2(pzpr);
    xx1 = 4.f * fem::alog(fem::ffloat(massta));
    xx2 = 4.f * fem::alog(fem::ffloat(masspr));
    xx1 = fem::exp(xx1);
    xx2 = fem::exp(xx2);
    psqare = (fem::pow2(s) + (xx1 + xx2) * fem::pow4(amu) -
              2.0f * s * fem::pow2(amu) *
                  fem::ffloat(fem::pow2(massta) + fem::pow2(masspr)) -
              2.0f * fem::ffloat(fem::pow2(massta) * fem::pow2(masspr)) *
                  fem::pow4(amu)) /
             (4.0f * s);
    // C
    eta = fem::sqrt(psqare + fem::pow2((fem::ffloat(massta) * amu)));
    pzta = -fem::sqrt(psqare);
    betata = pzta / eta;
    gammta = 1.0f / fem::sqrt(1.0f - fem::pow2(betata));
    // C
    epr = fem::sqrt(psqare + fem::pow2((fem::ffloat(masspr) * amu)));
    pzpr = fem::sqrt(psqare);
    betapr = pzpr / epr;
    gammpr = 1.0f / fem::sqrt(1.0f - fem::pow2(betapr));
    // C
    // C        WRITE(12,'(10x,''2) C.M.-FRAME:  '')')
    // C        WRITE(12,'(10x,''   ETOTAL "GEV" '',2F11.4)') ETA, EPR
    // C        WRITE(12,'(10x,''   P "GEV/C"    '',2F11.4)') PZTA, PZPR
    // C        WRITE(12,'(10x,''   BETA         '',2F11.4)') BETATA, BETAPR
    // C        WRITE(12,'(10x,''   GAMMA        '',2F11.4)') GAMMTA, GAMMPR
    // C        WRITE(12,'(10x,''S "GEV**2"      '',F11.4)')  S
    // C        WRITE(12,'(10x,''PSQARE "GEV/C"2 '',E14.3)')  PSQARE
    // C        WRITE(12,'(/10x,''*** CALCULATION DONE IN CM-FRAME ***''/)')
  } else {
    // C        WRITE(12,'(/10x,''*** CALCULATION DONE IN LAB-FRAME ***''/)')
  }
  // C MOMENTUM PER PARTICLE
  pzta = pzta / fem::ffloat(massta);
  pzpr = pzpr / fem::ffloat(masspr);
  // C total initial energy in the N-N cms frame
  sve.ecms0 = eta + epr;
  // C-----------------------------------------------------------------------
  // C
  // C Start loop over many runs of different impact parameters
  // C IF MANYB=1, RUN AT A FIXED IMPACT PARAMETER B0, OTHERWISE GENERATE
  // C MINIMUM BIAS EVENTS WITHIN THE IMPACT PARAMETER RANGE OF B_MIN AND B_MAX
  FEM_DO_SAFE(sve.imany, 1, manyb) {
    // C------------------------------------------------------------------------
    // C Initialize the impact parameter B
    if (manyb > 1) {
    statement_111:
      bx = 1.0f - 2.0f * ranart(nseed);
      by = 1.0f - 2.0f * ranart(nseed);
      b2 = bx * bx + by * by;
      if (b2 > 1.0f) {
        goto statement_111;
      }
      b = fem::sqrt(b2) * (cmn.bm - bi) + bi;
    } else {
      b = cmn.b0;
    }
    // C      WRITE(12,'(///10X,''RUN NUMBER:'',I6)') IMANY
    // C      WRITE(12,'(//10X,''IMPACT PARAMETER B FOR THIS RUN:'',
    // C     &             F9.3,'' FM''/10X,49(''*'')/)') B
    // C
    // C-----------------------------------------------------------------------
    // C       INITIALIZATION
    // C1 INITIALIZATION IN ISOSPIN SPACE FOR BOTH THE PROJECTILE AND TARGET
    coulin(cmn, masspr, massta, num);
    // C2 INITIALIZATION IN PHASE SPACE FOR THE TARGET
    init(cmn, 1, massta, num, radta, b / 2.f, zeropt + zdist / 2.f, pzta,
         gammta, iseed, mass, imomen);
    // C3.1 INITIALIZATION IN PHASE SPACE FOR THE PROJECTILE
    init(cmn, 1 + massta, mass, num, radpr, -b / 2.f, zeropt - zdist / 2.f,
         pzpr, gammpr, iseed, mass, imomen);
    // C3.2 OUTPAR IS THE NO. OF ESCAPED PARTICLES
    outpar = 0;
    // C3.3 INITIALIZATION FOR THE NO. OF PARTICLES IN EACH SAMPLE
    // C    THIS IS NEEDED DUE TO THE FACT THAT PIONS CAN BE PRODUCED OR
    // ABSORBED
    massr(0) = 0;
    FEM_DO_SAFE(ir, 1, num) { massr(ir) = mass; }
    // C3.4 INITIALIZation FOR THE KAON SPECTRUM
    // C      CALL KSPEC0(BETAC,GAMMC)
    // C calculate the local baryon density matrix
    dens(cmn, ipot, mass, num, outpar);
    // C
    // C-----------------------------------------------------------------------
    // C       CONTROL PRINTOUT OF INITIAL CONFIGURATION
    // C
    // C      WRITE(12,'(''**********  INITIAL CONFIGURATION  **********''/)')
    // C
    // C print out the INITIAL density matrix in the reaction plane
    // C       do ix=-10,10
    // C       do iz=-10,10
    // C       write(1053,992)ix,iz,rho(ix,0,iz)/0.168
    // C       end do
    // C-----------------------------------------------------------------------
    // C       CALCULATE MOMENTA FOR T = 0.5 * DT
    // C       (TO OBTAIN 2ND DEGREE ACCURACY!)
    // C       "Reference: J. AICHELIN ET AL., PHYS. REV. C31, 1730 (1985)"
    // C
    if (icoll != -1) {
      FEM_DO_SAFE(i, 1, ntotal) {
        ix = fem::nint(r(1, i));
        iy = fem::nint(r(2, i));
        iz = fem::nint(r(3, i));
        // Clin-4/2008 check bounds:
        if (ix >= maxx || iy >= maxx || iz >= maxz || ix <= -maxx ||
            iy <= -maxx || iz <= -maxz) {
          goto statement_700;
        }
        gradu(cmn, ipot, ix, iy, iz, gradx, grady, gradz);
        p(1, i) = p(1, i) - (0.5f * dt) * gradx;
        p(2, i) = p(2, i) - (0.5f * dt) * grady;
        p(3, i) = p(3, i) - (0.5f * dt) * gradz;
      statement_700:;
      }
    }
    // C-----------------------------------------------------------------------
    // C4 INITIALIZATION OF TIME-LOOP VARIABLES
    // C4.1 COLLISION NUMBER COUNTERS
    // Clin 51      RCNNE  = 0
    rcnne = 0;
    rdd = 0;
    rpp = 0;
    rppk = 0;
    rpn = 0;
    rpd = 0;
    rkn = 0;
    rnnk = 0;
    rddk = 0;
    rndk = 0;
    rcnnd = 0;
    rcndn = 0;
    rcoll = 0;
    rbloc = 0;
    rdirt = 0;
    rdecay = 0;
    rres = 0;
    // C4.11 KAON PRODUCTION PROBABILITY COUNTER FOR PERTURBATIVE CALCULATIONS
    // ONLY
    FEM_DO_SAFE(kkk, 1, 5) {
      skaon(kkk) = 0;
      FEM_DO_SAFE(is, 1, 2000) { sekaon(kkk, is) = 0; }
    }
    // C4.12 anti-proton and anti-kaon counters
    sve.pr0 = 0.f;
    sve.pr1 = 0.f;
    sve.ska0 = 0.f;
    sve.ska1 = 0.f;
    // C       ============== LOOP OVER ALL TIME STEPS ================       *
    // C                             STARTS HERE                              *
    // C       ========================================================       *
    // Cbz11/16/98
    if (iapar2(1) != 1) {
      FEM_DO_SAFE(i, 1, maxstr) {
        FEM_DO_SAFE(j, 1, 3) {
          r(j, i) = 0.f;
          p(j, i) = 0.f;
        }
        e(i) = 0.f;
        lb(i) = 0;
        // Cbz3/25/00
        id(i) = 0;
        // C     sp 12/19/00
        proper(i) = 1.f;
      }
      mass = 0;
      // Cbz12/22/98
      // C         MASSR(1) = 0
      // C         NP = 0
      // C         NPI = 1
      np = 0;
      FEM_DO_SAFE(j, 1, num) {
        massr(j) = 0;
        npi(j) = 1;
      }
      FEM_DO_SAFE(i, 1, maxr) {
        FEM_DO_SAFE(j, 1, maxstr) {
          rt(1, j, i) = 0.f;
          rt(2, j, i) = 0.f;
          rt(3, j, i) = 0.f;
          pt(1, j, i) = 0.f;
          pt(2, j, i) = 0.f;
          pt(3, j, i) = 0.f;
          et(j, i) = 0.f;
          lt(j, i) = 0;
          // C     sp 12/19/00
          prot(j, i) = 1.f;
        }
      }
      // Cbz12/22/98end
    }
    // Cbz11/16/98end
    // C
    FEM_DO_SAFE(nt, 1, ntmax) {
      // CTEMPORARY PARTICLE COUNTERS
      // C4.2 PION COUNTERS : LP1,LP2 AND LP3 ARE THE NO. OF P+,P0 AND P-
      lp1 = 0;
      lp2 = 0;
      lp3 = 0;
      // C4.3 DELTA COUNTERS : LD1,LD2,LD3 AND LD4 ARE THE NO. OF D++,D+,D0 AND
      // D-
      ld1 = 0;
      ld2 = 0;
      ld3 = 0;
      ld4 = 0;
      // C4.4 N*(1440) COUNTERS : LN1 AND LN2 ARE THE NO. OF N*+ AND N*0
      ln1 = 0;
      ln2 = 0;
      // C4.5 N*(1535) counters
      ln5 = 0;
      // C4.6 ETA COUNTERS
      le = 0;
      // C4.7 KAON COUNTERS
      lkaon = 0;
      // C
      // Clin-11/09/00:
      // C KAON* COUNTERS
      lkaons = 0;
      // C
      // C-----------------------------------------------------------------------
      if (icoll != 1) {
        // C STUDYING BINARY COLLISIONS AMONG PARTICLES DURING THIS TIME
        // INTERVAL * Clin-10/25/02 get rid of argument usage mismatch in
        // relcol(.nt.):
        numnt = nt;
        relcol(cmn, lcoll, lbloc, lcnne, ldd, lpp, lppk, lpn, lpd, lrho, lomega,
               lkn, lnnk, lddk, lndk, lcnnd, lcndn, ldirt, ldecay, lres, ldou,
               lddrho, lnnrho, lnnom, numnt, ntmax, sve.sp, sve.akaon, sve.sk);
        // C     &    LNNOM,NT,ntmax,sp,akaon,sk)
        // Clin-10/25/02-end
        // C-----------------------------------------------------------------------
        // C
        // C dilepton production from Dalitz decay
        // C of pi0 at final time
        // C      if(nt .eq. ntmax) call dalitz_pi(nt,ntmax)
        // C * C********************************* C                Lables of
        // collision channels                             *
        // C*********************************
        // C         LCOLL   - NUMBER OF COLLISIONS (INTEGER,OUTPUT) * C LBLOC
        // - NUMBER OF PULI-BLOCKED COLLISIONS (INTEGER,OUTPUT) * C         LCNNE
        // - NUMBER OF ELASTIC COLLISION       (INTEGER,OUTPUT) * C         LCNND
        // - NUMBER OF N+N->N+DELTA REACTION   (INTEGER,OUTPUT) * C         LCNDN
        // - NUMBER OF N+DELTA->N+N REACTION   (INTEGER,OUTPUT) * C         LDD
        // - NUMBER OF RESONANCE+RESONANCE COLLISIONS C         LPP     - NUMBER
        // OF PION+PION elastic COLIISIONS C         lppk    - number of
        // pion(RHO,OMEGA)+pion(RHO,OMEGA) C                 -->K+K- collisions
        // C         LPN     - NUMBER OF PION+N-->KAON+X
        // C         lpd     - number of pion+n-->delta+pion
        // C         lrho    - number of pion+n-->Delta+rho
        // C         lomega  - number of pion+n-->Delta+omega
        // C         LKN     - NUMBER OF KAON RESCATTERINGS
        // C         LNNK    - NUMBER OF bb-->kAON PROCESS
        // C         LDDK    - NUMBER OF DD-->KAON PROCESS
        // C         LNDK    - NUMBER OF ND-->KAON PROCESS
        // C**********************************
        // C TIME-INTEGRATED COLLISIONS NUMBERS OF VARIOUS PROCESSES
        rcoll += fem::ffloat(lcoll) / num;
        rbloc += fem::ffloat(lbloc) / num;
        rcnne += fem::ffloat(lcnne) / num;
        rdd += fem::ffloat(ldd) / num;
        rpp += fem::ffloat(lpp) / num;
        rppk += fem::ffloat(lppk) / num;
        rpn += fem::ffloat(lpn) / num;
        rpd += fem::ffloat(lpd) / num;
        rkn += fem::ffloat(lkn) / num;
        rnnk += fem::ffloat(lnnk) / num;
        rddk += fem::ffloat(lddk) / num;
        rndk += fem::ffloat(lndk) / num;
        rcnnd += fem::ffloat(lcnnd) / num;
        rcndn += fem::ffloat(lcndn) / num;
        rdirt += fem::ffloat(ldirt) / num;
        rdecay += fem::ffloat(ldecay) / num;
        rres += fem::ffloat(lres) / num;
        // C AVERAGE RATES OF VARIOUS COLLISIONS IN THE CURRENT TIME STEP
        sve.adirt = ldirt / dt / num;
        sve.acoll = (lcoll - lbloc) / dt / num;
        sve.acnnd = lcnnd / dt / num;
        sve.acndn = lcndn / dt / num;
        sve.adecay = ldecay / dt / num;
        sve.ares = lres / dt / num;
        sve.adou = ldou / dt / num;
        sve.addrho = lddrho / dt / num;
        sve.annrho = lnnrho / dt / num;
        sve.annom = lnnom / dt / num;
        sve.add = ldd / dt / num;
        sve.app = lpp / dt / num;
        sve.appk = lppk / dt / num;
        sve.apn = lpn / dt / num;
        sve.apd = lpd / dt / num;
        sve.arh = lrho / dt / num;
        sve.aom = lomega / dt / num;
        sve.akn = lkn / dt / num;
        sve.annk = lnnk / dt / num;
        sve.addk = lddk / dt / num;
        sve.andk = lndk / dt / num;
        // C PRINT OUT THE VARIOUS COLLISION RATES
        // C (1)N-N COLLISIONS
        // C       WRITE(1010,9991)NT*DT,ACNND,ADOU,ADIRT,ADDRHO,ANNRHO+ANNOM
        // C9991       FORMAT(6(E10.3,2X))
        // C (2)PION-N COLLISIONS
        // C       WRITE(1011,'(5(E10.3,2X))')NT*DT,apd,ARH,AOM,APN
        // C (3)KAON PRODUCTION CHANNELS
        // C        WRITE(1012,9993)NT*DT,ANNK,ADDK,ANDK,APN,Appk
        // C (4)D(N*)+D(N*) COLLISION
        // C       WRITE(1013,'(4(E10.3,2X))')NT*DT,ADDK,ADD,ADD+ADDK
        // C (5)MESON+MESON
        // C       WRITE(1014,'(4(E10.3,2X))')NT*DT,APPK,APP,APP+APPK
        // C (6)DECAY AND RESONANCE
        // C       WRITE(1016,'(3(E10.3,2X))')NT*DT,ARES,ADECAY
        // C (7)N+D(N*)
        // C       WRITE(1017,'(4(E10.3,2X))')NT*DT,ACNDN,ANDK,ACNDN+ANDK
        // C9992    FORMAT(5(E10.3,2X))
        // C9993    FORMAT(6(E10.3,2X))
        // C PRINT OUT TIME-INTEGRATED COLLISION INFORMATION
        // Cbz12/28/98
        // C        write(1018,'(5(e10.3,2x),/, 4(e10.3,2x))')
        // C     &           RCNNE,RCNND,RCNDN,RDIRT,rpd,
        // C     &           RDECAY,RRES,RDD,RPP
        // C        write(1018,'(6(e10.3,2x),/, 5(e10.3,2x))')
        // C     &           NT*DT,RCNNE,RCNND,RCNDN,RDIRT,rpd,
        // C     &           NT*DT,RDECAY,RRES,RDD,RPP
        // Cbz12/18/98end
        // C PRINT OUT TIME-INTEGRATED KAON MULTIPLICITIES FROM DIFFERENT
        // CHANNELS C WRITE(1019,'(7(E10.3,2X))')NT*DT,RNNK,RDDK,RNDK,RPN,Rppk,
        // C     &                           RNNK+RDDK+RNDK+RPN+Rppk
        // C *
        // C
      }
      // C
      // C       UPDATE BARYON DENSITY
      // C
      dens(cmn, ipot, mass, num, outpar);
      // C
      // C       UPDATE POSITIONS FOR ALL THE PARTICLES PRESENT AT THIS TIME
      // C
      sumene = 0;
      iso = 0;
      FEM_DO_SAFE(mrun, 1, num) {
        iso += massr(mrun - 1);
        FEM_DO_SAFE(i0, 1, massr(mrun)) {
          i = i0 + iso;
          etotal = fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                             fem::pow2(p(2, i)) + fem::pow2(p(3, i)));
          sumene += etotal;
          // C for kaons, if there is a potential
          // C CALCULATE THE ENERGY OF THE KAON ACCORDING TO THE IMPULSE
          // APPROXIMATION C REFERENCE: B.A. LI AND C.M. KO, PHYS. REV. C 54
          // (1996) 3283.
          if (kpoten != 0 && lb(i) == 23) {
            den = 0.f;
            ix = fem::nint(r(1, i));
            iy = fem::nint(r(2, i));
            iz = fem::nint(r(3, i));
            // Clin-4/2008:
            // C       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            // C     & ABS(IZ) .LT. MAXZ) den=rho(ix,iy,iz)
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
            }
            // C         ecor=0.1973**2*0.255*kmul*4*3.14159*(1.+0.4396/0.938)
            // C         etotal=sqrt(etotal**2+ecor*den)
            // C** G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV,
            // m^*=m C     GeV^2 fm^3
            akg = 0.1727f;
            // C     GeV fm^3
            bkg = 0.333f;
            rnsg = den;
            ecor = -akg * rnsg + fem::pow2((bkg * den));
            etotal = fem::sqrt(fem::pow2(etotal) + ecor);
          }
          // C
          if (kpoten != 0 && lb(i) == 21) {
            den = 0.f;
            ix = fem::nint(r(1, i));
            iy = fem::nint(r(2, i));
            iz = fem::nint(r(3, i));
            // Clin-4/2008:
            // C       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            // C     & ABS(IZ) .LT. MAXZ) den=rho(ix,iy,iz)
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
            }
            // C* for song potential no effect on position
            // C** G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV,
            // m^*=m C     GeV^2 fm^3
            akg = 0.1727f;
            // C     GeV fm^3
            bkg = 0.333f;
            rnsg = den;
            ecor = -akg * rnsg + fem::pow2((bkg * den));
            etotal = fem::sqrt(fem::pow2(etotal) + ecor);
          }
          // C
          // C UPDATE POSITIONS
          r(1, i) += dt * p(1, i) / etotal;
          r(2, i) += dt * p(2, i) / etotal;
          r(3, i) += dt * p(3, i) / etotal;
          // C use cyclic boundary conitions
          if (cycbox != 0) {
            if (r(1, i) > cycbox / 2) {
              r(1, i) = r(1, i) - cycbox;
            }
            if (r(1, i) <= -cycbox / 2) {
              r(1, i) += cycbox;
            }
            if (r(2, i) > cycbox / 2) {
              r(2, i) = r(2, i) - cycbox;
            }
            if (r(2, i) <= -cycbox / 2) {
              r(2, i) += cycbox;
            }
            if (r(3, i) > cycbox / 2) {
              r(3, i) = r(3, i) - cycbox;
            }
            if (r(3, i) <= -cycbox / 2) {
              r(3, i) += cycbox;
            }
          }
          // C UPDATE THE DELTA, N* AND PION COUNTERS
          lb1 = lb(i);
          // C 1. FOR DELTA++
          if (lb1 == 9) {
            ld1++;
          }
          // C 2. FOR DELTA+
          if (lb1 == 8) {
            ld2++;
          }
          // C 3. FOR DELTA0
          if (lb1 == 7) {
            ld3++;
          }
          // C 4. FOR DELTA-
          if (lb1 == 6) {
            ld4++;
          }
          // C 5. FOR N*+(1440)
          if (lb1 == 11) {
            ln1++;
          }
          // C 6. FOR N*0(1440)
          if (lb1 == 10) {
            ln2++;
          }
          // C 6.1 FOR N*(1535)
          if ((lb1 == 13) || (lb1 == 12)) {
            ln5++;
          }
          // C 6.2 FOR ETA
          if (lb1 == 0) {
            le++;
          }
          // C 6.3 FOR KAONS
          if (lb1 == 23) {
            lkaon++;
          }
          // Clin-11/09/00: FOR KAON*
          if (lb1 == 30) {
            lkaons++;
          }
          // C
          // C UPDATE PION COUNTER
          // C 7. FOR PION+
          if (lb1 == 5) {
            lp1++;
          }
          // C 8. FOR PION0
          if (lb1 == 4) {
            lp2++;
          }
          // C 9. FOR PION-
          if (lb1 == 3) {
            lp3++;
          }
        }
      }
      lp = lp1 + lp2 + lp3;
      ld = ld1 + ld2 + ld3 + ld4;
      ln = ln1 + ln2;
      alp = fem::ffloat(lp) / fem::ffloat(num);
      ald = fem::ffloat(ld) / fem::ffloat(num);
      aln = fem::ffloat(ln) / fem::ffloat(num);
      aln5 = fem::ffloat(ln5) / fem::ffloat(num);
      sve.atotal = alp + ald + aln + 0.5f * aln5;
      sve.ale = fem::ffloat(le) / fem::ffloat(num);
      sve.alkaon = fem::ffloat(lkaon) / fem::ffloat(num);
      // C UPDATE MOMENTUM DUE TO COULOMB INTERACTION
      if (icou == 1) {
        // C       with Coulomb interaction
        iso = 0;
        FEM_DO_SAFE(irun, 1, num) {
          iso += massr(irun - 1);
          FEM_DO_SAFE(il, 1, massr(irun)) {
            temp(1, il) = 0.f;
            temp(2, il) = 0.f;
            temp(3, il) = 0.f;
          }
          FEM_DO_SAFE(il, 1, massr(irun)) {
            i = iso + il;
            if (zet(lb(i)) != 0) {
              FEM_DO_SAFE(jl, 1, il - 1) {
                j = iso + jl;
                if (zet(lb(j)) != 0) {
                  ddx = r(1, i) - r(1, j);
                  ddy = r(2, i) - r(2, j);
                  ddz = r(3, i) - r(3, j);
                  rdiff = fem::sqrt(fem::pow2(ddx) + fem::pow2(ddy) +
                                    fem::pow2(ddz));
                  if (rdiff <= 1.f) {
                    rdiff = 1.f;
                  }
                  grp = zet(lb(i)) * zet(lb(j)) / fem::pow3(rdiff);
                  ddx = ddx * grp;
                  ddy = ddy * grp;
                  ddz = ddz * grp;
                  temp(1, il) += ddx;
                  temp(2, il) += ddy;
                  temp(3, il) += ddz;
                  temp(1, jl) = temp(1, jl) - ddx;
                  temp(2, jl) = temp(2, jl) - ddy;
                  temp(3, jl) = temp(3, jl) - ddz;
                }
              }
            }
          }
          FEM_DO_SAFE(il, 1, massr(irun)) {
            i = iso + il;
            if (zet(lb(i)) != 0) {
              FEM_DO_SAFE(idir, 1, 3) {
                p(idir, i) += temp(idir, il) * dt * 0.00144f;
              }
            }
          }
        }
      }
      // C       In the following, we shall:
      // C       (1) UPDATE MOMENTA DUE TO THE MEAN FIELD FOR BARYONS AND KAONS,
      // C       (2) calculate the thermalization, temperature in a sphere of
      // C           radius 2.0 fm AROUND THE CM
      // C       (3) AND CALCULATE THE NUMBER OF PARTICLES IN THE HIGH DENSITY
      // REGION
      spt = 0;
      spz = 0;
      ncen = 0;
      ekin = 0;
      sve.nlost = 0;
      mean = 0;
      nquark = 0;
      nbaryn = 0;
      // Csp06/18/01
      rads = 2.f;
      zras = 0.1f;
      denst = 0.f;
      edenst = 0.f;
      // Csp06/18/01 end
      FEM_DO_SAFE(irun, 1, num) {
        mean += massr(irun - 1);
        FEM_DO_SAFE(j, 1, massr(irun)) {
          i = j + mean;
          // C
          // Csp06/18/01
          radut = fem::sqrt(fem::pow2(r(1, i)) + fem::pow2(r(2, i)));
          if (radut <= rads) {
            if (fem::abs(r(3, i)) <= zras * nt * dt) {
              // C         vols = 3.14159*radut**2*abs(r(3,i))      ! cylinder
              // pi*r^2*l C     cylinder pi*r^2*l
              vols = 3.14159f * fem::pow2(rads) * zras;
              engs = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                               fem::pow2(p(3, i)) + fem::pow2(e(i)));
              gammas = 1.f;
              if (e(i) != 0.f) {
                gammas = engs / e(i);
              }
              // C     rho
              denst += 1.f / gammas / vols;
              // C     energy density
              edenst += engs / gammas / gammas / vols;
            }
          }
          // Csp06/18/01 end
          // C
          drr = fem::sqrt(fem::pow2(r(1, i)) + fem::pow2(r(2, i)) +
                          fem::pow2(r(3, i)));
          if (drr <= 2.0f) {
            spt += fem::pow2(p(1, i)) + fem::pow2(p(2, i));
            spz += fem::pow2(p(3, i));
            ncen++;
            ekin += fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                              fem::pow2(p(3, i)) + fem::pow2(e(i))) -
                    e(i);
          }
          ix = fem::nint(r(1, i));
          iy = fem::nint(r(2, i));
          iz = fem::nint(r(3, i));
          // C calculate the No. of particles in the high density region
          // Clin-4/2008:
          // C              IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
          // C     & ABS(IZ) .LT. MAXZ) THEN
          if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx && iy > -maxx &&
              iz > -maxz) {
            if (rho(ix, iy, iz) / 0.168f > cmn.dencut) {
              goto statement_5800;
            }
            if ((rho(ix, iy, iz) / 0.168f > 5.f) && (e(i) > 0.9f)) {
              nbaryn++;
            }
            if (pel(ix, iy, iz) > 2.0f) {
              nquark++;
            }
          }
          // C*
          // C If there is a kaon potential, propogating kaons
          if (kpoten != 0 && lb(i) == 23) {
            den = 0.f;
            // Clin-4/2008:
            // C       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            // C     & ABS(IZ) .LT. MAXZ)then
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
              // C        ecor=0.1973**2*0.255*kmul*4*3.14159*(1.+0.4396/0.938)
              // C etotal=sqrt(P(1,i)**2+p(2,I)**2+p(3,i)**2+e(i)**2+ecor*den)
              // C** for G.Q Li potential form with n_s = n_b and pot(n_0)=29
              // MeV C     !! GeV^2 fm^3
              akg = 0.1727f;
              // C     !! GeV fm^3
              bkg = 0.333f;
              rnsg = den;
              ecor = -akg * rnsg + fem::pow2((bkg * den));
              etotal = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                                 fem::pow2(p(3, i)) + fem::pow2(e(i)) + ecor);
              ecor = -akg + 2.f * fem::pow2(bkg) * den + 2.f * bkg * etotal;
              // C** G.Q. Li potential (END)
              graduk(cmn, ix, iy, iz, gradxk, gradyk, gradzk);
              p(1, i) = p(1, i) - dt * gradxk * ecor / (2.f * etotal);
              p(2, i) = p(2, i) - dt * gradyk * ecor / (2.f * etotal);
              p(3, i) = p(3, i) - dt * gradzk * ecor / (2.f * etotal);
            }
          }
          // C
          if (kpoten != 0 && lb(i) == 21) {
            den = 0.f;
            // Clin-4/2008:
            // C           IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            // C     &        ABS(IZ) .LT. MAXZ)then
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
              graduk(cmn, ix, iy, iz, gradxk, gradyk, gradzk);
              // C        P(1,I) = P(1,I) - DT * GRADXk*(-0.12/0.168)    !! song
              // potential C        P(2,I) = P(2,I) - DT * GRADYk*(-0.12/0.168)
              // C        P(3,I) = P(3,I) - DT * GRADZk*(-0.12/0.168)
              // C** for G.Q Li potential form with n_s = n_b and pot(n_0)=29
              // MeV C    !! GeV^2 fm^3
              akg = 0.1727f;
              // C     !! GeV fm^3
              bkg = 0.333f;
              rnsg = den;
              ecor = -akg * rnsg + fem::pow2((bkg * den));
              etotal = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                                 fem::pow2(p(3, i)) + fem::pow2(e(i)) + ecor);
              ecor = -akg + 2.f * fem::pow2(bkg) * den - 2.f * bkg * etotal;
              p(1, i) = p(1, i) - dt * gradxk * ecor / (2.f * etotal);
              p(2, i) = p(2, i) - dt * gradyk * ecor / (2.f * etotal);
              p(3, i) = p(3, i) - dt * gradzk * ecor / (2.f * etotal);
              // C** G.Q. Li potential (END)
            }
          }
          // C
          // C for other mesons, there is no potential
          if (j > mass) {
            goto statement_5800;
          }
          // C  with mean field interaction for baryons   (open endif below)
          // !!sp05 C*      if( (iabs(lb(i)).eq.1.or.iabs(lb(i)).eq.2) .or. C* &
          // (iabs(lb(i)).ge.6.and.iabs(lb(i)).le.17) .or. C*    &
          // iabs(lb(i)).eq.40.or.iabs(lb(i)).eq.41 )then
          if (icoll != -1) {
            // C check if the baryon has run off the lattice
            // C             IX0=NINT(R(1,I)/DX)
            // C             IY0=NINT(R(2,I)/DY)
            // C             IZ0=NINT(R(3,I)/DZ)
            // C             IPX0=NINT(P(1,I)/DPX)
            // C             IPY0=NINT(P(2,I)/DPY)
            // C             IPZ0=NINT(P(3,I)/DPZ)
            // C      if ( (abs(ix0).gt.mx) .or. (abs(iy0).gt.my) .or.
            // (abs(iz0).gt.mz) C     &  .or. (abs(ipx0).gt.mpx) .or. (abs(ipy0)
            // C     &  .or. (ipz0.lt.-mpz) .or. (ipz0.gt.mpzp)) NLOST=NLOST+1
            // Clin-4/2008:
            // C              IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX
            // .AND. C     &                                    ABS(IZ) .LT. MAXZ
            // ) THEN
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              gradu(cmn, ipot, ix, iy, iz, gradx, grady, gradz);
              tz = 0.f;
              gradxn = 0;
              gradyn = 0;
              gradzn = 0;
              gradxp = 0;
              gradyp = 0;
              gradzp = 0;
              if (icou == 1) {
                gradup(cmn, ix, iy, iz, gradxp, gradyp, gradzp);
                gradun(cmn, ix, iy, iz, gradxn, gradyn, gradzn);
                if (zet(lb(i)) != 0) {
                  tz = -1;
                }
                if (zet(lb(i)) == 0) {
                  tz = 1;
                }
              }
              if (fem::iabs(lb(i)) >= 14 && fem::iabs(lb(i)) <= 17) {
                facl = 2.f / 3.f;
              } else if (fem::iabs(lb(i)) == 40 || fem::iabs(lb(i)) == 41) {
                facl = 1.f / 3.f;
              } else {
                facl = 1.f;
              }
              p(1, i) =
                  p(1, i) - facl * dt * (gradx + asy * (gradxn - gradxp) * tz);
              p(2, i) =
                  p(2, i) - facl * dt * (grady + asy * (gradyn - gradyp) * tz);
              p(3, i) =
                  p(3, i) - facl * dt * (gradz + asy * (gradzn - gradzp) * tz);
            }
          }
        // C*          endif          !!sp05
        statement_5800:;
        }
      }
      // C print out the average no. of particles in regions where the local
      // C baryon density is higher than 5*rho0
      // C       write(1072,'(e10.3,2x,e10.3)')nt*dt,float(nbaryn)/float(num)
      // C print out the average no. of particles in regions where the local
      // C energy density is higher than 2 GeV/fm^3.
      // C       write(1073,'(e10.3,2x,e10.3)')nt*dt,float(nquark)/float(num)
      // C print out the no. of particles that have run off the lattice
      // C          IF (NLOST .NE. 0 .AND. (NT/NFREQ)*NFREQ .EQ. NT) THEN
      // C            WRITE(12,'(5X,''***'',I7,'' TESTPARTICLES LOST AFTER '',
      // C     &                   ''TIME STEP NUMBER'',I4)') NLOST, NT
      // C         END IF
      // C
      // C       update phase space density
      // C        call platin(mode,mass,num,dx,dy,dz,dpx,dpy,dpz,fnorm)
      // C
      // C       CONTROL-PRINTOUT OF CONFIGURATION (IF REQUIRED)
      // C
      // C        if (inout(5) .eq. 2) CALL ENERGY(NT,IPOT,NUM,MASS,EMIN,EMAX)
      // C
      // C print out central baryon density as a function of time
      sve.cden = rho(0, 0, 0) / 0.168f;
      // Cc        WRITE(1002,990)FLOAT(NT)*DT,CDEN
      // C        WRITE(1002,1990)FLOAT(NT)*DT,CDEN,denst/real(num)
      // C print out the central energy density as a function of time
      // Cc        WRITE(1003,990)FLOAT(NT)*DT,PEL(0,0,0)
      // C        WRITE(1003,1990)FLOAT(NT)*DT,PEL(0,0,0),edenst/real(num)
      // C print out the no. of pion-like particles as a function of time
      // C        WRITE(1004,9999)FLOAT(NT)*DT,ALD,ALN,ALP,ALN5,
      // C     &               ALD+ALN+ALP+0.5*ALN5
      // C print out the no. of eta-like particles as a function of time
      // C        WRITE(1005,991)FLOAT(NT)*DT,ALN5,ALE,ALE+0.5*ALN5
      // C990       FORMAT(E10.3,2X,E10.3)
      // C1990       FORMAT(E10.3,2X,E10.3,2X,E10.3)
      // C991       FORMAT(E10.3,2X,E10.3,2X,E10.3,2X,E10.3)
      // C9999    FORMAT(e10.3,2X,e10.3,2X,E10.3,2X,E10.3,2X,
      // C     1  E10.3,2X,E10.3)
      // C THE FOLLOWING OUTPUTS CAN BE TURNED ON/OFF by setting icflow and
      // icrho=0 C print out the baryon and meson density matrix in the reaction
      // plane
      if ((nt / nfreq) * nfreq == nt) {
        if (cmn.icflow == 1) {
          flow(cmn, nt);
        }
        // Cbz11/18/98
        // C       if(icrho.ne.1)go to 10000
        // C       if (icrho .eq. 1) then
        // Cbz11/18/98end
        // C       do ix=-10,10
        // C       do iz=-10,10
        // C       write(1053,992)ix,iz,rho(ix,0,iz)/0.168
        // C       write(1054,992)ix,iz,pirho(ix,0,iz)/0.168
        // C       write(1055,992)ix,iz,pel(ix,0,iz)
        // C       end do
        // Cbz11/18/98
        // C        end if
        // Cbz11/18/98end
        // C992       format(i3,i3,e11.4)
      }
      // C print out the ENERGY density matrix in the reaction plane
      // C CHECK LOCAL MOMENTUM EQUILIBRIUM IN EACH CELL,
      // C AND PERFORM ON-LINE FLOW ANALYSIS AT A FREQUENCY OF NFREQ
      // C        IF ((NT/NFREQ)*NFREQ .EQ. NT ) THEN
      // C       call flow(nt)
      // C       call equ(ipot,mass,num,outpar)
      // C       do ix=-10,10
      // C       do iz=-10,10
      // C       write(1055,992)ix,iz,pel(ix,0,iz)
      // C       write(1056,992)ix,iz,rxy(ix,0,iz)
      // C       end do
      // C       endif
      // C calculate the volume of high BARYON AND ENERGY density
      // C matter as a function of time
      // C       vbrho=0.
      // C       verho=0.
      // C       do ix=-20,20
      // C       do iy=-20,20
      // C       do iz=-20,20
      // C       if(rho(ix,iy,iz)/0.168.gt.5.)vbrho=vbrho+1.
      // C       if(pel(ix,iy,iz).gt.2.)verho=verho+1.
      // C       end do
      // C       write(1081,993)dt*nt,vbrho
      // C       write(1082,993)dt*nt,verho
      // C993       format(e11.4,2x,e11.4)
      // C-----------------------------------------------------------------------
      // Cbz11/16/98
      // C.....for read-in initial conditions produce particles from read-in
      // C.....common block.
      // C.....note that this part is only for cascade with number of test
      // particles C.....NUM = 1.
      if (iapar2(1) != 1) {
        ct = nt * dt;
        // Cbz12/22/98
        // C         NP = MASSR(1)
        // C         DO WHILE (FTAR(NPI) .GT. CT - DT .AND. FTAR(NPI) .LE. CT)
        // C            NP = NP + 1
        // C            R(1, NP) = GXAR(NPI) + PXAR(NPI) / PEAR(NPI) * (CT -
        // FTAR(NPI)) C            R(2, NP) = GYAR(NPI) + PYAR(NPI) / PEAR(NPI) *
        // (CT - FTAR(NPI)) C            R(3, NP) = GZAR(NPI) + PZAR(NPI) /
        // PEAR(NPI) * (CT - FTAR(NPI)) C            P(1, NP) = PXAR(NPI) C P(2,
        // NP) = PYAR(NPI) C            P(3, NP) = PZAR(NPI) C            E(NP) =
        // XMAR(NPI) C            LB(NP) = IARFLV(ITYPAR(NPI)) C            NPI =
        // NPI + 1 C         END DO C         MASSR(1) = NP
        ia = 0;
        FEM_DO_SAFE(irun, 1, num) {
          FEM_DO_SAFE(ic, 1, massr(irun)) {
            ie = ia + ic;
            rt(1, ic, irun) = r(1, ie);
            rt(2, ic, irun) = r(2, ie);
            rt(3, ic, irun) = r(3, ie);
            pt(1, ic, irun) = p(1, ie);
            pt(2, ic, irun) = p(2, ie);
            pt(3, ic, irun) = p(3, ie);
            et(ic, irun) = e(ie);
            lt(ic, irun) = lb(ie);
            // C         !! sp 12/19/00
            prot(ic, irun) = proper(ie);
            // Clin-5/2008:
            dpertt(ic, irun) = dpertp(ie);
          }
          np = massr(irun);
          np1 = npi(irun);
          // C
          // Cbz10/05/99
          // C            DO WHILE (FT1(NP1, IRUN) .GT. CT - DT .AND.
          // C     &           FT1(NP1, IRUN) .LE. CT)
          // Cbz10/06/99
          // C            DO WHILE (NPI(IRUN).LE.MULTI1(IRUN).AND.
          // Cbz10/06/99 end
          // Clin-11/13/00 finally read in all unformed particles and do the
          // decays in ART: C           DO WHILE (NP1.LE.MULTI1(IRUN).AND. C    &
          // FT1(NP1, IRUN) .GT. CT - DT .AND. C    &           FT1(NP1, IRUN)
          // .LE. CT)
          // C
          ctlong = ct;
          if (nt == (ntmax - 1)) {
            ctlong = 1.e30f;
          } else if (nt == ntmax) {
            goto statement_1111;
          }
          // C
          while (np1 <= multi1(irun) && ft1(np1, irun) > ((nt - 1) * dt) &&
                 ft1(np1, irun) <= ctlong) {
            // Clin-ma-5/2016 changed the following to 2nd line above to avoid
            // bug C     that leads to loss of hadrons inside ART due to finite
            // accuracy C     [which results in (ct-dt) + dt != ct exactly]: C &
            // FT1(NP1, IRUN) .GT. (CT - DT) .AND.
            np++;
            udt = (ct - ft1(np1, irun)) / ee1(np1, irun);
            // Clin-10/28/03 since all unformed hadrons at time ct are read in
            // at nt=ntmax-1, C     their positions should not be propagated to
            // time ct:
            if (nt == (ntmax - 1)) {
              ftsvt(np, irun) = ft1(np1, irun);
              if (ft1(np1, irun) > ct) {
                udt = 0.f;
              }
            }
            rt(1, np, irun) = gx1(np1, irun) + px1(np1, irun) * udt;
            rt(2, np, irun) = gy1(np1, irun) + py1(np1, irun) * udt;
            rt(3, np, irun) = gz1(np1, irun) + pz1(np1, irun) * udt;
            pt(1, np, irun) = px1(np1, irun);
            pt(2, np, irun) = py1(np1, irun);
            pt(3, np, irun) = pz1(np1, irun);
            et(np, irun) = xm1(np1, irun);
            lt(np, irun) = iarflv(ityp1(np1, irun));
            // Clin-5/2008:
            dpertt(np, irun) = dpp1(np1, irun);
            // Clin-4/30/03 ctest off
            // C     record initial phi,K*,Lambda(1520) resonances formed during
            // the timestep: C               if(LT(NP, IRUN).eq.29.or.iabs(LT(NP,
            // IRUN)).eq.30) C     1              write(17,112) 'formed',LT(NP,
            // IRUN),PX1(NP1, IRUN), C     2 PY1(NP1, IRUN),PZ1(NP1,
            // IRUN),XM1(NP1, IRUN),nt C 112 format(a10,1x,I4,4(1x,f9.3),1x,I4)
            // C
            np1++;
            // C     !! sp 12/19/00
            prot(np, irun) = 1.f;
          }
        // C
        statement_1111:
          npi(irun) = np1;
          ia += massr(irun);
          massr(irun) = np;
        }
        ia = 0;
        FEM_DO_SAFE(irun, 1, num) {
          ia += massr(irun - 1);
          FEM_DO_SAFE(ic, 1, massr(irun)) {
            ie = ia + ic;
            r(1, ie) = rt(1, ic, irun);
            r(2, ie) = rt(2, ic, irun);
            r(3, ie) = rt(3, ic, irun);
            p(1, ie) = pt(1, ic, irun);
            p(2, ie) = pt(2, ic, irun);
            p(3, ie) = pt(3, ic, irun);
            e(ie) = et(ic, irun);
            lb(ie) = lt(ic, irun);
            // C     !! sp 12/19/00
            proper(ie) = prot(ic, irun);
            if (nt == (ntmax - 1)) {
              ftsv(ie) = ftsvt(ic, irun);
            }
            // Clin-5/2008:
            dpertp(ie) = dpertt(ic, irun);
          }
          // Clin-3/2009 Moved here to better take care of freezeout spacetime:
          hbtout(massr(irun), nt, ntmax);
        }
        // Cbz12/22/98end
      }
      // Cbz11/16/98end
      // C
      // Clin-5/2009 ctest off:
      // C      call flowh(ct)
      // C
    }
    // C
    // C                                                                      *
    // C       ==============  END OF TIME STEP LOOP   ================       *
    // C
    // C***********************************
    // C     WRITE OUT particle's MOMENTA ,and/OR COORDINATES ,
    // C     label and/or their local baryon density in the final state
    iss = 0;
    FEM_DO_SAFE(lrun, 1, num) {
      iss += massr(lrun - 1);
      FEM_DO_SAFE(l0, 1, massr(lrun)) { sve.ipart = iss + l0; }
    }
    // C
    // Cbz11/16/98
    if (iapar2(1) != 1) {
      // Cbz12/22/98
      // C        NSH = MASSR(1) - NPI + 1
      // C        IAINT2(1) = IAINT2(1) + NSH
      // C.....to shift the unformed particles to the end of the common block
      // C        IF (NSH .GT. 0) THEN
      // C           IB = IAINT2(1)
      // C           IE = MASSR(1) + 1
      // C           II = -1
      // C        ELSE IF (NSH .LT. 0) THEN
      // C           IB = MASSR(1) + 1
      // C           IE = IAINT2(1)
      // C           II = 1
      // C        END IF
      // C        IF (NSH .NE. 0) THEN
      // C           DO I = IB, IE, II
      // C              J = I - NSH
      // C              ITYPAR(I) = ITYPAR(J)
      // C              GXAR(I) = GXAR(J)
      // C              GYAR(I) = GYAR(J)
      // C              GZAR(I) = GZAR(J)
      // C              FTAR(I) = FTAR(J)
      // C              PXAR(I) = PXAR(J)
      // C              PYAR(I) = PYAR(J)
      // C              PZAR(I) = PZAR(J)
      // C              PEAR(I) = PEAR(J)
      // C              XMAR(I) = XMAR(J)
      // C           END DO
      // C        END IF
      // C
      // C.....to copy ART particle info to COMMON /ARPRC/
      // C        DO I = 1, MASSR(1)
      // C           ITYPAR(I) = INVFLV(LB(I))
      // C           GXAR(I) = R(1, I)
      // C           GYAR(I) = R(2, I)
      // C           GZAR(I) = R(3, I)
      // C           FTAR(I) = CT
      // C           PXAR(I) = P(1, I)
      // C           PYAR(I) = P(2, I)
      // C           PZAR(I) = P(3, I)
      // C           XMAR(I) = E(I)
      // C           PEAR(I) = SQRT(PXAR(I) ** 2 + PYAR(I) ** 2 + PZAR(I) ** 2
      // C     &        + XMAR(I) ** 2)
      // C        END DO
      ia = 0;
      FEM_DO_SAFE(irun, 1, num) {
        ia += massr(irun - 1);
        np1 = npi(irun);
        nsh = massr(irun) - np1 + 1;
        multi1(irun) += nsh;
        // C.....to shift the unformed particles to the end of the common block
        if (nsh > 0) {
          ib = multi1(irun);
          ie = massr(irun) + 1;
          ii = -1;
        } else if (nsh < 0) {
          ib = massr(irun) + 1;
          ie = multi1(irun);
          ii = 1;
        }
        if (nsh != 0) {
          FEM_DOSTEP(i, ib, ie, ii) {
            j = i - nsh;
            ityp1(i, irun) = ityp1(j, irun);
            gx1(i, irun) = gx1(j, irun);
            gy1(i, irun) = gy1(j, irun);
            gz1(i, irun) = gz1(j, irun);
            ft1(i, irun) = ft1(j, irun);
            px1(i, irun) = px1(j, irun);
            py1(i, irun) = py1(j, irun);
            pz1(i, irun) = pz1(j, irun);
            ee1(i, irun) = ee1(j, irun);
            xm1(i, irun) = xm1(j, irun);
            // C     !! sp 12/19/00
            pro1(i, irun) = pro1(j, irun);
            // Clin-5/2008:
            dpp1(i, irun) = dpp1(j, irun);
          }
        }
        // C
        // C.....to copy ART particle info to COMMON /ARPRC1/
        FEM_DO_SAFE(i, 1, massr(irun)) {
          ib = ia + i;
          ityp1(i, irun) = invflv(lb(ib));
          gx1(i, irun) = r(1, ib);
          gy1(i, irun) = r(2, ib);
          gz1(i, irun) = r(3, ib);
          // Clin-10/28/03:
          // C since all unformed hadrons at time ct are read in at nt=ntmax-1,
          // C their formation time ft1 should be kept to determine their
          // freezeout(x,t): C              FT1(I, IRUN) = CT
          if (ft1(i, irun) < ct) {
            ft1(i, irun) = ct;
          }
          px1(i, irun) = p(1, ib);
          py1(i, irun) = p(2, ib);
          pz1(i, irun) = p(3, ib);
          xm1(i, irun) = e(ib);
          ee1(i, irun) =
              fem::sqrt(fem::pow2(px1(i, irun)) + fem::pow2(py1(i, irun)) +
                        fem::pow2(pz1(i, irun)) + fem::pow2(xm1(i, irun)));
          // C     !! sp 12/19/00
          pro1(i, irun) = proper(ib);
        }
      }
      // Cbz12/22/98end
    }
    // Cbz11/16/98end
    // C
    // C*********************************
    // C                                                                      *
    // C       ======= END OF MANY LOOPS OVER IMPACT PARAMETERS ==========    *
    // C                                                               *
    // C*********************************
  }
  // C
  // C-----------------------------------------------------------------------
  // C                       ==== ART COMPLETED ====
  // C-----------------------------------------------------------------------
  // Cbz11/16/98
  // C      STOP
  // Cbz11/16/98end
}

struct blockdata_ppbdat_save {
  int i;

  blockdata_ppbdat_save() : i(fem::int0) {}
};

// C
// C*******************************
void blockdata_ppbdat(common& cmn) {
  FEM_CMN_SVE(blockdata_ppbdat);
  // COMMON ppbmas
  arr_ref<int> niso(cmn.niso, dimension(15));
  arr_ref<float, 2> ppbm(cmn.ppbm, dimension(15, 2));
  arr_ref<float> thresh(cmn.thresh, dimension(15));
  // COMMON ppb1
  arr_ref<float> factr2(cmn.factr2, dimension(6));
  //
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float am1440 = 1.44f;
  const float am1535 = 1.535f;
  if (is_called_first_time) {
    {
      static const float values[] = {1.87656f,  1.877737f, 1.878914f, 2.17028f,
                                     2.171457f, 2.37828f,  2.379457f, 2.464f,
                                     2.47328f,  2.474457f, 2.672f,    2.767f,
                                     2.88f,     2.975f,    3.07f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), thresh;
    }
    {
      fem::data_values data;
      data.values, amp, amp, amn, amp, amn, amp, amn, am0;
      data.values, amp, amn, am0, am0, am1440, am1440, am1535;
      FEM_DO_SAFE(sve.i, 1, 15) { data, ppbm(sve.i, 1); }
    }
    {
      fem::data_values data;
      data.values, amp, amn, amn, am0, am0, am1440, am1440, am0;
      data.values, am1535, am1535, am1440, am1535, am1440, am1535, am1535;
      FEM_DO_SAFE(sve.i, 1, 15) { data, ppbm(sve.i, 2); }
    }
    fem::data((values, 0, 1, 1.17e-01f, 3.27e-03f, 3.58e-05f, 1.93e-07f)),
        factr2;
    {
      static const int values[] = {1, 2, 1,  16, 16, 4, 4, 64,
                                   4, 4, 32, 32, 4,  8, 4};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), niso;
    }
  }
  // C
  // C     to give default values to parameters for BbarB production from mesons
  // Cc      SAVE /ppbmas/
  // Cc      SAVE /ppb1/
  // Cc      SAVE /ppmm/
  // C     thresh(i) gives the mass thresh for final channel i:
  // C     ppbm(i,j=1,2) gives masses for the two final baryons of channel i,
  // C     with j=1 for the lighter baryon:
  // C     factr2(i) gives weights for producing i pions from ppbar
  // annihilation: C     niso(i) gives the degeneracy factor for final channel i:
  // C
}

}  // namespace AMPT
