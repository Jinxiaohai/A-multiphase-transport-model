#include <array>
#include <cmath>
#include <list>
#include <vector>


#include <fem.hpp>  /// Fortran EMulation library of fable module

using namespace std;

namespace AMPT {

using namespace fem::major_types;

#define acosh std::acosh

/// double acosh(double x) { return log(x + sqrt(x * x - 1)); }

void dcosh(...) {
  throw std::runtime_error("Missing function implementation: dcosh");
}

void dfour(...) {
  throw std::runtime_error("Missing function implementation: dfour");
}

void digk(...) {
  throw std::runtime_error("Missing function implementation: digk");
}

void djgk(...) {
  throw std::runtime_error("Missing function implementation: djgk");
}

std::complex<float> fgk(...) {
  throw std::runtime_error("Missing function implementation: fgk");
}

void four(...) {
  throw std::runtime_error("Missing function implementation: four");
}

void hmeps(...) {
  throw std::runtime_error("Missing function implementation: hmeps");
}

void idint(...) {
  throw std::runtime_error("Missing function implementation: idint");
}

void ludbrb(...) {
  throw std::runtime_error("Missing function implementation: ludbrb");
}

void pawt(...) {
  throw std::runtime_error("Missing function implementation: pawt");
}

void rand(...) {
  throw std::runtime_error("Missing function implementation: rand");
}

void srand(...) {
  throw std::runtime_error("Missing function implementation: srand");
}

struct common_gg {
  float dx;
  float dy;
  float dz;
  float dpx;
  float dpy;
  float dpz;

  common_gg()
      : dx(fem::float0),
        dy(fem::float0),
        dz(fem::float0),
        dpx(fem::float0),
        dpy(fem::float0),
        dpz(fem::float0) {}
};

struct common_zz {
  int zta;
  int zpr;

  common_zz() : zta(fem::int0), zpr(fem::int0) {}
};

struct common_run {
  int num;

  common_run() : num(fem::int0) {}
};

struct common_input1 {
  int masspr;
  int massta;
  int iseed;
  int iavoid;
  float dt;

  common_input1()
      : masspr(fem::int0),
        massta(fem::int0),
        iseed(fem::int0),
        iavoid(fem::int0),
        dt(fem::float0) {}
};

struct common_input2 {
  int ilab;
  int manyb;
  int ntmax;
  int icoll;
  int insys;
  int ipot;
  int mode;
  int imomen;
  int nfreq;
  int icflow;
  int icrho;
  int icou;
  int kpoten;
  int kmul;

  common_input2()
      : ilab(fem::int0),
        manyb(fem::int0),
        ntmax(fem::int0),
        icoll(fem::int0),
        insys(fem::int0),
        ipot(fem::int0),
        mode(fem::int0),
        imomen(fem::int0),
        nfreq(fem::int0),
        icflow(fem::int0),
        icrho(fem::int0),
        icou(fem::int0),
        kpoten(fem::int0),
        kmul(fem::int0) {}
};

struct common_input3 {
  float plab;
  float elab;
  float zeropt;
  float b0;
  float bi;
  float bm;
  float dencut;
  float cycbox;

  common_input3()
      : plab(fem::float0),
        elab(fem::float0),
        zeropt(fem::float0),
        b0(fem::float0),
        bi(fem::float0),
        bm(fem::float0),
        dencut(fem::float0),
        cycbox(fem::float0) {}
};

struct common_imulst {
  int iperts;

  common_imulst() : iperts(fem::int0) {}
};

struct common_coal {
  double dpcoal;
  double drcoal;
  double ecritl;

  common_coal()
      : dpcoal(fem::double0), drcoal(fem::double0), ecritl(fem::double0) {}
};

struct common_anim {
  int nevent;
  int isoft;
  int isflag;
  int izpc;

  common_anim()
      : nevent(fem::int0),
        isoft(fem::int0),
        isflag(fem::int0),
        izpc(fem::int0) {}
};

struct common_para7 {
  int ioscar;
  int nsmbbbar;
  int nsmmeson;

  common_para7()
      : ioscar(fem::int0), nsmbbbar(fem::int0), nsmmeson(fem::int0) {}
};

struct common_embed {
  int iembed;
  int nsembd;
  float pxqembd;
  float pyqembd;
  float xembd;
  float yembd;
  float psembd;
  float tmaxembd;
  float phidecomp;

  common_embed()
      : iembed(fem::int0),
        nsembd(fem::int0),
        pxqembd(fem::float0),
        pyqembd(fem::float0),
        xembd(fem::float0),
        yembd(fem::float0),
        psembd(fem::float0),
        tmaxembd(fem::float0),
        phidecomp(fem::float0) {}
};

struct common_xyembed {
  static const int nxymax = 10001;

  int nxyjet;
  arr<float, 2> xyjet;

  common_xyembed()
      : nxyjet(fem::int0), xyjet(dimension(nxymax, 2), fem::fill0) {}
};

const int common_xyembed::nxymax;

struct common_arprnt {
  arr<float> arpar1;
  arr<int> iapar2;
  arr<float> arint1;
  arr<int> iaint2;

  common_arprnt()
      : arpar1(dimension(100), fem::fill0),
        iapar2(dimension(50), fem::fill0),
        arint1(dimension(100), fem::fill0),
        iaint2(dimension(50), fem::fill0) {}
};

struct common_arprc {
  static const int maxstr = 150001;

  arr<int> itypar;
  arr<float> gxar;
  arr<float> gyar;
  arr<float> gzar;
  arr<float> ftar;
  arr<float> pxar;
  arr<float> pyar;
  arr<float> pzar;
  arr<float> pear;
  arr<float> xmar;

  common_arprc()
      : itypar(dimension(maxstr), fem::fill0),
        gxar(dimension(maxstr), fem::fill0),
        gyar(dimension(maxstr), fem::fill0),
        gzar(dimension(maxstr), fem::fill0),
        ftar(dimension(maxstr), fem::fill0),
        pxar(dimension(maxstr), fem::fill0),
        pyar(dimension(maxstr), fem::fill0),
        pzar(dimension(maxstr), fem::fill0),
        pear(dimension(maxstr), fem::fill0),
        xmar(dimension(maxstr), fem::fill0) {}
};

const int common_arprc::maxstr;

struct common_dpert {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> dpertt;
  arr<float> dpertp;
  arr<float> dplast;
  arr<float> dpdcy;
  arr<float, 2> dpdpi;
  arr<float, 2> dpt;
  arr<float, 2> dpp1;
  arr<float, 2> dppion;

  common_dpert()
      : dpertt(dimension(maxstr, maxr), fem::fill0),
        dpertp(dimension(maxstr), fem::fill0),
        dplast(dimension(maxstr), fem::fill0),
        dpdcy(dimension(maxstr), fem::fill0),
        dpdpi(dimension(maxstr, maxr), fem::fill0),
        dpt(dimension(maxstr, maxr), fem::fill0),
        dpp1(dimension(maxstr, maxr), fem::fill0),
        dppion(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_dpert::maxstr;
const int common_dpert::maxr;

struct common_smearz {
  double smearp;
  double smearh;

  common_smearz() : smearp(fem::double0), smearh(fem::double0) {}
};

struct common_rndf77 {
  int nseed;

  common_rndf77() : nseed(fem::int0) {}
};

struct common_para8 {
  int idpert;
  int npertd;
  int idxsec;

  common_para8() : idpert(fem::int0), npertd(fem::int0), idxsec(fem::int0) {}
};

struct common_nzpc {
  int nattzp;

  common_nzpc() : nattzp(fem::int0) {}
};

struct common_hparnt {
  arr<float> hipr1;
  arr<int> ihpr2;
  arr<float> hint1;
  arr<int> ihnt2;

  common_hparnt()
      : hipr1(dimension(100), fem::fill0),
        ihpr2(dimension(50), fem::fill0),
        hint1(dimension(100), fem::fill0),
        ihnt2(dimension(50), fem::fill0) {}
};

struct common_arerc1 {
  static const int maxr = 1;

  arr<int> multi1;

  common_arerc1() : multi1(dimension(maxr), fem::fill0) {}
};

const int common_arerc1::maxr;

struct common_arprc1 {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<int, 2> ityp1;
  arr<float, 2> gx1;
  arr<float, 2> gy1;
  arr<float, 2> gz1;
  arr<float, 2> ft1;
  arr<float, 2> px1;
  arr<float, 2> py1;
  arr<float, 2> pz1;
  arr<float, 2> ee1;
  arr<float, 2> xm1;

  common_arprc1()
      : ityp1(dimension(maxstr, maxr), fem::fill0),
        gx1(dimension(maxstr, maxr), fem::fill0),
        gy1(dimension(maxstr, maxr), fem::fill0),
        gz1(dimension(maxstr, maxr), fem::fill0),
        ft1(dimension(maxstr, maxr), fem::fill0),
        px1(dimension(maxstr, maxr), fem::fill0),
        py1(dimension(maxstr, maxr), fem::fill0),
        pz1(dimension(maxstr, maxr), fem::fill0),
        ee1(dimension(maxstr, maxr), fem::fill0),
        xm1(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_arprc1::maxstr;
const int common_arprc1::maxr;

struct common_tdecay {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float> tfdcy;
  arr<float, 2> tfdpi;
  arr<float> tft;

  common_tdecay()
      : tfdcy(dimension(maxstr), fem::fill0),
        tfdpi(dimension(maxstr, maxr), fem::fill0),
        tft(dimension(maxstr), fem::fill0) {}
};

const int common_tdecay::maxstr;
const int common_tdecay::maxr;

struct common_ludat2 {
  arr<int, 2> kchg;
  arr<float, 2> pmas;
  arr<float> parf;
  arr<float, 2> vckm;

  common_ludat2()
      : kchg(dimension(500, 3), fem::fill0),
        pmas(dimension(500, 4), fem::fill0),
        parf(dimension(2000), fem::fill0),
        vckm(dimension(4, 4), fem::fill0) {}
};

struct common_arana1 {
  arr<float> dy1ntb;
  arr<float> dy1ntp;
  arr<float> dy1hm;
  arr<float> dy1kp;
  arr<float> dy1km;
  arr<float> dy1k0s;
  arr<float> dy1la;
  arr<float> dy1lb;
  arr<float> dy1phi;
  arr<float> dm1pip;
  arr<float> dm1pim;
  arr<float> dmt1pr;
  arr<float> dmt1pb;
  arr<float> dmt1kp;
  arr<float> dm1km;
  arr<float> dm1k0s;
  arr<float> dmt1la;
  arr<float> dmt1lb;
  arr<float> dy1msn;
  arr<float> dy1pip;
  arr<float> dy1pim;
  arr<float> dy1pi0;
  arr<float> dy1pr;
  arr<float> dy1pb;
  arr<float> dy1neg;
  arr<float> dy1ch;
  arr<float> de1neg;
  arr<float> de1ch;

  common_arana1()
      : dy1ntb(dimension(50), fem::fill0),
        dy1ntp(dimension(50), fem::fill0),
        dy1hm(dimension(50), fem::fill0),
        dy1kp(dimension(50), fem::fill0),
        dy1km(dimension(50), fem::fill0),
        dy1k0s(dimension(50), fem::fill0),
        dy1la(dimension(50), fem::fill0),
        dy1lb(dimension(50), fem::fill0),
        dy1phi(dimension(50), fem::fill0),
        dm1pip(dimension(50), fem::fill0),
        dm1pim(dimension(50), fem::fill0),
        dmt1pr(dimension(50), fem::fill0),
        dmt1pb(dimension(50), fem::fill0),
        dmt1kp(dimension(50), fem::fill0),
        dm1km(dimension(50), fem::fill0),
        dm1k0s(dimension(50), fem::fill0),
        dmt1la(dimension(50), fem::fill0),
        dmt1lb(dimension(50), fem::fill0),
        dy1msn(dimension(50), fem::fill0),
        dy1pip(dimension(50), fem::fill0),
        dy1pim(dimension(50), fem::fill0),
        dy1pi0(dimension(50), fem::fill0),
        dy1pr(dimension(50), fem::fill0),
        dy1pb(dimension(50), fem::fill0),
        dy1neg(dimension(50), fem::fill0),
        dy1ch(dimension(50), fem::fill0),
        de1neg(dimension(50), fem::fill0),
        de1ch(dimension(50), fem::fill0) {}
};

struct common_arana2 {
  arr<float> dy2ntb;
  arr<float> dy2ntp;
  arr<float> dy2hm;
  arr<float> dy2kp;
  arr<float> dy2km;
  arr<float> dy2k0s;
  arr<float> dy2la;
  arr<float> dy2lb;
  arr<float> dy2phi;
  arr<float> dm2pip;
  arr<float> dm2pim;
  arr<float> dmt2pr;
  arr<float> dmt2pb;
  arr<float> dmt2kp;
  arr<float> dm2km;
  arr<float> dm2k0s;
  arr<float> dmt2la;
  arr<float> dmt2lb;
  arr<float> dy2msn;
  arr<float> dy2pip;
  arr<float> dy2pim;
  arr<float> dy2pi0;
  arr<float> dy2pr;
  arr<float> dy2pb;
  arr<float> dy2neg;
  arr<float> dy2ch;
  arr<float> de2neg;
  arr<float> de2ch;

  common_arana2()
      : dy2ntb(dimension(50), fem::fill0),
        dy2ntp(dimension(50), fem::fill0),
        dy2hm(dimension(50), fem::fill0),
        dy2kp(dimension(50), fem::fill0),
        dy2km(dimension(50), fem::fill0),
        dy2k0s(dimension(50), fem::fill0),
        dy2la(dimension(50), fem::fill0),
        dy2lb(dimension(50), fem::fill0),
        dy2phi(dimension(50), fem::fill0),
        dm2pip(dimension(50), fem::fill0),
        dm2pim(dimension(50), fem::fill0),
        dmt2pr(dimension(50), fem::fill0),
        dmt2pb(dimension(50), fem::fill0),
        dmt2kp(dimension(50), fem::fill0),
        dm2km(dimension(50), fem::fill0),
        dm2k0s(dimension(50), fem::fill0),
        dmt2la(dimension(50), fem::fill0),
        dmt2lb(dimension(50), fem::fill0),
        dy2msn(dimension(50), fem::fill0),
        dy2pip(dimension(50), fem::fill0),
        dy2pim(dimension(50), fem::fill0),
        dy2pi0(dimension(50), fem::fill0),
        dy2pr(dimension(50), fem::fill0),
        dy2pb(dimension(50), fem::fill0),
        dy2neg(dimension(50), fem::fill0),
        dy2ch(dimension(50), fem::fill0),
        de2neg(dimension(50), fem::fill0),
        de2ch(dimension(50), fem::fill0) {}
};

struct common_ee {
  static const int maxstr = 150001;

  arr<int> id;
  arr<int> lb;

  common_ee()
      : id(dimension(maxstr), fem::fill0), lb(dimension(maxstr), fem::fill0) {}
};

const int common_ee::maxstr;

struct common_aa {
  static const int maxstr = 150001;

  arr<float, 2> r;

  common_aa() : r(dimension(3, maxstr), fem::fill0) {}
};

const int common_aa::maxstr;

struct common_bb {
  static const int maxstr = 150001;

  arr<float, 2> p;

  common_bb() : p(dimension(3, maxstr), fem::fill0) {}
};

const int common_bb::maxstr;

struct common_cc {
  static const int maxstr = 150001;

  arr<float> e;

  common_cc() : e(dimension(maxstr), fem::fill0) {}
};

const int common_cc::maxstr;

struct common_bg {
  float betax;
  float betay;
  float betaz;
  float gamma;

  common_bg()
      : betax(fem::float0),
        betay(fem::float0),
        betaz(fem::float0),
        gamma(fem::float0) {}
};

struct common_nn {
  int nnn;

  common_nn() : nnn(fem::int0) {}
};

struct common_pa {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 3> rpion;

  common_pa() : rpion(dimension(3, maxstr, maxr), fem::fill0) {}
};

const int common_pa::maxstr;
const int common_pa::maxr;

struct common_pb {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 3> ppion;

  common_pb() : ppion(dimension(3, maxstr, maxr), fem::fill0) {}
};

const int common_pb::maxstr;
const int common_pb::maxr;

struct common_pc {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> epion;

  common_pc() : epion(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_pc::maxstr;
const int common_pc::maxr;

struct common_pd {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<int, 2> lpion;

  common_pd() : lpion(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_pd::maxstr;
const int common_pd::maxr;

struct common_leadng {
  int lb1;
  float px1;
  float py1;
  float pz1;
  float em1;
  float e1;
  float xfnl;
  float yfnl;
  float zfnl;
  float tfnl;
  float px1n;
  float py1n;
  float pz1n;
  float dp1n;

  common_leadng()
      : lb1(fem::int0),
        px1(fem::float0),
        py1(fem::float0),
        pz1(fem::float0),
        em1(fem::float0),
        e1(fem::float0),
        xfnl(fem::float0),
        yfnl(fem::float0),
        zfnl(fem::float0),
        tfnl(fem::float0),
        px1n(fem::float0),
        py1n(fem::float0),
        pz1n(fem::float0),
        dp1n(fem::float0) {}
};

struct common_dpi {
  float em2;
  int lb2;

  common_dpi() : em2(fem::float0), lb2(fem::int0) {}
};

struct common_table {
  arr<float> xarray;
  arr<float> earray;

  common_table()
      : xarray(dim1(0, 1000), fem::fill0), earray(dim1(0, 1000), fem::fill0) {}
};

struct common_arevt {
  int iaevt;
  int iarun;
  int miss;

  common_arevt() : iaevt(fem::int0), iarun(fem::int0), miss(fem::int0) {}
};

struct common_ff {
  static const int mx = 4;
  static const int my = 4;
  static const int mz = 8;
  static const int mpx = 4;
  static const int mpy = 4;
  static const int mpz = 10;
  static const int mpzp = 10;

  arr<float, 6> f;

  common_ff()
      : f(dim1(-mx, mx)
              .dim2(-my, my)
              .dim3(-mz, mz)
              .dim4(-mpx, mpx)
              .dim5(-mpy, mpy)
              .dim6(-mpz, mpzp),
          fem::fill0) {}
};

const int common_ff::mx;
const int common_ff::my;
const int common_ff::mz;
const int common_ff::mpx;
const int common_ff::mpy;
const int common_ff::mpz;
const int common_ff::mpzp;

struct common_input {
  int nstar;
  int ndirct;
  float dir;

  common_input() : nstar(fem::int0), ndirct(fem::int0), dir(fem::float0) {}
};

struct common_ppbmas {
  arr<int> niso;
  int nstate;
  arr<float, 2> ppbm;
  arr<float> thresh;
  arr<float> weight;

  common_ppbmas()
      : niso(dimension(15), fem::fill0),
        nstate(fem::int0),
        ppbm(dimension(15, 2), fem::fill0),
        thresh(dimension(15), fem::fill0),
        weight(dimension(15), fem::fill0) {}
};

struct common_ppb1 {
  float ene;
  arr<float> factr2;
  float fsum;
  float ppinnb;
  float s;
  float wtot;

  common_ppb1()
      : ene(fem::float0),
        factr2(dimension(6), fem::fill0),
        fsum(fem::float0),
        ppinnb(fem::float0),
        s(fem::float0),
        wtot(fem::float0) {}
};

struct common_ppmm {
  float pprr;
  float ppee;
  float pppe;
  float rpre;
  float xopoe;
  float rree;

  common_ppmm()
      : pprr(fem::float0),
        ppee(fem::float0),
        pppe(fem::float0),
        rpre(fem::float0),
        xopoe(fem::float0),
        rree(fem::float0) {}
};

struct common_dd {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> rho;
  arr<float, 3> rhop;
  arr<float, 3> rhon;

  common_dd()
      : rho(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rhop(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rhon(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
             fem::fill0) {}
};

const int common_dd::maxx;
const int common_dd::maxz;

struct common_hh {
  static const int maxstr = 150001;

  arr<float> proper;

  common_hh() : proper(dimension(maxstr), fem::fill0) {}
};

const int common_hh::maxstr;

struct common_pe {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> propi;

  common_pe() : propi(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_pe::maxstr;
const int common_pe::maxr;

struct common_rr {
  static const int maxr = 1;

  arr<int> massr;

  common_rr() : massr(dim1(0, maxr), fem::fill0) {}
};

const int common_rr::maxr;

struct common_dpifsl {
  int lbnn1;
  int lbnn2;
  int lbnd1;
  int lbnd2;
  int lbns1;
  int lbns2;
  int lbnp1;
  int lbnp2;
  int lbdd1;
  int lbdd2;
  int lbds1;
  int lbds2;
  int lbdp1;
  int lbdp2;
  int lbss1;
  int lbss2;
  int lbsp1;
  int lbsp2;
  int lbpp1;
  int lbpp2;

  common_dpifsl()
      : lbnn1(fem::int0),
        lbnn2(fem::int0),
        lbnd1(fem::int0),
        lbnd2(fem::int0),
        lbns1(fem::int0),
        lbns2(fem::int0),
        lbnp1(fem::int0),
        lbnp2(fem::int0),
        lbdd1(fem::int0),
        lbdd2(fem::int0),
        lbds1(fem::int0),
        lbds2(fem::int0),
        lbdp1(fem::int0),
        lbdp2(fem::int0),
        lbss1(fem::int0),
        lbss2(fem::int0),
        lbsp1(fem::int0),
        lbsp2(fem::int0),
        lbpp1(fem::int0),
        lbpp2(fem::int0) {}
};

struct common_dpifsm {
  float xmnn1;
  float xmnn2;
  float xmnd1;
  float xmnd2;
  float xmns1;
  float xmns2;
  float xmnp1;
  float xmnp2;
  float xmdd1;
  float xmdd2;
  float xmds1;
  float xmds2;
  float xmdp1;
  float xmdp2;
  float xmss1;
  float xmss2;
  float xmsp1;
  float xmsp2;
  float xmpp1;
  float xmpp2;

  common_dpifsm()
      : xmnn1(fem::float0),
        xmnn2(fem::float0),
        xmnd1(fem::float0),
        xmnd2(fem::float0),
        xmns1(fem::float0),
        xmns2(fem::float0),
        xmnp1(fem::float0),
        xmnp2(fem::float0),
        xmdd1(fem::float0),
        xmdd2(fem::float0),
        xmds1(fem::float0),
        xmds2(fem::float0),
        xmdp1(fem::float0),
        xmdp2(fem::float0),
        xmss1(fem::float0),
        xmss2(fem::float0),
        xmsp1(fem::float0),
        xmsp2(fem::float0),
        xmpp1(fem::float0),
        xmpp2(fem::float0) {}
};

struct common_dpisig {
  float sdmel;
  float sdmnn;
  float sdmnd;
  float sdmns;
  float sdmnp;
  float sdmdd;
  float sdmds;
  float sdmdp;
  float sdmss;
  float sdmsp;
  float sdmpp;

  common_dpisig()
      : sdmel(fem::float0),
        sdmnn(fem::float0),
        sdmnd(fem::float0),
        sdmns(fem::float0),
        sdmnp(fem::float0),
        sdmdd(fem::float0),
        sdmds(fem::float0),
        sdmdp(fem::float0),
        sdmss(fem::float0),
        sdmsp(fem::float0),
        sdmpp(fem::float0) {}
};

struct common_ludat1 {
  arr<int> mstu;
  arr<float> paru;
  arr<int> mstj;
  arr<float> parj;

  common_ludat1()
      : mstu(dimension(200), fem::fill0),
        paru(dimension(200), fem::fill0),
        mstj(dimension(200), fem::fill0),
        parj(dimension(200), fem::fill0) {}
};

struct common_ludat4 {
  arr<fem::str<8> > chaf;

  common_ludat4() : chaf(dimension(500), fem::fill0) {}
};

struct common_lujets {
  int n;
  arr<int, 2> k;
  arr<float, 2> p;
  arr<float, 2> v;

  common_lujets()
      : n(fem::int0),
        k(dimension(9000, 5), fem::fill0),
        p(dimension(9000, 5), fem::fill0),
        v(dimension(9000, 5), fem::fill0) {}
};

struct common_ludat3 {
  arr<int, 2> mdcy;
  arr<int, 2> mdme;
  arr<float> brat;
  arr<int, 2> kfdp;

  common_ludat3()
      : mdcy(dimension(500, 3), fem::fill0),
        mdme(dimension(2000, 2), fem::fill0),
        brat(dimension(2000), fem::fill0),
        kfdp(dimension(2000, 5), fem::fill0) {}
};

struct common_resdcy {
  int nsav;
  int iksdcy;

  common_resdcy() : nsav(fem::int0), iksdcy(fem::int0) {}
};

struct common_phidcy {
  int iphidcy;
  float pttrig;
  int ntrig;
  int maxmiss;
  int ipi0dcy;

  common_phidcy()
      : iphidcy(fem::int0),
        pttrig(fem::float0),
        ntrig(fem::int0),
        maxmiss(fem::int0),
        ipi0dcy(fem::int0) {}
};

struct common_ss {
  arr<int> inout;

  common_ss() : inout(dimension(20), fem::fill0) {}
};

struct common_kkk {
  arr<float> tkaon;
  arr<float, 2> ekaon;

  common_kkk()
      : tkaon(dimension(7), fem::fill0),
        ekaon(dim1(7).dim2(0, 2000), fem::fill0) {}
};

struct common_kaon {
  arr<float, 3> ak;
  arr<float, 3> speck;
  int mf;

  common_kaon()
      : ak(dimension(3, 50, 36), fem::fill0),
        speck(dimension(50, 36, 7), fem::fill0),
        mf(fem::int0) {}
};

struct common_lastt {
  int itimeh;
  float bimp;

  common_lastt() : itimeh(fem::int0), bimp(fem::float0) {}
};

struct common_hbt {
  static const int maxstr = 150001;

  arr<int> lblast;
  arr<float, 2> xlast;
  arr<float, 2> plast;
  int nlast;

  common_hbt()
      : lblast(dimension(maxstr), fem::fill0),
        xlast(dimension(4, maxstr), fem::fill0),
        plast(dimension(4, maxstr), fem::fill0),
        nlast(fem::int0) {}
};

const int common_hbt::maxstr;

struct common_ftmax {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float> ftsv;
  arr<float, 2> ftsvt;

  common_ftmax()
      : ftsv(dimension(maxstr), fem::fill0),
        ftsvt(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_ftmax::maxstr;
const int common_ftmax::maxr;

struct common_ddpi {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> pirho;

  common_ddpi()
      : pirho(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
              fem::fill0) {}
};

const int common_ddpi::maxx;
const int common_ddpi::maxz;

struct common_tt {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> pel;
  arr<float, 3> rxy;

  common_tt()
      : pel(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rxy(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0) {
  }
};

const int common_tt::maxx;
const int common_tt::maxz;

struct common_bbb {
  static const int maxx = 20;
  static const int maxz = 24;

  arr<float, 3> bxx;
  arr<float, 3> byy;
  arr<float, 3> bzz;

  common_bbb()
      : bxx(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        byy(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        bzz(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0) {
  }
};

const int common_bbb::maxx;
const int common_bbb::maxz;

struct common_snn {
  float efrm;
  int npart1;
  int npart2;
  float epsipz;
  float epsipt;
  float pzproj;
  float pztarg;

  common_snn()
      : efrm(fem::float0),
        npart1(fem::int0),
        npart2(fem::int0),
        epsipz(fem::float0),
        epsipt(fem::float0),
        pzproj(fem::float0),
        pztarg(fem::float0) {}
};

struct common_oscar1 {
  int iap;
  int izp;
  int iat;
  int izt;

  common_oscar1()
      : iap(fem::int0), izp(fem::int0), iat(fem::int0), izt(fem::int0) {}
};

struct common_oscar2 {
  fem::str<8> frame;
  fem::str<25> amptvn;

  common_oscar2() : frame(fem::char0), amptvn(fem::char0) {}
};

struct common_hjglbr {
  int nelt;
  int ninthj;
  int nelp;
  int ninp;

  common_hjglbr()
      : nelt(fem::int0), ninthj(fem::int0), nelp(fem::int0), ninp(fem::int0) {}
};

struct common_phihj {
  int iphirp;
  float phirp;

  common_phihj() : iphirp(fem::int0), phirp(fem::float0) {}
};

struct common_pp {
  arr<float, 2> prho;

  common_pp() : prho(dim1(-20, 20).dim2(-24, 24), fem::fill0) {}
};

struct common_qq {
  static const int maxz = 24;

  arr<float, 2> phrho;

  common_qq() : phrho(dim1(-maxz, maxz).dim2(-24, 24), fem::fill0) {}
};

const int common_qq::maxz;

struct common_arercp {
  static const int maxstr = 150001;
  static const int maxr = 1;

  arr<float, 2> pro1;

  common_arercp() : pro1(dimension(maxstr, maxr), fem::fill0) {}
};

const int common_arercp::maxstr;
const int common_arercp::maxr;

struct common_para1 {
  int mul;

  common_para1() : mul(fem::int0) {}
};

struct common_hjcrdn {
  arr<float, 2> yp;
  arr<float, 2> yt;

  common_hjcrdn()
      : yp(dimension(3, 300), fem::fill0), yt(dimension(3, 300), fem::fill0) {}
};

struct common_hjjet1 {
  arr<int> npj;
  arr<int, 2> kfpj;
  arr<float, 2> pjpx;
  arr<float, 2> pjpy;
  arr<float, 2> pjpz;
  arr<float, 2> pjpe;
  arr<float, 2> pjpm;
  arr<int> ntj;
  arr<int, 2> kftj;
  arr<float, 2> pjtx;
  arr<float, 2> pjty;
  arr<float, 2> pjtz;
  arr<float, 2> pjte;
  arr<float, 2> pjtm;

  common_hjjet1()
      : npj(dimension(300), fem::fill0),
        kfpj(dimension(300, 500), fem::fill0),
        pjpx(dimension(300, 500), fem::fill0),
        pjpy(dimension(300, 500), fem::fill0),
        pjpz(dimension(300, 500), fem::fill0),
        pjpe(dimension(300, 500), fem::fill0),
        pjpm(dimension(300, 500), fem::fill0),
        ntj(dimension(300), fem::fill0),
        kftj(dimension(300, 500), fem::fill0),
        pjtx(dimension(300, 500), fem::fill0),
        pjty(dimension(300, 500), fem::fill0),
        pjtz(dimension(300, 500), fem::fill0),
        pjte(dimension(300, 500), fem::fill0),
        pjtm(dimension(300, 500), fem::fill0) {}
};

struct common_hjjet2 {
  static const int maxstr = 150001;

  int nsg;
  arr<int> njsg;
  arr<int, 2> iasg;
  arr<int, 2> k1sg;
  arr<int, 2> k2sg;
  arr<float, 2> pxsg;
  arr<float, 2> pysg;
  arr<float, 2> pzsg;
  arr<float, 2> pesg;
  arr<float, 2> pmsg;

  common_hjjet2()
      : nsg(fem::int0),
        njsg(dimension(maxstr), fem::fill0),
        iasg(dimension(maxstr, 3), fem::fill0),
        k1sg(dimension(maxstr, 100), fem::fill0),
        k2sg(dimension(maxstr, 100), fem::fill0),
        pxsg(dimension(maxstr, 100), fem::fill0),
        pysg(dimension(maxstr, 100), fem::fill0),
        pzsg(dimension(maxstr, 100), fem::fill0),
        pesg(dimension(maxstr, 100), fem::fill0),
        pmsg(dimension(maxstr, 100), fem::fill0) {}
};

const int common_hjjet2::maxstr;

struct common_prec1 {
  static const int maxptn = 400001;

  arr<double> gx0;
  arr<double> gy0;
  arr<double> gz0;
  arr<double> ft0;
  arr<double> px0;
  arr<double> py0;
  arr<double> pz0;
  arr<double> e0;
  arr<double> xmass0;
  arr<int> ityp0;

  common_prec1()
      : gx0(dimension(maxptn), fem::fill0),
        gy0(dimension(maxptn), fem::fill0),
        gz0(dimension(maxptn), fem::fill0),
        ft0(dimension(maxptn), fem::fill0),
        px0(dimension(maxptn), fem::fill0),
        py0(dimension(maxptn), fem::fill0),
        pz0(dimension(maxptn), fem::fill0),
        e0(dimension(maxptn), fem::fill0),
        xmass0(dimension(maxptn), fem::fill0),
        ityp0(dimension(maxptn), fem::fill0) {}
};

const int common_prec1::maxptn;

struct common_arout {
  int iout;

  common_arout() : iout(fem::int0) {}
};

struct common_ilist8 {
  static const int maxptn = 400001;

  arr<int> lstrg1;
  arr<int> lpart1;

  common_ilist8()
      : lstrg1(dimension(maxptn), fem::fill0),
        lpart1(dimension(maxptn), fem::fill0) {}
};

const int common_ilist8::maxptn;

struct common_srec1 {
  int nsp;
  int nst;
  int nsi;

  common_srec1() : nsp(fem::int0), nst(fem::int0), nsi(fem::int0) {}
};

struct common_srec2 {
  static const int maxstr = 150001;

  arr<double> ataui;
  arr<double> zt1;
  arr<double> zt2;
  arr<double> zt3;

  common_srec2()
      : ataui(dimension(maxstr), fem::fill0),
        zt1(dimension(maxstr), fem::fill0),
        zt2(dimension(maxstr), fem::fill0),
        zt3(dimension(maxstr), fem::fill0) {}
};

const int common_srec2::maxstr;

struct common_soft {
  static const int maxstr = 150001;

  arr<double, 2> pxsgs;
  arr<double, 2> pysgs;
  arr<double, 2> pzsgs;
  arr<double, 2> pesgs;
  arr<double, 2> pmsgs;
  arr<double, 2> gxsgs;
  arr<double, 2> gysgs;
  arr<double, 2> gzsgs;
  arr<double, 2> ftsgs;
  arr<int, 2> k1sgs;
  arr<int, 2> k2sgs;
  arr<int> njsgs;

  common_soft()
      : pxsgs(dimension(maxstr, 3), fem::fill0),
        pysgs(dimension(maxstr, 3), fem::fill0),
        pzsgs(dimension(maxstr, 3), fem::fill0),
        pesgs(dimension(maxstr, 3), fem::fill0),
        pmsgs(dimension(maxstr, 3), fem::fill0),
        gxsgs(dimension(maxstr, 3), fem::fill0),
        gysgs(dimension(maxstr, 3), fem::fill0),
        gzsgs(dimension(maxstr, 3), fem::fill0),
        ftsgs(dimension(maxstr, 3), fem::fill0),
        k1sgs(dimension(maxstr, 3), fem::fill0),
        k2sgs(dimension(maxstr, 3), fem::fill0),
        njsgs(dimension(maxstr), fem::fill0) {}
};

const int common_soft::maxstr;

struct common_hijdat {
  arr<float, 2> hidat0;
  arr<float> hidat;

  common_hijdat()
      : hidat0(dimension(10, 10), fem::fill0),
        hidat(dimension(10), fem::fill0) {}
};

struct common_pypars {
  arr<int> mstp;
  arr<float> parp;
  arr<int> msti;
  arr<float> pari;

  common_pypars()
      : mstp(dimension(200), fem::fill0),
        parp(dimension(200), fem::fill0),
        msti(dimension(200), fem::fill0),
        pari(dimension(200), fem::fill0) {}
};

struct common_pyint1 {
  arr<int> mint;
  arr<float> vint;

  common_pyint1()
      : mint(dimension(400), fem::fill0), vint(dimension(400), fem::fill0) {}
};

struct common_pysubs {
  int msel;
  arr<int> msub;
  arr<int, 2> kfin;
  arr<float> ckin;

  common_pysubs()
      : msel(fem::int0),
        msub(dimension(200), fem::fill0),
        kfin(dim1(2).dim2(-40, 40), fem::fill0),
        ckin(dimension(200), fem::fill0) {}
};

struct common_pyint2 {
  arr<int> iset;
  arr<int, 2> kfpr;
  arr<float, 2> coef;
  arr<int, 3> icol;

  common_pyint2()
      : iset(dimension(200), fem::fill0),
        kfpr(dimension(200, 2), fem::fill0),
        coef(dimension(200, 20), fem::fill0),
        icol(dimension(40, 4, 2), fem::fill0) {}
};

struct common_pyint4 {
  arr<float, 2> widp;
  arr<float, 2> wide;
  arr<float, 2> wids;

  common_pyint4()
      : widp(dim1(21, 40).dim2(0, 40), fem::fill0),
        wide(dim1(21, 40).dim2(0, 40), fem::fill0),
        wids(dim1(21, 40).dim2(3), fem::fill0) {}
};

struct common_pyint3 {
  arr<float, 2> xsfx;
  arr<int, 2> isig;
  arr<float> sigh;

  common_pyint3()
      : xsfx(dim1(2).dim2(-40, 40), fem::fill0),
        isig(dimension(1000, 3), fem::fill0),
        sigh(dimension(1000), fem::fill0) {}
};

struct common_pyint5 {
  arr<int, 2> ngen;
  arr<float, 2> xsec;

  common_pyint5()
      : ngen(dim1(0, 200).dim2(3), fem::fill0),
        xsec(dim1(0, 200).dim2(3), fem::fill0) {}
};

struct common_hjjet4 {
  static const int maxstr = 150001;

  int ndr;
  arr<int, 2> iadr;
  arr<int> kfdr;
  arr<float, 2> pdr;

  common_hjjet4()
      : ndr(fem::int0),
        iadr(dimension(maxstr, 2), fem::fill0),
        kfdr(dimension(maxstr), fem::fill0),
        pdr(dimension(maxstr, 5), fem::fill0) {}
};

const int common_hjjet4::maxstr;

struct common_xydr {
  static const int maxstr = 150001;

  arr<float, 2> rtdr;

  common_xydr() : rtdr(dimension(maxstr, 2), fem::fill0) {}
};

const int common_xydr::maxstr;

struct common_hpint {
  int mint4;
  int mint5;
  arr<float, 2> atco;
  arr<float> atxs;

  common_hpint()
      : mint4(fem::int0),
        mint5(fem::int0),
        atco(dimension(200, 20), fem::fill0),
        atxs(dim1(0, 200), fem::fill0) {}
};

struct common_pyint6 {
  arr<fem::str<28> > proc;

  common_pyint6() : proc(dim1(0, 200), fem::fill0) {}
};

struct common_besel {
  float x4;

  common_besel() : x4(fem::float0) {}
};

struct common_hijhb {
  arr<float, 2> rr;
  arr<float, 2> xx;

  common_hijhb()
      : rr(dimension(10, 201), fem::fill0),
        xx(dimension(10, 201), fem::fill0) {}
};

struct common_dpmcm1 {
  int jjp;
  int jjt;
  float amp;
  float amt;
  float apx0;
  float atx0;
  float ampn;
  float amtn;
  float amp0;
  float amt0;
  int nfdp;
  int nfdt;
  float wp;
  float wm;
  float sw;
  float xremp;
  float xremt;
  float dpkc1;
  float dpkc2;
  float pp11;
  float pp12;
  float pt11;
  float pt12;
  float ptp2;
  float ptt2;

  common_dpmcm1()
      : jjp(fem::int0),
        jjt(fem::int0),
        amp(fem::float0),
        amt(fem::float0),
        apx0(fem::float0),
        atx0(fem::float0),
        ampn(fem::float0),
        amtn(fem::float0),
        amp0(fem::float0),
        amt0(fem::float0),
        nfdp(fem::int0),
        nfdt(fem::int0),
        wp(fem::float0),
        wm(fem::float0),
        sw(fem::float0),
        xremp(fem::float0),
        xremt(fem::float0),
        dpkc1(fem::float0),
        dpkc2(fem::float0),
        pp11(fem::float0),
        pp12(fem::float0),
        pt11(fem::float0),
        pt12(fem::float0),
        ptp2(fem::float0),
        ptt2(fem::float0) {}
};

struct common_dpmcm2 {
  int ndpm;
  arr<int, 2> kdpm;
  arr<float, 2> pdpm1;
  arr<float, 2> pdpm2;

  common_dpmcm2()
      : ndpm(fem::int0),
        kdpm(dimension(20, 2), fem::fill0),
        pdpm1(dimension(20, 5), fem::fill0),
        pdpm2(dimension(20, 5), fem::fill0) {}
};

struct common_lor {
  double enenew;
  double pxnew;
  double pynew;
  double pznew;

  common_lor()
      : enenew(fem::double0),
        pxnew(fem::double0),
        pynew(fem::double0),
        pznew(fem::double0) {}
};

struct common_decom {
  arr<double, 2> ptwo;

  common_decom() : ptwo(dimension(2, 5), fem::fill0) {}
};

struct common_hmain1 {
  float eatt;
  int jatt;
  int natt;
  int nt;
  int np;
  int n0;
  int n01;
  int n10;
  int n11;

  common_hmain1()
      : eatt(fem::float0),
        jatt(fem::int0),
        natt(fem::int0),
        nt(fem::int0),
        np(fem::int0),
        n0(fem::int0),
        n01(fem::int0),
        n10(fem::int0),
        n11(fem::int0) {}
};

struct common_hmain2 {
  static const int maxstr = 150001;

  arr<int, 2> katt;
  arr<float, 2> patt;

  common_hmain2()
      : katt(dimension(maxstr, 4), fem::fill0),
        patt(dimension(maxstr, 4), fem::fill0) {}
};

const int common_hmain2::maxstr;

struct common_ilist7 {
  static const int maxptn = 400001;

  arr<int> lstrg0;
  arr<int> lpart0;

  common_ilist7()
      : lstrg0(dimension(maxptn), fem::fill0),
        lpart0(dimension(maxptn), fem::fill0) {}
};

const int common_ilist7::maxptn;

struct common_noprec {
  static const int maxidl = 4001;

  int nnozpc;
  arr<int> itypn;
  arr<float> gxn;
  arr<float> gyn;
  arr<float> gzn;
  arr<float> ftn;
  arr<float> pxn;
  arr<float> pyn;
  arr<float> pzn;
  arr<float> een;
  arr<float> xmn;

  common_noprec()
      : nnozpc(fem::int0),
        itypn(dimension(maxidl), fem::fill0),
        gxn(dimension(maxidl), fem::fill0),
        gyn(dimension(maxidl), fem::fill0),
        gzn(dimension(maxidl), fem::fill0),
        ftn(dimension(maxidl), fem::fill0),
        pxn(dimension(maxidl), fem::fill0),
        pyn(dimension(maxidl), fem::fill0),
        pzn(dimension(maxidl), fem::fill0),
        een(dimension(maxidl), fem::fill0),
        xmn(dimension(maxidl), fem::fill0) {}
};

const int common_noprec::maxidl;

struct common_precpa {
  static const int maxptn = 400001;

  arr<double> vxp0;
  arr<double> vyp0;
  arr<double> vzp0;
  arr<double> xstrg0;
  arr<double> ystrg0;
  arr<double> xstrg;
  arr<double> ystrg;
  arr<int> istrg0;
  arr<int> istrg;

  common_precpa()
      : vxp0(dimension(maxptn), fem::fill0),
        vyp0(dimension(maxptn), fem::fill0),
        vzp0(dimension(maxptn), fem::fill0),
        xstrg0(dimension(maxptn), fem::fill0),
        ystrg0(dimension(maxptn), fem::fill0),
        xstrg(dimension(maxptn), fem::fill0),
        ystrg(dimension(maxptn), fem::fill0),
        istrg0(dimension(maxptn), fem::fill0),
        istrg(dimension(maxptn), fem::fill0) {}
};

const int common_precpa::maxptn;

struct common_loclco {
  arr<double> gxp;
  arr<double> gyp;
  arr<double> gzp;
  arr<double> ftp;
  arr<double> pxp;
  arr<double> pyp;
  arr<double> pzp;
  arr<double> pep;
  arr<double> pmp;

  common_loclco()
      : gxp(dimension(3), fem::fill0),
        gyp(dimension(3), fem::fill0),
        gzp(dimension(3), fem::fill0),
        ftp(dimension(3), fem::fill0),
        pxp(dimension(3), fem::fill0),
        pyp(dimension(3), fem::fill0),
        pzp(dimension(3), fem::fill0),
        pep(dimension(3), fem::fill0),
        pmp(dimension(3), fem::fill0) {}
};

struct common_prtn23 {
  arr<double> gxp0;
  arr<double> gyp0;
  arr<double> gzp0;
  double ft0fom;

  common_prtn23()
      : gxp0(dimension(3), fem::fill0),
        gyp0(dimension(3), fem::fill0),
        gzp0(dimension(3), fem::fill0),
        ft0fom(fem::double0) {}
};

struct common_strg {
  static const int maxstr = 150001;

  arr<int> np;

  common_strg() : np(dimension(maxstr), fem::fill0) {}
};

const int common_strg::maxstr;

struct common_frzprc {
  static const int maxptn = 400001;

  arr<double> gxfrz;
  arr<double> gyfrz;
  arr<double> gzfrz;
  arr<double> ftfrz;
  arr<double> pxfrz;
  arr<double> pyfrz;
  arr<double> pzfrz;
  arr<double> efrz;
  arr<double> xmfrz;
  arr<double> tfrz;
  arr<int> ifrz;
  arr<int> idfrz;
  int itlast;

  common_frzprc()
      : gxfrz(dimension(maxptn), fem::fill0),
        gyfrz(dimension(maxptn), fem::fill0),
        gzfrz(dimension(maxptn), fem::fill0),
        ftfrz(dimension(maxptn), fem::fill0),
        pxfrz(dimension(maxptn), fem::fill0),
        pyfrz(dimension(maxptn), fem::fill0),
        pzfrz(dimension(maxptn), fem::fill0),
        efrz(dimension(maxptn), fem::fill0),
        xmfrz(dimension(maxptn), fem::fill0),
        tfrz(dimension(302), fem::fill0),
        ifrz(dimension(maxptn), fem::fill0),
        idfrz(dimension(maxptn), fem::fill0),
        itlast(fem::int0) {}
};

const int common_frzprc::maxptn;

struct common_para3 {
  int nsevt;
  int nevnt;
  int nsbrun;
  int ievt;
  int isbrun;

  common_para3()
      : nsevt(fem::int0),
        nevnt(fem::int0),
        nsbrun(fem::int0),
        ievt(fem::int0),
        isbrun(fem::int0) {}
};

struct common_rndm1 {
  int number;

  common_rndm1() : number(fem::int0) {}
};

struct common_rndm3 {
  int iseedp;

  common_rndm3() : iseedp(fem::int0) {}
};

struct common_ilist3 {
  double size1;
  double size2;
  double size3;
  double v1;
  double v2;
  double v3;
  double size;

  common_ilist3()
      : size1(fem::double0),
        size2(fem::double0),
        size3(fem::double0),
        v1(fem::double0),
        v2(fem::double0),
        v3(fem::double0),
        size(fem::double0) {}
};

struct common_para2 {
  double xmp;
  double xmu;
  double alpha;
  double rscut2;
  double cutof2;

  common_para2()
      : xmp(fem::double0),
        xmu(fem::double0),
        alpha(fem::double0),
        rscut2(fem::double0),
        cutof2(fem::double0) {}
};

struct common_para5 {
  int iconfg;
  int iordsc;

  common_para5() : iconfg(fem::int0), iordsc(fem::int0) {}
};

struct common_prec5 {
  static const int maxptn = 400001;

  arr<double> eta;
  arr<double> rap;
  arr<double> tau;

  common_prec5()
      : eta(dimension(maxptn), fem::fill0),
        rap(dimension(maxptn), fem::fill0),
        tau(dimension(maxptn), fem::fill0) {}
};

const int common_prec5::maxptn;

struct common_para6 {
  double centy;

  common_para6() : centy(fem::double0) {}
};

struct common_para4 {
  int iftflg;
  int ireflg;
  int igeflg;
  int ibstfg;

  common_para4()
      : iftflg(fem::int0),
        ireflg(fem::int0),
        igeflg(fem::int0),
        ibstfg(fem::int0) {}
};

struct common_par1 {
  double formt;

  common_par1() : formt(fem::double0) {}
};

struct common_prec4 {
  static const int maxptn = 400001;

  arr<double> vx;
  arr<double> vy;
  arr<double> vz;

  common_prec4()
      : vx(dimension(maxptn), fem::fill0),
        vy(dimension(maxptn), fem::fill0),
        vz(dimension(maxptn), fem::fill0) {}
};

const int common_prec4::maxptn;

struct common_ilist4 {
  static const int maxptn = 400001;

  int ifmpt;
  int ichkpt;
  arr<int> indx;

  common_ilist4()
      : ifmpt(fem::int0),
        ichkpt(fem::int0),
        indx(dimension(maxptn), fem::fill0) {}
};

const int common_ilist4::maxptn;

struct common_ilist5 {
  static const int maxptn = 400001;

  arr<double> ct;
  arr<double> ot;
  double tlarge;

  common_ilist5()
      : ct(dimension(maxptn), fem::fill0),
        ot(dimension(maxptn), fem::fill0),
        tlarge(fem::double0) {}
};

const int common_ilist5::maxptn;

struct common_prec3 {
  static const int maxptn = 400001;

  arr<double> gxs;
  arr<double> gys;
  arr<double> gzs;
  arr<double> fts;
  arr<double> pxs;
  arr<double> pys;
  arr<double> pzs;
  arr<double> es;
  arr<double> xmasss;
  arr<int> ityps;

  common_prec3()
      : gxs(dimension(maxptn), fem::fill0),
        gys(dimension(maxptn), fem::fill0),
        gzs(dimension(maxptn), fem::fill0),
        fts(dimension(maxptn), fem::fill0),
        pxs(dimension(maxptn), fem::fill0),
        pys(dimension(maxptn), fem::fill0),
        pzs(dimension(maxptn), fem::fill0),
        es(dimension(maxptn), fem::fill0),
        xmasss(dimension(maxptn), fem::fill0),
        ityps(dimension(maxptn), fem::fill0) {}
};

const int common_prec3::maxptn;

struct common_prec6 {
  static const int maxptn = 400001;

  arr<double> etas;
  arr<double> raps;
  arr<double> taus;

  common_prec6()
      : etas(dimension(maxptn), fem::fill0),
        raps(dimension(maxptn), fem::fill0),
        taus(dimension(maxptn), fem::fill0) {}
};

const int common_prec6::maxptn;

struct common_precpb {
  static const int maxptn = 400001;

  arr<double> vxp;
  arr<double> vyp;
  arr<double> vzp;

  common_precpb()
      : vxp(dimension(maxptn), fem::fill0),
        vyp(dimension(maxptn), fem::fill0),
        vzp(dimension(maxptn), fem::fill0) {}
};

const int common_precpb::maxptn;

struct common_ilist1 {
  static const int maxptn = 400001;

  int iscat;
  int jscat;
  arr<int> next;
  arr<int> last;
  int ictype;
  arr<int> icsta;
  arr<int> nic;
  arr<int> icels;

  common_ilist1()
      : iscat(fem::int0),
        jscat(fem::int0),
        next(dimension(maxptn), fem::fill0),
        last(dimension(maxptn), fem::fill0),
        ictype(fem::int0),
        icsta(dimension(maxptn), fem::fill0),
        nic(dimension(maxptn), fem::fill0),
        icels(dimension(maxptn), fem::fill0) {}
};

const int common_ilist1::maxptn;

struct common_ilist2 {
  int icell;
  arr<int, 3> icel;

  common_ilist2() : icell(fem::int0), icel(dimension(10, 10, 10), fem::fill0) {}
};

struct common_ilist6 {
  double t;
  int iopern;
  int icolln;

  common_ilist6() : t(fem::double0), iopern(fem::int0), icolln(fem::int0) {}
};

struct common_ana2 {
  arr<double> det;
  arr<double> dn;
  arr<double> detdy;
  arr<double> detdn;
  arr<double> dndy;
  arr<double> det1;
  arr<double> dn1;
  arr<double> detdy1;
  arr<double> detdn1;
  arr<double> dndy1;
  arr<double> det2;
  arr<double> dn2;
  arr<double> detdy2;
  arr<double> detdn2;
  arr<double> dndy2;

  common_ana2()
      : det(dimension(12), fem::fill0),
        dn(dimension(12), fem::fill0),
        detdy(dimension(12), fem::fill0),
        detdn(dimension(12), fem::fill0),
        dndy(dimension(12), fem::fill0),
        det1(dimension(12), fem::fill0),
        dn1(dimension(12), fem::fill0),
        detdy1(dimension(12), fem::fill0),
        detdn1(dimension(12), fem::fill0),
        dndy1(dimension(12), fem::fill0),
        det2(dimension(12), fem::fill0),
        dn2(dimension(12), fem::fill0),
        detdy2(dimension(12), fem::fill0),
        detdn2(dimension(12), fem::fill0),
        dndy2(dimension(12), fem::fill0) {}
};

struct common_aurec1 {
  int jxa;
  int jya;
  int jza;

  common_aurec1() : jxa(fem::int0), jya(fem::int0), jza(fem::int0) {}
};

struct common_aurec2 {
  static const int maxptn = 400001;

  arr<double> dgxa;
  arr<double> dgya;
  arr<double> dgza;

  common_aurec2()
      : dgxa(dimension(maxptn), fem::fill0),
        dgya(dimension(maxptn), fem::fill0),
        dgza(dimension(maxptn), fem::fill0) {}
};

const int common_aurec2::maxptn;

struct common_rndm2 {
  int iff;

  common_rndm2() : iff(fem::int0) {}
};

struct common_ana1 {
  arr<double> ts;

  common_ana1() : ts(dimension(12), fem::fill0) {}
};

struct common_ana3 {
  arr<double, 3> em;

  common_ana3() : em(dimension(4, 4, 12), fem::fill0) {}
};

struct common_ana4 {
  arr<double> fdetdy;
  arr<double> fdndy;
  arr<double> fdndpt;

  common_ana4()
      : fdetdy(dimension(24), fem::fill0),
        fdndy(dimension(24), fem::fill0),
        fdndpt(dimension(12), fem::fill0) {}
};

struct common_frzout {
  arr<double> xnprod;
  arr<double> etprod;
  arr<double> xnfrz;
  arr<double> etfrz;
  arr<double> dnprod;
  arr<double> detpro;
  arr<double> dnfrz;
  arr<double> detfrz;

  common_frzout()
      : xnprod(dimension(30), fem::fill0),
        etprod(dimension(30), fem::fill0),
        xnfrz(dimension(30), fem::fill0),
        etfrz(dimension(30), fem::fill0),
        dnprod(dimension(30), fem::fill0),
        detpro(dimension(30), fem::fill0),
        dnfrz(dimension(30), fem::fill0),
        detfrz(dimension(30), fem::fill0) {}
};

struct common_wood {
  float r;
  float d;
  float fnorm;
  float w;

  common_wood()
      : r(fem::float0), d(fem::float0), fnorm(fem::float0), w(fem::float0) {}
};

struct common_njet {
  int n;
  int ipcrs;

  common_njet() : n(fem::int0), ipcrs(fem::int0) {}
};

struct common_cmsflag {
  double dshadow;
  int ishadow;

  common_cmsflag() : dshadow(fem::double0), ishadow(fem::int0) {}
};

struct common_sedvax {
  int num1;

  common_sedvax() : num1(fem::int0) {}
};

struct common_bveg1 {
  arr<double> xl;
  arr<double> xu;
  double acc;
  int ndim;
  int ncall;
  int itmx;
  int nprn;

  common_bveg1()
      : xl(dimension(10), fem::fill0),
        xu(dimension(10), fem::fill0),
        acc(fem::double0),
        ndim(fem::int0),
        ncall(fem::int0),
        itmx(fem::int0),
        nprn(fem::int0) {}
};

struct common_bveg2 {
  arr<double, 2> xi;
  double si;
  double si2;
  double swgt;
  double schi;
  int ndo;
  int it;

  common_bveg2()
      : xi(dimension(50, 10), fem::fill0),
        si(fem::double0),
        si2(fem::double0),
        swgt(fem::double0),
        schi(fem::double0),
        ndo(fem::int0),
        it(fem::int0) {}
};

struct common_bveg3 {
  double f;
  double ti;
  double tsi;

  common_bveg3() : f(fem::double0), ti(fem::double0), tsi(fem::double0) {}
};

struct common_iflow {
  double v2i;
  double eti;
  double xmulti;
  double v2mi;
  double s2mi;
  double xmmult;
  double v2bi;
  double s2bi;
  double xbmult;

  common_iflow()
      : v2i(fem::double0),
        eti(fem::double0),
        xmulti(fem::double0),
        v2mi(fem::double0),
        s2mi(fem::double0),
        xmmult(fem::double0),
        v2bi(fem::double0),
        s2bi(fem::double0),
        xbmult(fem::double0) {}
};

struct common_fflow {
  float v2f;
  float etf;
  float xmultf;
  float v2fpi;
  float xmulpi;

  common_fflow()
      : v2f(fem::float0),
        etf(fem::float0),
        xmultf(fem::float0),
        v2fpi(fem::float0),
        xmulpi(fem::float0) {}
};

struct common_hflow {
  arr<double, 2> v2h;
  arr<double, 2> xnhadr;
  arr<double, 2> eth;
  arr<double, 2> v2h2;
  arr<double, 2> s2h;

  common_hflow()
      : v2h(dimension(30, 3), fem::fill0),
        xnhadr(dimension(30, 3), fem::fill0),
        eth(dimension(30, 3), fem::fill0),
        v2h2(dimension(30, 3), fem::fill0),
        s2h(dimension(30, 3), fem::fill0) {}
};

struct common_ebe {
  arr<double> v2hp;
  arr<double> xnhadp;
  arr<double> v2hsum;
  arr<double> v2h2sm;

  common_ebe()
      : v2hp(dimension(3), fem::fill0),
        xnhadp(dimension(3), fem::fill0),
        v2hsum(dimension(3), fem::fill0),
        v2h2sm(dimension(3), fem::fill0) {}
};

struct common : fem::common,
                common_gg,
                common_zz,
                common_run,
                common_input1,
                common_input2,
                common_input3,
                common_imulst,
                common_coal,
                common_anim,
                common_para7,
                common_embed,
                common_xyembed,
                common_arprnt,
                common_arprc,
                common_dpert,
                common_smearz,
                common_rndf77,
                common_para8,
                common_nzpc,
                common_hparnt,
                common_arerc1,
                common_arprc1,
                common_tdecay,
                common_ludat2,
                common_arana1,
                common_arana2,
                common_ee,
                common_aa,
                common_bb,
                common_cc,
                common_bg,
                common_nn,
                common_pa,
                common_pb,
                common_pc,
                common_pd,
                common_leadng,
                common_dpi,
                common_table,
                common_arevt,
                common_ff,
                common_input,
                common_ppbmas,
                common_ppb1,
                common_ppmm,
                common_dd,
                common_hh,
                common_pe,
                common_rr,
                common_dpifsl,
                common_dpifsm,
                common_dpisig,
                common_ludat1,
                common_ludat4,
                common_lujets,
                common_ludat3,
                common_resdcy,
                common_phidcy,
                common_ss,
                common_kkk,
                common_kaon,
                common_lastt,
                common_hbt,
                common_ftmax,
                common_ddpi,
                common_tt,
                common_bbb,
                common_snn,
                common_oscar1,
                common_oscar2,
                common_hjglbr,
                common_phihj,
                common_pp,
                common_qq,
                common_arercp,
                common_para1,
                common_hjcrdn,
                common_hjjet1,
                common_hjjet2,
                common_prec1,
                common_arout,
                common_ilist8,
                common_srec1,
                common_srec2,
                common_soft,
                common_hijdat,
                common_pypars,
                common_pyint1,
                common_pysubs,
                common_pyint2,
                common_pyint4,
                common_pyint3,
                common_pyint5,
                common_hjjet4,
                common_xydr,
                common_hpint,
                common_pyint6,
                common_besel,
                common_hijhb,
                common_dpmcm1,
                common_dpmcm2,
                common_lor,
                common_decom,
                common_hmain1,
                common_hmain2,
                common_ilist7,
                common_noprec,
                common_precpa,
                common_loclco,
                common_prtn23,
                common_strg,
                common_frzprc,
                common_para3,
                common_rndm1,
                common_rndm3,
                common_ilist3,
                common_para2,
                common_para5,
                common_prec5,
                common_para6,
                common_para4,
                common_par1,
                common_prec4,
                common_ilist4,
                common_ilist5,
                common_prec3,
                common_prec6,
                common_precpb,
                common_ilist1,
                common_ilist2,
                common_ilist6,
                common_ana2,
                common_aurec1,
                common_aurec2,
                common_rndm2,
                common_ana1,
                common_ana3,
                common_ana4,
                common_frzout,
                common_wood,
                common_njet,
                common_cmsflag,
                common_sedvax,
                common_bveg1,
                common_bveg2,
                common_bveg3,
                common_iflow,
                common_fflow,
                common_hflow,
                common_ebe {
  fem::variant_core common_ludatr;
  fem::variant_core common_prec2;
  fem::variant_core common_hstrng;
  fem::variant_core common_cprod;
  fem::cmn_sve artset_sve;
  fem::cmn_sve addhad_sve;
  fem::cmn_sve arini1_sve;
  fem::cmn_sve arindx_sve;
  fem::cmn_sve artord_sve;
  fem::cmn_sve arini_sve;
  fem::cmn_sve arini2_sve;
  fem::cmn_sve blockdata_ardata_sve;
  fem::cmn_sve artan1_sve;
  fem::cmn_sve artan2_sve;
  fem::cmn_sve artout_sve;
  fem::cmn_sve iarflv_sve;
  fem::cmn_sve coulin_sve;
  fem::cmn_sve x2kaon_sve;
  fem::cmn_sve pinsg0_sve;
  fem::cmn_sve aknel_sve;
  fem::cmn_sve akpel_sve;
  fem::cmn_sve aknsgm_sve;
  fem::cmn_sve akpsgm_sve;
  fem::cmn_sve akplam_sve;
  fem::cmn_sve fstate_sve;
  fem::cmn_sve rotate_sve;
  fem::cmn_sve nnkaon_sve;
  fem::cmn_sve lorntz_sve;
  fem::cmn_sve npik_sve;
  fem::cmn_sve pihypn_sve;
  fem::cmn_sve kaonn_sve;
  fem::cmn_sve distce_sve;
  fem::cmn_sve newka_sve;
  fem::cmn_sve cms_sve;
  fem::cmn_sve width_sve;
  fem::cmn_sve fde_sve;
  fem::cmn_sve w1535_sve;
  fem::cmn_sve fd5_sve;
  fem::cmn_sve fns_sve;
  fem::cmn_sve sigma_sve;
  fem::cmn_sve ang_sve;
  fem::cmn_sve n1535_sve;
  fem::cmn_sve ptdis_sve;
  fem::cmn_sve ptr_sve;
  fem::cmn_sve fmassd_sve;
  fem::cmn_sve w1440_sve;
  fem::cmn_sve fmassn_sve;
  fem::cmn_sve fmassr_sve;
  fem::cmn_sve rmasdd_sve;
  fem::cmn_sve ddp2_sve;
  fem::cmn_sve frho_sve;
  fem::cmn_sve rhomas_sve;
  fem::cmn_sve ddrho_sve;
  fem::cmn_sve pprho_sve;
  fem::cmn_sve ppomga_sve;
  fem::cmn_sve x2pi_sve;
  fem::cmn_sve x3pi_sve;
  fem::cmn_sve x33pi_sve;
  fem::cmn_sve pp1_sve;
  fem::cmn_sve s1535_sve;
  fem::cmn_sve pplpk_sve;
  fem::cmn_sve ppk0_sve;
  fem::cmn_sve ppk1_sve;
  fem::cmn_sve x4pi_sve;
  fem::cmn_sve fkaon_sve;
  fem::cmn_sve fdelta_sve;
  fem::cmn_sve rmass_sve;
  fem::cmn_sve bbkaon_sve;
  fem::cmn_sve xrho_sve;
  fem::cmn_sve omega_sve;
  fem::cmn_sve sbbdm_sve;
  fem::cmn_sve bbdangle_sve;
  fem::cmn_sve crnn_sve;
  fem::cmn_sve rhores_sve;
  fem::cmn_sve bbarfs_sve;
  fem::cmn_sve crpp_sve;
  fem::cmn_sve denom_sve;
  fem::cmn_sve m1535_sve;
  fem::cmn_sve crnd_sve;
  fem::cmn_sve reab2d_sve;
  fem::cmn_sve crdd_sve;
  fem::cmn_sve dkine_sve;
  fem::cmn_sve decay_sve;
  fem::cmn_sve dkine2_sve;
  fem::cmn_sve decay2_sve;
  fem::cmn_sve dreson_sve;
  fem::cmn_sve xnpi_sve;
  fem::cmn_sve pnlka_sve;
  fem::cmn_sve pnska_sve;
  fem::cmn_sve wida1_sve;
  fem::cmn_sve xn1535_sve;
  fem::cmn_sve pp2_sve;
  fem::cmn_sve ppt_sve;
  fem::cmn_sve ppxs_sve;
  fem::cmn_sve twopi_sve;
  fem::cmn_sve threpi_sve;
  fem::cmn_sve fourpi_sve;
  fem::cmn_sve crpn_sve;
  fem::cmn_sve cren_sve;
  fem::cmn_sve crdir_sve;
  fem::cmn_sve crpd_sve;
  fem::cmn_sve crrd_sve;
  fem::cmn_sve crlaba_sve;
  fem::cmn_sve crkn_sve;
  fem::cmn_sve pbarfs_sve;
  fem::cmn_sve crppba_sve;
  fem::cmn_sve crkhyp_sve;
  fem::cmn_sve crlan_sve;
  fem::cmn_sve crkpla_sve;
  fem::cmn_sve crkkpi_sve;
  fem::cmn_sve pipik_sve;
  fem::cmn_sve xkkann_sve;
  fem::cmn_sve xkksan_sve;
  fem::cmn_sve crkspi_sve;
  fem::cmn_sve crkphi_sve;
  fem::cmn_sve crksph_sve;
  fem::cmn_sve pionpp_sve;
  fem::cmn_sve pipp1_sve;
  fem::cmn_sve reab_sve;
  fem::cmn_sve xpp_sve;
  fem::cmn_sve xnp_sve;
  fem::cmn_sve xnd_sve;
  fem::cmn_sve xddin_sve;
  fem::cmn_sve dirct1_sve;
  fem::cmn_sve dirct2_sve;
  fem::cmn_sve fdr_sve;
  fem::cmn_sve erhon_sve;
  fem::cmn_sve fd1_sve;
  fem::cmn_sve dirct3_sve;
  fem::cmn_sve fd2_sve;
  fem::cmn_sve dpion_sve;
  fem::cmn_sve xppbar_sve;
  fem::cmn_sve xphib_sve;
  fem::cmn_sve crphib_sve;
  fem::cmn_sve pibphi_sve;
  fem::cmn_sve phimes_sve;
  fem::cmn_sve crphim_sve;
  fem::cmn_sve xkhype_sve;
  fem::cmn_sve getnst_sve;
  fem::cmn_sve ppbbar_sve;
  fem::cmn_sve prbbar_sve;
  fem::cmn_sve rrbbar_sve;
  fem::cmn_sve pobbar_sve;
  fem::cmn_sve robbar_sve;
  fem::cmn_sve oobbar_sve;
  fem::cmn_sve ptor_sve;
  fem::cmn_sve ptoe_sve;
  fem::cmn_sve pptope_sve;
  fem::cmn_sve rptore_sve;
  fem::cmn_sve xop2oe_sve;
  fem::cmn_sve eetorr_sve;
  fem::cmn_sve ksreso_sve;
  fem::cmn_sve aknpsg_sve;
  fem::cmn_sve pertur_sve;
  fem::cmn_sve crhb_sve;
  fem::cmn_sve lambar_sve;
  fem::cmn_sve distc0_sve;
  fem::cmn_sve sdmbb_sve;
  fem::cmn_sve dmangle_sve;
  fem::cmn_sve dmelangle_sve;
  fem::cmn_sve crdmbb_sve;
  fem::cmn_sve sdbelastic_sve;
  fem::cmn_sve dbelangle_sve;
  fem::cmn_sve crdbel_sve;
  fem::cmn_sve rlu_sve;
  fem::cmn_sve lulist_sve;
  fem::cmn_sve ludecy_sve;
  fem::cmn_sve resdec_sve;
  fem::cmn_sve relcol_sve;
  fem::cmn_sve init_sve;
  fem::cmn_sve dens_sve;
  fem::cmn_sve gradu_sve;
  fem::cmn_sve graduk_sve;
  fem::cmn_sve gradup_sve;
  fem::cmn_sve gradun_sve;
  fem::cmn_sve tablem_sve;
  fem::cmn_sve flow_sve;
  fem::cmn_sve hoscar_sve;
  fem::cmn_sve hbtout_sve;
  fem::cmn_sve artmn_sve;
  fem::cmn_sve blockdata_ppbdat_sve;
  fem::cmn_sve hjana1_sve;
  fem::cmn_sve hjan2a_sve;
  fem::cmn_sve hjan2b_sve;
  fem::cmn_sve hjana2_sve;
  fem::cmn_sve hboost_sve;
  fem::cmn_sve quench_sve;
  fem::cmn_sve ar3jet_sve;
  fem::cmn_sve arorie_sve;
  fem::cmn_sve atrobo_sve;
  fem::cmn_sve attrad_sve;
  fem::cmn_sve luboei_sve;
  fem::cmn_sve hijfrg_sve;
  fem::cmn_sve pyovly_sve;
  fem::cmn_sve pygamm_sve;
  fem::cmn_sve pystfe_sve;
  fem::cmn_sve pystfu_sve;
  fem::cmn_sve pyspen_sve;
  fem::cmn_sve pymult_sve;
  fem::cmn_sve pyremn_sve;
  fem::cmn_sve hijhrd_sve;
  fem::cmn_sve pyinki_sve;
  fem::cmn_sve pyxtot_sve;
  fem::cmn_sve pymaxi_sve;
  fem::cmn_sve pyinit_sve;
  fem::cmn_sve jetini_sve;
  fem::cmn_sve attflv_sve;
  fem::cmn_sve hijini_sve;
  fem::cmn_sve hijels_sve;
  fem::cmn_sve gauss2_sve;
  fem::cmn_sve romg_sve;
  fem::cmn_sve hijcsc_sve;
  fem::cmn_sve hirnd2_sve;
  fem::cmn_sve hijsft_sve;
  fem::cmn_sve hirnd_sve;
  fem::cmn_sve lorenz_sve;
  fem::cmn_sve decomp_sve;
  fem::cmn_sve htop_sve;
  fem::cmn_sve resmass_sve;
  fem::cmn_sve exchge_sve;
  fem::cmn_sve locldr_sve;
  fem::cmn_sve coales_sve;
  fem::cmn_sve index1_sve;
  fem::cmn_sve ptoh_sve;
  fem::cmn_sve minijet_out_sve;
  fem::cmn_sve embedhighpt_sve;
  fem::cmn_sve zpstrg_sve;
  fem::cmn_sve readi_sve;
  fem::cmn_sve ran1_sve;
  fem::cmn_sve posit1_sve;
  fem::cmn_sve posit2_sve;
  fem::cmn_sve posit3_sve;
  fem::cmn_sve energy_sve;
  fem::cmn_sve momntm_sve;
  fem::cmn_sve genei_sve;
  fem::cmn_sve boosti_sve;
  fem::cmn_sve ftime1_sve;
  fem::cmn_sve ftime_sve;
  fem::cmn_sve inifrz_sve;
  fem::cmn_sve inirec_sve;
  fem::cmn_sve iilist_sve;
  fem::cmn_sve inian2_sve;
  fem::cmn_sve local_sve;
  fem::cmn_sve savrec_sve;
  fem::cmn_sve getict_sve;
  fem::cmn_sve newcre_sve;
  fem::cmn_sve celasn_sve;
  fem::cmn_sve oldcre_sve;
  fem::cmn_sve wallc1_sve;
  fem::cmn_sve wallc2_sve;
  fem::cmn_sve wallcb_sve;
  fem::cmn_sve fixtim_sve;
  fem::cmn_sve isco1_sve;
  fem::cmn_sve isco2_sve;
  fem::cmn_sve isco3_sve;
  fem::cmn_sve isco4_sve;
  fem::cmn_sve isco5_sve;
  fem::cmn_sve isco6_sve;
  fem::cmn_sve isco7_sve;
  fem::cmn_sve isco8_sve;
  fem::cmn_sve isco9_sve;
  fem::cmn_sve isco10_sve;
  fem::cmn_sve isco11_sve;
  fem::cmn_sve isco12_sve;
  fem::cmn_sve isco_sve;
  fem::cmn_sve mintm_sve;
  fem::cmn_sve chcell_sve;
  fem::cmn_sve chout_sve;
  fem::cmn_sve chin1_sve;
  fem::cmn_sve chin2_sve;
  fem::cmn_sve chin3_sve;
  fem::cmn_sve reor_sve;
  fem::cmn_sve dchcel_sve;
  fem::cmn_sve dchout_sve;
  fem::cmn_sve dchin1_sve;
  fem::cmn_sve dchin2_sve;
  fem::cmn_sve dchin3_sve;
  fem::cmn_sve cellre_sve;
  fem::cmn_sve newpos_sve;
  fem::cmn_sve getht_sve;
  fem::cmn_sve cropro_sve;
  fem::cmn_sve xnormv_sve;
  fem::cmn_sve zprota_sve;
  fem::cmn_sve newmom_sve;
  fem::cmn_sve ud2_sve;
  fem::cmn_sve chkcel_sve;
  fem::cmn_sve chkout_sve;
  fem::cmn_sve chkin1_sve;
  fem::cmn_sve chkin2_sve;
  fem::cmn_sve chkin3_sve;
  fem::cmn_sve ulist1_sve;
  fem::cmn_sve ulist_sve;
  fem::cmn_sve zpcrun_sve;
  fem::cmn_sve zpca1c_sve;
  fem::cmn_sve zpca1a_sve;
  fem::cmn_sve zpca2a_sve;
  fem::cmn_sve zpca2b_sve;
  fem::cmn_sve zpca2c_sve;
  fem::cmn_sve zpcou1_sve;
  fem::cmn_sve zpcou2_sve;
  fem::cmn_sve zpcmn_sve;
  fem::cmn_sve hijing_sve;
  fem::cmn_sve ftot_sve;
  fem::cmn_sve fhin_sve;
  fem::cmn_sve ftotjt_sve;
  fem::cmn_sve ftotrg_sve;
  fem::cmn_sve sgmin_sve;
  fem::cmn_sve fnjet_sve;
  fem::cmn_sve gauss1_sve;
  fem::cmn_sve hifun_sve;
  fem::cmn_sve hijwds_sve;
  fem::cmn_sve gmre_sve;
  fem::cmn_sve parton_sve;
  fem::cmn_sve g_sve;
  fem::cmn_sve fjet_sve;
  fem::cmn_sve ghvq_sve;
  fem::cmn_sve gphotn_sve;
  fem::cmn_sve fjetrg_sve;
  fem::cmn_sve aran9_sve;
  fem::cmn_sve vegas_sve;
  fem::cmn_sve crsjet_sve;
  fem::cmn_sve hijcrs_sve;
  fem::cmn_sve lugive_sve;
  fem::cmn_sve hijset_sve;
  fem::cmn_sve blockdata_hidata_sve;
  fem::cmn_sve blockdata_ludata_sve;
  fem::cmn_sve blockdata_pydata_sve;
  fem::cmn_sve getnp_sve;
  fem::cmn_sve blockdata_zpcbdt_sve;
  fem::cmn_sve readpa_sve;
  fem::cmn_sve inian1_sve;
  fem::cmn_sve program_ampt_sve;
  fem::cmn_sve hjan1b_sve;
  fem::cmn_sve hjan1a_sve;
  fem::cmn_sve hjana3_sve;
  fem::cmn_sve hjana4_sve;
  fem::cmn_sve flowh_sve;
  fem::cmn_sve flowh0_sve;
  fem::cmn_sve iniflw_sve;
  fem::cmn_sve frztm_sve;

  common(int argc, char const* argv[]) : fem::common(argc, argv) {}
};

struct artset_save {
  int iplab;
  int ixy;

  artset_save() : iplab(fem::int0), ixy(fem::int0) {}
};

/// C     FYI: taken file unit numbers are 10-88, 91-93;
/// C     so free file unit numbers are 1-4,7-9,89,97-99.
/// C....................amptsub.f
/// C.....this file contains 4 sections:
/// C.....1. ART subroutines;
/// C.....2. ART functions;
/// C.....3. ART block data;
/// C.....4. subprocesses borrowed from other codes.
/// C.....5. the previous artana.f
/// C.....6. the previous zpcsub.f
/// C.....7. subroutine getnp
/// C.....Note that Parts1-4 are the previous artsub.f
/// C
/// C=======================================================================
/// C.....subroutine to set up ART parameters and analysis files
/// C.....before looping different events
void artset(common& cmn) {
  FEM_CMN_SVE(artset);
  common_read read(cmn);
  common_write write(cmn);
  /// COMMON input2
  int& icoll = cmn.icoll;
  int& ipot = cmn.ipot;
  int& imomen = cmn.imomen;
  /// COMMON input3
  float& plab = cmn.plab;
  float& elab = cmn.elab;
  /// COMMON anim
  int& isoft = cmn.isoft;
  /// COMMON para7
  int& ioscar = cmn.ioscar;
  /// COMMON embed
  int& iembed = cmn.iembed;
  /// COMMON xyembed
  int& nxyjet = cmn.nxyjet;
  const int nxymax = 10001;
  arr_ref<float, 2> xyjet(cmn.xyjet, dimension(nxymax, 2));
  ///
  /// SAVE
  int& iplab = sve.iplab;
  int& ixy = sve.ixy;
  ///
  /// C
  /// Clin-10/03/03
  /// C     "SAVE   " (without argument) is used for most subroutines and
  /// functions, C     this is important for the success when using "f77" to
  /// compile: Cc      SAVE /gg/ Cc      SAVE /zz/ Cc      SAVE /RUN/ Cc SAVE
  /// /input1/ Cc      SAVE /INPUT2/ Cc      SAVE /INPUT3/ Cc      SAVE /imulst/
  /// Clin-10/03/03  ecritl: local energy density below which a parton
  /// C     will freeze out (in GeV/fm^3), for improvements on string melting,
  /// C     not used in this version of AMPT:
  /// Clin-4/2008
  /// C      data ecritl/1.d0/
  cmn.ecritl = 1.e0;
  /// C
  /// C     combine ART initialization into ampt.ini:
  /// C     (Note that the following values are relics from the old ART
  /// structure) C.....input parameter file C      OPEN(13, FILE = 'art1.ini',
  /// STATUS = 'UNKNOWN') C      READ (13, *) MASSTA, ZTA
  cmn.massta = 1;
  cmn.zta = 1;
  /// C      write(12,*) massta, zta, ' massta, zta'
  /// C      READ (13, *) MASSPR, ZPR
  cmn.masspr = 1;
  cmn.zpr = 1;
  /// C      write(12,*) masspr, zpr, ' masspr, zpr'
  /// C      READ (13, *) PLAB, IPLAB
  plab = 14.6f;
  iplab = 2;
  /// C      write(12,*) plab, iplab, ' plab, iplab'
  const float amu = 0.9383f;
  if (iplab == 2) {
    elab = fem::sqrt(fem::pow2(plab) + fem::pow2(amu)) - amu;
  } else {
    elab = plab;
  }
  elab = elab * 1000.f;
  /// C      READ (13, *) ZEROPT
  cmn.zeropt = 0.f;
  /// C      write(12,*) zeropt, ' zeropt'
  /// Clin-10/03/03 ISEED was used as a seed for random number inside ART,
  /// C     not used in AMPT:
  cmn.iseed = 700721;
  /// C     0/1: (Normal or Perturbative) multistrange partice production.
  /// C     Perturbative option is disabled for now:
  cmn.iperts = 0;
  /// C      READ (13, *) MANYB, B0, BI, BM
  /// C     2/04/00 MANYB MUST BE SET TO 1 !
  /// C     in order to skip impact parameter setting by ART, then B0 has no
  /// effect.
  cmn.manyb = 1;
  cmn.b0 = 1;
  cmn.bi = 0;
  cmn.bm = 0;
  /// C      write(12,*) manyb, b0, bi, bm, ' manyb, b0, bi, bm'
  /// C      READ (13, *) ISEED
  /// C      write(12,*) iseed, ' iseed'
  /// C      READ (13, *) DT
  /// C      write(12,*) dt, ' dt'
  /// C      READ (13, *) NTMAX
  /// C      write(12,*) ntmax, ' ntmax'
  /// C      READ (13, *) ICOLL
  icoll = -1;
  /// C      write(12,*) icoll, ' icoll'
  /// C      READ (13, *) NUM
  /// C     2/11/03 run events without test particles for now:
  cmn.num = 1;
  /// C      write(12,*) num, ' num'
  /// C      READ (13, *) INSYS
  cmn.insys = 1;
  /// C      write(12,*) insys, ' insys'
  /// C      READ (13, *) IPOT
  ipot = 3;
  /// C      write(12,*) ipot, ' ipot'
  /// C      READ (13, *) MODE
  cmn.mode = 0;
  if (icoll == -1) {
    ipot = 0;
  }
  /// C      write(12,*) mode, ' mode'
  /// C      READ (13, *) DX, DY, DZ
  cmn.dx = 2.73f;
  cmn.dy = 2.73f;
  cmn.dz = 2.73f;
  /// C      write(12,*) dx,dy,dz,' dx,dy,dz'
  /// C      READ (13, *) DPX, DPY, DPZ
  cmn.dpx = 0.6f;
  cmn.dpy = 0.6f;
  cmn.dpz = 0.6f;
  /// C      write(12,*) dpx,dpy,dpz,' dpx,dpy,dpz'
  /// C      READ (13, *) IAVOID
  cmn.iavoid = 1;
  /// C      write(12,*) iavoid, ' iavoid'
  /// C      READ (13, *) IMOMEN
  imomen = 1;
  /// C      write(12,*) imomen, ' imomen'
  if (icoll == -1) {
    imomen = 3;
  }
  /// C      READ (13, *) NFREQ
  cmn.nfreq = 10;
  /// C      write(12,*) nfreq, ' nfreq'
  /// C      READ (13, *) ICFLOW
  cmn.icflow = 0;
  /// C      write(12,*) ICFLOW, ' ICFLOW'
  /// C      READ (13, *) ICRHO
  cmn.icrho = 0;
  /// C      write(12,*) ICRHO, ' ICRHO'
  /// C      READ (13, *) ICOU
  cmn.icou = 0;
  /// C      write(12,*)icou, ' icou'
  /// C kaon potential control parameter
  /// C KMUL IS A MULTIPLIER TO THE STANDARD K-N SCATTERING LENGTH
  /// C      READ (13, *) KPOTEN, KMUL
  cmn.kpoten = 0;
  cmn.kmul = 1;
  /// C      write(12,*)kpoten,kmul, ' kpoten, kmul'
  /// C mean field control parameter FOR BARYONS
  /// C no mean filed is used for baryons if their
  /// C local density is higher than dencut.
  /// C      READ (13, *) DENCUT
  cmn.dencut = 15;
  /// C      write(12,*)dencut, ' dencut'
  /// C test reactions in a box of side-length cycbox
  /// C input cycbox
  /// C      READ (13, *) CYCBOX
  cmn.cycbox = 0;
  /// C      write(12,*) cycbox, ' cycbox'
  /// C
  /// Clin-5b/2008
  /// C      if(ioscar.eq.2) then
  if (ioscar == 2 || ioscar == 3) {
    cmn.io.open(92, "ana/parton-initial-afterPropagation.dat")
        .status("UNKNOWN");
  }
  if (ioscar == 3) {
    /// Clin-6/2009 write out full parton collision history:
    cmn.io.open(95, "ana/parton-collisionsHistory.dat").status("UNKNOWN");
    /// Clin-6/2009 write out initial minijet information:
    cmn.io.open(96, "ana/minijet-initial-beforePropagation.dat")
        .status("UNKNOWN");
    /// Clin-6/2009 write out parton info after coalescence:
    if (isoft == 4 || isoft == 5) {
      cmn.io.open(85, "ana/parton-after-coalescence.dat").status("UNKNOWN");
    }
  }
  /// Clin-6/2009 write out initial transverse positions of initial nucleons:
  cmn.io.open(94, "ana/npart-xy.dat").status("UNKNOWN");
  /// C
  /// Clin-8/2009 In case that random positions are used to embed high-Pt jets:
  if (iembed == 3 || iembed == 4) {
    cmn.io.open(97, "embed-jet-xy.txt").status("UNKNOWN");
    read(97, star), nxyjet;
    /// C     Save positions in array to reuse when embedding more jet pairs
    /// C     than the number of entries in the position file:
    if (cmn.nevent > nxyjet) {
      if (nxyjet > nxymax) {
        write(6, star),
            "Too many lines in embed-jet-xy.txt: increase value of the "
            "parameter"
            " nxymax";
        FEM_STOP(0);
      } else if (nxyjet <= 0) {
        write(6, star), "Check number of entries in embed-jet-xy.txt";
        FEM_STOP(0);
      }
      FEM_DO_SAFE(ixy, 1, nxyjet) {
        read(97, star), xyjet(ixy, 1), xyjet(ixy, 2);
      }
    }
  }
  /// C
}

/// C
/// Clin-10/01/03 random number generator for f77:
float ranart(int const& /* nseed */) {
  float return_value = fem::float0;
  /// Clin-4/2008 ran(nseed) is renamed to avoid conflict with system functions:
  /// C      ran=rand()
  return_value = rand(0);
  /// C     one may also use the following random number generator in
  /// PYTHIA/JETSET: C      ranart=rlu(0)
  return return_value;
}

/// C
/// Clin-8/2014 define function asinh():
float asinh(float const& x) {
  float return_value = fem::float0;
  if (x > 0) {
    return_value = fem::alog(x + fem::sqrt(fem::pow2(x) + 1.f));
  } else {
    /// C     a la suggestion de YP Liu:
    return_value = -fem::alog(-x + fem::sqrt(fem::pow2(x) + 1.f));
  }
  return return_value;
}

struct addhad_save {
  int i;
  int nadd;
  int np0;
  float rap;
  float tau0;
  float taui;
  float vx;
  float vy;
  float zsmear;

  addhad_save()
      : i(fem::int0),
        nadd(fem::int0),
        np0(fem::int0),
        rap(fem::float0),
        tau0(fem::float0),
        taui(fem::float0),
        vx(fem::float0),
        vy(fem::float0),
        zsmear(fem::float0) {}
};

/// C
/// Clin-3/2009
/// C     Initialize hadron weights;
/// C     Can add initial hadrons before the hadron cascade starts (but after
/// ZPC).
void addhad(common& cmn) {
  FEM_CMN_SVE(addhad);
  common_write write(cmn);
  /// COMMON arprnt
  arr_cref<float> arpar1(cmn.arpar1, dimension(100));
  arr_ref<int> iaint2(cmn.iaint2, dimension(50));
  /// COMMON arprc
  const int maxstr = 150001;
  arr_ref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_ref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_ref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_ref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_ref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_ref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_ref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_ref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_ref<float> pear(cmn.pear, dimension(maxstr));
  arr_ref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON dpert
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON para8
  int& idpert = cmn.idpert;
  ///
  /// SAVE
  int& i = sve.i;
  int& nadd = sve.nadd;
  int& np0 = sve.np0;
  float& rap = sve.rap;
  float& tau0 = sve.tau0;
  float& taui = sve.taui;
  float& vx = sve.vx;
  float& vy = sve.vy;
  float& zsmear = sve.zsmear;
  ///
  /// C
  /// C     All hadrons at the start of hadron cascade have the weight of 1
  /// C     except those inserted by the user in this subroutine:
  np0 = iaint2(1);
  FEM_DO_SAFE(i, 1, np0) { dpertp(i) = 1.f; }
  /// C     Specify number, species, weight, initial x,p,m for inserted hadrons
  /// here:
  nadd = 0;
  tau0 = arpar1(1);
  const float xmd = 1.8756f;
  FEM_DO_SAFE(i, np0 + 1, np0 + nadd) {
    itypar(i) = 42;
    /// Clin-5/2012 fix type mismatch:
    /// C         dpertp(I)=1d0/dble(nadd)
    dpertp(i) = 1.f / fem::ffloat(nadd);
    gxar(i) = 5.f * (1.f - 2.f * ranart(nseed));
    gyar(i) = 5.f * (1.f - 2.f * ranart(nseed));
    gzar(i) = 2.f * (1.f - 2.f * ranart(nseed));
    ftar(i) = 0.f;
    pxar(i) = 1.f;
    pyar(i) = 0.f;
    pzar(i) = 1.f;
    xmar(i) = xmd;
    /// C
    pear(i) = fem::sqrt(fem::pow2(pxar(i)) + fem::pow2(pyar(i)) +
                        fem::pow2(pzar(i)) + fem::pow2(xmar(i)));
    /// Clin-9/2012 determine rapidity more generally:
    /// C         RAP=0.5*alog((PEAR(I)+PZAR(I)+1e-5)/(PEAR(I)-PZAR(I)+1e-5))
    rap = asinh(pzar(i) / fem::sqrt(fem::pow2(xmar(i)) + fem::pow2(pxar(i)) +
                                    fem::pow2(pyar(i))));
    /// C
    vx = pxar(i) / pear(i);
    vy = pyar(i) / pear(i);
    /// C.....give initial formation time shift and boost according to rapidity:
    taui = ftar(i) + tau0;
    ftar(i) = taui * fem::cosh(rap);
    gxar(i) += vx * tau0 * fem::cosh(rap);
    gyar(i) += vy * tau0 * fem::cosh(rap);
    /// C     Allow the intial z-position to be different from the Bjorken
    /// picture:
    gzar(i) += taui * fem::sinh(rap);
    /// C         GZAR(I)=TAUI*SINH(RAP)
    zsmear = fem::sngl(cmn.smearh) * (2.f * ranart(nseed) - 1.f);
    gzar(i) += zsmear;
  }
  iaint2(1) += nadd;
  /// C
  if (nadd >= 1 && idpert != 1 && idpert != 2) {
    write(16, star),
        "IDPERT must be 1 or 2 to add initial hadrons, set NPERTD to 0 if you "
        "do"
        " not need perturbative deuterons";
    FEM_STOP(0);
  }
  if (iaint2(1) > maxstr) {
    write(16, star), "Too many initial hadrons, array size is exceeded!";
    FEM_STOP(0);
  }
  /// C
}

struct arini1_save {
  int i;
  int np;
  float rap;
  float tau0;
  float taui;
  float vx;
  float vy;
  float zsmear;

  arini1_save()
      : i(fem::int0),
        np(fem::int0),
        rap(fem::float0),
        tau0(fem::float0),
        taui(fem::float0),
        vx(fem::float0),
        vy(fem::float0),
        zsmear(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....subroutine to generate formation time and position at formation time
/// C.....from read-in initial conditions with an averaged formation proper
/// C.....time.
/// C
void arini1(common& cmn) {
  FEM_CMN_SVE(arini1);
  common_write write(cmn);
  /// COMMON arprnt
  arr_cref<float> arpar1(cmn.arpar1, dimension(100));
  arr_cref<int> iaint2(cmn.iaint2, dimension(50));
  /// COMMON arprc
  const int maxstr = 150001;
  arr_cref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_ref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_ref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_ref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_ref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_cref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_cref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_cref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_cref<float> pear(cmn.pear, dimension(maxstr));
  arr_cref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON anim
  int& isoft = cmn.isoft;
  /// COMMON nzpc
  int& nattzp = cmn.nattzp;
  /// COMMON hparnt
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  /// COMMON para8
  int& idpert = cmn.idpert;
  ///
  /// SAVE
  int& i = sve.i;
  int& np = sve.np;
  float& rap = sve.rap;
  float& tau0 = sve.tau0;
  float& taui = sve.taui;
  float& vx = sve.vx;
  float& vy = sve.vy;
  float& zsmear = sve.zsmear;
  ///
  /// C
  /// C.....before invoking ARINI1:
  /// C.....ARPAR1(1), IAINT2(1) must be set:
  /// C
  /// Cc      SAVE /ARPRNT/
  /// Cc      SAVE /ARPRC/
  /// Cc      SAVE /smearz/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /anim/
  /// Cc      SAVE /nzpc/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /RNDF77/
  /// C
  /// Clin-5/2008 for perturbatively-produced hadrons (currently only
  /// deuterons):
  cmn.io.open(91, "ana/deuteron_processes.dat").status("UNKNOWN");
  if (idpert == 1 || idpert == 2) {
    cmn.io.open(90, "ana/ampt_pert.dat").status("UNKNOWN");
  }
  /// C.....generate formation time and position at formation time.
  tau0 = arpar1(1);
  np = iaint2(1);
  /// Clin-7/10/01     initial positions already given for hadrons
  /// C     formed from partons inside ZPC (from string melting):
  if (isoft == 3 || isoft == 4 || isoft == 5) {
    /// Clin-8/2015 fixed a bug that may skip "dpertp(I)=1." in addhad and
    /// C     cause the first few events to be missing in ampt.dat
    /// C     (mostly for low-multiplicity events such as PP collisions):
    /// C         if(NP.le.nattzp) return
    if (np > nattzp) {
      /// C
      FEM_DO_SAFE(i, nattzp + 1, np) {
        /// Clin-9/2012 determine rapidity more generally
        /// C     to prevent overflow when Pt~=0 and E=|Pz|:
        /// C            IF (ABS(PZAR(I)) .GE. PEAR(I)) THEN
        /// C               PRINT *, ' IN ARINI1'
        /// C               PRINT *, 'ABS(PZ) .GE. EE for particle ', I
        /// C               PRINT *, ' FLAV = ', ITYPAR(I), ' PX = ', PXAR(I),
        /// C     &              ' PY = ', PYAR(I)
        /// C               PRINT *, ' PZ = ', PZAR(I), ' EE = ', PEAR(I)
        /// C               PRINT *, ' XM = ', XMAR(I)
        /// C               RAP = 1000000.0
        /// C               GOTO 50
        /// C            END IF
        /// Cc            RAP=0.5*LOG((PEAR(I)+PZAR(I))/(PEAR(I)-PZAR(I)))
        /// C RAP=0.5*LOG((PEAR(I)+PZAR(I)+1e-5)/(PEAR(I)-PZAR(I)+1e-5)) C 50
        /// CONTINUE
        if ((fem::pow2(xmar(i)) + fem::pow2(pxar(i)) + fem::pow2(pyar(i))) >
            0.f) {
          rap = asinh(pzar(i) /
                      fem::sqrt(fem::pow2(xmar(i)) + fem::pow2(pxar(i)) +
                                fem::pow2(pyar(i))));
        } else {
          write(6, star), " IN ARINI1 mt=0";
          rap = 1000000.0f * fem::sign(1.f, pzar(i));
        }
        /// C
        vx = pxar(i) / pear(i);
        vy = pyar(i) / pear(i);
        ftar(i) = tau0 * fem::cosh(rap);
        gxar(i) += vx * ftar(i);
        gyar(i) += vy * ftar(i);
        gzar(i) = tau0 * fem::sinh(rap);
        /// Clin-5/2009 No formation time for spectator projectile or target
        /// nucleons:
        if (pxar(i) == 0 && pyar(i) == 0 &&
            (itypar(i) == 2112 || itypar(i) == 2212)) {
          /// Clin-2/2013 for spectator target nucleons in LAB frame:
          /// C     1           .and.(PEAR(I)*2/HINT1(1)).gt.0.99
          if ((pear(i) / hint1(6) > 0.99f && pear(i) / hint1(6) < 1.01f) ||
              (pear(i) / hint1(7) > 0.99f && pear(i) / hint1(7) < 1.01f)) {
            /// C
            taui = 1.e-20f;
            ftar(i) = taui * fem::cosh(rap);
            gzar(i) = taui * fem::sinh(rap);
          }
        }
      }
      /// Clin-8/2015:
    }
    /// Clin-7/10/01-end
    /// Clin-3/2009 cleanup of program flow:
  } else {
    FEM_DO_SAFE(i, 1, np) {
      /// Clin-9/2012 determine rapidity more generally:
      /// C            IF (ABS(PZAR(I)) .GE. PEAR(I)) THEN
      /// C               PRINT *, ' IN ARINI1'
      /// C               PRINT *, 'ABS(PZ) .GE. EE for particle ', I
      /// C               PRINT *, ' FLAV = ', ITYPAR(I), ' PX = ', PXAR(I),
      /// C     &              ' PY = ', PYAR(I)
      /// C               PRINT *, ' PZ = ', PZAR(I), ' EE = ', PEAR(I)
      /// C               PRINT *, ' XM = ', XMAR(I)
      /// C               RAP = 1000000.0
      /// C               GOTO 100
      /// Cc               STOP
      /// C            END IF
      /// C 100        CONTINUE
      /// C RAP=0.5*LOG((PEAR(I)+PZAR(I)+1e-5)/(PEAR(I)-PZAR(I)+1e-5))
      if ((fem::pow2(xmar(i)) + fem::pow2(pxar(i)) + fem::pow2(pyar(i))) >
          0.f) {
        rap =
            asinh(pzar(i) / fem::sqrt(fem::pow2(xmar(i)) + fem::pow2(pxar(i)) +
                                      fem::pow2(pyar(i))));
      } else {
        write(6, star), " IN ARINI1 mt=0";
        rap = 1000000.0f * fem::sign(1.f, pzar(i));
      }
      /// C
      vx = pxar(i) / pear(i);
      vy = pyar(i) / pear(i);
      /// C.....give initial formation time shift
      taui = ftar(i) + tau0;
      ftar(i) = taui * fem::cosh(rap);
      gxar(i) += vx * tau0 * fem::cosh(rap);
      gyar(i) += vy * tau0 * fem::cosh(rap);
      /// C     4/25/03: hadron z-position upon formation determined the same
      /// way as x,y:
      gzar(i) = taui * fem::sinh(rap);
      /// C     the old prescription:
      /// C            GZAR(I) = GZAR(I) + TAU0 * SINH(RAP)
      zsmear = fem::sngl(cmn.smearh) * (2.f * ranart(cmn.nseed) - 1.f);
      gzar(i) += zsmear;
      /// Cbz1/28/99end
      /// C     10/05/01 no formation time for spectator projectile or target
      /// nucleons:
      if (pxar(i) == 0 && pyar(i) == 0 &&
          (itypar(i) == 2112 || itypar(i) == 2212)) {
        /// Clin-2/2013 for spectator target nucleons in LAB frame:
        /// C     1           .and.(PEAR(I)*2/HINT1(1)).gt.0.99
        if ((pear(i) / hint1(6) > 0.99f && pear(i) / hint1(6) < 1.01f) ||
            (pear(i) / hint1(7) > 0.99f && pear(i) / hint1(7) < 1.01f)) {
          /// C
          /// Clin-5/2008:
          /// C               TAUI=0.00001
          taui = 1.e-20f;
          ftar(i) = taui * fem::cosh(rap);
          gzar(i) = taui * fem::sinh(rap) + zsmear;
        }
      }
    }
    /// Clin-3/2009 cleanup of program flow:
  }
  /// C
  /// Clin-3/2009 Add initial hadrons before the hadron cascade starts:
  addhad(cmn);
  /// C
}

struct arindx_save {
  int i;
  int indxt;
  int ir;
  int j;
  int l;
  float q;

  arindx_save()
      : i(fem::int0),
        indxt(fem::int0),
        ir(fem::int0),
        j(fem::int0),
        l(fem::int0),
        q(fem::float0) {}
};

/// C
/// C=======================================================================
/// C
/// C.....Routine borrowed from ZPC.
/// C.....double precision  is modified to real*4.
/// C
/// Cbz1/29/99
/// C      subroutine index1(n, m, arrin, indx)
void arindx(common& cmn, int const& n, int const& m, arr_cref<float> arrin,
            arr_ref<int> indx) {
  FEM_CMN_SVE(arindx);
  arrin(dimension(n));
  indx(dimension(n));
  int& i = sve.i;
  int& indxt = sve.indxt;
  int& ir = sve.ir;
  int& j = sve.j;
  int& l = sve.l;
  float& q = sve.q;
  /// Cbz1/29/99end
  /// C     indexes the first m elements of ARRIN of length n, i.e., outputs
  /// INDX C     such that ARRIN(INDEX(J)) is in ascending order for J=1,...,m
  /// C
  /// C      implicit real*4 (a-h, o-z)
  /// C
  FEM_DO_SAFE(j, 1, m) { indx(j) = j; }
  l = m / 2 + 1;
  ir = m;
statement_10:
  if (l > 1) {
    l = l - 1;
    indxt = indx(l);
    q = arrin(indxt);
  } else {
    indxt = indx(ir);
    q = arrin(indxt);
    indx(ir) = indx(1);
    ir = ir - 1;
    if (ir == 1) {
      indx(1) = indxt;
      return;
    }
  }
  i = l;
  j = l + l;
statement_20:
  if (j <= ir) {
    if (j < ir) {
      if (arrin(indx(j)) < arrin(indx(j + 1))) {
        j++;
      }
    }
    if (q < arrin(indx(j))) {
      indx(i) = indx(j);
      i = j;
      j += j;
    } else {
      j = ir + 1;
    }
    goto statement_20;
  }
  indx(i) = indxt;
  goto statement_10;
  /// C
}

struct artord_save {
  static const int maxstr = 150001;

  arr<float> dptemp;
  arr<float> ee0;
  arr<float> ft0;
  arr<float> gx0;
  arr<float> gy0;
  arr<float> gz0;
  int i;
  arr<int> indx;
  arr<int> ityp0;
  int np;
  int npar;
  arr<float> px0;
  arr<float> py0;
  arr<float> pz0;
  arr<float> xm0;

  artord_save()
      : dptemp(dimension(maxstr), fem::fill0),
        ee0(dimension(maxstr), fem::fill0),
        ft0(dimension(maxstr), fem::fill0),
        gx0(dimension(maxstr), fem::fill0),
        gy0(dimension(maxstr), fem::fill0),
        gz0(dimension(maxstr), fem::fill0),
        i(fem::int0),
        indx(dimension(maxstr), fem::fill0),
        ityp0(dimension(maxstr), fem::fill0),
        np(fem::int0),
        npar(fem::int0),
        px0(dimension(maxstr), fem::fill0),
        py0(dimension(maxstr), fem::fill0),
        pz0(dimension(maxstr), fem::fill0),
        xm0(dimension(maxstr), fem::fill0) {}
};

const int artord_save::maxstr;

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....subroutine to order particle labels according to increasing
/// C.....formation time
/// C
void artord(common& cmn) {
  FEM_CMN_SVE(artord);
  /// COMMON arprnt
  arr_ref<int> iaint2(cmn.iaint2, dimension(50));
  /// COMMON arprc
  const int maxstr = 150001;
  arr_ref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_ref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_ref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_ref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_ref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_ref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_ref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_ref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_ref<float> pear(cmn.pear, dimension(maxstr));
  arr_ref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON dpert
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  ///
  /// SAVE
  arr_ref<float> dptemp(sve.dptemp, dimension(maxstr));
  arr_ref<float> ee0(sve.ee0, dimension(maxstr));
  arr_ref<float> ft0(sve.ft0, dimension(maxstr));
  arr_ref<float> gx0(sve.gx0, dimension(maxstr));
  arr_ref<float> gy0(sve.gy0, dimension(maxstr));
  arr_ref<float> gz0(sve.gz0, dimension(maxstr));
  int& i = sve.i;
  arr_ref<int> indx(sve.indx, dimension(maxstr));
  arr_ref<int> ityp0(sve.ityp0, dimension(maxstr));
  int& np = sve.np;
  int& npar = sve.npar;
  arr_ref<float> px0(sve.px0, dimension(maxstr));
  arr_ref<float> py0(sve.py0, dimension(maxstr));
  arr_ref<float> pz0(sve.pz0, dimension(maxstr));
  arr_ref<float> xm0(sve.xm0, dimension(maxstr));
  ///
  /// C
  /// C.....before invoking ARTORD:
  /// C.....IAINT2(1) must be set:
  /// Cc      SAVE /ARPRNT/
  /// Cc      SAVE /ARPRC/
  /// Clin-3/2009 Take care of particle weights when user inserts initial
  /// hadrons:
  /// C
  npar = 0;
  np = iaint2(1);
  FEM_DO_SAFE(i, 1, np) {
    ityp0(i) = itypar(i);
    gx0(i) = gxar(i);
    gy0(i) = gyar(i);
    gz0(i) = gzar(i);
    ft0(i) = ftar(i);
    px0(i) = pxar(i);
    py0(i) = pyar(i);
    pz0(i) = pzar(i);
    ee0(i) = pear(i);
    xm0(i) = xmar(i);
    /// Clin-3/2009:
    dptemp(i) = dpertp(i);
  }
  arindx(cmn, maxstr, np, ft0, indx);
  FEM_DO_SAFE(i, 1, np) {
    /// Cbz12/3/98
    /// C         IF (ITYP0(INDX(I)) .EQ. 211) THEN
    /// C         IF (ITYP0(INDX(I)) .EQ. 211 .OR. ITYP0(INDX(I)) .EQ. 321) THEN
    /// C         IF (ITYP0(INDX(I)) .EQ. 211 .OR. ITYP0(INDX(I)) .EQ. 2212 .OR.
    /// C     &      ITYP0(INDX(I)) .EQ. 2112 .OR. ITYP0(INDX(I)) .EQ. -211 .OR.
    /// C     &      ITYP0(INDX(I)) .EQ. 111) THEN
    /// C         IF (ITYP0(INDX(I)) .EQ. 211 .OR. ITYP0(INDX(I)) .EQ. 2212 .OR.
    /// C     &      ITYP0(INDX(I)) .EQ. 2112) THEN
    npar++;
    /// C         ITYPAR(I) = ITYP0(INDX(I))
    /// C         GXAR(I) = GX0(INDX(I))
    /// C         GYAR(I) = GY0(INDX(I))
    /// C         GZAR(I) = GZ0(INDX(I))
    /// C         FTAR(I) = FT0(INDX(I))
    /// C         PXAR(I) = PX0(INDX(I))
    /// C         PYAR(I) = PY0(INDX(I))
    /// C         PZAR(I) = PZ0(INDX(I))
    /// C         PEAR(I) = EE0(INDX(I))
    /// C         XMAR(I) = XM0(INDX(I))
    itypar(npar) = ityp0(indx(i));
    gxar(npar) = gx0(indx(i));
    gyar(npar) = gy0(indx(i));
    gzar(npar) = gz0(indx(i));
    ftar(npar) = ft0(indx(i));
    pxar(npar) = px0(indx(i));
    pyar(npar) = py0(indx(i));
    pzar(npar) = pz0(indx(i));
    pear(npar) = ee0(indx(i));
    xmar(npar) = xm0(indx(i));
    /// Clin-3/2009:
    dpertp(npar) = dptemp(indx(i));
    /// C         END IF
    /// Cbz12/3/98end
  }
  iaint2(1) = npar;
  /// C
}

struct arini_save {
  int iflg;

  arini_save() : iflg(fem::int0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....subroutine to initialize cascade.
/// C
void arini(common& cmn) {
  FEM_CMN_SVE(arini);
  common_write write(cmn);
  arr_cref<int> iapar2(cmn.iapar2, dimension(50));
  ///
  int& iflg = sve.iflg;
  /// C
  /// C.....before invoking ARINI:
  /// C.....IAPAR2(1), IAINT2(1) must be set.
  /// Cc      SAVE /ARPRNT/
  /// C
  /// Ctest off for resonance (phi, K*) studies:
  /// C      OPEN (89, FILE = 'ana/decay_rec.dat', STATUS = 'UNKNOWN')
  /// C
  iflg = iapar2(1);
  switch (iflg) {
    case 1:
      goto statement_200;
    case 2:
      goto statement_200;
    case 3:
      goto statement_300;
    default:
      break;
  }
  /// C
  /// C.....error choice of initialization
  write(6, star), "IAPAR2(1) must be 1, 2, or 3";
  FEM_STOP(0);
/// C
/// C.....to use default initial conditions generated by the cascade,
/// C.....or to read in initial conditions.
statement_200:
  return;
/// C
/// C.....to generate formation time and the position at formation time from
/// C.....read-in initial conditions with an averaged formation proper time.
statement_300:
  arini1(cmn);
  /// C.....ordering the particle label according to increasing order of
  /// C.....formation time.
  artord(cmn);
  /// C
}

struct arini2_save {
  int i;
  int ip;
  int irun;

  arini2_save() : i(fem::int0), ip(fem::int0), irun(fem::int0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....subroutine to copy individually generated particle record into
/// C.....particle record for many test particle runs.
/// C
void arini2(common& cmn, int const& k) {
  FEM_CMN_SVE(arini2);
  /// COMMON arprnt
  arr_cref<int> iaint2(cmn.iaint2, dimension(50));
  /// COMMON arprc
  const int maxstr = 150001;
  arr_cref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_cref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_cref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_cref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_cref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_cref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_cref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_cref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_cref<float> pear(cmn.pear, dimension(maxstr));
  arr_cref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON arerc1
  const int maxr = 1;
  arr_ref<int> multi1(cmn.multi1, dimension(maxr));
  /// COMMON arprc1
  arr_ref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
  arr_ref<float, 2> gx1(cmn.gx1, dimension(maxstr, maxr));
  arr_ref<float, 2> gy1(cmn.gy1, dimension(maxstr, maxr));
  arr_ref<float, 2> gz1(cmn.gz1, dimension(maxstr, maxr));
  arr_ref<float, 2> ft1(cmn.ft1, dimension(maxstr, maxr));
  arr_ref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
  arr_ref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
  /// COMMON tdecay
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  arr_ref<float> tft(cmn.tft, dimension(maxstr));
  /// COMMON input1
  float& dt = cmn.dt;
  /// COMMON input2
  int& ntmax = cmn.ntmax;
  /// COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dpp1(cmn.dpp1, dimension(maxstr, maxr));
  ///
  /// SAVE
  int& i = sve.i;
  int& ip = sve.ip;
  int& irun = sve.irun;
  ///
  /// C
  /// Cc      SAVE /ARPRNT/
  /// Cc      SAVE /ARPRC/
  /// Cc      SAVE /ARERC1/
  /// Cc      SAVE /ARPRC1/
  /// Cc      SAVE /tdecay/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /INPUT2/
  /// Cc      SAVE /RNDF77/
  /// C
  multi1(k) = iaint2(1);
  FEM_DO_SAFE(i, 1, multi1(k)) {
    ityp1(i, k) = itypar(i);
    gx1(i, k) = gxar(i);
    gy1(i, k) = gyar(i);
    gz1(i, k) = gzar(i);
    ft1(i, k) = ftar(i);
    px1(i, k) = pxar(i);
    py1(i, k) = pyar(i);
    pz1(i, k) = pzar(i);
    ee1(i, k) = pear(i);
    xm1(i, k) = xmar(i);
    /// Clin-3/2009 hadron weights are initialized in addhad():
    /// Clin-5/2008 all hadrons not perturbatively-produced have the weight of
    /// 1: C         dpp1(I,K)=1.
    dpp1(i, k) = dpertp(i);
  }
  /// C
  /// C     initialize final time of each particle to ntmax*dt except for
  /// C     decay daughters, which have values given by tfdcy() and >(ntmax*dt):
  FEM_DO_SAFE(ip, 1, maxstr) {
    tfdcy(ip) = ntmax * dt;
    tft(ip) = ntmax * dt;
  }
  /// C
  FEM_DO_SAFE(irun, 1, maxr) {
    FEM_DO_SAFE(ip, 1, maxstr) { tfdpi(ip, irun) = ntmax * dt; }
  }
  /// C
}

struct blockdata_ardata_save {};

/// C
/// C=======================================================================
/// C
void blockdata_ardata(common& cmn) {
  FEM_CMN_SVE(blockdata_ardata);
  /// COMMON arprnt
  arr_ref<float> arpar1(cmn.arpar1, dimension(100));
  arr_ref<int> iapar2(cmn.iapar2, dimension(50));
  arr_ref<float> arint1(cmn.arint1, dimension(100));
  arr_ref<int> iaint2(cmn.iaint2, dimension(50));
  ///
  if (is_called_first_time) {
    fem::data((values, 1.19f, 99 * datum(0.0f))), arpar1;
    fem::data((values, 3, 49 * datum(0))), iapar2;
    fem::data((values, 100 * datum(0.0f))), arint1;
    fem::data((values, 50 * datum(0))), iaint2;
  }
  /// C
  /// Cc      SAVE /ARPRNT/
  /// C
}

/// C
/// C*********************************************************************
/// C
int lucomp(common& cmn, int const& kf) {
  int return_value = fem::int0;
  /// COMMON ludat2
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  /// C
  /// C...Purpose: to compress the standard KF codes for use in mass and decay
  /// C...arrays; also to check whether a given code actually is defined.
  /// C
  /// C...Subdivide KF code into constituent pieces.
  return_value = 0;
  int kfa = fem::iabs(kf);
  int kfla = fem::mod(kfa / 1000, 10);
  int kflb = fem::mod(kfa / 100, 10);
  int kflc = fem::mod(kfa / 10, 10);
  int kfls = fem::mod(kfa, 10);
  int kflr = fem::mod(kfa / 10000, 10);
  /// C
  /// C...Simple cases: direct translation or special codes.
  if (kfa == 0 || kfa >= 100000) {
  } else if (kfa <= 100) {
    return_value = kfa;
    if (kf < 0 && kchg(kfa, 3) == 0) {
      return_value = 0;
    }
  } else if (kfls == 0) {
    if (kf == 130) {
      return_value = 221;
    }
    if (kf == 310) {
      return_value = 222;
    }
    if (kfa == 210) {
      return_value = 281;
    }
    if (kfa == 2110) {
      return_value = 282;
    }
    if (kfa == 2210) {
      return_value = 283;
    }
    /// C
    /// C...Mesons.
  } else if (kfa - 10000 * kflr < 1000) {
    if (kflb == 0 || kflb == 9 || kflc == 0 || kflc == 9) {
    } else if (kflb < kflc) {
    } else if (kf < 0 && kflb == kflc) {
    } else if (kflb == kflc) {
      if (kflr == 0 && kfls == 1) {
        return_value = 110 + kflb;
      } else if (kflr == 0 && kfls == 3) {
        return_value = 130 + kflb;
      } else if (kflr == 1 && kfls == 3) {
        return_value = 150 + kflb;
      } else if (kflr == 1 && kfls == 1) {
        return_value = 170 + kflb;
      } else if (kflr == 2 && kfls == 3) {
        return_value = 190 + kflb;
      } else if (kflr == 0 && kfls == 5) {
        return_value = 210 + kflb;
      }
    } else if (kflb <= 5 && kflc <= 3) {
      if (kflr == 0 && kfls == 1) {
        return_value = 100 + ((kflb - 1) * (kflb - 2)) / 2 + kflc;
      } else if (kflr == 0 && kfls == 3) {
        return_value = 120 + ((kflb - 1) * (kflb - 2)) / 2 + kflc;
      } else if (kflr == 1 && kfls == 3) {
        return_value = 140 + ((kflb - 1) * (kflb - 2)) / 2 + kflc;
      } else if (kflr == 1 && kfls == 1) {
        return_value = 160 + ((kflb - 1) * (kflb - 2)) / 2 + kflc;
      } else if (kflr == 2 && kfls == 3) {
        return_value = 180 + ((kflb - 1) * (kflb - 2)) / 2 + kflc;
      } else if (kflr == 0 && kfls == 5) {
        return_value = 200 + ((kflb - 1) * (kflb - 2)) / 2 + kflc;
      }
    } else if ((kfls == 1 && kflr <= 1) || (kfls == 3 && kflr <= 2) ||
               (kfls == 5 && kflr == 0)) {
      return_value = 80 + kflb;
    }
    /// C
    /// C...Diquarks.
  } else if ((kflr == 0 || kflr == 1) && kflc == 0) {
    if (kfls != 1 && kfls != 3) {
    } else if (kfla == 9 || kflb == 0 || kflb == 9) {
    } else if (kfla < kflb) {
    } else if (kfls == 1 && kfla == kflb) {
    } else {
      return_value = 90;
    }
    /// C
    /// C...Spin 1/2 baryons.
  } else if (kflr == 0 && kfls == 2) {
    if (kfla == 9 || kflb == 0 || kflb == 9 || kflc == 9) {
    } else if (kfla <= kflc || kfla < kflb) {
    } else if (kfla >= 6 || kflb >= 4 || kflc >= 4) {
      return_value = 80 + kfla;
    } else if (kflb < kflc) {
      return_value = 300 + ((kfla + 1) * kfla * (kfla - 1)) / 6 +
                     (kflc * (kflc - 1)) / 2 + kflb;
    } else {
      return_value = 330 + ((kfla + 1) * kfla * (kfla - 1)) / 6 +
                     (kflb * (kflb - 1)) / 2 + kflc;
    }
    /// C
    /// C...Spin 3/2 baryons.
  } else if (kflr == 0 && kfls == 4) {
    if (kfla == 9 || kflb == 0 || kflb == 9 || kflc == 9) {
    } else if (kfla < kflb || kflb < kflc) {
    } else if (kfla >= 6 || kflb >= 4) {
      return_value = 80 + kfla;
    } else {
      return_value = 360 + ((kfla + 1) * kfla * (kfla - 1)) / 6 +
                     (kflb * (kflb - 1)) / 2 + kflc;
    }
  }
  /// C
  return return_value;
}

/// C
/// C*********************************************************************
/// C
int luchge(common& cmn, int const& kf) {
  int return_value = fem::int0;
  /// COMMON ludat2
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  /// C
  /// C...Purpose: to give three times the charge for a particle/parton.
  /// C
  /// C...Initial values. Simple case of direct readout.
  return_value = 0;
  int kfa = fem::iabs(kf);
  int kc = lucomp(cmn, kfa);
  if (kc == 0) {
  } else if (kfa <= 100 || kc <= 80 || kc > 100) {
    return_value = kchg(kc, 1);
    /// C
    /// C...Construction from quark content for heavy meson, diquark, baryon.
  } else if (fem::mod(kfa / 1000, 10) == 0) {
    return_value =
        (kchg(fem::mod(kfa / 100, 10), 1) - kchg(fem::mod(kfa / 10, 10), 1)) *
        fem::pow((-1), fem::mod(kfa / 100, 10));
  } else if (fem::mod(kfa / 10, 10) == 0) {
    return_value =
        kchg(fem::mod(kfa / 1000, 10), 1) + kchg(fem::mod(kfa / 100, 10), 1);
  } else {
    return_value = kchg(fem::mod(kfa / 1000, 10), 1) +
                   kchg(fem::mod(kfa / 100, 10), 1) +
                   kchg(fem::mod(kfa / 10, 10), 1);
  }
  /// C
  /// C...Add on correct sign.
  return_value = return_value * fem::isign(1, kf);
  /// C
  return return_value;
}

struct artan1_save {
  float dxmt;
  float ee;
  float eta;
  int i;
  int ieta;
  int imt;
  int ityp;
  int iy;
  int j;
  float ptot;
  float px;
  float py;
  float pz;
  float xm;
  float xmt;
  float y;

  artan1_save()
      : dxmt(fem::float0),
        ee(fem::float0),
        eta(fem::float0),
        i(fem::int0),
        ieta(fem::int0),
        imt(fem::int0),
        ityp(fem::int0),
        iy(fem::int0),
        j(fem::int0),
        ptot(fem::float0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        xm(fem::float0),
        xmt(fem::float0),
        y(fem::float0) {}
};

/// C
/// C=======================================================================
/// C
/// Clin Below is the previous artana.f:
/// C=======================================================================
/// C
/// C.....analysis subroutine before the hadronic space-time evolution
/// C
void artan1(common& cmn) {
  FEM_CMN_SVE(artan1);
  common_write write(cmn);
  const int maxr = 1;
  arr_cref<int> multi1(cmn.multi1, dimension(maxr));
  const int maxstr = 150001;
  arr_cref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
  arr_cref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                         dimension(maxstr, maxr));
  arr_cref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                         dimension(maxstr, maxr));
  arr_cref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                         dimension(maxstr, maxr));
  arr_cref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
  arr_cref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
  arr_ref<float> dy1ntb(cmn.dy1ntb, dimension(50));
  arr_ref<float> dy1ntp(cmn.dy1ntp, dimension(50));
  arr_ref<float> dy1hm(cmn.dy1hm, dimension(50));
  arr_ref<float> dy1kp(cmn.dy1kp, dimension(50));
  arr_ref<float> dy1km(cmn.dy1km, dimension(50));
  arr_ref<float> dy1k0s(cmn.dy1k0s, dimension(50));
  arr_ref<float> dy1la(cmn.dy1la, dimension(50));
  arr_ref<float> dy1lb(cmn.dy1lb, dimension(50));
  arr_ref<float> dy1phi(cmn.dy1phi, dimension(50));
  arr_ref<float> dm1pip(cmn.dm1pip, dimension(50));
  arr_ref<float> dm1pim(cmn.dm1pim, dimension(50));
  arr_ref<float> dmt1pr(cmn.dmt1pr, dimension(50));
  arr_ref<float> dmt1pb(cmn.dmt1pb, dimension(50));
  arr_ref<float> dmt1kp(cmn.dmt1kp, dimension(50));
  arr_ref<float> dm1km(cmn.dm1km, dimension(50));
  arr_ref<float> dm1k0s(cmn.dm1k0s, dimension(50));
  arr_ref<float> dmt1la(cmn.dmt1la, dimension(50));
  arr_ref<float> dmt1lb(cmn.dmt1lb, dimension(50));
  arr_ref<float> dy1msn(cmn.dy1msn, dimension(50));
  arr_ref<float> dy1pip(cmn.dy1pip, dimension(50));
  arr_ref<float> dy1pim(cmn.dy1pim, dimension(50));
  arr_ref<float> dy1pi0(cmn.dy1pi0, dimension(50));
  arr_ref<float> dy1pr(cmn.dy1pr, dimension(50));
  arr_ref<float> dy1pb(cmn.dy1pb, dimension(50));
  arr_ref<float> dy1neg(cmn.dy1neg, dimension(50));
  arr_ref<float> dy1ch(cmn.dy1ch, dimension(50));
  arr_ref<float> de1neg(cmn.de1neg, dimension(50));
  arr_ref<float> de1ch(cmn.de1ch, dimension(50));
  ///
  float& dxmt = sve.dxmt;
  float& eta = sve.eta;
  int& i = sve.i;
  int& ieta = sve.ieta;
  int& imt = sve.imt;
  int& ityp = sve.ityp;
  int& iy = sve.iy;
  int& j = sve.j;
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& xm = sve.xm;
  float& xmt = sve.xmt;
  float& y = sve.y;
  const float by = 0.4f;
  const float ymt1 = -1.0f;
  const float ymt2 = 1.0f;
  const float bmt = 0.05f;
  /// C.....y cut for mt spectrum
  /// Cbz3/17/99
  /// C      PARAMETER (YMT1 = -0.4, YMT2 = 0.4)
  /// Cbz3/17/99 end
  /// C.....bin width for mt spectrum and y spectrum
  /// Clin-9/26/03 no symmetrization in y (or eta) for ana/*.dat:
  /// C      PARAMETER (BMT = 0.05, BY = 0.2)
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /ARERC1/
  /// Cbz3/17/99
  /// C     &     dm1k0s(50), DMT1LA(50), DMT1LB(50)
  /// Cc      SAVE /ARPRC1/
  /// Cc      SAVE /ARANA1/
  /// C
  /// Cbz3/17/99 end
  FEM_DO_SAFE(j, 1, cmn.num) {
    FEM_DO_SAFE(i, 1, multi1(j)) {
      ityp = ityp1(i, j);
      px = px1(i, j);
      py = py1(i, j);
      pz = pz1(i, j);
      sve.ee = ee1(i, j);
      xm = xm1(i, j);
      /// C     2/24/03 leptons and photons:
      if (xm < 0.01f) {
        goto statement_200;
      }
      sve.ptot = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
      /// Clin-9/2012 determine pseudo-rapidity more generally:
      /// C            eta = 0.5*alog((Ptot+pz+1e-5)/(ptot-pz+1e-5))
      if ((fem::pow2(px) + fem::pow2(py)) > 0.f) {
        eta = asinh(pz / fem::sqrt(fem::pow2(px) + fem::pow2(py)));
      } else {
        eta = 1000000.0f * fem::sign(1.f, pz);
        /// Clin-2/2013 for spectator target nucleons in LAB frame,
        /// C     note that finite precision of HBOOST
        /// C     would give spectator target nucleons a small but non-zero pz:
        if (fem::abs(pz) <= 1e-3f) {
          eta = 0.f;
        }
      }
      /// C
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(xm));
      dxmt = xmt - xm;
      /// Clin-9/2012 determine rapidity more generally:
      /// C            IF (ABS(PZ) .GE. EE) THEN
      /// C               PRINT *, 'IN ARTAN1'
      /// C               PRINT *, 'PARTICLE ', I, ' RUN ', J, 'PREC ERR'
      /// Ccbzdbg2/16/99
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// Ccbzdbg2/16/99
      /// Ccbzdbg2/15/99
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', EE
      /// Ccbzdbg2/16/99
      /// C               PRINT *, ' XM = ', XM
      /// Ccbzdbg2/16/99end
      /// C               GOTO 200
      /// C            else
      /// Cc            Y = 0.5 * LOG((EE + PZ) / (EE - PZ))
      /// C               Y = 0.5 * LOG((EE + PZ +1e-5) / (EE - PZ +1e-5))
      /// Cc               STOP
      /// Ccbzdbg2/15/99end
      /// C            END IF
      if (xmt > 0.f) {
        y = asinh(pz / xmt);
      } else {
        write(6, star), " IN ARTAN1 mt=0";
        y = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      /// C.....rapidity cut for the rapidity distribution
      if (fem::abs(y) >= 10.0f) {
        goto statement_100;
      }
      /// Clin-9/26/03 no symmetrization in y (or eta) for ana/*.dat:
      /// C            IY = 1 + int(ABS(Y) / BY)
      /// C            Ieta = 1 + int(ABS(eta) / BY)
      if (fem::abs(eta) >= 10.0f) {
        goto statement_100;
      }
      iy = 1 + fem::fint((y + 10.f) / by);
      ieta = 1 + fem::fint((eta + 10.f) / by);
      /// C
      if (ityp < -1000) {
        dy1ntb(iy) = dy1ntb(iy) - 1.0f;
      }
      if (ityp > 1000) {
        dy1ntb(iy) += 1.0f;
      }
      if (ityp == -2212) {
        dy1ntp(iy) = dy1ntp(iy) - 1.0f;
      }
      if (ityp == 2212) {
        dy1ntp(iy) += 1.0f;
      }
      /// C            IF (ITYP .EQ. -211 .OR. ITYP .EQ. -321 .OR.
      /// C     &         ITYP .EQ. -2212) THEN
      if (ityp == -2112) {
        dy1hm(iy) += 1.0f;
      }
      /// C
      if (luchge(cmn, ityp) != 0) {
        dy1ch(iy) += 1.0f;
        de1ch(ieta) += 1.0f;
        if (luchge(cmn, ityp) < 0) {
          dy1neg(iy) += 1.0f;
          de1neg(ieta) += 1.0f;
        }
      }
      /// C
      /// Cbz3/17/99
      if ((ityp >= 100 && ityp < 1000) || (ityp > -1000 && ityp <= -100)) {
        dy1msn(iy) += 1.0f;
      }
      if (ityp == 211) {
        dy1pip(iy) += 1.0f;
      }
      if (ityp == -211) {
        dy1pim(iy) += 1.0f;
      }
      if (ityp == 111) {
        dy1pi0(iy) += 1.0f;
      }
      if (ityp == 2212) {
        dy1pr(iy) += 1.0f;
      }
      if (ityp == -2212) {
        dy1pb(iy) += 1.0f;
      }
      /// Cbz3/17/99 end
      if (ityp == 321) {
        dy1kp(iy) += 1.0f;
      }
      if (ityp == -321) {
        dy1km(iy) += 1.0f;
      }
      /// Clin-4/24/03 evaluate K0L instead of K0S, since sometimes we may decay
      /// K0S: C            IF (ITYP .EQ. 310) THEN
      if (ityp == 130) {
        dy1k0s(iy) += 1.0f;
      }
      if (ityp == 3122) {
        dy1la(iy) += 1.0f;
      }
      if (ityp == -3122) {
        dy1lb(iy) += 1.0f;
      }
      if (ityp == 333) {
        dy1phi(iy) += 1.0f;
      }
    /// C
    /// C.....insert rapidity cut for mt spectrum here
    statement_100:
      if (y < ymt1 || y > ymt2) {
        goto statement_200;
      }
      if (dxmt >= 50.0f * bmt || dxmt == 0) {
        goto statement_200;
      }
      imt = 1 + fem::fint(dxmt / bmt);
      if (ityp == 211) {
        dm1pip(imt) += 1.0f / xmt;
      }
      if (ityp == -211) {
        dm1pim(imt) += 1.0f / xmt;
      }
      if (ityp == 2212) {
        dmt1pr(imt) += 1.0f / xmt;
      }
      if (ityp == -2212) {
        dmt1pb(imt) += 1.0f / xmt;
      }
      if (ityp == 321) {
        dmt1kp(imt) += 1.0f / xmt;
      }
      if (ityp == -321) {
        dm1km(imt) += 1.0f / xmt;
      }
      /// Clin-4/24/03:
      /// C            IF (ITYP .EQ. 310) THEN
      if (ityp == 130) {
        dm1k0s(imt) += 1.0f / xmt;
      }
      if (ityp == 3122) {
        dmt1la(imt) += 1.0f / xmt;
      }
      if (ityp == -3122) {
        dmt1lb(imt) += 1.0f / xmt;
      }
    /// C
    statement_200:;
    }
  }
  /// C
}

struct artan2_save {
  float dxmt;
  float ee;
  float eta;
  int i;
  int ieta;
  int imt;
  int ityp;
  int iy;
  int j;
  float ptot;
  float px;
  float py;
  float pz;
  float xm;
  float xmt;
  float y;

  artan2_save()
      : dxmt(fem::float0),
        ee(fem::float0),
        eta(fem::float0),
        i(fem::int0),
        ieta(fem::int0),
        imt(fem::int0),
        ityp(fem::int0),
        iy(fem::int0),
        j(fem::int0),
        ptot(fem::float0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        xm(fem::float0),
        xmt(fem::float0),
        y(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....analysis subroutine after the hadronic space-time evolution
/// C
void artan2(common& cmn) {
  FEM_CMN_SVE(artan2);
  common_write write(cmn);
  const int maxr = 1;
  arr_cref<int> multi1(cmn.multi1, dimension(maxr));
  const int maxstr = 150001;
  arr_cref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
  arr_cref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                         dimension(maxstr, maxr));
  arr_cref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                         dimension(maxstr, maxr));
  arr_cref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                         dimension(maxstr, maxr));
  arr_cref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
  arr_cref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
  arr_ref<float> dy2ntb(cmn.dy2ntb, dimension(50));
  arr_ref<float> dy2ntp(cmn.dy2ntp, dimension(50));
  arr_ref<float> dy2hm(cmn.dy2hm, dimension(50));
  arr_ref<float> dy2kp(cmn.dy2kp, dimension(50));
  arr_ref<float> dy2km(cmn.dy2km, dimension(50));
  arr_ref<float> dy2k0s(cmn.dy2k0s, dimension(50));
  arr_ref<float> dy2la(cmn.dy2la, dimension(50));
  arr_ref<float> dy2lb(cmn.dy2lb, dimension(50));
  arr_ref<float> dy2phi(cmn.dy2phi, dimension(50));
  arr_ref<float> dm2pip(cmn.dm2pip, dimension(50));
  arr_ref<float> dm2pim(cmn.dm2pim, dimension(50));
  arr_ref<float> dmt2pr(cmn.dmt2pr, dimension(50));
  arr_ref<float> dmt2pb(cmn.dmt2pb, dimension(50));
  arr_ref<float> dmt2kp(cmn.dmt2kp, dimension(50));
  arr_ref<float> dm2km(cmn.dm2km, dimension(50));
  arr_ref<float> dm2k0s(cmn.dm2k0s, dimension(50));
  arr_ref<float> dmt2la(cmn.dmt2la, dimension(50));
  arr_ref<float> dmt2lb(cmn.dmt2lb, dimension(50));
  arr_ref<float> dy2msn(cmn.dy2msn, dimension(50));
  arr_ref<float> dy2pip(cmn.dy2pip, dimension(50));
  arr_ref<float> dy2pim(cmn.dy2pim, dimension(50));
  arr_ref<float> dy2pi0(cmn.dy2pi0, dimension(50));
  arr_ref<float> dy2pr(cmn.dy2pr, dimension(50));
  arr_ref<float> dy2pb(cmn.dy2pb, dimension(50));
  arr_ref<float> dy2neg(cmn.dy2neg, dimension(50));
  arr_ref<float> dy2ch(cmn.dy2ch, dimension(50));
  arr_ref<float> de2neg(cmn.de2neg, dimension(50));
  arr_ref<float> de2ch(cmn.de2ch, dimension(50));
  ///
  float& dxmt = sve.dxmt;
  float& eta = sve.eta;
  int& i = sve.i;
  int& ieta = sve.ieta;
  int& imt = sve.imt;
  int& ityp = sve.ityp;
  int& iy = sve.iy;
  int& j = sve.j;
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& xm = sve.xm;
  float& xmt = sve.xmt;
  float& y = sve.y;
  const float by = 0.4f;
  const float ymt1 = -1.0f;
  const float ymt2 = 1.0f;
  const float bmt = 0.05f;
  /// C
  /// C.....y cut for mt spectrum
  /// Cbz3/17/99
  /// C      PARAMETER (YMT1 = -0.4, YMT2 = 0.4)
  /// Cbz3/17/99 end
  /// C.....bin width for mt spectrum and y spectrum
  /// C      PARAMETER (BMT = 0.05, BY = 0.2)
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /ARERC1/
  /// Cbz3/17/99
  /// C     &     dm2k0s(50), DMT2LA(50), DMT2LB(50)
  /// Cc      SAVE /ARPRC1/
  /// Cbz3/17/99 end
  /// Cc      SAVE /ARANA2/
  /// C
  FEM_DO_SAFE(j, 1, cmn.num) {
    FEM_DO_SAFE(i, 1, multi1(j)) {
      ityp = ityp1(i, j);
      px = px1(i, j);
      py = py1(i, j);
      pz = pz1(i, j);
      sve.ee = ee1(i, j);
      xm = xm1(i, j);
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(xm));
      /// C     2/24/03 leptons and photons:
      if (xm < 0.01f) {
        goto statement_200;
      }
      dxmt = xmt - xm;
      sve.ptot = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
      /// Clin-9/2012 determine pseudo-rapidity more generally:
      /// C            eta = 0.5*alog((Ptot+pz+1e-5)/(ptot-pz+1e-5))
      if ((fem::pow2(px) + fem::pow2(py)) > 0.f) {
        eta = asinh(pz / fem::sqrt(fem::pow2(px) + fem::pow2(py)));
      } else {
        eta = 1000000.0f * fem::sign(1.f, pz);
        /// Clin-2/2013 for spectator target nucleons in LAB frame:
        if (fem::abs(pz) <= 1e-3f) {
          eta = 0.f;
        }
      }
      /// C
      /// Clin-9/2012 determine rapidity more generally:
      /// C            IF (ABS(PZ) .GE. EE) THEN
      /// C               PRINT *, 'IN ARTAN2'
      /// C               PRINT *, 'PARTICLE ', I, ' RUN ', J, 'PREC ERR'
      /// Ccbzdbg2/16/99
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// Ccbzdbg2/16/99
      /// Ccbzdbg2/15/99
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', EE
      /// Ccbzdbg2/16/99
      /// C               PRINT *, ' XM = ', XM
      /// Ccbzdbg2/16/99end
      /// C               GOTO 200
      /// Cc               STOP
      /// Ccbzdbg2/15/99end
      /// C            END IF
      /// C            Y = 0.5 * LOG((EE + PZ +1e-5) / (EE - PZ + 1e-5))
      if (xmt > 0.f) {
        y = asinh(pz / xmt);
      } else {
        write(6, star), " IN ARTAN2 mt=0";
        y = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      /// C.....rapidity cut for the rapidity distribution
      if (fem::abs(y) >= 10.0f) {
        goto statement_100;
      }
      /// C            IY = 1 + int(ABS(Y) / BY)
      /// C            Ieta = 1 + int(ABS(eta) / BY)
      if (fem::abs(eta) >= 10.0f) {
        goto statement_100;
      }
      iy = 1 + fem::fint((y + 10.f) / by);
      ieta = 1 + fem::fint((eta + 10.f) / by);
      /// C
      if (ityp < -1000) {
        dy2ntb(iy) = dy2ntb(iy) - 1.0f;
      }
      if (ityp > 1000) {
        dy2ntb(iy) += 1.0f;
      }
      if (ityp == -2212) {
        dy2ntp(iy) = dy2ntp(iy) - 1.0f;
      }
      if (ityp == 2212) {
        dy2ntp(iy) += 1.0f;
      }
      if (ityp == -2112) {
        dy2hm(iy) += 1.0f;
      }
      /// C
      if (luchge(cmn, ityp) != 0) {
        dy2ch(iy) += 1.0f;
        de2ch(ieta) += 1.0f;
        if (luchge(cmn, ityp) < 0) {
          dy2neg(iy) += 1.0f;
          de2neg(ieta) += 1.0f;
        }
      }
      /// C
      /// Cbz3/17/99
      if ((ityp >= 100 && ityp < 1000) || (ityp > -1000 && ityp <= -100)) {
        dy2msn(iy) += 1.0f;
      }
      if (ityp == 211) {
        dy2pip(iy) += 1.0f;
      }
      if (ityp == -211) {
        dy2pim(iy) += 1.0f;
      }
      if (ityp == 111) {
        dy2pi0(iy) += 1.0f;
      }
      if (ityp == 2212) {
        dy2pr(iy) += 1.0f;
      }
      if (ityp == -2212) {
        dy2pb(iy) += 1.0f;
      }
      /// Cbz3/17/99 end
      if (ityp == 321) {
        dy2kp(iy) += 1.0f;
      }
      if (ityp == -321) {
        dy2km(iy) += 1.0f;
      }
      /// Clin-4/24/03:
      /// C            IF (ITYP .EQ. 310) THEN
      if (ityp == 130) {
        dy2k0s(iy) += 1.0f;
      }
      if (ityp == 3122) {
        dy2la(iy) += 1.0f;
      }
      if (ityp == -3122) {
        dy2lb(iy) += 1.0f;
      }
      if (ityp == 333) {
        dy2phi(iy) += 1.0f;
      }
    /// C
    /// C.....insert rapidity cut for mt spectrum here
    statement_100:
      if (y < ymt1 || y > ymt2) {
        goto statement_200;
      }
      if (dxmt >= 50.0f * bmt || dxmt == 0) {
        goto statement_200;
      }
      imt = 1 + fem::fint(dxmt / bmt);
      if (ityp == 211) {
        dm2pip(imt) += 1.0f / xmt;
      }
      if (ityp == -211) {
        dm2pim(imt) += 1.0f / xmt;
      }
      if (ityp == 2212) {
        dmt2pr(imt) += 1.0f / xmt;
      }
      if (ityp == -2212) {
        dmt2pb(imt) += 1.0f / xmt;
      }
      if (ityp == 321) {
        dmt2kp(imt) += 1.0f / xmt;
      }
      if (ityp == -321) {
        dm2km(imt) += 1.0f / xmt;
      }
      /// Clin-4/24/03:
      /// C            IF (ITYP .EQ. 310) THEN
      if (ityp == 130) {
        dm2k0s(imt) += 1.0f / xmt;
      }
      if (ityp == 3122) {
        dmt2la(imt) += 1.0f / xmt;
      }
      if (ityp == -3122) {
        dmt2lb(imt) += 1.0f / xmt;
      }
    /// C
    statement_200:;
    }
  }
  /// C
}

struct artout_save {
  int i;
  float scale1;
  float scale2;
  float ymid;

  artout_save()
      : i(fem::int0),
        scale1(fem::float0),
        scale2(fem::float0),
        ymid(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....output analysis results at the end of the simulation
/// C
void artout(common& cmn, int const& nevnt) {
  FEM_CMN_SVE(artout);
  common_write write(cmn);
  /// COMMON run
  int& num = cmn.num;
  /// COMMON arana1
  arr_cref<float> dy1ntb(cmn.dy1ntb, dimension(50));
  arr_cref<float> dy1ntp(cmn.dy1ntp, dimension(50));
  arr_cref<float> dy1hm(cmn.dy1hm, dimension(50));
  arr_cref<float> dy1kp(cmn.dy1kp, dimension(50));
  arr_cref<float> dy1km(cmn.dy1km, dimension(50));
  arr_cref<float> dy1k0s(cmn.dy1k0s, dimension(50));
  arr_cref<float> dy1la(cmn.dy1la, dimension(50));
  arr_cref<float> dy1lb(cmn.dy1lb, dimension(50));
  arr_cref<float> dy1phi(cmn.dy1phi, dimension(50));
  arr_cref<float> dm1pip(cmn.dm1pip, dimension(50));
  arr_cref<float> dm1pim(cmn.dm1pim, dimension(50));
  arr_cref<float> dmt1pr(cmn.dmt1pr, dimension(50));
  arr_cref<float> dmt1pb(cmn.dmt1pb, dimension(50));
  arr_cref<float> dmt1kp(cmn.dmt1kp, dimension(50));
  arr_cref<float> dm1km(cmn.dm1km, dimension(50));
  arr_cref<float> dm1k0s(cmn.dm1k0s, dimension(50));
  arr_cref<float> dmt1la(cmn.dmt1la, dimension(50));
  arr_cref<float> dmt1lb(cmn.dmt1lb, dimension(50));
  arr_cref<float> dy1msn(cmn.dy1msn, dimension(50));
  arr_cref<float> dy1pip(cmn.dy1pip, dimension(50));
  arr_cref<float> dy1pim(cmn.dy1pim, dimension(50));
  arr_cref<float> dy1pi0(cmn.dy1pi0, dimension(50));
  arr_cref<float> dy1pr(cmn.dy1pr, dimension(50));
  arr_cref<float> dy1pb(cmn.dy1pb, dimension(50));
  arr_cref<float> dy1neg(cmn.dy1neg, dimension(50));
  arr_cref<float> dy1ch(cmn.dy1ch, dimension(50));
  arr_cref<float> de1neg(cmn.de1neg, dimension(50));
  arr_cref<float> de1ch(cmn.de1ch, dimension(50));
  /// COMMON arana2
  arr_cref<float> dy2ntb(cmn.dy2ntb, dimension(50));
  arr_cref<float> dy2ntp(cmn.dy2ntp, dimension(50));
  arr_cref<float> dy2hm(cmn.dy2hm, dimension(50));
  arr_cref<float> dy2kp(cmn.dy2kp, dimension(50));
  arr_cref<float> dy2km(cmn.dy2km, dimension(50));
  arr_cref<float> dy2k0s(cmn.dy2k0s, dimension(50));
  arr_cref<float> dy2la(cmn.dy2la, dimension(50));
  arr_cref<float> dy2lb(cmn.dy2lb, dimension(50));
  arr_cref<float> dy2phi(cmn.dy2phi, dimension(50));
  arr_cref<float> dm2pip(cmn.dm2pip, dimension(50));
  arr_cref<float> dm2pim(cmn.dm2pim, dimension(50));
  arr_cref<float> dmt2pr(cmn.dmt2pr, dimension(50));
  arr_cref<float> dmt2pb(cmn.dmt2pb, dimension(50));
  arr_cref<float> dmt2kp(cmn.dmt2kp, dimension(50));
  arr_cref<float> dm2km(cmn.dm2km, dimension(50));
  arr_cref<float> dm2k0s(cmn.dm2k0s, dimension(50));
  arr_cref<float> dmt2la(cmn.dmt2la, dimension(50));
  arr_cref<float> dmt2lb(cmn.dmt2lb, dimension(50));
  arr_cref<float> dy2msn(cmn.dy2msn, dimension(50));
  arr_cref<float> dy2pip(cmn.dy2pip, dimension(50));
  arr_cref<float> dy2pim(cmn.dy2pim, dimension(50));
  arr_cref<float> dy2pi0(cmn.dy2pi0, dimension(50));
  arr_cref<float> dy2pr(cmn.dy2pr, dimension(50));
  arr_cref<float> dy2pb(cmn.dy2pb, dimension(50));
  arr_cref<float> dy2neg(cmn.dy2neg, dimension(50));
  arr_cref<float> dy2ch(cmn.dy2ch, dimension(50));
  arr_cref<float> de2neg(cmn.de2neg, dimension(50));
  arr_cref<float> de2ch(cmn.de2ch, dimension(50));
  ///
  /// SAVE
  int& i = sve.i;
  float& scale1 = sve.scale1;
  float& scale2 = sve.scale2;
  float& ymid = sve.ymid;
  ///
  static const char* format_333 = "(2(f12.5,1x))";
  /// C
  /// C.....y cut for mt spectrum
  /// Cbz3/17/99
  /// C      PARAMETER (YMT1 = -0.4, YMT2 = 0.4)
  /// Cbz3/17/99 end
  /// C.....bin width for mt spectrum and y spectrum
  /// C      PARAMETER (BMT = 0.05, BY = 0.2)
  /// Cc      SAVE /RUN/
  /// Cbz3/17/99
  /// C     &     dm1k0s(50), DMT1LA(50), DMT1LB(50)
  /// Cc      SAVE /ARPRC1/
  /// Cbz3/17/99 end
  /// Cc      SAVE /ARANA1/
  /// Cbz3/17/99
  /// C     &     dm2k0s(50), DMT2LA(50), DMT2LB(50)
  /// Cc      SAVE /ARANA2/
  /// Cbz3/17/99 end
  cmn.io.open(30, "ana/dndy_netb.dat").status("UNKNOWN");
  cmn.io.open(31, "ana/dndy_netp.dat").status("UNKNOWN");
  cmn.io.open(32, "ana/dndy_nb.dat").status("UNKNOWN");
  cmn.io.open(33, "ana/dndy_neg.dat").status("UNKNOWN");
  cmn.io.open(34, "ana/dndy_ch.dat").status("UNKNOWN");
  cmn.io.open(35, "ana/dnde_neg.dat").status("UNKNOWN");
  cmn.io.open(36, "ana/dnde_ch.dat").status("UNKNOWN");
  cmn.io.open(37, "ana/dndy_kp.dat").status("UNKNOWN");
  cmn.io.open(38, "ana/dndy_km.dat").status("UNKNOWN");
  /// Clin-4/24/03
  /// C      OPEN (39, FILE = 'ana/dndy_k0s.dat', STATUS = 'UNKNOWN')
  cmn.io.open(39, "ana/dndy_k0l.dat").status("UNKNOWN");
  cmn.io.open(40, "ana/dndy_la.dat").status("UNKNOWN");
  cmn.io.open(41, "ana/dndy_lb.dat").status("UNKNOWN");
  cmn.io.open(42, "ana/dndy_phi.dat").status("UNKNOWN");
  /// Cbz3/17/99
  cmn.io.open(43, "ana/dndy_meson.dat").status("UNKNOWN");
  cmn.io.open(44, "ana/dndy_pip.dat").status("UNKNOWN");
  cmn.io.open(45, "ana/dndy_pim.dat").status("UNKNOWN");
  cmn.io.open(46, "ana/dndy_pi0.dat").status("UNKNOWN");
  cmn.io.open(47, "ana/dndy_pr.dat").status("UNKNOWN");
  cmn.io.open(48, "ana/dndy_pb.dat").status("UNKNOWN");
  /// Cbz3/17/99 end
  /// C
  cmn.io.open(50, "ana/dndmtdy_pip.dat").status("UNKNOWN");
  cmn.io.open(51, "ana/dndmtdy_0_1_pim.dat").status("UNKNOWN");
  cmn.io.open(52, "ana/dndmtdy_pr.dat").status("UNKNOWN");
  cmn.io.open(53, "ana/dndmtdy_pb.dat").status("UNKNOWN");
  cmn.io.open(54, "ana/dndmtdy_kp.dat").status("UNKNOWN");
  cmn.io.open(55, "ana/dndmtdy_0_5_km.dat").status("UNKNOWN");
  cmn.io.open(56, "ana/dndmtdy_k0s.dat").status("UNKNOWN");
  cmn.io.open(57, "ana/dndmtdy_la.dat").status("UNKNOWN");
  cmn.io.open(58, "ana/dndmtdy_lb.dat").status("UNKNOWN");
  /// Clin-9/26/03 no symmetrization in y (or eta) for ana/*.dat:
  /// C      SCALE1 = 1. / REAL(NEVNT * NUM) / BY / 2.0
  const float by = 0.4f;
  scale1 = 1.f / fem::real(nevnt * num) / by;
  const float bmt = 0.05f;
  const float ymt2 = 1.0f;
  const float ymt1 = -1.0f;
  scale2 = 1.f / fem::real(nevnt * num) / bmt / (ymt2 - ymt1);
  /// C
  FEM_DO_SAFE(i, 1, 50) {
    ymid = -10.f + by * (i - 0.5f);
    write(30, format_333), ymid, scale1* dy1ntb(i);
    write(31, format_333), ymid, scale1* dy1ntp(i);
    write(32, format_333), ymid, scale1* dy1hm(i);
    write(37, format_333), ymid, scale1* dy1kp(i);
    write(38, format_333), ymid, scale1* dy1km(i);
    write(39, format_333), ymid, scale1* dy1k0s(i);
    write(40, format_333), ymid, scale1* dy1la(i);
    write(41, format_333), ymid, scale1* dy1lb(i);
    write(42, format_333), ymid, scale1* dy1phi(i);
    write(33, format_333), ymid, scale1* dy1neg(i);
    write(34, format_333), ymid, scale1* dy1ch(i);
    write(35, format_333), ymid, scale1* de1neg(i);
    write(36, format_333), ymid, scale1* de1ch(i);
    write(43, format_333), ymid, scale1* dy1msn(i);
    write(44, format_333), ymid, scale1* dy1pip(i);
    write(45, format_333), ymid, scale1* dy1pim(i);
    write(46, format_333), ymid, scale1* dy1pi0(i);
    write(47, format_333), ymid, scale1* dy1pr(i);
    write(48, format_333), ymid, scale1* dy1pb(i);
    /// C
    if (dm1pip(i) != 0.0f) {
      write(50, format_333), bmt*(i - 0.5f), scale2* dm1pip(i);
    }
    if (dm1pim(i) != 0.0f) {
      write(51, format_333), bmt*(i - 0.5f), scale2 * 0.1f * dm1pim(i);
    }
    if (dmt1pr(i) != 0.0f) {
      write(52, format_333), bmt*(i - 0.5f), scale2* dmt1pr(i);
    }
    if (dmt1pb(i) != 0.0f) {
      write(53, format_333), bmt*(i - 0.5f), scale2* dmt1pb(i);
    }
    if (dmt1kp(i) != 0.0f) {
      write(54, format_333), bmt*(i - 0.5f), scale2* dmt1kp(i);
    }
    if (dm1km(i) != 0.0f) {
      write(55, format_333), bmt*(i - 0.5f), scale2 * 0.5f * dm1km(i);
    }
    if (dm1k0s(i) != 0.0f) {
      write(56, format_333), bmt*(i - 0.5f), scale2* dm1k0s(i);
    }
    if (dmt1la(i) != 0.0f) {
      write(57, format_333), bmt*(i - 0.5f), scale2* dmt1la(i);
    }
    if (dmt1lb(i) != 0.0f) {
      write(58, format_333), bmt*(i - 0.5f), scale2* dmt1lb(i);
    }
  }
  /// C
  FEM_DO_SAFE(i, 30, 48) { write(i, star), "after hadron evolution"; }
  FEM_DO_SAFE(i, 50, 58) { write(i, star), "after hadron evolution"; }
  /// C
  FEM_DO_SAFE(i, 1, 50) {
    ymid = -10.f + by * (i - 0.5f);
    write(30, format_333), ymid, scale1* dy2ntb(i);
    write(31, format_333), ymid, scale1* dy2ntp(i);
    write(32, format_333), ymid, scale1* dy2hm(i);
    write(37, format_333), ymid, scale1* dy2kp(i);
    write(38, format_333), ymid, scale1* dy2km(i);
    write(39, format_333), ymid, scale1* dy2k0s(i);
    write(40, format_333), ymid, scale1* dy2la(i);
    write(41, format_333), ymid, scale1* dy2lb(i);
    write(42, format_333), ymid, scale1* dy2phi(i);
    write(33, format_333), ymid, scale1* dy2neg(i);
    write(34, format_333), ymid, scale1* dy2ch(i);
    write(35, format_333), ymid, scale1* de2neg(i);
    write(36, format_333), ymid, scale1* de2ch(i);
    write(43, format_333), ymid, scale1* dy2msn(i);
    write(44, format_333), ymid, scale1* dy2pip(i);
    write(45, format_333), ymid, scale1* dy2pim(i);
    write(46, format_333), ymid, scale1* dy2pi0(i);
    write(47, format_333), ymid, scale1* dy2pr(i);
    write(48, format_333), ymid, scale1* dy2pb(i);
    /// C
    if (dm2pip(i) != 0.0f) {
      write(50, format_333), bmt*(i - 0.5f), scale2* dm2pip(i);
    }
    if (dm2pim(i) != 0.0f) {
      write(51, format_333), bmt*(i - 0.5f), scale2 * 0.1f * dm2pim(i);
    }
    if (dmt2pr(i) != 0.0f) {
      write(52, format_333), bmt*(i - 0.5f), scale2* dmt2pr(i);
    }
    if (dmt2pb(i) != 0.0f) {
      write(53, format_333), bmt*(i - 0.5f), scale2* dmt2pb(i);
    }
    if (dmt2kp(i) != 0.0f) {
      write(54, format_333), bmt*(i - 0.5f), scale2* dmt2kp(i);
    }
    if (dm2km(i) != 0.0f) {
      write(55, format_333), bmt*(i - 0.5f), scale2 * 0.5f * dm2km(i);
    }
    if (dm2k0s(i) != 0.0f) {
      write(56, format_333), bmt*(i - 0.5f), scale2* dm2k0s(i);
    }
    if (dmt2la(i) != 0.0f) {
      write(57, format_333), bmt*(i - 0.5f), scale2* dmt2la(i);
    }
    if (dmt2lb(i) != 0.0f) {
      write(58, format_333), bmt*(i - 0.5f), scale2* dmt2lb(i);
    }
  }
  /// C
}

struct iarflv_save {
  float r;

  iarflv_save() : r(fem::float0) {}
};

/// C
/// C=======================================================================
/// C
/// C.....function to convert PDG flavor code into ART flavor code.
/// C
int iarflv(common& cmn, int const& ipdg) {
  int return_value = fem::int0;
  FEM_CMN_SVE(iarflv);
  /// SAVE
  float& r = sve.r;
  ///
  /// C
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  /// C.....anti-Delta-
  if (ipdg == -1114) {
    return_value = -6;
    return return_value;
  }
  /// C
  /// C.....anti-Delta0
  if (ipdg == -2114) {
    return_value = -7;
    return return_value;
  }
  /// C
  /// C.....anti-Delta+
  if (ipdg == -2214) {
    return_value = -8;
    return return_value;
  }
  /// C
  /// C.....anti-Delta++
  if (ipdg == -2224) {
    return_value = -9;
    return return_value;
  }
  /// C
  /// Cbzdbg2/23/99
  /// C.....anti-proton
  if (ipdg == -2212) {
    return_value = -1;
    return return_value;
  }
  /// C
  /// C.....anti-neutron
  if (ipdg == -2112) {
    return_value = -2;
    return return_value;
  }
  /// Cbzdbg2/23/99end
  /// C
  /// C.....eta
  if (ipdg == 221) {
    return_value = 0;
    return return_value;
  }
  /// C
  /// C.....proton
  if (ipdg == 2212) {
    return_value = 1;
    return return_value;
  }
  /// C
  /// C.....neutron
  if (ipdg == 2112) {
    return_value = 2;
    return return_value;
  }
  /// C
  /// C.....pi-
  if (ipdg == -211) {
    return_value = 3;
    return return_value;
  }
  /// C
  /// C.....pi0
  if (ipdg == 111) {
    return_value = 4;
    return return_value;
  }
  /// C
  /// C.....pi+
  if (ipdg == 211) {
    return_value = 5;
    return return_value;
  }
  /// C
  /// C.....Delta-
  if (ipdg == 1114) {
    return_value = 6;
    return return_value;
  }
  /// C
  /// C.....Delta0
  if (ipdg == 2114) {
    return_value = 7;
    return return_value;
  }
  /// C
  /// C.....Delta+
  if (ipdg == 2214) {
    return_value = 8;
    return return_value;
  }
  /// C
  /// C.....Delta++
  if (ipdg == 2224) {
    return_value = 9;
    return return_value;
  }
  /// C
  /// C.....Lambda
  if (ipdg == 3122) {
    return_value = 14;
    return return_value;
  }
  /// C
  /// C.....Lambda-bar
  if (ipdg == -3122) {
    return_value = -14;
    return return_value;
  }
  /// C
  /// C.....Sigma-
  if (ipdg == 3112) {
    return_value = 15;
    return return_value;
  }
  /// C
  /// C.....Sigma-bar
  if (ipdg == -3112) {
    return_value = -15;
    return return_value;
  }
  /// C
  /// C.....Sigma0
  if (ipdg == 3212) {
    return_value = 16;
    return return_value;
  }
  /// C
  /// C.....Sigma0-bar
  if (ipdg == -3212) {
    return_value = -16;
    return return_value;
  }
  /// C
  /// C.....Sigma+
  if (ipdg == 3222) {
    return_value = 17;
    return return_value;
  }
  /// C
  /// C.....Sigma+ -bar
  if (ipdg == -3222) {
    return_value = -17;
    return return_value;
  }
  /// C
  /// C.....K-
  if (ipdg == -321) {
    return_value = 21;
    return return_value;
  }
  /// C
  /// C.....K+
  if (ipdg == 321) {
    return_value = 23;
    return return_value;
  }
  /// C
  /// C.....temporary entry for K0
  if (ipdg == 311) {
    return_value = 23;
    return return_value;
  }
  /// C
  /// C.....temporary entry for K0bar
  if (ipdg == -311) {
    return_value = 21;
    return return_value;
  }
  /// C
  /// C.....temporary entry for K0S and K0L
  if (ipdg == 310 || ipdg == 130) {
    r = ranart(cmn.nseed);
    if (r > 0.5f) {
      return_value = 23;
    } else {
      return_value = 21;
    }
    return return_value;
  }
  /// C
  /// C.....rho-
  if (ipdg == -213) {
    return_value = 25;
    return return_value;
  }
  /// C
  /// C.....rho0
  if (ipdg == 113) {
    return_value = 26;
    return return_value;
  }
  /// C
  /// C.....rho+
  if (ipdg == 213) {
    return_value = 27;
    return return_value;
  }
  /// C
  /// C.....omega
  if (ipdg == 223) {
    return_value = 28;
    return return_value;
  }
  /// C
  /// C.....phi
  if (ipdg == 333) {
    return_value = 29;
    return return_value;
  }
  /// C
  /// C.....K*+
  if (ipdg == 323) {
    return_value = 30;
    return return_value;
  }
  /// C.....K*-
  if (ipdg == -323) {
    return_value = -30;
    return return_value;
  }
  /// C.....temporary entry for K*0
  if (ipdg == 313) {
    return_value = 30;
    return return_value;
  }
  /// C.....temporary entry for K*0bar
  if (ipdg == -313) {
    return_value = -30;
    return return_value;
  }
  /// C
  /// C...... eta-prime
  if (ipdg == 331) {
    return_value = 31;
    return return_value;
  }
  /// C
  /// C...... a1
  /// C     IF (IPDG .EQ. 777) THEN
  /// C        IARFLV = 32
  /// C        RETURN
  /// C     END IF
  /// C
  /// C... cascade-
  if (ipdg == 3312) {
    return_value = 40;
    return return_value;
  }
  /// C
  /// C... cascade+ (bar)
  if (ipdg == -3312) {
    return_value = -40;
    return return_value;
  }
  /// C
  /// C... cascade0
  if (ipdg == 3322) {
    return_value = 41;
    return return_value;
  }
  /// C
  /// C... cascade0 -bar
  if (ipdg == -3322) {
    return_value = -41;
    return return_value;
  }
  /// C
  /// C... Omega-
  if (ipdg == 3334) {
    return_value = 45;
    return return_value;
  }
  /// C
  /// C... Omega+ (bar)
  if (ipdg == -3334) {
    return_value = -45;
    return return_value;
  }
  /// C
  /// C... Di-Omega
  if (ipdg == 6666) {
    return_value = 44;
    return return_value;
  }
  /// C sp06/05/01 end
  /// C
  /// Clin-3/2009 keep the same ID numbers in case there are initial deuterons:
  if (ipdg == 42 || ipdg == -42) {
    return_value = ipdg;
    return return_value;
  }
  /// C
  /// C.....other
  return_value = ipdg + 10000;
  /// C
  return return_value;
}

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....function to convert ART flavor code into PDG flavor code.
/// C
int invflv(common& cmn, int const& iart) {
  int return_value = fem::int0;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// C
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  /// C.....anti-Delta-
  if (iart == -6) {
    return_value = -1114;
    return return_value;
  }
  /// C
  /// C.....anti-Delta0
  if (iart == -7) {
    return_value = -2114;
    return return_value;
  }
  /// C
  /// C.....anti-Delta+
  if (iart == -8) {
    return_value = -2214;
    return return_value;
  }
  /// C
  /// C.....anti-Delta++
  if (iart == -9) {
    return_value = -2224;
    return return_value;
  }
  /// C
  /// Cbzdbg2/23/99
  /// C.....anti-proton
  if (iart == -1) {
    return_value = -2212;
    return return_value;
  }
  /// C
  /// C.....anti-neutron
  if (iart == -2) {
    return_value = -2112;
    return return_value;
  }
  /// Cbzdbg2/23/99end
  /// C
  /// C.....eta
  if (iart == 0) {
    return_value = 221;
    return return_value;
  }
  /// C
  /// C.....proton
  if (iart == 1) {
    return_value = 2212;
    return return_value;
  }
  /// C
  /// C.....neutron
  if (iart == 2) {
    return_value = 2112;
    return return_value;
  }
  /// C
  /// C.....pi-
  if (iart == 3) {
    return_value = -211;
    return return_value;
  }
  /// C
  /// C.....pi0
  if (iart == 4) {
    return_value = 111;
    return return_value;
  }
  /// C
  /// C.....pi+
  if (iart == 5) {
    return_value = 211;
    return return_value;
  }
  /// C
  /// C.....Delta-
  if (iart == 6) {
    return_value = 1114;
    return return_value;
  }
  /// C
  /// C.....Delta0
  if (iart == 7) {
    return_value = 2114;
    return return_value;
  }
  /// C
  /// C.....Delta+
  if (iart == 8) {
    return_value = 2214;
    return return_value;
  }
  /// C
  /// C.....Delta++
  if (iart == 9) {
    return_value = 2224;
    return return_value;
  }
  /// C
  /// Cc.....N*(1440), N*(1535) temporary entry
  /// C      IF (IART .GE. 10 .AND. IART .LE.13) THEN
  /// C         INVFLV = 0
  /// C         RETURN
  /// C      END IF
  /// C
  /// C.....Lambda
  if (iart == 14) {
    return_value = 3122;
    return return_value;
  }
  /// C.....Lambda-bar
  if (iart == -14) {
    return_value = -3122;
    return return_value;
  }
  /// C
  /// Cbz3/12/99
  /// C.....temporary entry for Sigma's
  /// C      IF (IART .EQ. 15) THEN
  /// C         R = RANART(NSEED)
  /// C         IF (R .GT. 2. / 3.) THEN
  /// C            INVFLV = 3112
  /// C         ELSE IF (R .GT. 1./ 3. .AND. R .LE. 2. / 3.) THEN
  /// C            INVFLV = 3212
  /// C         ELSE
  /// C            INVFLV = 3222
  /// C         END IF
  /// C         RETURN
  /// C      END IF
  /// C
  /// C.....Sigma-
  if (iart == 15) {
    return_value = 3112;
    return return_value;
  }
  /// C
  /// C.....Sigma- bar
  if (iart == -15) {
    return_value = -3112;
    return return_value;
  }
  /// C
  /// C.....Sigma0
  if (iart == 16) {
    return_value = 3212;
    return return_value;
  }
  /// C
  /// C.....Sigma0 -bar
  if (iart == -16) {
    return_value = -3212;
    return return_value;
  }
  /// C
  /// C.....Sigma+
  if (iart == 17) {
    return_value = 3222;
    return return_value;
  }
  /// C
  /// C.....Sigma+ -bar
  if (iart == -17) {
    return_value = -3222;
    return return_value;
  }
  /// C
  /// Clin-2/23/03 K0S and K0L are generated at the last timestep:
  /// C.....temporary entry for K- and K0bar
  if (iart == 21) {
    /// C         R = RANART(NSEED)
    /// C         IF (R .GT. 0.5) THEN
    return_value = -321;
    /// C         ELSE
    /// C            INVFLV = -311
    /// C            R = RANART(NSEED)
    /// C            IF (R .GT. 0.5) THEN
    /// C               INVFLV = 310
    /// C            ELSE
    /// C               INVFLV = 130
    /// C            END IF
    /// C         END IF
    return return_value;
  }
  /// C
  /// C.....temporary entry for K+ and K0
  if (iart == 23) {
    /// C         R = RANART(NSEED)
    /// C         IF (R .GT. 0.5) THEN
    return_value = 321;
    /// C         ELSE
    /// C            INVFLV = 311
    /// C            R = RANART(NSEED)
    /// C            IF (R .GT. 0.5) THEN
    /// C               INVFLV = 310
    /// C            ELSE
    /// C               INVFLV = 130
    /// C            END IF
    /// C         END IF
    return return_value;
  }
  /// C
  /// C.....K0Long:
  if (iart == 22) {
    return_value = 130;
    return return_value;
  }
  /// C.....K0Short:
  if (iart == 24) {
    return_value = 310;
    return return_value;
  }
  /// C
  /// C.....rho-
  if (iart == 25) {
    return_value = -213;
    return return_value;
  }
  /// C
  /// C.....rho0
  if (iart == 26) {
    return_value = 113;
    return return_value;
  }
  /// C
  /// C.....rho+
  if (iart == 27) {
    return_value = 213;
    return return_value;
  }
  /// C
  /// C.....omega
  if (iart == 28) {
    return_value = 223;
    return return_value;
  }
  /// C
  /// C.....phi
  if (iart == 29) {
    return_value = 333;
    return return_value;
  }
  /// C
  /// C.....temporary entry for K*+ and K*0
  if (iart == 30) {
    return_value = 323;
    if (ranart(nseed) > 0.5f) {
      return_value = 313;
    }
    return return_value;
  }
  /// C
  /// C.....temporary entry for K*- and K*0bar
  if (iart == -30) {
    return_value = -323;
    if (ranart(nseed) > 0.5f) {
      return_value = -313;
    }
    return return_value;
  }
  /// C
  /// C... eta-prime (bar)
  if (iart == 31) {
    return_value = 331;
    return return_value;
  }
  /// C
  /// C... a1
  if (iart == 32) {
    return_value = 777;
    return return_value;
  }
  /// C
  /// C... cascade-
  if (iart == 40) {
    return_value = 3312;
    return return_value;
  }
  /// C
  /// C... cascade+ (bar)
  if (iart == -40) {
    return_value = -3312;
    return return_value;
  }
  /// C
  /// C... cascade0
  if (iart == 41) {
    return_value = 3322;
    return return_value;
  }
  /// C
  /// C... cascade0 -bar
  if (iart == -41) {
    return_value = -3322;
    return return_value;
  }
  /// C
  /// C... Omega-
  if (iart == 45) {
    return_value = 3334;
    return return_value;
  }
  /// C
  /// C... Omega+ (bar)
  if (iart == -45) {
    return_value = -3334;
    return return_value;
  }
  /// C
  /// C... Di-Omega
  if (iart == 44) {
    return_value = 6666;
    return return_value;
  }
  /// C sp 12/19/00 end
  /// C
  /// Clin-5/2008 deuteron ID numbers in ART and ampt.dat:
  if (iart == 42) {
    return_value = 42;
    return return_value;
  } else if (iart == -42) {
    return_value = -42;
    return return_value;
  }
  /// C
  /// C.....other
  return_value = iart - 10000;
  /// C
  return return_value;
}

struct coulin_save {
  int i;
  int irun;
  int mass;

  coulin_save() : i(fem::int0), irun(fem::int0), mass(fem::int0) {}
};

/// C*********************************
void coulin(common& cmn, int const& masspr, int const& massta, int const& num) {
  FEM_CMN_SVE(coulin);
  /// COMMON ee
  const int maxstr = 150001;
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON zz
  int& zta = cmn.zta;
  int& zpr = cmn.zpr;
  ///
  /// SAVE
  int& i = sve.i;
  int& irun = sve.irun;
  int& mass = sve.mass;
  ///
  /// C                                                                      *
  /// C     purpose:   initialization of array zet() and lb() for all runs  *
  /// C                lb(i) = 1   =>  proton                               *
  /// C                lb(i) = 2   =>  neutron                              *
  /// C*********************************
  /// Cc      SAVE /EE/
  /// Cc      SAVE /zz/
  mass = massta + masspr;
  FEM_DO_SAFE(irun, 1, num) {
    FEM_DO_SAFE(i, 1 + (irun - 1) * mass, zta + (irun - 1) * mass) {
      lb(i) = 1;
    }
    FEM_DO_SAFE(i, zta + 1 + (irun - 1) * mass, massta + (irun - 1) * mass) {
      lb(i) = 2;
    }
    FEM_DO_SAFE(i, massta + 1 + (irun - 1) * mass,
                massta + zpr + (irun - 1) * mass) {
      lb(i) = 1;
    }
    FEM_DO_SAFE(i, massta + zpr + 1 + (irun - 1) * mass,
                massta + masspr + (irun - 1) * mass) {
      lb(i) = 2;
    }
  }
}

struct x2kaon_save {
  float f1;
  float f2;
  float f3;
  float sigma1;
  float sigma2;
  float sigma3;
  float smin;
  float x;

  x2kaon_save()
      : f1(fem::float0),
        f2(fem::float0),
        f3(fem::float0),
        sigma1(fem::float0),
        sigma2(fem::float0),
        sigma3(fem::float0),
        smin(fem::float0),
        x(fem::float0) {}
};

/// C
/// C*****************************************
/// C for pp-->pp + kaon + anti-kaon
/// C      real*4 function X2kaon(srt)
float x2kaon(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x2kaon);
  /// SAVE
  float& f1 = sve.f1;
  float& f2 = sve.f2;
  float& f3 = sve.f3;
  float& sigma1 = sve.sigma1;
  float& sigma2 = sve.sigma2;
  float& sigma3 = sve.sigma3;
  float& smin = sve.smin;
  float& x = sve.x;
  ///
  /// C  This function contains the experimental total pp->pp+K(+)K(-) Xsections
  /// * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb
  /// * C * C***************************************** C     minimum c.m.s.
  /// energy to create 2 kaon. = 2*(mp+mk)
  smin = 2.8639f;
  return_value = 0.0000001f;
  if (srt < smin) {
    return return_value;
  }
  sigma1 = 2.8f;
  sigma2 = 7.7f;
  sigma3 = 3.9f;
  x = fem::pow2(srt) / fem::pow2(smin) + 0.0000001f;
  f1 = (1.f + 1.f / fem::sqrt(x)) * fem::alog(x) -
       4.f * (1.f - 1.f / fem::sqrt(x));
  f2 = 1.f - (1.f / fem::sqrt(x)) * (1.f + fem::alog(fem::sqrt(x)));
  f3 = fem::pow(((x - 1.f) / fem::pow2(x)), 3.5f);
  return_value =
      fem::pow3((1.f - 1.f / x)) * (sigma1 * f1 + sigma2 * f2) + sigma3 * f3;
  return return_value;
}

struct pinsg0_save {
  float ratio;
  float srt0;

  pinsg0_save() : ratio(fem::float0), srt0(fem::float0) {}
};

float pinsg0(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pinsg0);
  /// SAVE
  float& ratio = sve.ratio;
  float& srt0 = sve.srt0;
  ///
  /// C cross section in mb for PI- + P -> P + K0 + K-
  /// C     Mn + 2* Mk
  srt0 = 0.938f + 2.f * 0.498f;
  if (srt < srt0) {
    return_value = 0.0f;
    return return_value;
  }
  ratio = fem::pow2(srt0) / fem::pow2(srt);
  return_value = 1.121f * fem::pow((1.f - ratio), 1.86f) * fem::pow2(ratio);
  return return_value;
}

struct aknel_save {
  float sigma1;

  aknel_save() : sigma1(fem::float0) {}
};

float aknel(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  FEM_CMN_SVE(aknel);
  /// SAVE
  float& sigma1 = sve.sigma1;
  ///
  /// Ccross section in mb for K- + N reactions.
  /// C        the following data come from PRC 41 (1701)
  /// C        sigma1: K(-) + neutron elastic
  if (pkaon < 0.5f || pkaon >= 4.0f) {
    sigma1 = 0.f;
  }
  if (pkaon >= 0.5f && pkaon < 1.0f) {
    sigma1 = 20.f * fem::pow(pkaon, 2.74f);
  }
  if (pkaon >= 1.0f && pkaon < 4.0f) {
    sigma1 = 20.f * fem::pow(pkaon, (-1.8f));
  }
  return_value = sigma1;
  return return_value;
}

struct akpel_save {
  float sigma2;

  akpel_save() : sigma2(fem::float0) {}
};

float akpel(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  FEM_CMN_SVE(akpel);
  /// SAVE
  float& sigma2 = sve.sigma2;
  ///
  /// Ccross section in mb for K- + N reactions.
  /// C        the following data come from PRC 41 (1701)
  /// C        sigma2: K(-) + proton elastic
  if (pkaon < 0.25f || pkaon >= 4.0f) {
    sigma2 = 0.f;
  }
  if (pkaon >= 0.25f && pkaon < 4.0f) {
    sigma2 = 13.f * fem::pow(pkaon, (-0.9f));
  }
  return_value = sigma2;
  return return_value;
}

struct aknsgm_save {
  float sigma2;

  aknsgm_save() : sigma2(fem::float0) {}
};

float aknsgm(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  FEM_CMN_SVE(aknsgm);
  /// SAVE
  float& sigma2 = sve.sigma2;
  ///
  /// Ccross section in mb for K- + N reactions.
  /// C        sigma2: x section for K- + n -> sigma0 + PI-
  if (pkaon < 0.5f || pkaon >= 6.0f) {
    sigma2 = 0.f;
  }
  if (pkaon >= 0.5f && pkaon < 1.0f) {
    sigma2 = 1.2f * fem::pow(pkaon, (-1.3f));
  }
  if (pkaon >= 1.0f && pkaon < 6.0f) {
    sigma2 = 1.2f * fem::pow(pkaon, (-2.3f));
  }
  return_value = sigma2;
  return return_value;
}

struct akpsgm_save {
  float sigma1;

  akpsgm_save() : sigma1(fem::float0) {}
};

float akpsgm(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  FEM_CMN_SVE(akpsgm);
  /// SAVE
  float& sigma1 = sve.sigma1;
  ///
  /// Ccross section in mb for K- + N reactions.
  /// C        sigma1: x section for K- + p -> sigma0 + PI0
  if (pkaon < 0.2f || pkaon >= 1.5f) {
    sigma1 = 0.f;
  }
  if (pkaon >= 0.2f && pkaon < 1.5f) {
    sigma1 = 0.6f * fem::pow(pkaon, (-1.8f));
  }
  return_value = sigma1;
  return return_value;
}

struct akplam_save {
  float p;
  float sigma;

  akplam_save() : p(fem::float0), sigma(fem::float0) {}
};

float akplam(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  FEM_CMN_SVE(akplam);
  /// SAVE
  float& p = sve.p;
  float& sigma = sve.sigma;
  ///
  /// Ccross section in mb for K- + N reactions.
  /// C        sigma: x section for K- + p -> lambda + PI0
  p = pkaon;
  if (pkaon < 0.2f || pkaon >= 10.0f) {
    sigma = 0.f;
  }
  if (pkaon >= 0.2f && pkaon < 0.9f) {
    sigma = 50.f * fem::pow2(p) - 67.f * p + 24.f;
  }
  if (pkaon >= 0.9f && pkaon < 10.0f) {
    sigma = 3.0f * fem::pow(pkaon, (-2.6f));
  }
  return_value = sigma;
  return return_value;
}

float aknlam(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  /// Ccross section in mb for K- + N reactions.
  return_value = akplam(cmn, pkaon);
  return return_value;
}

struct fstate_save {
  float aka;
  float bbb;
  float beta;
  float ekm;
  float ekmax;
  float ekp;
  float fac;
  float gama;
  float guass;
  int icount;
  arr<float> pe;
  float pio;
  float pkmax;
  float ptkm;
  float ptkmi2;
  float ptkp;
  float ptkpl2;
  float ptp;
  float ptp2;
  float pzcms;
  float pzkm;
  float pzkp;
  float resten;
  float restms;
  float restpz;
  float rmt3;
  float rmt4;
  float rsq;
  float v1;
  float v2;
  float xstar;

  fstate_save()
      : aka(fem::float0),
        bbb(fem::float0),
        beta(fem::float0),
        ekm(fem::float0),
        ekmax(fem::float0),
        ekp(fem::float0),
        fac(fem::float0),
        gama(fem::float0),
        guass(fem::float0),
        icount(fem::int0),
        pe(dimension(4), fem::fill0),
        pio(fem::float0),
        pkmax(fem::float0),
        ptkm(fem::float0),
        ptkmi2(fem::float0),
        ptkp(fem::float0),
        ptkpl2(fem::float0),
        ptp(fem::float0),
        ptp2(fem::float0),
        pzcms(fem::float0),
        pzkm(fem::float0),
        pzkp(fem::float0),
        resten(fem::float0),
        restms(fem::float0),
        restpz(fem::float0),
        rmt3(fem::float0),
        rmt4(fem::float0),
        rsq(fem::float0),
        v1(fem::float0),
        v2(fem::float0),
        xstar(fem::float0) {}
};

void fstate(common& cmn, int const& /* iseed */, float const& srt,
            float const& dm3, float const& dm4, arr_ref<float> px,
            arr_ref<float> py, arr_ref<float> pz, int& iflag) {
  FEM_CMN_SVE(fstate);
  px(dimension(4));
  py(dimension(4));
  pz(dimension(4));
  common_write write(cmn);
  int& nseed = cmn.nseed;
  ///
  float& aka = sve.aka;
  float& bbb = sve.bbb;
  float& beta = sve.beta;
  float& ekm = sve.ekm;
  float& ekmax = sve.ekmax;
  float& ekp = sve.ekp;
  float& fac = sve.fac;
  float& gama = sve.gama;
  float& guass = sve.guass;
  int& icount = sve.icount;
  arr_ref<float> pe(sve.pe, dimension(4));
  float& pio = sve.pio;
  float& pkmax = sve.pkmax;
  float& ptkm = sve.ptkm;
  float& ptkmi2 = sve.ptkmi2;
  float& ptkp = sve.ptkp;
  float& ptkpl2 = sve.ptkpl2;
  float& ptp = sve.ptp;
  float& ptp2 = sve.ptp2;
  float& pzcms = sve.pzcms;
  float& pzkm = sve.pzkm;
  float& pzkp = sve.pzkp;
  float& resten = sve.resten;
  float& restms = sve.restms;
  float& restpz = sve.restpz;
  float& rmt3 = sve.rmt3;
  float& rmt4 = sve.rmt4;
  float& rsq = sve.rsq;
  float& v1 = sve.v1;
  float& v2 = sve.v2;
  float& xstar = sve.xstar;
  /// C        function: decide final momentum for N,N,K(+),and K(-)
  /// Cc      SAVE /RNDF77/
  /// C
  iflag = -1;
  /// C        iflag=-1: fail to find momenta
  /// C             = 1: success
  pio = 3.1415926f;
  aka = 0.498f;
  /// C        v=0.43
  /// C        w=-0.84
  /// C        b=3.78
  /// C        c=0.47
  /// C        d=3.60
  /// C        fmax=1.056
  /// C        gmax=1.+c
  /// C
  icount = 0;
  ekmax = (srt - dm3 - dm4) / 2.f;
  if (ekmax <= aka) {
    return;
  }
  pkmax = fem::sqrt(fem::pow2(ekmax) - fem::pow2(aka));
  /// C
  if (dm3 <= 0.0f || dm4 <= 0.0f) {
    write(1, star), "error: minus mass!!!";
    return;
  }
/// C
/// C        after we have the momenta for both nucleus, we sample the
/// C        transverse momentum for K-.
/// C        dsigma/dpt**2 = exp(-4.145*pt**2) obtained by fitting data on
/// C        page 72, fig 23i.
statement_50:
  icount++;
  if (icount > 10) {
    return;
  }
  ptkmi2 = -1.f / 4.145f * fem::alog(ranart(nseed));
  ptkm = fem::sqrt(ptkmi2);
statement_3:
  v1 = ranart(nseed);
  v2 = ranart(nseed);
  rsq = fem::pow2(v1) + fem::pow2(v2);
  if (rsq >= 1.0f || rsq <= 0.f) {
    goto statement_3;
  }
  fac = fem::sqrt(-2.f * fem::alog(rsq) / rsq);
  guass = v1 * fac;
  if (guass >= 5.f) {
    goto statement_3;
  }
  xstar = guass / 5.f;
  pzkm = pkmax * xstar;
  ekm = fem::sqrt(fem::pow2(aka) + fem::pow2(pzkm) + fem::pow2(ptkm));
  if (ranart(nseed) > aka / ekm) {
    goto statement_50;
  }
  bbb = ranart(nseed);
  px(3) = ptkm * fem::cos(2.f * pio * bbb);
  py(3) = ptkm * fem::sin(2.f * pio * bbb);
  if (ranart(nseed) > 0.5f) {
    pzkm = -1.f * pzkm;
  }
  pz(3) = pzkm;
  pe(3) = ekm;
statement_150:
  ptkpl2 = -1.f / 3.68f * fem::alog(ranart(nseed));
  ptkp = fem::sqrt(ptkpl2);
statement_13:
  v1 = ranart(nseed);
  v2 = ranart(nseed);
  rsq = fem::pow2(v1) + fem::pow2(v2);
  if (rsq >= 1.0f || rsq <= 0.f) {
    goto statement_13;
  }
  fac = fem::sqrt(-2.f * fem::alog(rsq) / rsq);
  guass = v1 * fac;
  if (guass >= 3.25f) {
    goto statement_13;
  }
  xstar = guass / 3.25f;
  pzkp = pkmax * xstar;
  ekp = fem::sqrt(fem::pow2(aka) + fem::pow2(pzkp) + fem::pow2(ptkp));
  if (ranart(nseed) > aka / ekp) {
    goto statement_150;
  }
  bbb = ranart(nseed);
  px(4) = ptkp * fem::cos(2.f * pio * bbb);
  py(4) = ptkp * fem::sin(2.f * pio * bbb);
  if (ranart(nseed) > 0.5f) {
    pzkp = -1.f * pzkp;
  }
  pz(4) = pzkp;
  pe(4) = ekp;
  /// C
  resten = srt - pe(3) - pe(4);
  restpz = -pz(3) - pz(4);
  /// C     resample
  if (resten <= fem::abs(restpz)) {
    goto statement_50;
  }
  restms = fem::sqrt(fem::pow2(resten) - fem::pow2(restpz));
  /// C     resample
  if (restms < (dm3 + dm4)) {
    goto statement_50;
  }
  ptp2 = -1.f / 2.76f * fem::alog(ranart(nseed));
  ptp = fem::sqrt(ptp2);
  bbb = ranart(nseed);
  px(2) = ptp * fem::cos(2.f * pio * bbb);
  py(2) = ptp * fem::sin(2.f * pio * bbb);
  px(1) = -1.f * (px(4) + px(3) + px(2));
  py(1) = -1.f * (py(4) + py(3) + py(2));
  /// C     transverse mass for K-
  rmt3 = fem::sqrt(fem::pow2(dm3) + fem::pow2(px(1)) + fem::pow2(py(1)));
  /// C     transverse mass for K+
  rmt4 = fem::sqrt(fem::pow2(dm4) + fem::pow2(px(2)) + fem::pow2(py(2)));
  if (restms < (rmt3 + rmt4)) {
    goto statement_50;
  }
  /// C        else: sampling success!
  pzcms = fem::sqrt((fem::pow2(restms) - fem::pow2((rmt3 + rmt4))) *
                    (fem::pow2(restms) - fem::pow2((rmt3 - rmt4)))) /
          2.f / restms;
  if (ranart(nseed) > 0.5f) {
    pz(1) = pzcms;
    pz(2) = -pzcms;
  } else {
    pz(1) = -pzcms;
    pz(2) = pzcms;
  }
  beta = restpz / resten;
  gama = 1.f / fem::sqrt(1.f - fem::pow2(beta));
  pz(1) = pz(1) * gama +
          beta * gama * fem::sqrt(fem::pow2(rmt3) + fem::pow2(pz(1)));
  pz(2) = pz(2) * gama +
          beta * gama * fem::sqrt(fem::pow2(rmt4) + fem::pow2(pz(2)));
  pe(1) = fem::sqrt(fem::pow2(rmt3) + fem::pow2(pz(1)));
  pe(2) = fem::sqrt(fem::pow2(rmt4) + fem::pow2(pz(2)));
  /// C
  iflag = 1;
}

struct rotate_save {
  float c1;
  float c2;
  float ct1;
  float ct2;
  float pr;
  float pr0;
  float s1;
  float s2;
  float scheck;
  float ss;
  float st1;
  float st2;
  float t1;
  float t2;

  rotate_save()
      : c1(fem::float0),
        c2(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        pr(fem::float0),
        pr0(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        scheck(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t2(fem::float0) {}
};

/// C**************************************
void rotate(common& cmn, float const& px0, float const& py0, float const& pz0,
            float& px, float& py, float& pz) {
  FEM_CMN_SVE(rotate);
  common_write write(cmn);
  /// SAVE
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& pr = sve.pr;
  float& pr0 = sve.pr0;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& scheck = sve.scheck;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t2 = sve.t2;
  ///
  /// C purpose: rotate the momentum of a particle in the CMS of p1+p2 such that
  /// C the x' y' and z' in the cms of p1+p2 is the same as the fixed x y and z
  /// C quantities:
  /// C            px0,py0 and pz0 are the cms momentum of the incoming
  /// colliding C            particles C            px, py and pz are the cms
  /// momentum of any one of the particles C            after the collision to
  /// be rotated C************************************** C the momentum, polar
  /// and azimuthal angles of the incoming momentm
  pr0 = fem::sqrt(fem::pow2(px0) + fem::pow2(py0) + fem::pow2(pz0));
  if (pr0 == 0) {
    pr0 = 0.00000001f;
  }
  c2 = pz0 / pr0;
  if (px0 == 0.0f && py0 == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py0, px0);
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck45: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  /// C      S2  =  SQRT( 1.0 - C2**2 )
  /// C
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  /// C the momentum, polar and azimuthal angles of the momentum to be rotated
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  if (pr == 0) {
    pr = 0.0000001f;
  }
  c1 = pz / pr;
  if (px == 0 && py == 0) {
    t1 = 0.f;
  } else {
    t1 = fem::atan2(py, px);
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c1);
  if (scheck < 0) {
    write(99, star), "scheck46: ", scheck;
    scheck = 0.f;
  }
  s1 = fem::sqrt(scheck);
  /// C      S1   = SQRT( 1.0 - C1**2 )
  /// C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ss = c2 * s1 * ct1 + s2 * c1;
  /// C THE MOMENTUM AFTER ROTATION
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
}

struct nnkaon_save {
  float betaak;
  float betak;
  float dm3;
  float dm4;
  float e1cm;
  float e2cm;
  float epcmak;
  float epcmk;
  float eti1;
  float eti2;
  int iflag;
  int lb1;
  int lb2;
  int n;
  float p1beta;
  float p2beta;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  arr<float> px;
  float pxrota;
  arr<float> py;
  float pyrota;
  arr<float> pz;
  float pzrota;
  float transf;

  nnkaon_save()
      : betaak(fem::float0),
        betak(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        e1cm(fem::float0),
        e2cm(fem::float0),
        epcmak(fem::float0),
        epcmk(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        iflag(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        n(fem::int0),
        p1beta(fem::float0),
        p2beta(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px(dimension(4), fem::fill0),
        pxrota(fem::float0),
        py(dimension(4), fem::fill0),
        pyrota(fem::float0),
        pz(dimension(4), fem::fill0),
        pzrota(fem::float0),
        transf(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....extracted from G. Song's ART expasion including K- interactions
/// C.....file `NEWNNK.FOR'
/// C
void nnkaon(common& cmn, int const& irun, int const& iseed, int& ictrl,
            int const& i1, int const& i2, int& iblock, float const& srt,
            float const& pcx, float const& pcy, float const& pcz,
            int const& nchrg) {
  FEM_CMN_SVE(nnkaon);
  /// COMMON aa
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  /// COMMON bb
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  /// COMMON nn
  int& nnn = cmn.nnn;
  /// COMMON pa
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  /// COMMON pb
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  /// COMMON pc
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  /// COMMON pd
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  /// COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  /// SAVE
  float& betaak = sve.betaak;
  float& betak = sve.betak;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& epcmak = sve.epcmak;
  float& epcmk = sve.epcmk;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  int& iflag = sve.iflag;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  int& n = sve.n;
  float& p1beta = sve.p1beta;
  float& p2beta = sve.p2beta;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  arr_ref<float> px(sve.px, dimension(4));
  float& pxrota = sve.pxrota;
  arr_ref<float> py(sve.py, dimension(4));
  float& pyrota = sve.pyrota;
  arr_ref<float> pz(sve.pz, dimension(4));
  float& pzrota = sve.pzrota;
  float& transf = sve.transf;
  ///
  /// C        <pt>=0.27+0.037*log(srt) was changed to 0.632 + ... on Aug. 14,
  /// 1997 C     CANCELED also alpha=1 changed to alpha=3 to decrease the leadng
  /// effect. Cc      SAVE /AA/ Cc      SAVE /BB/ Cc      SAVE /CC/ Cc      SAVE
  /// /EE/ Cc      SAVE /BG/ Cc      SAVE /NN/ Cc      SAVE /RUN/ Cc      SAVE
  /// /PA/ Cc      SAVE /PB/ Cc      SAVE /PC/ Cc      SAVE /PD/ C dm1=e(i1) C
  /// dm2=e(i2)
  dm3 = 0.938f;
  dm4 = 0.938f;
  /// C     10/24/02 initialize n to 0:
  n = 0;
  /// C
  /// Cbz3/11/99 neutralk
  /// C        if(nchrg.eq.-2.or.nchrg.ge.3) dm3=1.232
  /// C        if(nchrg.eq.4) dm4=1.232
  if (nchrg <= -1 || nchrg >= 3) {
    dm3 = 1.232f;
  }
  if (nchrg == -2 || nchrg == 4) {
    dm4 = 1.232f;
  }
  /// Cbz3/11/99 neutralk end
  iblock = 0;
  fstate(cmn, iseed, srt, dm3, dm4, px, py, pz, iflag);
  if (iflag < 0) {
    /// C           write(60,*)'------------final state fail-------',n
    /// C     no anti-kaon production
    ictrl = -1;
    n++;
    return;
  }
  iblock = 12;
  /// C Rotate the momenta of particles in the cms of I1 & I2
  /// C px(1), py(1), pz(1): momentum of I1
  /// C px(2), py(2), pz(2): momentum of I2
  /// C px(3), py(3), pz(3): momentum of anti-kaon
  /// C px(4), py(4), pz(4): momentum of kaon
  /// C
  /// C     10/28/02 get rid of argument usage mismatch in rotate():
  pxrota = px(1);
  pyrota = py(1);
  pzrota = pz(1);
  /// C        call rotate(pcx,pcy,pcz,px(1),py(1),pz(1))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  px(1) = pxrota;
  py(1) = pyrota;
  pz(1) = pzrota;
  /// C
  pxrota = px(2);
  pyrota = py(2);
  pzrota = pz(2);
  /// C        call rotate(pcx,pcy,pcz,px(2),py(2),pz(2))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  px(2) = pxrota;
  py(2) = pyrota;
  pz(2) = pzrota;
  /// C
  pxrota = px(3);
  pyrota = py(3);
  pzrota = pz(3);
  /// C        call rotate(pcx,pcy,pcz,px(3),py(3),pz(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  px(3) = pxrota;
  py(3) = pyrota;
  pz(3) = pzrota;
  /// C
  pxrota = px(4);
  pyrota = py(4);
  pzrota = pz(4);
  /// C        call rotate(pcx,pcy,pcz,px(4),py(4),pz(4))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  px(4) = pxrota;
  py(4) = pyrota;
  pz(4) = pzrota;
  /// C
  nnn += 2;
  /// C     K+
  lpion(nnn, irun) = 23;
  if (nchrg == -1 || nchrg == -2) {
    /// C        To keep charge conservation. D-n->nnK0K-, D-D- -> nD-K0K-
    /// C
    /// Cbz3/7/99 neutralk
    /// C           lpion(nnn,irun)=24 ! K0
    /// Cbz3/7/99 neutralk end
    /// C
  }
  /// C     aka: rest mass of K
  const float aka = 0.498f;
  epion(nnn, irun) = aka;
  /// C     K-
  lpion(nnn - 1, irun) = 21;
  /// C     aka: rest mass of K
  epion(nnn - 1, irun) = aka;
  /// C Find the momenta of particles in the final state in the nucleus_nucleus
  /// C cms frame.   Lorentz transformation into lab frame.
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px(1)) + fem::pow2(py(1)) +
                   fem::pow2(pz(1)));
  p1beta = px(1) * betax + py(1) * betay + pz(1) * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px(1);
  pt2i1 = betay * transf + py(1);
  pt3i1 = betaz * transf + pz(1);
  eti1 = dm3;
  /// C        lb1   = lb(i1)
  lb1 = 2;
  if (nchrg >= -2 && nchrg <= 1) {
    lb1 = 2;
  }
  /// C
  /// Cbz3/7/99 neutralk
  if (nchrg == -2 || nchrg == -1) {
    lb1 = 6;
  }
  /// Cbz3/7/99 neutralk end
  /// C
  /// Cbz3/11/99 neutralk
  /// C        if(nchrg.eq.2.or.nchrg.eq.3) lb1=1
  /// C        if(nchrg.eq.4) lb1=9
  if (nchrg == 1 || nchrg == 2) {
    lb1 = 1;
  }
  if (nchrg == 3 || nchrg == 4) {
    lb1 = 9;
  }
  /// Cbz3/11/99 neutralk end
  /// C
  /// C For second nulceon, same
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px(2)) + fem::pow2(py(2)) +
                   fem::pow2(pz(2)));
  p2beta = px(2) * betax + py(2) * betay + pz(2) * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1) + e2cm);
  pt1i2 = betax * transf + px(2);
  pt2i2 = betay * transf + py(2);
  pt3i2 = betaz * transf + pz(2);
  eti2 = dm4;
  /// C        lb2   = lb(i2)
  lb2 = 2;
  /// C
  /// Cbz3/11/99 neutralk
  /// C        if(nchrg.eq.-1.or.nchrg.eq.0) lb2=2
  /// C        if(nchrg.eq. 2.or.nchrg.eq.1) lb2=1
  /// C        if(nchrg.eq. 4.or.nchrg.eq.3) lb2=9
  /// C        if(nchrg.eq.-2) lb2=6
  if (nchrg >= -1 || nchrg <= 1) {
    lb2 = 2;
  }
  if (nchrg == 2 || nchrg == 3) {
    lb2 = 1;
  }
  if (nchrg == 4) {
    lb2 = 9;
  }
  if (nchrg == -2) {
    lb2 = 6;
  }
  /// Cbz3/11/99 neutralk end
  /// C
  /// C        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  /// C
  /// C                px1 = p(1,i1)
  /// C                py1 = p(2,i1)
  /// C                pz1 = p(3,i1)
  /// C                em1 = e(i1)
  /// C                id(i1) = 2
  /// C                id(i2) = 2
  /// C                id1 = id(i1)
  /// C                iblock = 101  ! K(+)K(-) production
  /// C Get anti-kaons' momenta and coordinates in nucleus-nucleus cms. frame.
  epcmk = fem::sqrt(fem::pow2(epion(nnn - 1, irun)) + fem::pow2(px(3)) +
                    fem::pow2(py(3)) + fem::pow2(pz(3)));
  betak = px(3) * betax + py(3) * betay + pz(3) * betaz;
  transf = gamma * (gamma * betak / (gamma + 1.f) + epcmk);
  ppion(1, nnn - 1, irun) = betax * transf + px(3);
  ppion(2, nnn - 1, irun) = betay * transf + py(3);
  ppion(3, nnn - 1, irun) = betaz * transf + pz(3);
  rpion(1, nnn - 1, irun) = r(1, i1);
  rpion(2, nnn - 1, irun) = r(2, i1);
  rpion(3, nnn - 1, irun) = r(3, i1);
  /// Clin-5/2008:
  dppion(nnn - 1, irun) = dpertp(i1) * dpertp(i2);
  /// C Same thing for kaon **************************************
  epcmak = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(px(4)) +
                     fem::pow2(py(4)) + fem::pow2(pz(4)));
  betaak = px(4) * betax + py(4) * betay + pz(4) * betaz;
  transf = gamma * (gamma * betaak / (gamma + 1.f) + epcmak);
  ppion(1, nnn, irun) = betax * transf + px(4);
  ppion(2, nnn, irun) = betay * transf + py(4);
  ppion(3, nnn, irun) = betaz * transf + pz(4);
  rpion(1, nnn, irun) = r(1, i2);
  rpion(2, nnn, irun) = r(2, i2);
  rpion(3, nnn, irun) = r(3, i2);
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
}

struct lorntz_save {
  float bb;
  float deno3;
  float ga;
  float gam;
  int i;
  float pib;
  float pjb;

  lorntz_save()
      : bb(fem::float0),
        deno3(fem::float0),
        ga(fem::float0),
        gam(fem::float0),
        i(fem::int0),
        pib(fem::float0),
        pjb(fem::float0) {}
};

void lorntz(common& cmn, int const& ilo, arr_cref<float> b, arr_ref<float> pi,
            arr_ref<float> pj) {
  FEM_CMN_SVE(lorntz);
  b(dimension(3));
  pi(dimension(4));
  pj(dimension(4));
  float& bb = sve.bb;
  float& deno3 = sve.deno3;
  float& ga = sve.ga;
  float& gam = sve.gam;
  int& i = sve.i;
  float& pib = sve.pib;
  float& pjb = sve.pjb;
  /// C       It uses to perform Lorentz (or inverse Lorentz) transformation
  /// C       dimension db(3)
  bb = b(1) * b(1) + b(2) * b(2) + b(3) * b(3);
  deno3 = fem::sqrt(1.f - bb);
  if (deno3 == 0.f) {
    deno3 = 1.e-10f;
  }
  gam = 1.f / deno3;
  ga = gam * gam / (gam + 1.f);
  if (ilo == 1) {
    goto statement_100;
  }
  /// C       Lorentz transformation
  pib = pi(1) * b(1) + pi(2) * b(2) + pi(3) * b(3);
  pjb = pj(1) * b(1) + pj(2) * b(2) + pj(3) * b(3);
  /// C       drb=drd(1)*b(1)+drd(2)*b(2)+drd(3)*b(3)
  /// C       drdb=db(1)*b(1)+db(2)*b(2)+db(3)*b(3)
  FEM_DO_SAFE(i, 1, 3) {
    pi(i) += b(i) * (ga * pib - gam * pi(4));
    pj(i) += b(i) * (ga * pjb - gam * pj(4));
    /// C       drd(i)=drd(i)+b(i)*ga*drb
    /// C       db(i)=db(i)+b(i)*ga*drdb
  }
  pi(4) = gam * (pi(4) - pib);
  pj(4) = gam * (pj(4) - pjb);
  return;
statement_100:
  /// C       inverse Lorentz transformation
  pib = pi(1) * b(1) + pi(2) * b(2) + pi(3) * b(3);
  pjb = pj(1) * b(1) + pj(2) * b(2) + pj(3) * b(3);
  FEM_DO_SAFE(i, 1, 3) {
    pi(i) += b(i) * (ga * pib + gam * pi(4));
    pj(i) += b(i) * (ga * pjb + gam * pj(4));
  }
  pi(4) = gam * (pi(4) + pib);
  pj(4) = gam * (pj(4) + pjb);
}

struct npik_save {
  arr<float> bb;
  float betak;
  float css;
  float e1cm;
  float e2cm;
  float eip;
  float epcmk;
  float eti1;
  float eti2;
  float fai;
  int i;
  int ilo;
  int k;
  int k1;
  int k2;
  int lb1;
  int lb2;
  arr<float> p1;
  float p1beta;
  arr<float> p2;
  float p2beta;
  arr<float> p3;
  float pk;
  float pkmax;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  arr<float> px;
  float px1cm;
  float pxrota;
  arr<float> py;
  float py1cm;
  float pyrota;
  arr<float> pz;
  float pz1cm;
  float pznp;
  float pzrota;
  float rmnp;
  float sss;
  float transf;

  npik_save()
      : bb(dimension(3), fem::fill0),
        betak(fem::float0),
        css(fem::float0),
        e1cm(fem::float0),
        e2cm(fem::float0),
        eip(fem::float0),
        epcmk(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fai(fem::float0),
        i(fem::int0),
        ilo(fem::int0),
        k(fem::int0),
        k1(fem::int0),
        k2(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        p1(dimension(4), fem::fill0),
        p1beta(fem::float0),
        p2(dimension(4), fem::fill0),
        p2beta(fem::float0),
        p3(dimension(4), fem::fill0),
        pk(fem::float0),
        pkmax(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px(dimension(4), fem::fill0),
        px1cm(fem::float0),
        pxrota(fem::float0),
        py(dimension(4), fem::fill0),
        py1cm(fem::float0),
        pyrota(fem::float0),
        pz(dimension(4), fem::fill0),
        pz1cm(fem::float0),
        pznp(fem::float0),
        pzrota(fem::float0),
        rmnp(fem::float0),
        sss(fem::float0),
        transf(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....extracted from G. Song's ART expasion including K- interactions
/// C.....file `NPIK.FOR'
/// C
/// C***************************************
/// C        subroutine npik(irun,iseed,dt,nt,ictrl,i1,i2,srt,
/// C     &                  pcx,pcy,pcz,nchrg,ratiok)
void npik(common& cmn, int const& irun, int const& /* iseed */,
          float const& /* dt */, int const& /* nt */, int& ictrl, int const& i1,
          int const& i2, float const& srt, float const& pcx, float const& pcy,
          float const& pcz, int const& /* nchrg */, float const& /* ratiok */,
          int& iblock) {
  FEM_CMN_SVE(npik);
  /// COMMON aa
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  /// COMMON bb
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  /// COMMON nn
  int& nnn = cmn.nnn;
  /// COMMON pa
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  /// COMMON pb
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  /// COMMON pc
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  /// COMMON pd
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  /// SAVE
  arr_ref<float> bb(sve.bb, dimension(3));
  float& betak = sve.betak;
  float& css = sve.css;
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& eip = sve.eip;
  float& epcmk = sve.epcmk;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fai = sve.fai;
  int& i = sve.i;
  int& ilo = sve.ilo;
  int& k = sve.k;
  int& k1 = sve.k1;
  int& k2 = sve.k2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  arr_ref<float> p1(sve.p1, dimension(4));
  float& p1beta = sve.p1beta;
  arr_ref<float> p2(sve.p2, dimension(4));
  float& p2beta = sve.p2beta;
  arr_ref<float> p3(sve.p3, dimension(4));
  float& pk = sve.pk;
  float& pkmax = sve.pkmax;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxrota = sve.pxrota;
  float& pyrota = sve.pyrota;
  float& pznp = sve.pznp;
  float& pzrota = sve.pzrota;
  float& rmnp = sve.rmnp;
  float& sss = sve.sss;
  float& transf = sve.transf;
  ///
  /// C
  /// C Process: PI + N -> K(-) + ANYTHING
  /// C 1.  PI- + P -> P + K0 + K-
  /// C 2.  PI+ + N -> P + K+ + K-
  /// C 3.  PI0 + P -> P + K+ + K-
  /// C 4.  PI0 + N -> P + K0 + K-
  /// C 5.  PI0 + N -> N + K+ + K-
  /// C 6.  PI- + P -> N + K+ + K-
  /// C 7.  PI- + N -> N + K0 + K-
  /// C NOTE: the mass of K is assumed to be same as K0. ie. 0.498 NOT 0.494
  /// C***************************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /RNDF77/
  sve.px1cm = pcx;
  sve.py1cm = pcy;
  sve.pz1cm = pcz;
  ictrl = 1;
  lb1 = lb(i1);
  lb2 = lb(i2);
  k1 = i1;
  k2 = i2;
  /// C        k1 must be bayron. k2 be meson. If not, exchange.
  if (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13)) {
    k1 = i2;
    k2 = i1;
  }
  /// Cbz3/8/99 neutralk
  /// Cbz10/12/99
  /// C        LB(I1) = 1 + 2 * RANART(NSEED)
  /// C        LB(I2) = 23
  lb(k1) = 1 + fem::fint(2 * ranart(nseed));
  lb(k2) = 23;
  /// C pkmax=sqrt((srt**2-(aka+0.938+aka)**2)*(srt**2-(aka+0.938-aka)**2)) C &
  /// /2./srt
  const float aka = 0.498f;
  pkmax = fem::sqrt((fem::pow2(srt) - fem::pow2((aka + 0.938f + aka))) *
                    (fem::pow2(srt) - fem::pow2((aka + 0.938f - aka)))) /
          2.f / srt;
  pk = ranart(nseed) * pkmax;
  /// C-----------------------------------------------------
  css = 1.f - 2.f * ranart(nseed);
  sss = fem::sqrt(1.f - fem::pow2(css));
  fai = 2 * 3.1415926f * ranart(nseed);
  p3(1) = pk * sss * fem::cos(fai);
  p3(2) = pk * sss * fem::sin(fai);
  p3(3) = pk * css;
  eip = srt - fem::sqrt(fem::pow2(aka) + fem::pow2(pk));
  rmnp = fem::sqrt(fem::pow2(eip) - fem::pow2(pk));
  FEM_DO_SAFE(i, 1, 3) { bb(i) = -1.f * p3(i) / eip; }
  /// C        bb: velocity of the other two particles as a whole.
  pznp = fem::sqrt((fem::pow2(rmnp) - fem::pow2((aka + 0.938f))) *
                   (fem::pow2(rmnp) - fem::pow2((0.938f - aka)))) /
         2.f / rmnp;
  /// C-----------------------------------------------------
  css = 1.f - 2.f * ranart(nseed);
  sss = fem::sqrt(1.f - fem::pow2(css));
  fai = 2 * 3.1415926f * ranart(nseed);
  p1(1) = pznp * sss * fem::cos(fai);
  p1(2) = pznp * sss * fem::sin(fai);
  p1(3) = pznp * css;
  p1(4) = fem::sqrt(fem::pow2(0.938f) + fem::pow2(pznp));
  p2(4) = fem::sqrt(fem::pow2(aka) + fem::pow2(pznp));
  FEM_DO_SAFE(i, 1, 3) { p2(i) = -1.f * p1(i); }
  /// C        p1,p2: the momenta of the two particles in their cms
  /// C        p1: momentum of N or P
  /// C        p2: momentum of anti_kaon
  /// C        p3: momentum of K0 or K+
  ilo = 1;
  /// C        write(61,*)'--------p1,p2',p1,p2
  /// C        write(61,*)'--------bb',bb
  lorntz(cmn, ilo, bb, p1, p2);
  /// C******* Checking *************
  /// C        pxsum = p1(1)+p2(1)+p3(1)
  /// C        pysum = p1(2)+p2(2)+p3(2)
  /// C        pzsum = p1(3)+p2(3)+p3(3)
  /// C        pesum = p1(4)+p2(4)+sqrt(p3(1)**2+p3(2)**2+p3(3)**2+aka**2)-srt
  /// C        write(61,*)'---p1,pxsum',p1,pxsum
  /// C        write(61,*)'---p2,pysum',p2,pysum
  /// C        write(61,*)'---p3,pzsum',p3,pzsum
  /// C        write(61,*)'---pesum',pesum
  /// C***********************************
  /// C
  /// C Rotate the momenta of particles in the cms of I1 & I2
  /// C px(1), py(1), pz(1): momentum of I1
  /// C px(2), py(2), pz(2): momentum of I2
  /// C px(3), py(3), pz(3): momentum of anti-kaon
  /// C
  /// C     10/28/02 get rid of argument usage mismatch in rotate():
  pxrota = p1(1);
  pyrota = p1(2);
  pzrota = p1(3);
  /// C        call rotate(pcx,pcy,pcz,p1(1),p1(2),p1(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p1(1) = pxrota;
  p1(2) = pyrota;
  p1(3) = pzrota;
  /// C
  pxrota = p2(1);
  pyrota = p2(2);
  pzrota = p2(3);
  /// C        call rotate(pcx,pcy,pcz,p2(1),p2(2),p2(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p2(1) = pxrota;
  p2(2) = pyrota;
  p2(3) = pzrota;
  /// C
  pxrota = p3(1);
  pyrota = p3(2);
  pzrota = p3(3);
  /// C        call rotate(pcx,pcy,pcz,p3(1),p3(2),p3(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p3(1) = pxrota;
  p3(2) = pyrota;
  p3(3) = pzrota;
  /// C
  nnn++;
  /// C     K(-)
  lpion(nnn, irun) = 21;
  /// C     aka: rest mass of K
  epion(nnn, irun) = aka;
  /// C Find the momenta of particles in the final state in the nucleus_nucleus
  /// C cms frame.   Lorentz transformation into lab frame.
  e1cm = fem::sqrt(fem::pow2(0.938f) + fem::pow2(p1(1)) + fem::pow2(p1(2)) +
                   fem::pow2(p1(3)));
  p1beta = p1(1) * betax + p1(2) * betay + p1(3) * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + p1(1);
  pt2i1 = betay * transf + p1(2);
  pt3i1 = betaz * transf + p1(3);
  eti1 = 0.938f;
  lb1 = lb(k1);
  /// C
  /// C For second nulceon, same
  e2cm = fem::sqrt(fem::pow2(aka) + fem::pow2(p3(1)) + fem::pow2(p3(2)) +
                   fem::pow2(p3(3)));
  p2beta = p3(1) * betax + p3(2) * betay + p3(3) * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1) + e2cm);
  pt1i2 = betax * transf + p3(1);
  pt2i2 = betay * transf + p3(2);
  pt3i2 = betaz * transf + p3(3);
  eti2 = aka;
  lb2 = lb(k2);
  /// C
  /// C        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
  /// C       k1 stand for nucleon, k2 stand for kaon. lpion stand for Kbar.
  p(1, k1) = pt1i1;
  p(2, k1) = pt2i1;
  p(3, k1) = pt3i1;
  e(k1) = eti1;
  lb(k1) = lb1;
  p(1, k2) = pt1i2;
  p(2, k2) = pt2i2;
  p(3, k2) = pt3i2;
  e(k2) = eti2;
  lb(k2) = lb2;
  /// C
  /// C                px1 = p(1,i1)
  /// C                py1 = p(2,i1)
  /// C                pz1 = p(3,i1)
  /// C                em1 = e(i1)
  /// C                id(i1) = 2
  /// C                id(i2) = 2
  /// C                id1 = id(i1)
  /// C     K(+)K(-) production
  iblock = 101;
  /// C Get Kaons' momenta and coordinates in nucleus-nucleus cms. frame.
  /// C  p2:  momentum of anti-kaon.
  /// C        epcmk = sqrt(epion(nnn,irun)**2 + p2(1)**2 + p2(2)**2 + p2(3)**2)
  epcmk = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(p2(1)) +
                    fem::pow2(p2(2)) + fem::pow2(p2(3)));
  betak = p2(1) * betax + p2(2) * betay + p2(3) * betaz;
  transf = gamma * (gamma * betak / (gamma + 1.f) + epcmk);
  ppion(1, nnn, irun) = betax * transf + p2(1);
  ppion(2, nnn, irun) = betay * transf + p2(2);
  ppion(3, nnn, irun) = betaz * transf + p2(3);
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Cbz3/2/99
  /// C        write(400,*)'2 ', ppion(1,nnn,irun), ppion(2,nnn,irun),
  /// C     &                    ppion(3,nnn,irun), dt*nt, srt
  /// Cbz3/2/99end
  /// C        write(420,*)ppion(1,nnn,irun), ppion(2,nnn,irun),
  /// C     &                    ppion(3,nnn,irun), dt*nt, srt
  k = i2;
  if (lb(i1) == 1 || lb(i1) == 2) {
    k = i1;
  }
  rpion(1, nnn, irun) = r(1, k);
  rpion(2, nnn, irun) = r(2, k);
  rpion(3, nnn, irun) = r(3, k);
}

struct pihypn_save {
  float css;
  float dm3;
  float dm4;
  float e1cm;
  float e2cm;
  float eti1;
  float eti2;
  float fai;
  int i;
  int k1;
  int k2;
  int lb1;
  int lb2;
  arr<float> p1;
  float p1beta;
  arr<float> p2;
  float p2beta;
  float pk;
  float pkmax;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px1cm;
  float pxrota;
  float py1cm;
  float pyrota;
  float pz1cm;
  float pzrota;
  float sss;
  float transf;

  pihypn_save()
      : css(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        e1cm(fem::float0),
        e2cm(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fai(fem::float0),
        i(fem::int0),
        k1(fem::int0),
        k2(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        p1(dimension(4), fem::fill0),
        p1beta(fem::float0),
        p2(dimension(4), fem::fill0),
        p2beta(fem::float0),
        pk(fem::float0),
        pkmax(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px1cm(fem::float0),
        pxrota(fem::float0),
        py1cm(fem::float0),
        pyrota(fem::float0),
        pz1cm(fem::float0),
        pzrota(fem::float0),
        sss(fem::float0),
        transf(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....extracted from G. Song's ART expasion including K- interactions
/// C.....file `PIHYPN.FOR'
/// C
/// C*****************************************
void pihypn(common& cmn, int const& ielstc, int const& /* irun */,
            int const& /* iseed */, float const& /* dt */, int const& /* nt */,
            int& ictrl, int const& i1, int const& i2, float const& srt,
            float const& pcx, float const& pcy, float const& pcz,
            int const& nchrg, int& iblock) {
  FEM_CMN_SVE(pihypn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& css = sve.css;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fai = sve.fai;
  int& i = sve.i;
  int& k1 = sve.k1;
  int& k2 = sve.k2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  arr_ref<float> p1(sve.p1, dimension(4));
  float& p1beta = sve.p1beta;
  arr_ref<float> p2(sve.p2, dimension(4));
  float& p2beta = sve.p2beta;
  float& pk = sve.pk;
  float& pkmax = sve.pkmax;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxrota = sve.pxrota;
  float& pyrota = sve.pyrota;
  float& pzrota = sve.pzrota;
  float& sss = sve.sss;
  float& transf = sve.transf;
  ///
  /// C
  /// C Process: PI + sigma(or Lambda) -> Kbar + N
  /// C NOTE: the mass of K is assumed to be same as K0. ie. 0.498 NOT 0.494
  /// C*****************************************
  /// C
  /// C NOTE: for PI + Hyperon: the produced kaons have mass 0.498
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /RNDF77/
  sve.px1cm = pcx;
  sve.py1cm = pcy;
  sve.pz1cm = pcz;
  ictrl = 1;
  /// Csp06/07/01
  const float aka = 0.498f;
  if (ielstc == 1) {
    /// C    L/Si + meson -> L/Si + meson
    k1 = i1;
    k2 = i2;
    dm3 = e(k1);
    dm4 = e(k2);
    iblock = 10;
  } else {
    iblock = 12;
    /// Csp06/07/01 end
    /// C        PI + Sigma(or Lambda) -> Kbar + N
    k1 = i1;
    k2 = i2;
    /// C        k1 must be bayron! So if I1 is PI, exchange k1 & k2.
    if (lb(i1) < 14 || lb(i1) > 17) {
      k1 = i2;
      k2 = i1;
    }
    /// Cbz3/8/99 neutralk
    lb(k1) = 1 + fem::fint(2 * ranart(nseed));
    if (nchrg == -2) {
      lb(k1) = 6;
    }
    /// C     if(nchrg.eq.-1) lb(k1)=2
    /// C     if(nchrg.eq. 0) lb(k1)=1
    /// C     if(nchrg.eq. 1) lb(k1)=9
    if (nchrg == 2) {
      lb(k1) = 9;
    }
    /// Cbz3/8/99 neutralk end
    /// C
    /// C     K-
    lb(k2) = 21;
    dm3 = 0.938f;
    if (nchrg == -2 || nchrg == 1) {
      dm3 = 1.232f;
    }
    dm4 = aka;
    /// C        dm3,dm4: the mass of final state particles.
  }
  /// C
  /// C*******Now, antikaon will be created.
  /// C        call antikaon_fstate(iseed,srt,dm1,dm2,dm3,dm4,px,py,pz,icou1)
  /// C        pkmax: the maximum momentum of anti-kaon
  pkmax = fem::sqrt((fem::pow2(srt) - fem::pow2((dm3 + dm4))) *
                    (fem::pow2(srt) - fem::pow2((dm3 - dm4)))) /
          2.f / srt;
  pk = pkmax;
  /// C-----------------------------------------------------
  css = 1.f - 2.f * ranart(nseed);
  sss = fem::sqrt(1.f - fem::pow2(css));
  fai = 2 * 3.1415926f * ranart(nseed);
  p1(1) = pk * sss * fem::cos(fai);
  p1(2) = pk * sss * fem::sin(fai);
  p1(3) = pk * css;
  FEM_DO_SAFE(i, 1, 3) { p2(i) = -1.f * p1(i); }
  /// C        p1,p2: the momenta of the two particles in their cms
  /// C        p1: momentum of kaon
  /// C        p2: momentum of Kbar
  /// C
  /// C Rotate the momenta of particles in the cms of I1 & I2
  /// Clin-10/28/02 get rid of argument usage mismatch in rotate():
  pxrota = p1(1);
  pyrota = p1(2);
  pzrota = p1(3);
  /// C        call rotate(pcx,pcy,pcz,p1(1),p1(2),p1(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p1(1) = pxrota;
  p1(2) = pyrota;
  p1(3) = pzrota;
  /// C
  pxrota = p2(1);
  pyrota = p2(2);
  pzrota = p2(3);
  /// C        call rotate(pcx,pcy,pcz,p2(1),p2(2),p2(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p2(1) = pxrota;
  p2(2) = pyrota;
  p2(3) = pzrota;
  /// Clin-10/28/02-end
  /// C
  /// C Find the momenta of particles in the final state in the nucleus_nucleus
  /// C cms frame.   Lorentz transformation into lab frame.
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(p1(1)) + fem::pow2(p1(2)) +
                   fem::pow2(p1(3)));
  p1beta = p1(1) * betax + p1(2) * betay + p1(3) * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + p1(1);
  pt2i1 = betay * transf + p1(2);
  pt3i1 = betaz * transf + p1(3);
  eti1 = dm3;
  lb1 = lb(k1);
  /// C
  /// C For second kaon, same
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(p2(1)) + fem::pow2(p2(2)) +
                   fem::pow2(p2(3)));
  p2beta = p2(1) * betax + p2(2) * betay + p2(3) * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1) + e2cm);
  pt1i2 = betax * transf + p2(1);
  pt2i2 = betay * transf + p2(2);
  pt3i2 = betaz * transf + p2(3);
  /// Cbz3/2/99
  /// C        write(400,*)'3 ', pt1i2, pt2i2, pt3i2, dt*nt, srt
  /// Cbz3/2/99end
  /// C        write(430,*)pt1i2, pt2i2, pt3i2, dt*nt, srt
  eti2 = dm4;
  lb2 = lb(k2);
  /// C
  /// C        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
  /// C        k1=i1
  /// C        k2=i2
  /// C       k1 stand for nucleon, k2 stand for kaon.
  p(1, k1) = pt1i1;
  p(2, k1) = pt2i1;
  p(3, k1) = pt3i1;
  e(k1) = eti1;
  lb(k1) = lb1;
  p(1, k2) = pt1i2;
  p(2, k2) = pt2i2;
  p(3, k2) = pt3i2;
  e(k2) = eti2;
  lb(k2) = lb2;
  /// C
  /// Cc                iblock = 101  ! K(+)K(-) production
  /// C Get Kaons' momenta and coordinates in nucleus-nucleus cms. frame.
}

struct kaonn_save {
  float css;
  float e1cm;
  float e2cm;
  float eee;
  float em1;
  float em2;
  float eti1;
  float eti2;
  float fai;
  int i;
  int k1;
  int k2;
  int lb1;
  int lb2;
  arr<float> p1;
  float p1beta;
  arr<float> p2;
  float p2beta;
  float pk;
  float pkmax;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px1cm;
  float pxrota;
  float py1cm;
  float pyrota;
  float pz1cm;
  float pzrota;
  float rrr;
  float sss;
  float transf;

  kaonn_save()
      : css(fem::float0),
        e1cm(fem::float0),
        e2cm(fem::float0),
        eee(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fai(fem::float0),
        i(fem::int0),
        k1(fem::int0),
        k2(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        p1(dimension(4), fem::fill0),
        p1beta(fem::float0),
        p2(dimension(4), fem::fill0),
        p2beta(fem::float0),
        pk(fem::float0),
        pkmax(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px1cm(fem::float0),
        pxrota(fem::float0),
        py1cm(fem::float0),
        pyrota(fem::float0),
        pz1cm(fem::float0),
        pzrota(fem::float0),
        rrr(fem::float0),
        sss(fem::float0),
        transf(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....extracted from G. Song's ART expasion including K- interactions
/// C.....file `KAONN.FOR'
/// C
/// C***************************************
void kaonn(common& cmn, float const& brel, float const& brsgm,
           int const& /* irun */, int const& /* iseed */, float const& /* dt */,
           int const& /* nt */, int& ictrl, int const& i1, int const& i2,
           int& iblock, float const& srt, float const& pcx, float const& pcy,
           float const& pcz, int const& /* nchrg */) {
  FEM_CMN_SVE(kaonn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& css = sve.css;
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fai = sve.fai;
  int& i = sve.i;
  int& k1 = sve.k1;
  int& k2 = sve.k2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  arr_ref<float> p1(sve.p1, dimension(4));
  float& p1beta = sve.p1beta;
  arr_ref<float> p2(sve.p2, dimension(4));
  float& p2beta = sve.p2beta;
  float& pk = sve.pk;
  float& pkmax = sve.pkmax;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxrota = sve.pxrota;
  float& pyrota = sve.pyrota;
  float& pzrota = sve.pzrota;
  float& rrr = sve.rrr;
  float& sss = sve.sss;
  float& transf = sve.transf;
  ///
  /// C
  /// C Process: PI + sigma(or Lambda) <- Kbar + N
  /// C NOTE: the mass of K is assumed to be same as K0. ie. 0.498 NOT 0.494
  /// C***************************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /RNDF77/
  sve.px1cm = pcx;
  sve.py1cm = pcy;
  sve.pz1cm = pcz;
  ictrl = 1;
  /// C        ratio: used for isospin decision.
  k1 = i1;
  k2 = i2;
  /// C        k1 must be bayron! So if I1 is Kaon, exchange k1 & k2.
  if (e(i1) < 0.5f && e(i1) > 0.01f) {
    k1 = i2;
    k2 = i1;
  }
  /// C** note: for print out only *******************************
  /// C     record kaon's mass
  sve.eee = e(k2);
  /// C** end **************
  rrr = ranart(nseed);
  const float asa = 1.1974f;
  const float ala = 1.1157f;
  if (rrr < brel) {
    /// C       Kbar + N -> Kbar + N
    lb1 = lb(k1);
    lb2 = lb(k2);
    em1 = e(k1);
    em2 = e(k2);
    iblock = 10;
  } else {
    iblock = 12;
    if (rrr < (brel + brsgm)) {
      /// C        nchrg: Net charges of the two incoming particles.
      /// C           Kbar + N -> Sigma + PI
      em1 = asa;
      em2 = 0.138f;
      /// C
      /// Cbz3/8/99 neutralk
      lb1 = 15 + fem::fint(3 * ranart(nseed));
      lb2 = 3 + fem::fint(3 * ranart(nseed));
    } else {
      /// C           Kbar + N -> Lambda + PI
      em1 = ala;
      em2 = 0.138f;
      /// C     LAmbda
      lb1 = 14;
      /// Cbz3/8/99 neutralk
      lb2 = 3 + fem::fint(3 * ranart(nseed));
      /// C           if(nchrg.eq.1)  lb2=5  ! K- + D++ -> Lambda + PI+
      /// C           if(nchrg.eq.0)  lb2=4  ! K- + p(D+,N*+) -> Lambda + PI0
      /// C          if(nchrg.eq.-1) lb2=3 ! K- + n(D,N*) -> Lambda + PI-
      /// Cbz3/8/99 neutralk
      /// C
    }
  }
  lb(k1) = lb1;
  lb(k2) = lb2;
  /// C
  /// C*******Now, antikaon will be created.
  /// C        call antikaon_fstate(iseed,srt,dm1,dm2,dm3,dm4,px,py,pz,icou1)
  /// C        pkmax: the maximum momentum of anti-kaon
  /// C        write(63,*)'srt,em1,em2',srt,em1,em2
  /// C        write(63,*)'-srt,em1,em2',srt,em1,em2
  pkmax = fem::sqrt((fem::pow2(srt) - fem::pow2((em1 + em2))) *
                    (fem::pow2(srt) - fem::pow2((em1 - em2)))) /
          2.f / srt;
  pk = pkmax;
  /// C-----------------------------------------------------
  css = 1.f - 2.f * ranart(nseed);
  sss = fem::sqrt(1.f - fem::pow2(css));
  fai = 2 * 3.1415926f * ranart(nseed);
  p1(1) = pk * sss * fem::cos(fai);
  p1(2) = pk * sss * fem::sin(fai);
  p1(3) = pk * css;
  FEM_DO_SAFE(i, 1, 3) { p2(i) = -1.f * p1(i); }
  /// C        p1,p2: the momenta of the two particles in their cms
  /// C        p1: momentum of kaon
  /// C        p2: momentum of Kbar
  /// C
  /// C Rotate the momenta of particles in the cms of I1 & I2
  /// C
  /// Clin-10/28/02 get rid of argument usage mismatch in rotate():
  pxrota = p1(1);
  pyrota = p1(2);
  pzrota = p1(3);
  /// C        call rotate(pcx,pcy,pcz,p1(1),p1(2),p1(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p1(1) = pxrota;
  p1(2) = pyrota;
  p1(3) = pzrota;
  /// C
  pxrota = p2(1);
  pyrota = p2(2);
  pzrota = p2(3);
  /// C        call rotate(pcx,pcy,pcz,p2(1),p2(2),p2(3))
  rotate(cmn, pcx, pcy, pcz, pxrota, pyrota, pzrota);
  p2(1) = pxrota;
  p2(2) = pyrota;
  p2(3) = pzrota;
  /// Clin-10/28/02-end
  /// C
  /// C Find the momenta of particles in the final state in the nucleus_nucleus
  /// C cms frame.   Lorentz transformation into lab frame.
  e1cm = fem::sqrt(fem::pow2(em1) + fem::pow2(p1(1)) + fem::pow2(p1(2)) +
                   fem::pow2(p1(3)));
  p1beta = p1(1) * betax + p1(2) * betay + p1(3) * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + p1(1);
  pt2i1 = betay * transf + p1(2);
  pt3i1 = betaz * transf + p1(3);
  eti1 = em1;
  /// C
  /// C For second kaon, same
  e2cm = fem::sqrt(fem::pow2(em2) + fem::pow2(p2(1)) + fem::pow2(p2(2)) +
                   fem::pow2(p2(3)));
  p2beta = p2(1) * betax + p2(2) * betay + p2(3) * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1) + e2cm);
  pt1i2 = betax * transf + p2(1);
  pt2i2 = betay * transf + p2(2);
  pt3i2 = betaz * transf + p2(3);
  eti2 = em2;
  /// C
  /// C        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
  /// C        k1=i1
  /// C        k2=i2
  /// C       k1 stand for bayron, k2 stand for meson.
  p(1, k1) = pt1i1;
  p(2, k1) = pt2i1;
  p(3, k1) = pt3i1;
  e(k1) = eti1;
  p(1, k2) = pt1i2;
  p(2, k2) = pt2i2;
  p(3, k2) = pt3i2;
  e(k2) = eti2;
  /// C
  /// Cc                iblock = 101  ! K(+)K(-) production
  /// C Get Kaons' momenta and coordinates in nucleus-nucleus cms. frame.
}

struct distce_save {
  float bbb;
  float ddd;
  float drbeta;
  float drcm;
  float dxcm;
  float dycm;
  float dzcm;
  float dzz;
  float e2;
  float p1beta;
  float prcm;
  float px2;
  float py2;
  float pz2;
  float relvel;
  float rsqare;
  float s;
  float transf;
  float x1;
  float x2;
  float y1;
  float y2;
  float z1;
  float z2;

  distce_save()
      : bbb(fem::float0),
        ddd(fem::float0),
        drbeta(fem::float0),
        drcm(fem::float0),
        dxcm(fem::float0),
        dycm(fem::float0),
        dzcm(fem::float0),
        dzz(fem::float0),
        e2(fem::float0),
        p1beta(fem::float0),
        prcm(fem::float0),
        px2(fem::float0),
        py2(fem::float0),
        pz2(fem::float0),
        relvel(fem::float0),
        rsqare(fem::float0),
        s(fem::float0),
        transf(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        z1(fem::float0),
        z2(fem::float0) {}
};

/// Clin-9/2012-end
/// C
/// C**************************************
void distce(common& cmn, int const& i1, int const& i2, float const& deltar,
            float const& ds, float const& dt, float const& ec, float const& srt,
            int& ic, float const& px1cm, float const& py1cm,
            float const& pz1cm) {
  FEM_CMN_SVE(distce);
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  float& em2 = cmn.em2;
  ///
  float& bbb = sve.bbb;
  float& ddd = sve.ddd;
  float& drbeta = sve.drbeta;
  float& drcm = sve.drcm;
  float& dxcm = sve.dxcm;
  float& dycm = sve.dycm;
  float& dzcm = sve.dzcm;
  float& dzz = sve.dzz;
  float& e2 = sve.e2;
  float& p1beta = sve.p1beta;
  float& prcm = sve.prcm;
  float& px2 = sve.px2;
  float& py2 = sve.py2;
  float& pz2 = sve.pz2;
  float& relvel = sve.relvel;
  float& rsqare = sve.rsqare;
  float& s = sve.s;
  float& transf = sve.transf;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& y1 = sve.y1;
  float& y2 = sve.y2;
  float& z1 = sve.z1;
  float& z2 = sve.z2;
  /// C PURPOSE : CHECK IF THE COLLISION BETWEEN TWO PARTICLES CAN HAPPEN
  /// C           BY CHECKING
  /// C                      (1) IF THE DISTANCE BETWEEN THEM IS SMALLER
  /// C           THAN THE MAXIMUM DISTANCE DETERMINED FROM THE CROSS SECTION.
  /// C                      (2) IF PARTICLE WILL PASS EACH OTHER WITHIN
  /// C           TWO HARD CORE RADIUS.
  /// C                      (3) IF PARTICLES WILL GET CLOSER.
  /// C VARIABLES :
  /// C           IC=1 COLLISION HAPPENED
  /// C           IC=-1 COLLISION CAN NOT HAPPEN
  /// C****************************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /BG/
  ic = 0;
  x1 = r(1, i1);
  y1 = r(2, i1);
  z1 = r(3, i1);
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  x2 = r(1, i2);
  y2 = r(2, i2);
  z2 = r(3, i2);
  px2 = p(1, i2);
  py2 = p(2, i2);
  pz2 = p(3, i2);
  em1 = e(i1);
  em2 = e(i2);
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  /// C            IF (ABS(X1-X2) .GT. DELTAR) GO TO 400
  /// C            IF (ABS(Y1-Y2) .GT. DELTAR) GO TO 400
  /// C            IF (ABS(Z1-Z2) .GT. DELTAR) GO TO 400
  rsqare = fem::pow2((x1 - x2)) + fem::pow2((y1 - y2)) + fem::pow2((z1 - z2));
  if (rsqare > fem::pow2(deltar)) {
    goto statement_400;
  }
  /// CNOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
  e2 = fem::sqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                 fem::pow2(pz2));
  s = srt * srt;
  if (s < ec) {
    goto statement_400;
  }
  /// CNOW THERE IS ENOUGH ENERGY AVAILABLE !
  /// CLORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
  /// C BETAX, BETAY, BETAZ AND GAMMA HAVE BEEN GIVEN IN THE SUBROUTINE CMS
  /// CTRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
  p1beta = px1 * betax + py1 * betay + pz1 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) - e1);
  prcm = fem::sqrt(fem::pow2(px1cm) + fem::pow2(py1cm) + fem::pow2(pz1cm));
  if (prcm <= 0.00001f) {
    goto statement_400;
  }
  /// CTRANSFORMATION OF SPATIAL DISTANCE
  drbeta = betax * (x1 - x2) + betay * (y1 - y2) + betaz * (z1 - z2);
  transf = gamma * gamma * drbeta / (gamma + 1);
  dxcm = betax * transf + x1 - x2;
  dycm = betay * transf + y1 - y2;
  dzcm = betaz * transf + z1 - z2;
  /// CDETERMINING IF THIS IS THE POINT OF CLOSEST APPROACH
  drcm = fem::sqrt(fem::pow2(dxcm) + fem::pow2(dycm) + fem::pow2(dzcm));
  dzz = (px1cm * dxcm + py1cm * dycm + pz1cm * dzcm) / prcm;
  if ((fem::pow2(drcm) - fem::pow2(dzz)) <= 0.f) {
    bbb = 0.f;
  } else {
    bbb = fem::sqrt(fem::pow2(drcm) - fem::pow2(dzz));
  }
  /// CWILL PARTICLE PASS EACH OTHER WITHIN 2 * HARD CORE RADIUS ?
  if (bbb > ds) {
    goto statement_400;
  }
  relvel = prcm * (1.0f / e1 + 1.0f / e2);
  ddd = relvel * dt * 0.5f;
  /// CWILL PARTICLES GET CLOSER ?
  if (fem::abs(ddd) < fem::abs(dzz)) {
    goto statement_400;
  }
  ic = 1;
  goto statement_500;
statement_400:
  ic = -1;
statement_500:;
}

struct newka_save {
  float bmass;
  float brel;
  float brsgm;
  float brsig;
  float ds;
  float dsr;
  float ec;
  float em1;
  float em2;
  int ic;
  int ielstc;
  int ik;
  int ik0;
  int ik1;
  int ik2;
  int ik3;
  int il;
  int im;
  int im3;
  int im4;
  int in;
  int inpion;
  int ipipi;
  int lb1;
  bool lb1bn;
  bool lb1bn0;
  bool lb1bn1;
  bool lb1mn;
  bool lb1mn0;
  bool lb1mn1;
  bool lb1mn2;
  int lb2;
  bool lb2bn;
  bool lb2bn0;
  bool lb2bn1;
  bool lb2mn;
  bool lb2mn0;
  bool lb2mn1;
  bool lb2mn2;
  int nchrg;
  float pkaon;
  float px1cm;
  float py1cm;
  float pz1cm;
  float ratiok;
  float sgsum;
  float sgsum1;
  float sgsum3;
  float sig;
  float sigela;
  float sigma0;
  float sigsgm;

  newka_save()
      : bmass(fem::float0),
        brel(fem::float0),
        brsgm(fem::float0),
        brsig(fem::float0),
        ds(fem::float0),
        dsr(fem::float0),
        ec(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ic(fem::int0),
        ielstc(fem::int0),
        ik(fem::int0),
        ik0(fem::int0),
        ik1(fem::int0),
        ik2(fem::int0),
        ik3(fem::int0),
        il(fem::int0),
        im(fem::int0),
        im3(fem::int0),
        im4(fem::int0),
        in(fem::int0),
        inpion(fem::int0),
        ipipi(fem::int0),
        lb1(fem::int0),
        lb1bn(fem::bool0),
        lb1bn0(fem::bool0),
        lb1bn1(fem::bool0),
        lb1mn(fem::bool0),
        lb1mn0(fem::bool0),
        lb1mn1(fem::bool0),
        lb1mn2(fem::bool0),
        lb2(fem::int0),
        lb2bn(fem::bool0),
        lb2bn0(fem::bool0),
        lb2bn1(fem::bool0),
        lb2mn(fem::bool0),
        lb2mn0(fem::bool0),
        lb2mn1(fem::bool0),
        lb2mn2(fem::bool0),
        nchrg(fem::int0),
        pkaon(fem::float0),
        px1cm(fem::float0),
        py1cm(fem::float0),
        pz1cm(fem::float0),
        ratiok(fem::float0),
        sgsum(fem::float0),
        sgsum1(fem::float0),
        sgsum3(fem::float0),
        sig(fem::float0),
        sigela(fem::float0),
        sigma0(fem::float0),
        sigsgm(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....extracted from G. Song's ART expasion including K- interactions
/// C.....file `NEWKAON.FOR'
/// C
/// C     5/01/03 send iblock value into art1f.f, necessary for resonance
/// studies: C        subroutine newka(icase,irun,iseed,dt,nt,ictrl,i1,i2, C &
/// srt,pcx,pcy,pcz)
void newka(common& cmn, int& icase, int const& irun, int const& iseed,
           float const& dt, int const& nt, int& ictrl, int const& i1,
           int const& i2, float const& srt, float const& pcx, float const& pcy,
           float const& pcz, int& iblock) {
  FEM_CMN_SVE(newka);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& bmass = sve.bmass;
  float& brel = sve.brel;
  float& brsgm = sve.brsgm;
  float& brsig = sve.brsig;
  float& ds = sve.ds;
  float& dsr = sve.dsr;
  float& ec = sve.ec;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ic = sve.ic;
  int& ielstc = sve.ielstc;
  int& ik = sve.ik;
  int& ik0 = sve.ik0;
  int& ik1 = sve.ik1;
  int& ik2 = sve.ik2;
  int& ik3 = sve.ik3;
  int& il = sve.il;
  int& im = sve.im;
  int& im3 = sve.im3;
  int& im4 = sve.im4;
  int& in = sve.in;
  int& inpion = sve.inpion;
  int& ipipi = sve.ipipi;
  int& lb1 = sve.lb1;
  bool& lb1bn = sve.lb1bn;
  bool& lb1bn0 = sve.lb1bn0;
  bool& lb1bn1 = sve.lb1bn1;
  bool& lb1mn = sve.lb1mn;
  bool& lb1mn0 = sve.lb1mn0;
  bool& lb1mn1 = sve.lb1mn1;
  bool& lb1mn2 = sve.lb1mn2;
  int& lb2 = sve.lb2;
  bool& lb2bn = sve.lb2bn;
  bool& lb2bn0 = sve.lb2bn0;
  bool& lb2bn1 = sve.lb2bn1;
  bool& lb2mn = sve.lb2mn;
  bool& lb2mn0 = sve.lb2mn0;
  bool& lb2mn1 = sve.lb2mn1;
  bool& lb2mn2 = sve.lb2mn2;
  int& nchrg = sve.nchrg;
  float& pkaon = sve.pkaon;
  float& px1cm = sve.px1cm;
  float& py1cm = sve.py1cm;
  float& pz1cm = sve.pz1cm;
  float& ratiok = sve.ratiok;
  float& sgsum = sve.sgsum;
  float& sgsum1 = sve.sgsum1;
  float& sgsum3 = sve.sgsum3;
  float& sig = sve.sig;
  float& sigela = sve.sigela;
  float& sigma0 = sve.sigma0;
  float& sigsgm = sve.sigsgm;
  ///
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /RNDF77/
  /// C
  /// Cbz3/7/99 neutralk
  /// C        logical lb1bn1, lb2bayon1, lb1bn0, lb2bn0
  /// Cbz3/7/99 neutralk end
  icase = -1;
  /// C        icase: flag for the type of reaction that is going to happen.
  /// C        icase=-1,  no desired reaction, return to main program.
  /// C              1,  NN,ND,DD
  /// C              2,  PI+N, PI+D
  /// C              3,  K(-) absorption.
  nchrg = -100;
  /// C        nchrg: Net charges of the two incoming particles.
  ictrl = 1;
  lb1 = lb(i1);
  lb2 = lb(i2);
  em1 = e(i1);
  em2 = e(i2);
  lb1bn = lb1 == 1 || lb1 == 2 || (lb1 > 5 && lb1 <= 13);
  lb2bn = lb2 == 1 || lb2 == 2 || (lb2 > 5 && lb2 <= 13);
  lb1bn0 = lb1 == 2 || lb1 == 7 || lb1 == 10 || lb1 == 12;
  lb2bn0 = lb2 == 2 || lb2 == 7 || lb2 == 10 || lb2 == 12;
  lb1bn1 = lb1 == 1 || lb1 == 8 || lb1 == 11 || lb1 == 13;
  lb2bn1 = lb2 == 1 || lb2 == 8 || lb2 == 11 || lb2 == 13;
  lb1mn = em1 < 0.2f || lb1 == 0 || (lb1 >= 25 && lb1 <= 29);
  lb2mn = em2 < 0.2f || lb2 == 0 || (lb2 >= 25 && lb2 <= 29);
  lb1mn0 = lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28 || lb1 == 29;
  lb2mn0 = lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28 || lb2 == 29;
  lb1mn1 = lb1 == 5 || lb1 == 27;
  lb2mn1 = lb2 == 5 || lb2 == 27;
  lb1mn2 = lb1 == 3 || lb1 == 25;
  lb2mn2 = lb2 == 3 || lb2 == 25;
  /// C
  /// C        1. consider N+N, N+Resonance, R + R reactions
  if (lb1bn && lb2bn) {
    /// C     NN,ND,DD:
    icase = 1;
    /// C     total cross section
    sig = 40.f;
    if (lb1 == 9 && lb2 == 9) {
      nchrg = 4;
    }
    if ((lb1bn1 && lb2 == 9) || (lb2bn1 && lb1 == 9)) {
      nchrg = 3;
    }
    if ((lb1bn0 && lb2 == 9) || (lb2bn0 && lb1 == 9) || (lb1bn1 && lb2bn1)) {
      nchrg = 2;
    }
    if ((lb1bn1 && lb2bn0) || (lb1 == 6 && lb2 == 9) || (lb2bn1 && lb1bn0) ||
        (lb2 == 6 && lb1 == 9)) {
      nchrg = 1;
    }
    if ((lb1bn0 && lb2bn0) || (lb1bn1 && lb2 == 6) || (lb2bn1 && lb1 == 6)) {
      nchrg = 0;
    }
    if ((lb1bn0 && lb2 == 6) || (lb2bn0 && lb1 == 6)) {
      nchrg = -1;
    }
    if (lb1 == 6 && lb2 == 6) {
      nchrg = -2;
    }
    /// C     brsig = x2kaon_no_isospin(srt)
    if (nchrg >= -1 && nchrg <= 2) {
      /// C     K,Kbar prduction x sect.
      brsig = x2kaon(cmn, srt);
    } else {
      brsig = 0.0f;
      /// C                if(nchrg.eq.-2.or.nchrg.eq.3) then
      /// C                   brsig = x2kaon(srt+0.938-1.232)
      /// C                else
      /// C     nchrg=4
      /// C                   brsig = x2kaon(srt+2.*(0.938-1.232))
      /// C                endif
    }
    /// C
    /// Cbz3/7/99 neutralk
    brsig = 2.0f * brsig;
    /// Cbz3/7/99 neutralk end
    /// C
  }
  /// C
  /// C        2. consider PI(meson:eta,omega,rho,phi) + N(N*,D)
  if ((lb1bn && lb2mn) || (lb2bn && lb1mn)) {
    /// C     PN,PD
    icase = 2;
    sig = 20.f;
    sigma0 = pinsg0(cmn, srt);
    brsig = 0.0f;
    if ((lb1bn1 && lb2mn0) || (lb2bn1 && lb1mn0) || (lb1bn0 && lb2mn1) ||
        (lb2bn0 && lb1mn1) || (lb1 == 9 && lb2mn2) || (lb2 == 9 && lb1mn2)) {
      nchrg = 1;
      /// Cbz3/2/99/song
      /// C                if(lb1bn1.or.lb2bn1) brsig=2.0*sigma0
      /// C                if(lb1bn0.or.lb2bn0) brsig=0.5*sigma0
      if (lb1bn1 || lb2bn1) {
        brsig = 0.5f * sigma0;
      }
      if (lb1bn0 || lb2bn0) {
        brsig = 2.0f * sigma0;
      }
      /// Cbz3/2/99/song end
      /// C                if(lb1.eq.9.or.lb2.eq.9) brsig=1.5*sigma0
    }
    if ((lb1bn0 && lb2mn0) || (lb2bn0 && lb1mn0) || (lb1bn1 && lb2mn2) ||
        (lb2bn1 && lb1mn2) || (lb1 == 6 && lb2mn1) || (lb2 == 6 && lb1mn1)) {
      nchrg = 0;
      if (lb1bn1 || lb2bn1) {
        /// Cbz3/2/99/song
        /// C                  brsig=1.5*sigma0
        brsig = 3.0f * sigma0;
        /// Cbz3/2/99/song end
        /// Cbz3/11/99/song
        /// C                  ratiok = 1./3.
        ratiok = 2.f / 3.f;
        /// Cbz3/11/99/song end
        /// C
        /// C                  ratiok: the ratio of channels: ->nK+k- vs. ->
        /// pK0K-
      }
      if (lb1bn0 || lb2bn0) {
        brsig = 2.5f * sigma0;
        /// Cbz3/2/99/song
        /// C                  ratiok = 0.8
        ratiok = 0.2f;
        /// Cbz3/2/99/song end
      }
      /// C                if(lb1.eq.6.or.lb2.eq.6) then
      /// C     lb=6 : D-
      /// C                  brsig=1.5*sigma0
      /// C                  ratiok = 0.5
      /// C                endif
    }
    if ((lb1bn0 && lb2mn2) || (lb2bn0 && lb1mn2) || (lb1 == 6 && lb2mn0) ||
        (lb2 == 6 && lb1mn0)) {
      nchrg = -1;
      if (lb1bn0 || lb2bn0) {
        brsig = sigma0;
      }
      /// C                if(lb1.eq.6.or.lb2.eq.6) brsig=sigma0
    }
    /// C          if((lb1.eq.6.and.lb2mn2).or.(lb2.eq.6.and.lb1mn2))then
    /// C                nchrg=-2
    /// C          endif
    /// C          if((lb1bn1.and.lb2mn1).or.(lb2bn1.and.lb1mn1)
    /// C    &           .or.(lb1.eq.9.and.lb2mn0).or.(lb2.eq.9.and.lb1mn0))
    /// then C                nchrg=2 C          endif
    /// C
    /// Cbz3/11/99 neutralk
    if ((lb1 == 6 && lb2mn2) || (lb2 == 6 && lb1mn2)) {
      nchrg = -2;
    }
    /// Cbz3/11/99 neutralk
    /// Cbz3/8/99 neutralk
    if ((lb1bn1 && lb2mn1) || (lb2bn1 && lb1mn1) || (lb1 == 9 && lb2mn0) ||
        (lb2 == 9 && lb1mn0)) {
      nchrg = 2;
    }
    /// Cbz3/8/99 neutralk end
    /// C
    /// Cbz3/7/99 neutralk
    if (nchrg >= -2 && nchrg <= 2) {
      brsig = 3.0f * sigma0;
    }
    /// Cbz3/7/99 neutralk end
    /// C
  }
  /// C
  /// C        3. consider K- + N(N*,D) absorption.
  /// C        if((lb1bn.and.lb2.eq.21).OR.(lb2bn.and.lb1.eq.21)) then
  const float aka = 0.498f;
  if ((lb1bn && (lb2 == 21 || lb2 == -30)) ||
      (lb2bn && (lb1 == 21 || lb1 == -30))) {
    /// C          bmass=em1+em2-aka
    bmass = 0.938f;
    if (srt <= (bmass + aka)) {
      /// Cbz3/2/99
      /// C write(100,*)'--lb1,lb2,em1,em2,srt',lb1,lb2,em1,em2,srt Cbz3/2/99end
      pkaon = 0.f;
    } else {
      pkaon = fem::sqrt(
          fem::pow2(((fem::pow2(srt) - (fem::pow2(aka) + fem::pow2(bmass))) /
                     2.f / bmass)) -
          fem::pow2(aka));
    }
    sig = 0.f;
    if (lb1 == 1 || lb2 == 1 || lb1 == 8 || lb2 == 8 || lb1 == 11 ||
        lb2 == 11 || lb1 == 13 || lb2 == 13) {
      /// C          K- + (D+,N*+)p ->
      nchrg = 0;
      sigela = akpel(cmn, pkaon);
      sigsgm = 3.f * akpsgm(cmn, pkaon);
      sig = sigela + sigsgm + akplam(cmn, pkaon);
    }
    if (lb1 == 2 || lb2 == 2 || lb1 == 7 || lb2 == 7 || lb1 == 10 ||
        lb2 == 10 || lb1 == 12 || lb2 == 12) {
      /// C          K- + (D0, N*0)n ->
      nchrg = -1;
      sigela = aknel(cmn, pkaon);
      sigsgm = 2.f * aknsgm(cmn, pkaon);
      sig = sigela + sigsgm + aknlam(cmn, pkaon);
    }
    if (lb1 == 6 || lb2 == 6) {
      /// C     K- + D-
      nchrg = -2;
      sigela = aknel(cmn, pkaon);
      sigsgm = aknsgm(cmn, pkaon);
      sig = sigela + sigsgm;
    }
    if (lb1 == 9 || lb2 == 9) {
      /// C     K- + D++
      nchrg = 1;
      sigela = akpel(cmn, pkaon);
      sigsgm = 2.f * akpsgm(cmn, pkaon);
      sig = sigela + sigsgm + akplam(cmn, pkaon);
    }
    /// C
    /// Cbz3/8/99 neutralk
    sigela = 0.5f * (akpel(cmn, pkaon) + aknel(cmn, pkaon));
    sigsgm = 1.5f * akpsgm(cmn, pkaon) + aknsgm(cmn, pkaon);
    sig = sigela + sigsgm + akplam(cmn, pkaon);
    /// Cbz3/8/99 neutralk end
    /// C
    if (sig > 1.e-7f) {
      /// C     K(-) + N reactions
      icase = 3;
      brel = sigela / sig;
      brsgm = sigsgm / sig;
      /// C              branch_lambda=akNlam(pkaon)/sig
      brsig = sig;
    }
  }
  /// C
  /// C        4. meson + hyperon -> K- + N
  /// C        if(((lb1.ge.14.and.lb1.le.17).and.lb2mn).OR.
  /// C     &     ((lb2.ge.14.and.lb2.le.17).and.lb1mn)) then
  if (((lb1 >= 14 && lb1 <= 17) && (lb2 >= 3 && lb2 <= 5)) ||
      ((lb2 >= 14 && lb2 <= 17) && (lb1 >= 3 && lb1 <= 5))) {
    /// C        first classify the reactions due to total charge.
    nchrg = -100;
    if ((lb1 == 15 && (lb2 == 3 || lb2 == 25)) ||
        (lb2 == 15 && (lb1 == 3 || lb1 == 25))) {
      nchrg = -2;
      /// C     D-
      bmass = 1.232f;
    }
    if ((lb1 == 15 && lb2mn0) || (lb2 == 15 && lb1mn0) ||
        ((lb1 == 14 || lb1 == 16) && (lb2 == 3 || lb2 == 25)) ||
        ((lb2 == 14 || lb2 == 16) && (lb1 == 3 || lb1 == 25))) {
      nchrg = -1;
      /// C     n
      bmass = 0.938f;
    }
    if ((lb1 == 15 && (lb2 == 5 || lb2 == 27)) ||
        (lb2 == 15 && (lb1 == 5 || lb1 == 27)) ||
        (lb1 == 17 && (lb2 == 3 || lb2 == 25)) ||
        (lb2 == 17 && (lb1 == 3 || lb1 == 25)) ||
        ((lb1 == 14 || lb1 == 16) && lb2mn0) ||
        ((lb2 == 14 || lb2 == 16) && lb1mn0)) {
      nchrg = 0;
      /// C     p
      bmass = 0.938f;
    }
    if ((lb1 == 17 && lb2mn0) || (lb2 == 17 && lb1mn0) ||
        ((lb1 == 14 || lb1 == 16) && (lb2 == 5 || lb2 == 27)) ||
        ((lb2 == 14 || lb2 == 16) && (lb1 == 5 || lb1 == 27))) {
      nchrg = 1;
      /// C     D++
      bmass = 1.232f;
    }
    sig = 0.f;
    if (nchrg != -100 && srt > (aka + bmass)) {
      /// C     PI+sigma or PI + Lambda => Kbar + N reactions
      icase = 4;
      /// C pkaon=sqrt(((srt**2-(aka**2+bmass**2))/2./bmass)**2-aka**2)
      pkaon = fem::sqrt(
          fem::pow2(((fem::pow2(srt) - (fem::pow2(aka) + fem::pow2(0.938f))) /
                     2.f / 0.938f)) -
          fem::pow2(aka));
      /// C     lambda + Pi
      if (lb1 == 14 || lb2 == 14) {
        if (nchrg >= 0) {
          sigma0 = akplam(cmn, pkaon);
        }
        if (nchrg < 0) {
          sigma0 = aknlam(cmn, pkaon);
        }
        /// C     sigma + pi
      } else {
        /// C     K-p or K-D++
        if (nchrg >= 0) {
          sigma0 = akpsgm(cmn, pkaon);
        }
        /// C     K-n or K-D-
        if (nchrg < 0) {
          sigma0 = aknsgm(cmn, pkaon);
        }
        /// C
        /// Cbz3/8/99 neutralk
        sigma0 = 1.5f * akpsgm(cmn, pkaon) + aknsgm(cmn, pkaon);
        /// Cbz3/8/99 neutralk end
        /// C
      }
      sig = (fem::pow2(srt) - fem::pow2((aka + bmass))) *
            (fem::pow2(srt) - fem::pow2((aka - bmass))) /
            (fem::pow2(srt) - fem::pow2((em1 + em2))) /
            (fem::pow2(srt) - fem::pow2((em1 - em2))) * sigma0;
      /// Cbz3/8/99 neutralk
      /// C     if(nchrg.eq.-2.or.nchrg.eq.1) sig=2.*sig K-D++, K-D-
      /// C     K0barD++, K-D-
      if (nchrg == -2 || nchrg == 2) {
        sig = 2.f * sig;
      }
      /// C
      /// Cbz3/8/99 neutralk end
      /// C
      /// C             the factor 2 comes from spin of delta, which is 3/2
      /// C             detailed balance. copy from Page 423 of N.P. A614 1997
      /// C
      /// Cbz3/8/99 neutralk
      if (lb1 == 14 || lb2 == 14) {
        sig = 4.0f / 3.0f * sig;
      } else if (nchrg == -2 || nchrg == 2) {
        sig = 8.0f / 9.0f * sig;
      } else {
        sig = 4.0f / 9.0f * sig;
      }
      /// Cbz3/8/99 neutralk end
      brsig = sig;
      if (sig < 1.e-7f) {
        sig = 1.e-7f;
      }
    }
    /// Csp05/07/01
    /// C comment icase=4 statement below if only inelastic
    /// C     PI+L/Si => Kbar + N  OR ELASTIC SCATTERING
    icase = 4;
    brsig = sig;
    /// C     elastic xsecn of 10mb
    sigela = 10.f;
    sig += sigela;
    brel = sigela / sig;
    /// Cc          brsig = sig
    /// Csp05/07/01 end
  }
  /// C
  /// C        if(em2.lt.0.2.and.em1.lt.0.2) then
  /// C     PI + PI
  /// C             icase=5
  /// C     assumed PI PI total x section.
  /// C              sig=50.
  /// C     Mk + Mkbar
  /// C              s0=aka+aka
  /// C              brsig = 0.
  /// C              if(srt.gt.s0) brsig = 2.7*(1.-s0**2/srt**2)**0.76
  /// C              x section for PIPI->KKbar   PRC43 (1991) 1881
  /// C        endif
  if (icase == -1) {
    ictrl = -1;
    return;
  }
  px1cm = pcx;
  py1cm = pcy;
  pz1cm = pcz;
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  /// C        ec=3.59709
  /// C        if((e(i1).ge.1.).and.(e(i2).ge.1.)) ec = 4.75
  /// C
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
  if (ic == -1) {
    /// C     no anti-kaon production
    ictrl = -1;
    /// C           in=in+1
    /// C           write(60,*)'--------------distance-----',in
    return;
  }
  /// C
  /// Clin-10/24/02 set to 0: ik,ik0-3,il,im,im3-4,in,inpion,ipipi,
  /// C     sgsum,sgsum1,sgsum3:
  ik = 0;
  ik0 = 0;
  ik1 = 0;
  ik2 = 0;
  ik3 = 0;
  il = 0;
  im = 0;
  im3 = 0;
  im4 = 0;
  in = 0;
  inpion = 0;
  ipipi = 0;
  sgsum = 0.f;
  sgsum1 = 0.f;
  sgsum3 = 0.f;
  if (icase == 1) {
    ik++;
    if (srt > 2.8639f) {
      ik0++;
      if (em1 < 1.0f && em2 < 1.0f) {
        ik1++;
        sgsum1 += brsig;
        /// C                        ratio_1=sgsum1/ik1/40.
      }
      if (em1 > 1.0f && em2 > 1.0f) {
        ik3++;
        sgsum3 += brsig;
        /// C                        ratio_3=sgsum3/ik3/40.
      }
      if (em1 > 1.0f && em2 < 1.0f) {
        ik2++;
      }
      if (em1 < 1.0f && em2 > 1.0f) {
        ik2++;
      }
      sgsum += brsig;
      /// C                ratio=sgsum/ik0/40.
    }
  }
  if (icase == 2) {
    inpion++;
  }
  if (icase == 5) {
    ipipi++;
  }
  /// C        write(62,*)'ik1,ik2,ik3',ik1,ik2,ik3,ratio_1,ratio_3,ratio
  /// C        write(62,*)'inpion,ipipi',inpion,ipipi
  if (ranart(nseed) > (brsig / sig)) {
    /// C     no anti-kaon production
    ictrl = -1;
    return;
  }
  il++;
  /// C        kaons could be created now.
  if (icase == 1) {
    in++;
    /// C          write(60,*)'------in,s2kaon,sig=',in,brsig,sig,lb1,lb2
    nnkaon(cmn, irun, iseed, ictrl, i1, i2, iblock, srt, pcx, pcy, pcz, nchrg);
  }
  if (icase == 2) {
    im++;
    /// C          call npik(irun,iseed,dt,nt,ictrl,i1,i2,srt,
    /// C     &              pcx,pcy,pcz,nchrg,ratiok)
    npik(cmn, irun, iseed, dt, nt, ictrl, i1, i2, srt, pcx, pcy, pcz, nchrg,
         ratiok, iblock);
  }
  /// C
  if (icase == 3) {
    im3++;
    /// C          write(63,*)'im3,lb1,lb2,pkaon',im3,lb1,lb2,pkaon
    /// C          write(63,*)'sig,el,sigma',sig,brel,brsgm
    /// C          write(63,*)'srt,pcx,pcy,pcz,em1,em2',srt,pcx,pcy,pcz,em1,em2
    kaonn(cmn, brel, brsgm, irun, iseed, dt, nt, ictrl, i1, i2, iblock, srt,
          pcx, pcy, pcz, nchrg);
    /// C         this subroutine format is diff. since three final states are
    /// possible
  }
  /// C
  if (icase == 4) {
    im4++;
    /// C          write(64,*)'im4,sigma0,branch,sig=',im4,sigma0,brsig,sig
    /// C          write(64,*)'lb1,lb2,em1,em2,pkaon=',lb1,lb2,em1,em2,pkaon
    /// C
    /// Csp06/07/01
    if (ranart(nseed) < brel) {
      ielstc = 1;
    } else {
      ielstc = 0;
    }
    /// C          call Pihypn(ielstc,irun,iseed,dt,nt,ictrl,i1,i2,srt,
    /// C     &                   pcx,pcy,pcz,nchrg)
    pihypn(cmn, ielstc, irun, iseed, dt, nt, ictrl, i1, i2, srt, pcx, pcy, pcz,
           nchrg, iblock);
    /// C
    /// Csp06/07/01 end
  }
  /// C        if(icase.eq.5) then
  /// C          im5=im5+1
  /// C          write(65,*)'---im5,s2kaon,sig=',im5,brsig,sig
  /// C          call pipikaon(irun,iseed,dt,nt,ictrl,i1,i2,srt,pcx,pcy,pcz)
  /// C        endif
  /// Cbz3/2/99
  /// C        write(101,*)lb1,lb2,lb(i1),lb(i2)
  /// C        write(101,*)em1,em2,e(i1),e(i2),srt
  /// Cbz3/2/99end
  /// C
}

struct cms_save {
  double dbetax;
  double dbetay;
  double dbetaz;
  double dgamma;
  double e1;
  double e2;
  double em1;
  double em2;
  double etotal;
  double p1beta;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double s;
  double scheck;
  double transf;

  cms_save()
      : dbetax(fem::double0),
        dbetay(fem::double0),
        dbetaz(fem::double0),
        dgamma(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        em1(fem::double0),
        em2(fem::double0),
        etotal(fem::double0),
        p1beta(fem::double0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        s(fem::double0),
        scheck(fem::double0),
        transf(fem::double0) {}
};

/// C
/// Clin-9/2012: use double precision for S in CMS(): to avoid crash
/// C     (segmentation fault due to s<0, which happened at high energies
/// C     such as LHC with large NTMAX for two almost-comoving hadrons
/// C     that have small Pt but large |Pz|):
/// C***************************************
/// C            SUBROUTINE CMS(I1,I2,PX1CM,PY1CM,PZ1CM,SRT)
/// C PURPOSE : FIND THE MOMENTA OF PARTICLES IN THE CMS OF THE
/// C          TWO COLLIDING PARTICLES
/// C VARIABLES :
/// C****************************************
/// C            PARAMETER (MAXSTR=150001)
/// C            COMMON   /AA/  R(3,MAXSTR)
/// Ccc      SAVE /AA/
/// C            COMMON   /BB/  P(3,MAXSTR)
/// Ccc      SAVE /BB/
/// C            COMMON   /CC/  E(MAXSTR)
/// Ccc      SAVE /CC/
/// C            COMMON   /BG/  BETAX,BETAY,BETAZ,GAMMA
/// Ccc      SAVE /BG/
/// C            SAVE
/// C            PX1=P(1,I1)
/// C            PY1=P(2,I1)
/// C            PZ1=P(3,I1)
/// C            PX2=P(1,I2)
/// C            PY2=P(2,I2)
/// C            PZ2=P(3,I2)
/// C            EM1=E(I1)
/// C            EM2=E(I2)
/// C            E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
/// C            E2=SQRT(EM2**2 + PX2**2 + PY2**2 + PZ2**2 )
/// C            S=(E1+E2)**2-(PX1+PX2)**2-(PY1+PY2)**2-(PZ1+PZ2)**2
/// C            SRT=SQRT(S)
/// C*LORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
/// C              ETOTAL = E1 + E2
/// C              BETAX  = (PX1+PX2) / ETOTAL
/// C              BETAY  = (PY1+PY2) / ETOTAL
/// C              BETAZ  = (PZ1+PZ2) / ETOTAL
/// C              GAMMA  = 1.0 / SQRT(1.0-BETAX**2-BETAY**2-BETAZ**2)
/// C*TRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
/// C              P1BETA = PX1*BETAX + PY1*BETAY + PZ1 * BETAZ
/// C              TRANSF = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) - E1 )
/// C              PX1CM  = BETAX * TRANSF + PX1
/// C              PY1CM  = BETAY * TRANSF + PY1
/// C              PZ1CM  = BETAZ * TRANSF + PZ1
/// C              RETURN
/// C              END
/// C***************************************
void cms(common& cmn, int const& i1, int const& i2, float& px1cm, float& py1cm,
         float& pz1cm, float& srt) {
  FEM_CMN_SVE(cms);
  common_write write(cmn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  ///
  /// SAVE
  double& dbetax = sve.dbetax;
  double& dbetay = sve.dbetay;
  double& dbetaz = sve.dbetaz;
  double& dgamma = sve.dgamma;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  double& em1 = sve.em1;
  double& em2 = sve.em2;
  double& etotal = sve.etotal;
  double& p1beta = sve.p1beta;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& s = sve.s;
  double& scheck = sve.scheck;
  double& transf = sve.transf;
  ///
  /// C PURPOSE : FIND THE MOMENTA OF PARTICLES IN THE CMS OF THE
  /// C          TWO COLLIDING PARTICLES
  /// C VARIABLES :
  /// C****************************************
  px1 = fem::dble(p(1, i1));
  py1 = fem::dble(p(2, i1));
  pz1 = fem::dble(p(3, i1));
  px2 = fem::dble(p(1, i2));
  py2 = fem::dble(p(2, i2));
  pz2 = fem::dble(p(3, i2));
  em1 = fem::dble(e(i1));
  em2 = fem::dble(e(i2));
  e1 = fem::dsqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                  fem::pow2(pz1));
  e2 = fem::dsqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                  fem::pow2(pz2));
  s = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) - fem::pow2((py1 + py2)) -
      fem::pow2((pz1 + pz2));
  if (s <= 0) {
    s = 0e0;
  }
  srt = fem::sngl(fem::dsqrt(s));
  /// CLORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
  etotal = e1 + e2;
  dbetax = (px1 + px2) / etotal;
  dbetay = (py1 + py2) / etotal;
  dbetaz = (pz1 + pz2) / etotal;
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.e0 - fem::pow2(dbetax) - fem::pow2(dbetay) - fem::pow2(dbetaz);
  if (scheck <= 0e0) {
    write(99, star), "scheck1: ", scheck;
    FEM_STOP(0);
  }
  dgamma = 1.e0 / fem::dsqrt(scheck);
  /// CTRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
  p1beta = px1 * dbetax + py1 * dbetay + pz1 * dbetaz;
  transf = dgamma * (dgamma * p1beta / (dgamma + 1e0) - e1);
  px1cm = fem::sngl(dbetax * transf + px1);
  py1cm = fem::sngl(dbetay * transf + py1);
  pz1cm = fem::sngl(dbetaz * transf + pz1);
  cmn.betax = fem::sngl(dbetax);
  cmn.betay = fem::sngl(dbetay);
  cmn.betaz = fem::sngl(dbetaz);
  cmn.gamma = fem::sngl(dgamma);
}

struct width_save {
  float aux;
  float avmass;
  float pimass;
  float qavail;

  width_save()
      : aux(fem::float0),
        avmass(fem::float0),
        pimass(fem::float0),
        qavail(fem::float0) {}
};

/// C FUNCTION WIDTH(DMASS) GIVES THE DELTA DECAY WIDTH FOR A GIVEN DELTA MASS
/// C HERE THE FORMULA GIVEN BY KITAZOE IS USED
float width(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(width);
  /// SAVE
  float& aux = sve.aux;
  float& avmass = sve.avmass;
  float& pimass = sve.pimass;
  float& qavail = sve.qavail;
  ///
  avmass = 0.938868f;
  pimass = 0.137265f;
  aux = 0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(avmass) -
                           fem::pow2(pimass))) -
        fem::pow2((avmass * pimass));
  if (aux > 0.f) {
    qavail = fem::sqrt(aux / fem::pow2(dmass));
  } else {
    qavail = 1.e-06f;
  }
  return_value =
      0.47f * fem::pow3(qavail) /
      (fem::pow2(pimass) * (1.f + 0.6f * fem::pow2((qavail / pimass))));
  /// C       width=0.115
  return return_value;
}

struct fde_save {
  float am0;
  float amn;
  float avpi;
  float fd;
  float p1;
  float p11;

  fde_save()
      : am0(fem::float0),
        amn(fem::float0),
        avpi(fem::float0),
        fd(fem::float0),
        p1(fem::float0),
        p11(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------------
/// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
/// CKITAZOE'S FORMULA
float fde(common& cmn, float& dmass, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fde);
  /// SAVE
  float& am0 = sve.am0;
  float& amn = sve.amn;
  float& avpi = sve.avpi;
  float& fd = sve.fd;
  float& p1 = sve.p1;
  float& p11 = sve.p11;
  ///
  amn = 0.938869f;
  avpi = 0.13803333f;
  am0 = 1.232f;
  fd = 4.f * (fem::pow2(am0)) * width(cmn, dmass) /
       (fem::pow2((fem::pow2(dmass) - fem::pow2(1.232f))) +
        fem::pow2(am0) * fem::pow2(width(cmn, dmass)));
  if (con == 1.f) {
    p11 = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
              (4.f * fem::pow2(srt)) -
          fem::pow2(dmass);
    if (p11 <= 0) {
      p11 = 1.e-06f;
    }
    p1 = fem::sqrt(p11);
  } else {
    dmass = amn + avpi;
    p11 = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
              (4.f * fem::pow2(srt)) -
          fem::pow2(dmass);
    if (p11 <= 0) {
      p11 = 1.e-06f;
    }
    p1 = fem::sqrt(p11);
  }
  return_value = fd * p1 * dmass;
  return return_value;
}

struct w1535_save {
  float aux;
  float avmass;
  float pimass;
  float qavail;

  w1535_save()
      : aux(fem::float0),
        avmass(fem::float0),
        pimass(fem::float0),
        qavail(fem::float0) {}
};

/// C***********************************
/// C FUNCTION W1535(DMASS) GIVES THE N*(1535) DECAY WIDTH
/// C     FOR A GIVEN N*(1535) MASS
/// C HERE THE FORMULA GIVEN BY KITAZOE IS USED
float w1535(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(w1535);
  /// SAVE
  float& aux = sve.aux;
  float& avmass = sve.avmass;
  float& pimass = sve.pimass;
  float& qavail = sve.qavail;
  ///
  avmass = 0.938868f;
  pimass = 0.137265f;
  aux = 0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(avmass) -
                           fem::pow2(pimass))) -
        fem::pow2((avmass * pimass));
  if (aux > 0.f) {
    qavail = fem::sqrt(aux / fem::pow2(dmass));
  } else {
    qavail = 1.e-06f;
  }
  return_value = 0.15f * qavail / 0.467f;
  /// C       W1535=0.15
  return return_value;
}

struct fd5_save {
  float am0;
  float amn;
  float avpi;
  float fd;
  float p1;
  float scheck;

  fd5_save()
      : am0(fem::float0),
        amn(fem::float0),
        avpi(fem::float0),
        fd(fem::float0),
        p1(fem::float0),
        scheck(fem::float0) {}
};

/// C-------------------------------------------------------------
/// CFUNCTION FDE(DMASS) GIVES N*(1535) MASS DISTRIBUTION BY USING OF
/// CKITAZOE'S FORMULA
float fd5(common& cmn, float& dmass, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fd5);
  common_write write(cmn);
  /// SAVE
  float& am0 = sve.am0;
  float& amn = sve.amn;
  float& avpi = sve.avpi;
  float& fd = sve.fd;
  float& p1 = sve.p1;
  float& scheck = sve.scheck;
  ///
  amn = 0.938869f;
  avpi = 0.13803333f;
  am0 = 1.535f;
  fd = 4.f * (fem::pow2(am0)) * w1535(cmn, dmass) /
       (fem::pow2((fem::pow2(dmass) - fem::pow2(1.535f))) +
        fem::pow2(am0) * fem::pow2(w1535(cmn, dmass)));
  if (con == 1.f) {
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck11: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    /// C           P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    /// C     1          /(4.*SRT**2)-DMASS**2)
    /// C
  } else {
    dmass = amn + avpi;
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck12: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    /// C        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    /// C     1  /(4.*SRT**2)-DMASS**2)
    /// C
  }
  return_value = fd * p1 * dmass;
  return return_value;
}

struct fns_save {
  float amn;
  float an0;
  float avpi;
  float fn;
  float p1;
  float scheck;
  float width;

  fns_save()
      : amn(fem::float0),
        an0(fem::float0),
        avpi(fem::float0),
        fn(fem::float0),
        p1(fem::float0),
        scheck(fem::float0),
        width(fem::float0) {}
};

/// C--------------------------------------------------------------------------
/// CFUNCTION FNS(DMASS) GIVES N* MASS DISTRIBUTION
/// C     BY USING OF BREIT-WIGNER FORMULA
float fns(common& cmn, float& dmass, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fns);
  common_write write(cmn);
  /// SAVE
  float& amn = sve.amn;
  float& an0 = sve.an0;
  float& avpi = sve.avpi;
  float& fn = sve.fn;
  float& p1 = sve.p1;
  float& scheck = sve.scheck;
  float& width = sve.width;
  ///
  width = 0.2f;
  amn = 0.938869f;
  avpi = 0.13803333f;
  an0 = 1.43f;
  fn = 4.f * (fem::pow2(an0)) * width /
       (fem::pow2((fem::pow2(dmass) - fem::pow2(1.44f))) +
        fem::pow2(an0) * fem::pow2(width));
  if (con == 1.f) {
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck13: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    /// C        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    /// C     1  /(4.*SRT**2)-DMASS**2)
    /// C
  } else {
    dmass = amn + avpi;
    /// Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2((fem::pow2(srt) + fem::pow2(dmass) - fem::pow2(amn))) /
                 (4.f * fem::pow2(srt)) -
             fem::pow2(dmass);
    if (scheck < 0) {
      write(99, star), "scheck14: ", scheck;
      scheck = 0.f;
    }
    p1 = fem::sqrt(scheck);
    /// C        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
    /// C     1  /(4.*SRT**2)-DMASS**2)
    /// C
  }
  return_value = fn * p1 * dmass;
  return return_value;
}

struct sigma_save {
  float alfa;
  float am0;
  float amass;
  float amass0;
  float beta;
  float deln;
  float p0;
  float p02;
  float p2;
  float pr;
  float pr2;
  float q;
  float q0;
  float q02;
  float q2;
  float s;
  float s0;
  float scheck;
  float ss;
  float ss0;
  float t;
  float t0;
  float zminus;
  float zplus;

  sigma_save()
      : alfa(fem::float0),
        am0(fem::float0),
        amass(fem::float0),
        amass0(fem::float0),
        beta(fem::float0),
        deln(fem::float0),
        p0(fem::float0),
        p02(fem::float0),
        p2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        q(fem::float0),
        q0(fem::float0),
        q02(fem::float0),
        q2(fem::float0),
        s(fem::float0),
        s0(fem::float0),
        scheck(fem::float0),
        ss(fem::float0),
        ss0(fem::float0),
        t(fem::float0),
        t0(fem::float0),
        zminus(fem::float0),
        zplus(fem::float0) {}
};

/// C------------------------------------------------------------------------------
/// C****************************************
float sigma(common& cmn, float const& srt, int const& id, int const& ioi,
            int const& iof) {
  float return_value = fem::float0;
  FEM_CMN_SVE(sigma);
  common_write write(cmn);
  /// SAVE
  float& alfa = sve.alfa;
  float& am0 = sve.am0;
  float& amass = sve.amass;
  float& amass0 = sve.amass0;
  float& beta = sve.beta;
  float& deln = sve.deln;
  float& p0 = sve.p0;
  float& p02 = sve.p02;
  float& p2 = sve.p2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& q = sve.q;
  float& q0 = sve.q0;
  float& q02 = sve.q02;
  float& q2 = sve.q2;
  float& s = sve.s;
  float& s0 = sve.s0;
  float& scheck = sve.scheck;
  float& ss = sve.ss;
  float& ss0 = sve.ss0;
  float& t = sve.t;
  float& t0 = sve.t0;
  float& zminus = sve.zminus;
  float& zplus = sve.zplus;
  ///
  /// CPURPOSE : THIS IS THE PROGRAM TO CALCULATE THE ISOSPIN DECOMPOSED CROSS
  /// C       SECTION BY USING OF B.J.VerWEST AND R.A.ARNDT'S PARAMETERIZATION
  /// CREFERENCE: PHYS. REV. C25(1982)1979
  /// CQUANTITIES: IOI -- INITIAL ISOSPIN OF THE TWO NUCLEON SYSTEM
  /// C            IOF -- FINAL   ISOSPIN -------------------------
  /// C            ID -- =1 FOR DELTA RESORANCE
  /// C                  =2 FOR N*    RESORANCE
  /// CDATE : MAY 15,1990
  /// C****************************************
  if (id == 1) {
    amass0 = 1.22f;
    t0 = 0.12f;
  } else {
    amass0 = 1.43f;
    t0 = 0.2f;
  }
  if ((ioi == 1) && (iof == 1)) {
    alfa = 3.772f;
    beta = 1.262f;
    am0 = 1.188f;
    t = 0.09902f;
  }
  if ((ioi == 1) && (iof == 0)) {
    alfa = 15.28f;
    beta = 0.f;
    am0 = 1.245f;
    t = 0.1374f;
  }
  if ((ioi == 0) && (iof == 1)) {
    alfa = 146.3f;
    beta = 0.f;
    am0 = 1.472f;
    t = 0.02649f;
  }
  const float amu = 0.9383f;
  zplus = (srt - amu - amass0) * 2.f / t0;
  const float amp = 0.1384f;
  zminus = (amu + amp - amass0) * 2.f / t0;
  deln = fem::atan(zplus) - fem::atan(zminus);
  if (deln == 0) {
    deln = 1.e-06f;
  }
  amass = amass0 +
          (t0 / 4.f) *
              fem::alog((1.f + fem::pow2(zplus)) / (1.f + fem::pow2(zminus))) /
              deln;
  s = fem::pow2(srt);
  p2 = s / 4.f - fem::pow2(amu);
  s0 = fem::pow2((amu + am0));
  p02 = s0 / 4.f - fem::pow2(amu);
  p0 = fem::sqrt(p02);
  pr2 = (s - fem::pow2((amu - amass))) * (s - fem::pow2((amu + amass))) /
        (4.f * s);
  if (pr2 > 1.e-06f) {
    pr = fem::sqrt(pr2);
  } else {
    pr = 0.f;
    return_value = 1.e-06f;
    return return_value;
  }
  ss = fem::pow2(amass);
  q2 = (ss - fem::pow2((amu - amp))) * (ss - fem::pow2((amu + amp))) /
       (4.f * ss);
  if (q2 > 1.e-06f) {
    q = fem::sqrt(q2);
  } else {
    q = 0.f;
    return_value = 1.e-06f;
    return return_value;
  }
  ss0 = fem::pow2(am0);
  q02 = (ss0 - fem::pow2((amu - amp))) * (ss0 - fem::pow2((amu + amp))) /
        (4.f * ss0);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = q02;
  if (scheck < 0) {
    write(99, star), "scheck20: ", scheck;
    scheck = 0.f;
  }
  q0 = fem::sqrt(scheck);
  /// C        Q0=SQRT(Q02)
  /// C
  const float pi = 3.1415926f;
  const float hc = 0.19733f;
  return_value =
      pi * fem::pow2((hc)) / (2.f * p2) * alfa * fem::pow((pr / p0), beta) *
      fem::pow2(am0) * fem::pow2(t) * fem::pow3((q / q0)) /
      (fem::pow2((ss - fem::pow2(am0))) + fem::pow2(am0) * fem::pow2(t));
  return_value = return_value * 10.f;
  if (return_value == 0) {
    return_value = 1.e-06f;
  }
  return return_value;
}

struct ang_save {
  float ang1;
  float ang2;
  float b1s;
  float b2s;
  float p;
  float q;
  float x;

  ang_save()
      : ang1(fem::float0),
        ang2(fem::float0),
        b1s(fem::float0),
        b2s(fem::float0),
        p(fem::float0),
        q(fem::float0),
        x(fem::float0) {}
};

/// C*********************************
/// C subroutine : ang.FOR
/// C PURPOSE : Calculate the angular distribution of Delta production process
/// C DATE    : Nov. 19, 1992
/// C REFERENCE: G. WOLF ET. AL., NUCL. PHYS. A517 (1990) 615
/// C Note: this function applies when srt is larger than 2.14 GeV,
/// C for less energetic reactions, we assume the angular distribution
/// C is isotropic.
/// C**********************************
float ang(common& cmn, float const& srt, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ang);
  /// SAVE
  float& ang1 = sve.ang1;
  float& ang2 = sve.ang2;
  float& b1s = sve.b1s;
  float& b2s = sve.b2s;
  float& p = sve.p;
  float& q = sve.q;
  float& x = sve.x;
  ///
  /// Cc      SAVE /RNDF77/
  /// C        if(srt.le.2.14)then
  /// C       b1s=0.5
  /// C       b2s=0.
  /// C      endif
  if ((srt > 2.14f) && (srt <= 2.4f)) {
    b1s = 29.03f - 23.75f * srt + 4.865f * fem::pow2(srt);
    b2s = -30.33f + 25.53f * srt - 5.301f * fem::pow2(srt);
  }
  if (srt > 2.4f) {
    b1s = 0.06f;
    b2s = 0.4f;
  }
  x = ranart(cmn.nseed);
  p = b1s / b2s;
  q = (2.f * x - 1.f) * (b1s + b2s) / b2s;
  if ((-q / 2.f + fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))) >=
      0.f) {
    ang1 = fem::pow(
        (-q / 2.f + fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  } else {
    ang1 = -fem::pow(
        (q / 2.f - fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  }
  if ((-q / 2.f - fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f))) >=
       0.f)) {
    ang2 = fem::pow(
        (-q / 2.f - fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  } else {
    ang2 = -fem::pow(
        (q / 2.f + fem::sqrt(fem::pow2((q / 2.f)) + fem::pow3((p / 3.f)))),
        (1.f / 3.f));
  }
  return_value = ang1 + ang2;
  return return_value;
}

struct n1535_save {
  float s0;
  float sigma;

  n1535_save() : s0(fem::float0), sigma(fem::float0) {}
};

/// C************************
/// C cross section for N*(1535) production in NN collisions
/// C VARIABLES:
/// C LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
/// C SRT IS THE CMS ENERGY
/// C X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
/// C NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA
/// C PRODUCTION CROSS SECTION
/// C DATE: MAY 18, 1994
/// C ***********************
void n1535(common& cmn, int const& lb1, int const& lb2, float const& srt,
           float& x1535) {
  FEM_CMN_SVE(n1535);
  /// SAVE
  float& s0 = sve.s0;
  float& sigma = sve.sigma;
  ///
  s0 = 2.424f;
  x1535 = 0.f;
  if (srt <= s0) {
    return;
  }
  sigma = 2.f * 0.102f * (srt - s0) / (0.058f + fem::pow2((srt - s0)));
  /// C I N*(1535) PRODUCTION IN NUCLEON-NUCLEON COLLISIONS
  /// C(1) pp->pN*(+)(1535), nn->nN*(0)(1535)
  /// Cbdbg11/25/98
  /// C       IF((LB1*LB2.EQ.1).OR.(LB1*LB2.EQ.4))then
  if ((lb1 * lb2 == 1) || (lb1 == 2 && lb2 == 2)) {
    /// Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  /// C(2) pn->pN*(0)(1535),pn->nN*(+)(1535)
  if (lb1 * lb2 == 2) {
    x1535 = 3.f * sigma;
    return;
  }
  /// C III N*(1535) PRODUCTION IN DELTA+DELTA REACTIONS
  /// C (5) D(++)+D(0), D(+)+D(+),D(+)+D(-),D(0)+D(0)
  /// Cbz11/25/98
  /// C       IF((LB1*LB2.EQ.63).OR.(LB1*LB2.EQ.64).OR.(LB1*LB2.EQ.48).
  /// C     1  OR.(LB1*LB2.EQ.49))then
  if ((lb1 * lb2 == 63 && (lb1 == 7 || lb2 == 7)) ||
      (lb1 * lb2 == 64 && (lb1 == 8 || lb2 == 8)) ||
      (lb1 * lb2 == 48 && (lb1 == 6 || lb2 == 6)) ||
      (lb1 * lb2 == 49 && (lb1 == 7 || lb2 == 7))) {
    /// Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  /// C (6) D(++)+D(-),D(+)+D(0)
  /// Cbz11/25/98
  /// C       IF((LB1*LB2.EQ.54).OR.(LB1*LB2.EQ.56))then
  if ((lb1 * lb2 == 54 && (lb1 == 6 || lb2 == 6)) ||
      (lb1 * lb2 == 56 && (lb1 == 7 || lb2 == 7))) {
    /// Cbz11/25/98end
    x1535 = 3.f * sigma;
    return;
  }
  /// C IV N*(1535) PRODUCTION IN N*(1440)+N*(1440) REACTIONS
  /// Cbz11/25/98
  /// C       IF((LB1*LB2.EQ.100).OR.(LB1*LB2.EQ.11*11))X1535=SIGMA
  if ((lb1 == 10 && lb2 == 10) || (lb1 == 11 && lb2 == 11)) {
    x1535 = sigma;
  }
  /// C       IF(LB1*LB2.EQ.110)X1535=3.*SIGMA
  if (lb1 * lb2 == 110 && (lb1 == 10 || lb2 == 10)) {
    x1535 = 3.f * sigma;
  }
  /// Cbdbg11/25/98end
}

struct ptdis_save {
  float b;
  float c;
  float d;

  ptdis_save() : b(fem::float0), c(fem::float0), d(fem::float0) {}
};

/// C********************************
float ptdis(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptdis);
  /// SAVE
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  ///
  /// C NUCLEON TRANSVERSE MOMENTUM DISTRIBUTION AT HIGH ENERGIES
  /// C DATE: Aug. 11, 1994
  /// C********************************
  b = 3.78f;
  c = 0.47f;
  d = 3.60f;
  /// C       b=b*3
  /// C       d=d*3
  return_value = 1.f / (2.f * b) * (1.f - fem::exp(-b * fem::pow2(x))) -
                 c / d * x * fem::exp(-d * x) -
                 c / fem::pow2(d) * (fem::exp(-d * x) - 1.f);
  return return_value;
}

struct ptr_save {
  int ie;
  float tryial;
  float xmax;
  float xmin;
  float xt;
  float ymax;
  float ymin;

  ptr_save()
      : ie(fem::int0),
        tryial(fem::float0),
        xmax(fem::float0),
        xmin(fem::float0),
        xt(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C******************************
float ptr(common& cmn, float& ptmax, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptr);
  arr_cref<float> xarray(cmn.xarray, dim1(0, 1000));
  arr_cref<float> earray(cmn.earray, dim1(0, 1000));
  ///
  int& ie = sve.ie;
  float& tryial = sve.tryial;
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& xt = sve.xt;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  /// C (2) Generate the transverse momentum
  /// C     OF nucleons
  /// C******************************
  /// Cc      SAVE /TABLE/
  /// Cc      SAVE /RNDF77/
  return_value = 0.f;
  if (ptmax <= 1.e-02f) {
    return_value = ptmax;
    return return_value;
  }
  if (ptmax > 2.01f) {
    ptmax = 2.01f;
  }
  tryial = ptdis(cmn, ptmax) / ptdis(cmn, 2.01f);
  xt = ranart(cmn.nseed) * tryial;
  /// C look up the table and
  /// CInterpolate double logarithmically to find pt
  FEM_DO_SAFE(ie, 1, 200) {
    if (earray(ie) == xt) {
      return_value = xarray(ie);
      return return_value;
    }
    if (xarray(ie - 1) <= 0.00001f) {
      goto statement_50;
    }
    if (xarray(ie) <= 0.00001f) {
      goto statement_50;
    }
    if (earray(ie - 1) <= 0.00001f) {
      goto statement_50;
    }
    if (earray(ie) <= 0.00001f) {
      goto statement_50;
    }
    if (earray(ie) > xt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(xt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      if (return_value > ptmax) {
        return_value = ptmax;
      }
      return return_value;
    }
  statement_50:;
  }
  return return_value;
}

struct fmassd_save {
  float am0;

  fmassd_save() : am0(fem::float0) {}
};

/// CFUNCTION Fmassd(DMASS) GIVES the delta MASS DISTRIBUTION
float fmassd(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fmassd);
  /// SAVE
  float& am0 = sve.am0;
  ///
  am0 = 1.232f;
  return_value = am0 * width(cmn, dmass) /
                 (fem::pow2((fem::pow2(dmass) - fem::pow2(am0))) +
                  fem::pow2(am0) * fem::pow2(width(cmn, dmass)));
  return return_value;
}

struct w1440_save {
  float aux;
  float avmass;
  float pimass;
  float qavail;

  w1440_save()
      : aux(fem::float0),
        avmass(fem::float0),
        pimass(fem::float0),
        qavail(fem::float0) {}
};

/// C***********************************
/// C FUNCTION W1440(DMASS) GIVES THE N*(1440) DECAY WIDTH
/// C     FOR A GIVEN N*(1535) MASS
/// C HERE THE FORMULA GIVEN BY KITAZOE IS USED
float w1440(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(w1440);
  /// SAVE
  float& aux = sve.aux;
  float& avmass = sve.avmass;
  float& pimass = sve.pimass;
  float& qavail = sve.qavail;
  ///
  avmass = 0.938868f;
  pimass = 0.137265f;
  aux = 0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(avmass) -
                           fem::pow2(pimass))) -
        fem::pow2((avmass * pimass));
  if (aux > 0.f) {
    qavail = fem::sqrt(aux) / dmass;
  } else {
    qavail = 1.e-06f;
  }
  /// C              w1440=0.2
  return_value = 0.2f * fem::pow3((qavail / 0.397f));
  return return_value;
}

struct fmassn_save {
  float am0;

  fmassn_save() : am0(fem::float0) {}
};

/// CFUNCTION Fmassn(DMASS) GIVES the N* MASS DISTRIBUTION
float fmassn(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fmassn);
  /// SAVE
  float& am0 = sve.am0;
  ///
  am0 = 1.44f;
  return_value = am0 * w1440(cmn, dmass) /
                 (fem::pow2((fem::pow2(dmass) - fem::pow2(am0))) +
                  fem::pow2(am0) * fem::pow2(w1440(cmn, dmass)));
  return return_value;
}

struct fmassr_save {
  float am0;
  float wid;

  fmassr_save() : am0(fem::float0), wid(fem::float0) {}
};

/// CFUNCTION Fmassr(DMASS) GIVES the rho MASS DISTRIBUTION
float fmassr(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fmassr);
  /// SAVE
  float& am0 = sve.am0;
  float& wid = sve.wid;
  ///
  am0 = 0.77f;
  wid = 0.153f;
  return_value = am0 * wid /
                 (fem::pow2((fem::pow2(dmass) - fem::pow2(am0))) +
                  fem::pow2(am0) * fem::pow2(wid));
  return return_value;
}

struct rmasdd_save {
  float amn;
  float amp;
  float dmax1;
  float dmax2;
  float fff;
  float fm1;
  float fm2;
  int ictrl;
  int ntry;
  int ntry1;
  int ntry2;
  float prob;
  float prob0;
  float q2;

  rmasdd_save()
      : amn(fem::float0),
        amp(fem::float0),
        dmax1(fem::float0),
        dmax2(fem::float0),
        fff(fem::float0),
        fm1(fem::float0),
        fm2(fem::float0),
        ictrl(fem::int0),
        ntry(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        prob(fem::float0),
        prob0(fem::float0),
        q2(fem::float0) {}
};

/// C**************************8
/// C   MASS GENERATOR for two resonances simultaneously
void rmasdd(common& cmn, float const& srt, float const& am10, float const& am20,
            float const& dmin1, float const& dmin2, int const& /* iseed */,
            int const& ic, float& dm1, float& dm2) {
  FEM_CMN_SVE(rmasdd);
  int& nseed = cmn.nseed;
  ///
  float& dmax1 = sve.dmax1;
  float& dmax2 = sve.dmax2;
  float& fff = sve.fff;
  float& fm1 = sve.fm1;
  float& fm2 = sve.fm2;
  int& ictrl = sve.ictrl;
  int& ntry = sve.ntry;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& prob = sve.prob;
  float& prob0 = sve.prob0;
  float& q2 = sve.q2;
  /// Cc      SAVE /RNDF77/
  sve.amn = 0.94f;
  sve.amp = 0.14f;
  /// C the maximum mass for resonance 1
  dmax1 = srt - dmin2;
/// C generate the mass for the first resonance
statement_5:
  ntry1 = 0;
  ntry2 = 0;
  ntry = 0;
  ictrl = 0;
statement_10:
  dm1 = ranart(nseed) * (dmax1 - dmin1) + dmin1;
  ntry1++;
  /// C the maximum mass for resonance 2
  if (ictrl == 0) {
    dmax2 = srt - dm1;
  }
/// C generate the mass for the second resonance
statement_20:
  dm2 = ranart(nseed) * (dmax2 - dmin2) + dmin2;
  ntry2++;
  /// C check the energy-momentum conservation with two masses
  /// C q2 in the following is q**2*4*srt**2
  q2 = (fem::pow2((fem::pow2(srt) - fem::pow2(dm1) - fem::pow2(dm2))) -
        4.f * fem::pow2(dm1) * fem::pow2(dm2));
  if (q2 <= 0) {
    dmax2 = dm2 - 0.01f;
    /// C         dmax1=dm1-0.01
    ictrl = 1;
    goto statement_20;
  }
  /// C determine the weight of the mass pair
  if (dmax1 < am10) {
    if (ic == 1) {
      fm1 = fmassd(cmn, dmax1);
    }
    if (ic == 2) {
      fm1 = fmassn(cmn, dmax1);
    }
    if (ic == 3) {
      fm1 = fmassd(cmn, dmax1);
    }
    if (ic == 4) {
      fm1 = fmassd(cmn, dmax1);
    }
  } else {
    if (ic == 1) {
      fm1 = fmassd(cmn, am10);
    }
    if (ic == 2) {
      fm1 = fmassn(cmn, am10);
    }
    if (ic == 3) {
      fm1 = fmassd(cmn, am10);
    }
    if (ic == 4) {
      fm1 = fmassd(cmn, am10);
    }
  }
  if (dmax2 < am20) {
    if (ic == 1) {
      fm2 = fmassd(cmn, dmax2);
    }
    if (ic == 2) {
      fm2 = fmassn(cmn, dmax2);
    }
    if (ic == 3) {
      fm2 = fmassn(cmn, dmax2);
    }
    if (ic == 4) {
      fm2 = fmassr(cmn, dmax2);
    }
  } else {
    if (ic == 1) {
      fm2 = fmassd(cmn, am20);
    }
    if (ic == 2) {
      fm2 = fmassn(cmn, am20);
    }
    if (ic == 3) {
      fm2 = fmassn(cmn, am20);
    }
    if (ic == 4) {
      fm2 = fmassr(cmn, am20);
    }
  }
  if (fm1 == 0.f) {
    fm1 = 1.e-04f;
  }
  if (fm2 == 0.f) {
    fm2 = 1.e-04f;
  }
  prob0 = fm1 * fm2;
  if (ic == 1) {
    prob = fmassd(cmn, dm1) * fmassd(cmn, dm2);
  }
  if (ic == 2) {
    prob = fmassn(cmn, dm1) * fmassn(cmn, dm2);
  }
  if (ic == 3) {
    prob = fmassd(cmn, dm1) * fmassn(cmn, dm2);
  }
  if (ic == 4) {
    prob = fmassd(cmn, dm1) * fmassr(cmn, dm2);
  }
  if (prob <= 1.e-06f) {
    prob = 1.e-06f;
  }
  fff = prob / prob0;
  ntry++;
  if (ranart(nseed) > fff && ntry <= 20) {
    goto statement_10;
  }
  /// C
  /// Clin-2/26/03 limit the mass of (rho,Delta,N*1440) below a certain value
  /// C     (here taken as its central value + 2* B-W fullwidth):
  if ((fem::abs(am10 - 0.77f) <= 0.01f && dm1 > 1.07f) ||
      (fem::abs(am10 - 1.232f) <= 0.01f && dm1 > 1.47f) ||
      (fem::abs(am10 - 1.44f) <= 0.01f && dm1 > 2.14f)) {
    goto statement_5;
  }
  if ((fem::abs(am20 - 0.77f) <= 0.01f && dm2 > 1.07f) ||
      (fem::abs(am20 - 1.232f) <= 0.01f && dm2 > 1.47f) ||
      (fem::abs(am20 - 1.44f) <= 0.01f && dm2 > 2.14f)) {
    goto statement_5;
  }
  /// C
}

struct ddp2_save {
  float amn;
  float amp;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float scheck;
  float sig;
  float srt1;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  ddp2_save()
      : amn(fem::float0),
        amp(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        srt1(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

/// C***********************************
void ddp2(common& cmn, float const& srt, int const& iseed, float& px, float& py,
          float& pz, float& dm1, float& pnx, float& pny, float& pnz, float& dm2,
          float& ppx, float& ppy, float& ppz, int& icou1) {
  FEM_CMN_SVE(ddp2);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  ///
  float& amp = sve.amp;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& srt1 = sve.srt1;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  /// C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  /// C THE PROCESS N+N--->D1+D2+PION
  /// C       DATE : July 25, 1994
  /// C Generate the masses and momentum for particles in the NN-->DDpi process
  /// C for a given center of mass energy srt, the momenta are given in the
  /// center C of mass of the NN C**************************************** Cc
  /// SAVE /TABLE/ Cc      SAVE /RNDF77/
  icou1 = 0;
  pi = 3.1415926f;
  sve.amn = 938.925f / 1000.f;
  amp = 137.265f / 1000.f;
  /// C (1) GENGRATE THE MASS OF DELTA1 AND DELTA2 USING
  srt1 = srt - amp - 0.02f;
  ntrym = 0;
statement_8:
  rmasdd(cmn, srt1, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
  ntrym++;
  /// C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  /// C FOR ONE OF THE RESONANCES
  v = 0.43f;
  w = -0.84f;
  /// C (2) Generate the transverse momentum
  /// C     OF DELTA1
  /// C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  if (ptmax2 <= 0) {
    goto statement_8;
  }
  ptmax = fem::sqrt(ptmax2) * 1.f / 3.f;
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  /// C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-09f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  /// C (3.2) THE GENERATED X IS
  /// C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  /// Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  /// C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  /// C The x and y components of the deltA1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  /// C find the momentum of delta2 and pion
  /// C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  /// C (1) Generate the momentum of the delta2 in the cms of delta2 and pion
  /// C     the energy of the cms of DP
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  /// C beta and gamma of the cms of delta2+pion
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck22: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  /// C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  /// C
  /// C the momentum of delta2 and pion in their cms frame
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  /// C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  /// Clin-10/25/02-end
  /// C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck23: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  /// C       pnz=SIG*SQRT(pn**2-PNT**2)
  /// C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  /// C (2) the momentum for the pion
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  /// C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  /// C (4) for the pion, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct frho_save {
  float am0;
  float fd;
  float wid;

  frho_save() : am0(fem::float0), fd(fem::float0), wid(fem::float0) {}
};

/// C
/// C------------------------------------------------------------------
/// C THE Breit Wigner FORMULA
float frho(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(frho);
  /// SAVE
  float& am0 = sve.am0;
  float& fd = sve.fd;
  float& wid = sve.wid;
  ///
  am0 = 0.77f;
  wid = 0.153f;
  fd = 0.25f * fem::pow2(wid) /
       (fem::pow2((dmass - am0)) + 0.25f * fem::pow2(wid));
  return_value = fd;
  return return_value;
}

struct rhomas_save {
  float dm;
  float dmin;
  float fm;
  int ntry1;

  rhomas_save()
      : dm(fem::float0), dmin(fem::float0), fm(fem::float0), ntry1(fem::int0) {}
};

/// C**************************8
/// C   RHO MASS GENERATOR
float rhomas(common& cmn, float const& dmax, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rhomas);
  int& nseed = cmn.nseed;
  ///
  float& dm = sve.dm;
  float& dmin = sve.dmin;
  float& fm = sve.fm;
  int& ntry1 = sve.ntry1;
  /// Cc      SAVE /RNDF77/
  /// C THE MINIMUM MASS FOR DELTA
  dmin = 0.28f;
  /// C RHO(770) production
  if (dmax < 0.77f) {
    fm = frho(cmn, dmax);
  } else {
    fm = 1.f;
  }
  if (fm == 0.f) {
    fm = 1.e-06f;
  }
  ntry1 = 0;
statement_10:
  dm = ranart(nseed) * (dmax - dmin) + dmin;
  ntry1++;
  if ((ranart(nseed) > frho(cmn, dm) / fm) && (ntry1 <= 10)) {
    goto statement_10;
  }
  /// Clin-2/26/03 limit the rho mass below a certain value
  /// C     (here taken as its central value + 2* B-W fullwidth):
  if (dm > 1.07f) {
    goto statement_10;
  }
  /// C
  return_value = dm;
  return return_value;
}

struct ddrho_save {
  float amn;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float rhomax;
  float scheck;
  float sig;
  float srt1;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  ddrho_save()
      : amn(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        rhomax(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        srt1(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

/// C***************************************
void ddrho(common& cmn, float const& srt, int const& iseed, float& px,
           float& py, float& pz, float& dm1, float& pnx, float& pny, float& pnz,
           float& dm2, float& ppx, float& ppy, float& ppz, float& amp,
           int& icou1) {
  FEM_CMN_SVE(ddrho);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  ///
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& rhomax = sve.rhomax;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& srt1 = sve.srt1;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  /// C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  /// C THE PROCESS N+N--->D1+D2+rho
  /// C       DATE : Nov.5, 1994
  /// C Generate the masses and momentum for particles in the NN-->DDrho process
  /// C for a given center of mass energy srt, the momenta are given in the
  /// center C of mass of the NN C**************************************** Cc
  /// SAVE /TABLE/ Cc      SAVE /RNDF77/
  icou1 = 0;
  pi = 3.1415926f;
  sve.amn = 938.925f / 1000.f;
  amp = 770.f / 1000.f;
  /// C (1) GENGRATE THE MASS OF DELTA1 AND DELTA2 USING
  srt1 = srt - amp - 0.02f;
  ntrym = 0;
statement_8:
  rmasdd(cmn, srt1, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
  ntrym++;
  /// C GENERATE THE MASS FOR THE RHO
  rhomax = srt - dm1 - dm2 - 0.02f;
  if (rhomax <= 0 && ntrym <= 20) {
    goto statement_8;
  }
  amp = rhomas(cmn, rhomax, iseed);
  /// C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  /// C FOR ONE OF THE RESONANCES
  v = 0.43f;
  w = -0.84f;
  /// C (2) Generate the transverse momentum
  /// C     OF DELTA1
  /// C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = ptmax2;
  if (scheck < 0) {
    write(99, star), "scheck24: ", scheck;
    scheck = 0.f;
  }
  ptmax = fem::sqrt(scheck) * 1.f / 3.f;
/// C       PTMAX=SQRT(PTMAX2)*1./3.
/// C
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  /// C (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
  /// C     USING THE GIVEN DISTRIBUTION
  /// C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-06f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  /// C (3.2) THE GENERATED X IS
  /// C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  /// Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  /// C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  /// C The x and y components of the delta1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  /// C find the momentum of delta2 and rho
  /// C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  /// C (1) Generate the momentum of the delta2 in the cms of delta2 and rho
  /// C     the energy of the cms of Drho
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  /// C beta and gamma of the cms of delta2 and rho
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck25: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  /// C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  /// C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  /// C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  /// Clin-10/25/02-end
  /// C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck26: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  /// C       pnz=SIG*SQRT(pn**2-PNT**2)
  /// C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  /// C (2) the momentum for the rho
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  /// C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  /// C (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct pprho_save {
  float amn;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int icou;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float rhomax;
  float scheck;
  float sig;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  pprho_save()
      : amn(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        icou(fem::int0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        rhomax(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

/// C***************************************
void pprho(common& cmn, float const& srt, int const& iseed, float& px,
           float& py, float& pz, float& dm1, float& pnx, float& pny, float& pnz,
           float& dm2, float& ppx, float& ppy, float& ppz, float& amp,
           int& icou1) {
  FEM_CMN_SVE(pprho);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  ///
  float& amn = sve.amn;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& rhomax = sve.rhomax;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  /// C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  /// C THE PROCESS N+N--->N1+N2+rho
  /// C       DATE : Nov.5, 1994
  /// C Generate the masses and momentum for particles in the NN--> process
  /// C for a given center of mass energy srt, the momenta are given in the
  /// center C of mass of the NN C**************************************** Cc
  /// SAVE /TABLE/ Cc      SAVE /RNDF77/
  ntrym = 0;
  icou1 = 0;
  pi = 3.1415926f;
  amn = 938.925f / 1000.f;
  /// C        AMP=770./1000.
  dm1 = amn;
  dm2 = amn;
  /// C GENERATE THE MASS FOR THE RHO
  rhomax = srt - dm1 - dm2 - 0.02f;
  if (rhomax <= 0) {
    sve.icou = -1;
    return;
  }
  amp = rhomas(cmn, rhomax, iseed);
  /// C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  /// C FOR ONE OF THE nucleons
  v = 0.43f;
  w = -0.84f;
  /// C (2) Generate the transverse momentum
  /// C     OF p1
  /// C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = ptmax2;
  if (scheck < 0) {
    write(99, star), "scheck27: ", scheck;
    scheck = 0.f;
  }
  ptmax = fem::sqrt(scheck) * 1.f / 3.f;
/// C       PTMAX=SQRT(PTMAX2)*1./3.
/// C
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  /// C (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
  /// C     USING THE GIVEN DISTRIBUTION
  /// C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  ntrym++;
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-06f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  /// C (3.2) THE GENERATED X IS
  /// C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  /// Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  /// C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  /// C The x and y components of the delta1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  /// C find the momentum of delta2 and rho
  /// C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  /// C (1) Generate the momentum of the delta2 in the cms of delta2 and rho
  /// C     the energy of the cms of Drho
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  /// C beta and gamma of the cms of the two partciles
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck28: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  /// C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  /// C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  /// C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  /// Clin-10/25/02-end
  /// C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck29: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  /// C       pnz=SIG*SQRT(pn**2-PNT**2)
  /// C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  /// C (2) the momentum for the rho
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  /// C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  /// C (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct ppomga_save {
  float amn;
  float amp;
  float bx;
  float by;
  float bz;
  float ek;
  float eln;
  float elnc;
  float en;
  float ep;
  float f00;
  float fai;
  float fain;
  float fmax00;
  float ga;
  int ntrym;
  int ntryx;
  float pbeta;
  float pi;
  float pn;
  float pn2;
  float pnt;
  float pt;
  float ptmax;
  float ptmax2;
  float pzmax;
  float pzmax2;
  float scheck;
  float sig;
  float trans0;
  float v;
  float w;
  float x;
  float x00;
  float xmax;
  float xptr;
  float xratio;

  ppomga_save()
      : amn(fem::float0),
        amp(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        ek(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        f00(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        fmax00(fem::float0),
        ga(fem::float0),
        ntrym(fem::int0),
        ntryx(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        pnt(fem::float0),
        pt(fem::float0),
        ptmax(fem::float0),
        ptmax2(fem::float0),
        pzmax(fem::float0),
        pzmax2(fem::float0),
        scheck(fem::float0),
        sig(fem::float0),
        trans0(fem::float0),
        v(fem::float0),
        w(fem::float0),
        x(fem::float0),
        x00(fem::float0),
        xmax(fem::float0),
        xptr(fem::float0),
        xratio(fem::float0) {}
};

/// C**************************8
/// C***************************************
void ppomga(common& cmn, float const& srt, int const& iseed, float& px,
            float& py, float& pz, float& dm1, float& pnx, float& pny,
            float& pnz, float& dm2, float& ppx, float& ppy, float& ppz,
            int& icou1) {
  FEM_CMN_SVE(ppomga);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  ///
  float& amn = sve.amn;
  float& amp = sve.amp;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& ek = sve.ek;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& ep = sve.ep;
  float& f00 = sve.f00;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& fmax00 = sve.fmax00;
  float& ga = sve.ga;
  int& ntrym = sve.ntrym;
  int& ntryx = sve.ntryx;
  float& pbeta = sve.pbeta;
  float& pi = sve.pi;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& pnt = sve.pnt;
  float& pt = sve.pt;
  float& ptmax = sve.ptmax;
  float& ptmax2 = sve.ptmax2;
  float& pzmax = sve.pzmax;
  float& pzmax2 = sve.pzmax2;
  float& scheck = sve.scheck;
  float& sig = sve.sig;
  float& trans0 = sve.trans0;
  float& v = sve.v;
  float& w = sve.w;
  float& x = sve.x;
  float& xmax = sve.xmax;
  float& xptr = sve.xptr;
  float& xratio = sve.xratio;
  /// C PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
  /// C THE PROCESS N+N--->N1+N2+OMEGA
  /// C       DATE : Nov.5, 1994
  /// C Generate the masses and momentum for particles in the NN--> process
  /// C for a given center of mass energy srt, the momenta are given in the
  /// center C of mass of the NN C**************************************** Cc
  /// SAVE /TABLE/ Cc      SAVE /RNDF77/
  ntrym = 0;
  icou1 = 0;
  pi = 3.1415926f;
  amn = 938.925f / 1000.f;
  amp = 782.f / 1000.f;
  dm1 = amn;
  dm2 = amn;
  /// C CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM
  /// C FOR ONE OF THE nucleons
  v = 0.43f;
  w = -0.84f;
  /// C (2) Generate the transverse momentum
  /// C     OF p1
  /// C (2.1) estimate the maximum transverse momentum
  ptmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
           (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
           fem::pow2(srt);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = ptmax2;
  if (scheck < 0) {
    write(99, star), "scheck30: ", scheck;
    scheck = 0.f;
  }
  ptmax = fem::sqrt(scheck) * 1.f / 3.f;
/// C       PTMAX=SQRT(PTMAX2)*1./3.
/// C
statement_7:
  pt = ptr(cmn, ptmax, iseed);
  /// C (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
  /// C     USING THE GIVEN DISTRIBUTION
  /// C (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
  pzmax2 = (fem::pow2(srt) - fem::pow2((dm1 + dm2 + amp))) *
               (fem::pow2(srt) - fem::pow2((dm1 - amp - dm2))) / 4.f /
               fem::pow2(srt) -
           fem::pow2(pt);
  ntrym++;
  if ((pzmax2 < 0.f) && ntrym <= 100) {
    goto statement_7;
  } else {
    pzmax2 = 1.e-09f;
  }
  pzmax = fem::sqrt(pzmax2);
  xmax = 2.f * pzmax / srt;
  /// C (3.2) THE GENERATED X IS
  /// C THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
  ntryx = 0;
  fmax00 = 1.056f;
  sve.x00 = 0.26f;
  if (fem::abs(xmax) > 0.26f) {
    f00 = fmax00;
  } else {
    f00 = 1.f + v * fem::abs(xmax) + w * fem::pow2(xmax);
  }
statement_9:
  x = xmax * (1.f - 2.f * ranart(nseed));
  ntryx++;
  xratio = (1.f + v * fem::abs(x) + w * fem::pow2(x)) / f00;
  /// Clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9
  if (xratio < ranart(nseed) && ntryx <= 50) {
    goto statement_9;
  }
  /// C (3.5) THE PZ IS
  pz = 0.5f * srt * x;
  /// C The x and y components of the delta1
  fai = 2.f * pi * ranart(nseed);
  px = pt * fem::cos(fai);
  py = pt * fem::sin(fai);
  /// C find the momentum of delta2 and rho
  /// C the energy of the delta1
  ek = fem::sqrt(fem::pow2(dm1) + fem::pow2(pt) + fem::pow2(pz));
  /// C (1) Generate the momentum of the delta2 in the cms of delta2 and rho
  /// C     the energy of the cms of Drho
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  bx = -px / eln;
  by = -py / eln;
  bz = -pz / eln;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck31: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  /// C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  /// C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(dm2) - fem::pow2(amp)) /
                   (2.f * elnc))) -
        fem::pow2(dm2);
  if (pn2 <= 0) {
    icou1 = -1;
    return;
  }
  pn = fem::sqrt(pn2);
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pn;
  /// C       PNT=PTR(0.33*PN,ISEED)
  pnt = ptr(cmn, xptr, iseed);
  /// Clin-10/25/02-end
  /// C
  fain = 2.f * pi * ranart(nseed);
  pnx = pnt * fem::cos(fain);
  pny = pnt * fem::sin(fain);
  sig = 1;
  if (x > 0) {
    sig = -1;
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pn) - fem::pow2(pnt);
  if (scheck < 0) {
    write(99, star), "scheck32: ", scheck;
    scheck = 0.f;
  }
  pnz = sig * fem::sqrt(scheck);
  /// C       pnz=SIG*SQRT(pn**2-PNT**2)
  /// C
  en = fem::sqrt(fem::pow2(dm2) + fem::pow2(pnx) + fem::pow2(pny) +
                 fem::pow2(pnz));
  /// C (2) the momentum for the rho
  ppx = -pnx;
  ppy = -pny;
  ppz = -pnz;
  ep = fem::sqrt(fem::pow2(amp) + fem::pow2(ppx) + fem::pow2(ppy) +
                 fem::pow2(ppz));
  /// C (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  pbeta = pnx * bx + pny * by + pnz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  pnx += bx * trans0;
  pny += by * trans0;
  pnz += bz * trans0;
  /// C (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
  if (ep == 0.f) {
    ep = 1.e-09f;
  }
  pbeta = ppx * bx + ppy * by + ppz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + ep);
  ppx += bx * trans0;
  ppy += by * trans0;
  ppz += bz * trans0;
}

struct x2pi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  x2pi_save()
      : earray(dimension(15), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(15), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for pp-->pp+2pi
/// C      real*4 function X2pi(srt)
float x2pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x2pi);
  /// SAVE
  arr_ref<float> earray(sve.earray, dimension(15));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(15));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {2.23f, 2.81f, 3.67f,  4.0f,  4.95f,
                                     5.52f, 5.97f, 6.04f,  6.6f,  6.9f,
                                     7.87f, 8.11f, 10.01f, 16.0f, 19.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {1.22f, 2.51f, 2.67f, 2.95f, 2.96f,
                                     2.84f, 2.8f,  3.2f,  2.7f,  3.0f,
                                     2.54f, 2.46f, 2.4f,  1.66f, 1.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  /// C  This function contains the experimental
  /// C     total pp-pp+pi(+)pi(-) Xsections    *
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C  earray = EXPerimental table with proton momentum in GeV/c * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye)* C *
  /// C*****************************************
  /// C      real*4   xarray(15), earray(15)
  /// C
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0.000001f;
  if (srt <= 2.2f) {
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 15) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct x3pi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  x3pi_save()
      : earray(dimension(12), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(12), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for pp-->pn+pi(+)pi(+)pi(-)
/// C      real*4 function X3pi(srt)
float x3pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x3pi);
  /// SAVE
  arr_ref<float> earray(sve.earray, dimension(12));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(12));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {0.02f, 0.4f,  1.15f, 1.60f, 2.19f, 2.85f,
                                     2.30f, 3.10f, 2.47f, 2.60f, 2.40f, 1.70f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {2.23f, 2.81f, 3.67f, 4.00f, 4.95f,  5.52f,
                                     5.97f, 6.04f, 6.60f, 6.90f, 10.01f, 19.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  This function contains the experimental pp->pp+3pi cross sections * C
  /// srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb * C
  /// earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  /// C      real*4   xarray(12), earray(12)
  /// C
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 1.e-06f;
  if (srt <= 2.3f) {
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 12) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct x33pi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  x33pi_save()
      : earray(dimension(12), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(12), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for pp-->pp+pi(+)pi(-)pi(0)
/// C      real*4 function X33pi(srt)
float x33pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x33pi);
  /// SAVE
  arr_ref<float> earray(sve.earray, dimension(12));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(12));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {0.02f, 0.22f, 0.74f, 1.10f, 1.76f, 1.84f,
                                     2.20f, 2.40f, 2.15f, 2.60f, 2.30f, 1.70f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {2.23f, 2.81f, 3.67f, 4.00f, 4.95f,  5.52f,
                                     5.97f, 6.04f, 6.60f, 6.90f, 10.01f, 19.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  This function contains the experimental pp->pp+3pi cross sections * C
  /// srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb * C
  /// earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  /// C      real*4   xarray(12), earray(12)
  /// C
  pmass = 0.9383f;
  return_value = 1.e-06f;
  if (srt <= 2.3f) {
    return return_value;
  }
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 12) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct pp1_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float plab2;
  float pmass;
  float pmax;
  float pmin;

  pp1_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        plab2(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0) {}
};

/// C*****************************************
/// C for pp-->inelastic
/// C      real*4 function pp1(srt)
float pp1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pp1);
  /// SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& plab = sve.plab;
  float& plab2 = sve.plab2;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  pmass = 0.9383f;
  return_value = 0.f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab2 =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (plab2 <= 0) {
    return return_value;
  }
  plab = fem::sqrt(plab2);
  pmin = 0.968f;
  pmax = 2080;
  if ((plab < pmin) || (plab > pmax)) {
    return_value = 0.f;
    return return_value;
  }
  /// C* fit parameters
  a = 30.9f;
  b = -28.9f;
  c = 0.192f;
  sve.d = -0.835f;
  an = -2.46f;
  return_value =
      a + b * (fem::pow(plab, an)) + c * fem::pow2((fem::alog(plab)));
  if (return_value <= 0) {
    return_value = 0.0f;
  }
  return return_value;
}

struct s1535_save {
  float s0;

  s1535_save() : s0(fem::float0) {}
};

/// C
/// C************************
/// C cross section for N*(1535) production in PP collisions
/// C VARIABLES:
/// C LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
/// C SRT IS THE CMS ENERGY
/// C X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
/// C NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA
/// C PRODUCTION CROSS SECTION
/// C DATE: Aug. 1 , 1994
/// C ********************************
float s1535(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(s1535);
  /// SAVE
  float& s0 = sve.s0;
  ///
  s0 = 2.424f;
  return_value = 0.f;
  if (srt <= s0) {
    return return_value;
  }
  return_value = 2.f * 0.102f * (srt - s0) / (0.058f + fem::pow2((srt - s0)));
  return return_value;
}

struct pplpk_save {
  float a;
  float an;
  float b;
  float c;
  float plab;
  float pmass;
  float pmax;
  float pmin;
  float scheck;

  pplpk_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0),
        scheck(fem::float0) {}
};

/// C*********************************
/// C elementary kaon production cross sections
/// C  from the CERN data book
/// C  date: Sept.2, 1994
/// C  for pp-->pLK+
/// C      real*4 function pplpk(srt)
float pplpk(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pplpk);
  common_write write(cmn);
  /// SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  float& scheck = sve.scheck;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C   find the center of mass energy corresponding to the given pm as
  /// C   if Lambda+N+K are produced
  return_value = 0.f;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (scheck < 0) {
    write(99, star), "scheck35: ", scheck;
    scheck = 0.f;
  }
  plab = fem::sqrt(scheck);
  /// C        plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
  /// C
  pmin = 2.82f;
  pmax = 25.0f;
  if (plab > pmax) {
    return_value = 0.036f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 0.f;
    return return_value;
  }
  /// C* fit parameters
  a = 0.0654f;
  b = -3.16f;
  c = -0.0029f;
  an = -4.14f;
  return_value =
      a + b * (fem::pow(plab, an)) + c * fem::pow2((fem::alog(plab)));
  if (return_value <= 0) {
    return_value = 0;
  }
  return return_value;
}

struct ppk0_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  ppk0_save()
      : earray(dimension(7), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(7), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C
/// C*****************************************
/// C for pp-->pSigma+K0
/// C      real*4 function ppk0(srt)
float ppk0(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppk0);
  arr_ref<float> earray(sve.earray, dimension(7));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(7));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {0.030f, 0.025f, 0.025f, 0.026f,
                                     0.02f,  0.014f, 0.06f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {3.67f, 4.95f, 5.52f, 6.05f,
                                     6.92f, 7.87f, 10.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C * C***************************************** C      real*4   xarray(7),
  /// earray(7)
  /// C
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0;
  if (srt <= 2.63f) {
    return return_value;
  }
  if (srt > 4.54f) {
    return_value = 0.037f;
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 7) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      goto statement_10;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      goto statement_10;
    }
  }
statement_10:
  return return_value;
}

struct ppk1_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  ppk1_save()
      : earray(dimension(7), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        xarray(dimension(7), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for pp-->pSigma0K+
/// C      real*4 function ppk1(srt)
float ppk1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppk1);
  arr_ref<float> earray(sve.earray, dimension(7));
  int& ie = sve.ie;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(7));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {0.013f, 0.025f, 0.016f, 0.012f,
                                     0.017f, 0.029f, 0.025f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {3.67f, 4.95f, 5.52f, 5.97f,
                                     6.05f, 6.92f, 7.87f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C * C***************************************** C      real*4   xarray(7),
  /// earray(7)
  /// C
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0.f;
  if (srt <= 2.63f) {
    return return_value;
  }
  if (srt > 4.08f) {
    return_value = 0.025f;
    return return_value;
  }
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass));
  if (plab < earray(1)) {
    return_value = xarray(1);
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 7) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      goto statement_10;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      goto statement_10;
    }
  }
statement_10:
  return return_value;
}

struct x4pi_save {
  float ada;
  float ak0;
  float akp;
  float al;
  float ana;
  float as;
  float es;
  float pmass;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnlk;
  float pmnlk2;
  float pmnsk;
  float pmnsk2;
  float pps1;
  float pps2;
  float ppsngl;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2dlk;
  float t2dsk;
  float t2nlk;
  float t2nsk;
  float xk1;
  float xk2;
  float xk3;
  float xk4;
  float xkaon;
  float xpp2pi;
  float xpp3pi;

  x4pi_save()
      : ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        es(fem::float0),
        pmass(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnlk(fem::float0),
        pmnlk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        pps1(fem::float0),
        pps2(fem::float0),
        ppsngl(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nlk(fem::float0),
        t2nsk(fem::float0),
        xk1(fem::float0),
        xk2(fem::float0),
        xk3(fem::float0),
        xk4(fem::float0),
        xkaon(fem::float0),
        xpp2pi(fem::float0),
        xpp3pi(fem::float0) {}
};

/// C*****************************************
/// C       REAL*4 FUNCTION X4pi(SRT)
float x4pi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(x4pi);
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& es = sve.es;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnlk2 = sve.pmnlk2;
  float& pmnsk2 = sve.pmnsk2;
  float& pps1 = sve.pps1;
  float& pps2 = sve.pps2;
  float& ppsngl = sve.ppsngl;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nlk = sve.t2nlk;
  float& t2nsk = sve.t2nsk;
  float& xk1 = sve.xk1;
  float& xk2 = sve.xk2;
  float& xk3 = sve.xk3;
  float& xk4 = sve.xk4;
  float& xkaon = sve.xkaon;
  float& xpp2pi = sve.xpp2pi;
  float& xpp3pi = sve.xpp3pi;
  /// C       CROSS SECTION FOR NN-->DD+rho PROCESS
  /// C *****************************
  akp = 0.498f;
  sve.ak0 = 0.498f;
  ana = 0.94f;
  ada = 1.232f;
  al = 1.1157f;
  as = 1.1197f;
  sve.pmass = 0.9383f;
  es = srt;
  if (es <= 4) {
    return_value = 0.f;
  } else {
    /// C cross section for two resonance pp-->DD+DN*+N*N*
    xpp2pi = 4.f * x2pi(cmn, es);
    /// C cross section for pp-->pp+spi
    xpp3pi = 3.f * (x3pi(cmn, es) + x33pi(cmn, es));
    /// C cross section for pp-->pD+ and nD++
    pps1 = sigma(cmn, es, 1, 1, 0) + 0.5f * sigma(cmn, es, 1, 1, 1);
    pps2 = 1.5f * sigma(cmn, es, 1, 1, 1);
    ppsngl = pps1 + pps2 + s1535(cmn, es);
    /// C CROSS SECTION FOR KAON PRODUCTION from the four channels
    /// C for NLK channel
    xk1 = 0;
    xk2 = 0;
    xk3 = 0;
    xk4 = 0;
    t1nlk = ana + al + akp;
    t2nlk = ana + al - akp;
    if (es <= t1nlk) {
      goto statement_333;
    }
    pmnlk2 = (fem::pow2(es) - fem::pow2(t1nlk)) *
             (fem::pow2(es) - fem::pow2(t2nlk)) / (4.f * fem::pow2(es));
    sve.pmnlk = fem::sqrt(pmnlk2);
    xk1 = pplpk(cmn, es);
    /// C for DLK channel
    t1dlk = ada + al + akp;
    t2dlk = ada + al - akp;
    if (es <= t1dlk) {
      goto statement_333;
    }
    pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
             (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
    sve.pmdlk = fem::sqrt(pmdlk2);
    xk3 = pplpk(cmn, es);
    /// C for NSK channel
    t1nsk = ana + as + akp;
    t2nsk = ana + as - akp;
    if (es <= t1nsk) {
      goto statement_333;
    }
    pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
             (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
    sve.pmnsk = fem::sqrt(pmnsk2);
    xk2 = ppk1(cmn, es) + ppk0(cmn, es);
    /// C for DSK channel
    t1dsk = ada + as + akp;
    t2dsk = ada + as - akp;
    if (es <= t1dsk) {
      goto statement_333;
    }
    pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
             (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
    sve.pmdsk = fem::sqrt(pmdsk2);
    xk4 = ppk1(cmn, es) + ppk0(cmn, es);
  /// C THE TOTAL KAON+ AND KAON0 PRODUCTION CROSS SECTION IS THEN
  statement_333:
    xkaon = 3.f * (xk1 + xk2 + xk3 + xk4);
    /// C cross section for pp-->DD+rho
    return_value = pp1(cmn, es) - ppsngl - xpp2pi - xpp3pi - xkaon;
    if (return_value <= 0) {
      return_value = 1.e-06f;
    }
  }
  return return_value;
}

struct fkaon_save {
  float fmax;

  fkaon_save() : fmax(fem::float0) {}
};

/// C
/// C*******************************
/// C
/// C       Kaon momentum distribution in baryon-baryon-->N lamda K process
/// C
/// C       NOTE: dsima/dp is prototional to (1-p/p_max)(p/p_max)^2
/// C              we use rejection method to generate kaon momentum
/// C
/// C       Variables: Fkaon = F(p)/F_max
/// C                 srt   = cms energy of the colliding pair,
/// C                          used to calculate the P_max
/// C       Date: Feb. 8, 1994
/// C
/// C       Reference: C. M. Ko et al.
/// C*******************************
float fkaon(common& cmn, float const& p, float& pmax) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fkaon);
  /// SAVE
  float& fmax = sve.fmax;
  ///
  fmax = 0.148f;
  if (pmax == 0.f) {
    pmax = 0.000001f;
  }
  return_value = (1.f - p / pmax) * fem::pow2((p / pmax));
  if (return_value > fmax) {
    return_value = fmax;
  }
  return_value = return_value / fmax;
  return return_value;
}

struct fdelta_save {
  float am0;
  float amn;
  float avpi;
  float fd;

  fdelta_save()
      : am0(fem::float0),
        amn(fem::float0),
        avpi(fem::float0),
        fd(fem::float0) {}
};

/// C**************************8
/// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
/// CKITAZOE'S FORMULA
float fdelta(common& cmn, float const& dmass) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fdelta);
  /// SAVE
  float& fd = sve.fd;
  ///
  sve.amn = 0.938869f;
  sve.avpi = 0.13803333f;
  sve.am0 = 1.232f;
  fd = 0.25f * fem::pow2(width(cmn, dmass)) /
       (fem::pow2((dmass - 1.232f)) + 0.25f * fem::pow2(width(cmn, dmass)));
  return_value = fd;
  return return_value;
}

struct rmass_save {
  float dm;
  float dmin;
  float fm;
  int ntry1;

  rmass_save()
      : dm(fem::float0), dmin(fem::float0), fm(fem::float0), ntry1(fem::int0) {}
};

/// C**************************8
/// C   DELTA MASS GENERATOR
float rmass(common& cmn, float const& dmax, int const& /* iseed */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rmass);
  int& nseed = cmn.nseed;
  ///
  float& dm = sve.dm;
  float& dmin = sve.dmin;
  float& fm = sve.fm;
  int& ntry1 = sve.ntry1;
  /// Cc      SAVE /RNDF77/
  /// C THE MINIMUM MASS FOR DELTA
  dmin = 1.078f;
  /// C Delta(1232) production
  if (dmax < 1.232f) {
    fm = fdelta(cmn, dmax);
  } else {
    fm = 1.f;
  }
  if (fm == 0.f) {
    fm = 1.e-06f;
  }
  ntry1 = 0;
statement_10:
  dm = ranart(nseed) * (dmax - dmin) + dmin;
  ntry1++;
  if ((ranart(nseed) > fdelta(cmn, dm) / fm) && (ntry1 <= 10)) {
    goto statement_10;
  }
  /// Clin-2/26/03 sometimes Delta mass can reach very high values
  /// (e.g. 15.GeV), C     thus violating the thresh of the collision which
  /// produces it C     and leads to large violation of energy conservation. C
  /// To limit the above, limit the Delta mass below a certain value C     (here
  /// taken as its central value + 2* B-W fullwidth):
  if (dm > 1.47f) {
    goto statement_10;
  }
  /// C
  return_value = dm;
  return return_value;
}

struct bbkaon_save {
  float aka;
  float bx;
  float by;
  float bz;
  float cs;
  float csn;
  float dm1;
  float dmax;
  float ek;
  float el;
  float eln;
  float elnc;
  float en;
  float fai;
  float fain;
  float ga;
  int ntry;
  float pbeta;
  float pi;
  float pk;
  float pmax;
  float pn;
  float pn2;
  float prob;
  float scheck;
  float ss;
  float ssn;
  float t1;
  float t2;
  float trans0;

  bbkaon_save()
      : aka(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        cs(fem::float0),
        csn(fem::float0),
        dm1(fem::float0),
        dmax(fem::float0),
        ek(fem::float0),
        el(fem::float0),
        eln(fem::float0),
        elnc(fem::float0),
        en(fem::float0),
        fai(fem::float0),
        fain(fem::float0),
        ga(fem::float0),
        ntry(fem::int0),
        pbeta(fem::float0),
        pi(fem::float0),
        pk(fem::float0),
        pmax(fem::float0),
        pn(fem::float0),
        pn2(fem::float0),
        prob(fem::float0),
        scheck(fem::float0),
        ss(fem::float0),
        ssn(fem::float0),
        t1(fem::float0),
        t2(fem::float0),
        trans0(fem::float0) {}
};

/// Csp11/21/01 end
/// C*********************************
void bbkaon(common& cmn, int const& ic, float const& srt, float& px, float& py,
            float& pz, float& ana, float& plx, float& ply, float& plz,
            float& ala, float& pkx, float& pky, float& pkz, int& icou1) {
  FEM_CMN_SVE(bbkaon);
  common_write write(cmn);
  int& nseed = cmn.nseed;
  ///
  float& aka = sve.aka;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& cs = sve.cs;
  float& csn = sve.csn;
  float& dm1 = sve.dm1;
  float& dmax = sve.dmax;
  float& ek = sve.ek;
  float& el = sve.el;
  float& eln = sve.eln;
  float& elnc = sve.elnc;
  float& en = sve.en;
  float& fai = sve.fai;
  float& fain = sve.fain;
  float& ga = sve.ga;
  int& ntry = sve.ntry;
  float& pbeta = sve.pbeta;
  float& pk = sve.pk;
  float& pmax = sve.pmax;
  float& pn = sve.pn;
  float& pn2 = sve.pn2;
  float& prob = sve.prob;
  float& scheck = sve.scheck;
  float& ss = sve.ss;
  float& ssn = sve.ssn;
  float& t1 = sve.t1;
  float& t2 = sve.t2;
  float& trans0 = sve.trans0;
  /// C purpose: generate the momenta for kaon,lambda/sigma and nucleon/delta
  /// C          in the BB-->nlk process
  /// C date: Sept. 9, 1994
  /// C
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  sve.pi = 3.1415962f;
  icou1 = 0;
  aka = 0.498f;
  ala = 1.116f;
  if (ic == 2 || ic == 4) {
    ala = 1.197f;
  }
  ana = 0.939f;
  /// C generate the mass of the delta
  if (ic > 2) {
    dmax = srt - aka - ala - 0.02f;
    dm1 = rmass(cmn, dmax, cmn.iseed);
    ana = dm1;
  }
  t1 = aka + ana + ala;
  t2 = ana + ala - aka;
  if (srt <= t1) {
    icou1 = -1;
    return;
  }
  pmax = fem::sqrt((fem::pow2(srt) - fem::pow2(t1)) *
                   (fem::pow2(srt) - fem::pow2(t2))) /
         (2.f * srt);
  if (pmax == 0.f) {
    pmax = 1.e-09f;
  }
  /// C (1) Generate the momentum of the kaon according to the distribution
  /// Fkaon C     and assume that the angular distribution is isotropic C     in
  /// the cms of the colliding pair
  ntry = 0;
statement_1:
  pk = pmax * ranart(nseed);
  ntry++;
  prob = fkaon(cmn, pk, pmax);
  if ((prob < ranart(nseed)) && (ntry <= 40)) {
    goto statement_1;
  }
  cs = 1.f - 2.f * ranart(nseed);
  ss = fem::sqrt(1.f - fem::pow2(cs));
  fai = 2.f * 3.14f * ranart(nseed);
  pkx = pk * ss * fem::cos(fai);
  pky = pk * ss * fem::sin(fai);
  pkz = pk * cs;
  /// C the energy of the kaon
  ek = fem::sqrt(fem::pow2(aka) + fem::pow2(pk));
  /// C (2) Generate the momentum of the nucleon/delta in the cms of N/delta
  /// C     and lamda/sigma
  /// C  the energy of the cms of NL
  eln = srt - ek;
  if (eln <= 0) {
    icou1 = -1;
    return;
  }
  /// C beta and gamma of the cms of L/S+N
  bx = -pkx / eln;
  by = -pky / eln;
  bz = -pkz / eln;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.f - fem::pow2(bx) - fem::pow2(by) - fem::pow2(bz);
  if (scheck <= 0) {
    write(99, star), "scheck44: ", scheck;
    FEM_STOP(0);
  }
  ga = 1.f / fem::sqrt(scheck);
  /// C       ga=1./sqrt(1.-bx**2-by**2-bz**2)
  /// C
  elnc = eln / ga;
  pn2 = fem::pow2(((fem::pow2(elnc) + fem::pow2(ana) - fem::pow2(ala)) /
                   (2.f * elnc))) -
        fem::pow2(ana);
  if (pn2 <= 0.f) {
    pn2 = 1.e-09f;
  }
  pn = fem::sqrt(pn2);
  csn = 1.f - 2.f * ranart(nseed);
  ssn = fem::sqrt(1.f - fem::pow2(csn));
  fain = 2.f * 3.14f * ranart(nseed);
  px = pn * ssn * fem::cos(fain);
  py = pn * ssn * fem::sin(fain);
  pz = pn * csn;
  en = fem::sqrt(fem::pow2(ana) + pn2);
  /// C the momentum of the lambda/sigma in the n-l cms frame is
  plx = -px;
  ply = -py;
  plz = -pz;
  /// C (3) LORENTZ-TRANSFORMATION INTO nn cms FRAME for the neutron/delta
  pbeta = px * bx + py * by + pz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + en);
  px += bx * trans0;
  py += by * trans0;
  pz += bz * trans0;
  /// C (4) Lorentz-transformation for the lambda/sigma
  el = fem::sqrt(fem::pow2(ala) + fem::pow2(plx) + fem::pow2(ply) +
                 fem::pow2(plz));
  pbeta = plx * bx + ply * by + plz * bz;
  trans0 = ga * (ga * pbeta / (ga + 1.f) + el);
  plx += bx * trans0;
  ply += by * trans0;
  plz += bz * trans0;
}

struct xrho_save {
  float es;
  float esmin;
  float pmass;
  float rmass;
  float trho;
  float xrho0;

  xrho_save()
      : es(fem::float0),
        esmin(fem::float0),
        pmass(fem::float0),
        rmass(fem::float0),
        trho(fem::float0),
        xrho0(fem::float0) {}
};

/// C *****************************
/// C       real*4 function xrho(srt)
float xrho(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xrho);
  /// SAVE
  float& es = sve.es;
  float& esmin = sve.esmin;
  float& rmass = sve.rmass;
  float& trho = sve.trho;
  float& xrho0 = sve.xrho0;
  ///
  /// C       xsection for pp-->pp+rho
  /// C *****************************
  sve.pmass = 0.9383f;
  rmass = 0.77f;
  trho = 0.151f;
  return_value = 0.000000001f;
  if (srt <= 2.67f) {
    return return_value;
  }
  esmin = 2.f * 0.9383f + rmass - trho / 2.f;
  es = srt;
  /// C the cross section for tho0 production is
  xrho0 = 0.24f * (es - esmin) / (1.4f + fem::pow2((es - esmin)));
  return_value = 3.f * xrho0;
  return return_value;
}

struct omega_save {
  float es;
  float esmin;
  float omass;
  float pmass;
  float tomega;

  omega_save()
      : es(fem::float0),
        esmin(fem::float0),
        omass(fem::float0),
        pmass(fem::float0),
        tomega(fem::float0) {}
};

/// C *****************************
/// C       real*4 function omega(srt)
float omega(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(omega);
  /// SAVE
  float& es = sve.es;
  float& esmin = sve.esmin;
  float& omass = sve.omass;
  float& tomega = sve.tomega;
  ///
  /// C       xsection for pp-->pp+omega
  /// C *****************************
  sve.pmass = 0.9383f;
  omass = 0.782f;
  tomega = 0.0084f;
  return_value = 0.00000001f;
  if (srt <= 2.68f) {
    return return_value;
  }
  esmin = 2.f * 0.9383f + omass - tomega / 2.f;
  es = srt;
  return_value = 0.36f * (es - esmin) / (1.25f + fem::pow2((es - esmin)));
  return return_value;
}

/// C
/// C     Part of the cross section function of NN->Deuteron+Pi (in mb):
float fnndpi(float const& s) {
  float return_value = fem::float0;
  const float srt0 = 2.012f;
  if (s <= fem::pow2(srt0)) {
    return_value = 0.f;
  } else {
    return_value = 26.f * fem::exp(-fem::pow2((s - 4.65f)) / 0.1f) +
                   4.f * fem::exp(-fem::pow2((s - 4.65f)) / 2.f) +
                   0.28f * fem::exp(-fem::pow2((s - 6.f)) / 10.f);
  }
  return return_value;
}

struct sbbdm_save {
  float fs;
  int ilb1;
  int ilb2;
  float pifactor;
  float pinitial;
  float s;
  float sbbdeta;
  float sbbdomega;
  float sbbdpi;
  float sbbdrho;
  float scheck;
  float snew;
  float threshold;
  float x1;

  sbbdm_save()
      : fs(fem::float0),
        ilb1(fem::int0),
        ilb2(fem::int0),
        pifactor(fem::float0),
        pinitial(fem::float0),
        s(fem::float0),
        sbbdeta(fem::float0),
        sbbdomega(fem::float0),
        sbbdpi(fem::float0),
        sbbdrho(fem::float0),
        scheck(fem::float0),
        snew(fem::float0),
        threshold(fem::float0),
        x1(fem::float0) {}
};

/// C---------------------------------------------------------------------------
/// C
/// Clin-8/2008 B+B->Deuteron+Meson cross section in mb:
void sbbdm(common& cmn, float const& srt, float& sdprod, int const& ianti,
           int& lbm, float& xmm, float& pfinal) {
  FEM_CMN_SVE(sbbdm);
  common_write write(cmn);
  /// COMMON leadng
  float& em1 = cmn.em1;
  /// COMMON dpi
  float& em2 = cmn.em2;
  /// COMMON para8
  int& idxsec = cmn.idxsec;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& fs = sve.fs;
  int& ilb1 = sve.ilb1;
  int& ilb2 = sve.ilb2;
  float& pifactor = sve.pifactor;
  float& pinitial = sve.pinitial;
  float& s = sve.s;
  float& sbbdeta = sve.sbbdeta;
  float& sbbdomega = sve.sbbdomega;
  float& sbbdpi = sve.sbbdpi;
  float& sbbdrho = sve.sbbdrho;
  float& scheck = sve.scheck;
  float& snew = sve.snew;
  float& threshold = sve.threshold;
  float& x1 = sve.x1;
  ///
  /// C
  sdprod = 0.f;
  sbbdpi = 0.f;
  sbbdrho = 0.f;
  sbbdomega = 0.f;
  sbbdeta = 0.f;
  if (srt <= (em1 + em2)) {
    return;
  }
  /// C
  ilb1 = fem::iabs(cmn.lb1);
  ilb2 = fem::iabs(cmn.lb2);
  /// Ctest off check Xsec using fixed mass for resonances:
  /// C      if(ilb1.ge.6.and.ilb1.le.9) then
  /// C         em1=1.232
  /// C      elseif(ilb1.ge.10.and.ilb1.le.11) then
  /// C         em1=1.44
  /// C      elseif(ilb1.ge.12.and.ilb1.le.13) then
  /// C         em1=1.535
  /// C      endif
  /// C      if(ilb2.ge.6.and.ilb2.le.9) then
  /// C         em2=1.232
  /// C      elseif(ilb2.ge.10.and.ilb2.le.11) then
  /// C         em2=1.44
  /// C      elseif(ilb2.ge.12.and.ilb2.le.13) then
  /// C         em2=1.535
  /// C      endif
  /// C
  s = fem::pow2(srt);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
  if (scheck <= 0) {
    write(99, star), "scheck50: ", scheck;
    FEM_STOP(0);
  }
  pinitial = fem::sqrt(scheck) / 2.f / srt;
  /// C      pinitial=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
  /// C
  fs = fnndpi(s);
  /// C     Determine isospin and spin factors for the ratio between
  /// C     BB->Deuteron+Meson and Deuteron+Meson->BB cross sections:
  if (idxsec == 1 || idxsec == 2) {
    /// C     Assume B+B -> d+Meson has the same cross sections as N+N -> d+pi:
  } else {
    /// C     Assume d+Meson -> B+B has the same cross sections as d+pi -> N+N,
    /// C     then determine B+B -> d+Meson cross sections:
    if (ilb1 >= 1 && ilb1 <= 2 && ilb2 >= 1 && ilb2 <= 2) {
      pifactor = 9.f / 8.f;
    } else if ((ilb1 >= 1 && ilb1 <= 2 && ilb2 >= 6 && ilb2 <= 9) ||
               (ilb2 >= 1 && ilb2 <= 2 && ilb1 >= 6 && ilb1 <= 9)) {
      pifactor = 9.f / 64.f;
    } else if ((ilb1 >= 1 && ilb1 <= 2 && ilb2 >= 10 && ilb2 <= 13) ||
               (ilb2 >= 1 && ilb2 <= 2 && ilb1 >= 10 && ilb1 <= 13)) {
      pifactor = 9.f / 16.f;
    } else if (ilb1 >= 6 && ilb1 <= 9 && ilb2 >= 6 && ilb2 <= 9) {
      pifactor = 9.f / 128.f;
    } else if ((ilb1 >= 6 && ilb1 <= 9 && ilb2 >= 10 && ilb2 <= 13) ||
               (ilb2 >= 6 && ilb2 <= 9 && ilb1 >= 10 && ilb1 <= 13)) {
      pifactor = 9.f / 64.f;
    } else if ((ilb1 >= 10 && ilb1 <= 11 && ilb2 >= 10 && ilb2 <= 11) ||
               (ilb2 >= 12 && ilb2 <= 13 && ilb1 >= 12 && ilb1 <= 13)) {
      pifactor = 9.f / 8.f;
    } else if ((ilb1 >= 10 && ilb1 <= 11 && ilb2 >= 12 && ilb2 <= 13) ||
               (ilb2 >= 10 && ilb2 <= 11 && ilb1 >= 12 && ilb1 <= 13)) {
      pifactor = 9.f / 16.f;
    }
  }
  /// C     d pi: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  /// C     (1) FOR P+P->Deuteron+pi+:
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((ilb1 * ilb2) == 1) {
    lbm = 5;
    if (ianti == 1) {
      lbm = 3;
    }
    xmm = ap2;
    /// C     (2)FOR N+N->Deuteron+pi-:
  } else if (ilb1 == 2 && ilb2 == 2) {
    lbm = 3;
    if (ianti == 1) {
      lbm = 5;
    }
    xmm = ap2;
    /// C     (3)FOR N+P->Deuteron+pi0:
  } else if ((ilb1 * ilb2) == 2) {
    lbm = 4;
    xmm = ap1;
  } else {
    /// C     For baryon resonances, use isospin-averaged cross sections:
    lbm = 3 + fem::fint(3 * ranart(nseed));
    if (lbm == 4) {
      xmm = ap1;
    } else {
      xmm = ap2;
    }
  }
  /// C
  const float xmd = 1.8756f;
  const float srt0 = 2.012f;
  if (srt >= (xmd + xmm)) {
    pfinal =
        fem::sqrt((s - fem::pow2((xmd + xmm))) * (s - fem::pow2((xmd - xmm)))) /
        2.f / srt;
    if ((ilb1 == 1 && ilb2 == 1) || (ilb1 == 2 && ilb2 == 2)) {
      /// C     for pp or nn initial states:
      sbbdpi = fs * pfinal / pinitial / 4.f;
    } else if ((ilb1 == 1 && ilb2 == 2) || (ilb1 == 2 && ilb2 == 1)) {
      /// C     factor of 1/2 for pn or np initial states:
      sbbdpi = fs * pfinal / pinitial / 4.f / 2.f;
    } else {
      /// C     for other BB initial states (spin- and isospin averaged):
      if (idxsec == 1) {
        /// C     1: assume the same |matrix element|**2/s (after averaging over
        /// initial C     spins and isospins) for B+B -> deuteron+meson at the
        /// same sqrt(s);
        sbbdpi = fs * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 2 || idxsec == 4) {
        threshold = fem::amax1(xmd + xmm, em1 + em2);
        snew = fem::pow2((srt - threshold + srt0));
        if (idxsec == 2) {
          /// C     2: assume the same |matrix element|**2/s for B+B ->
          /// deuteron+meson C     at the same sqrt(s)-threshold:
          sbbdpi = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
        } else if (idxsec == 4) {
          /// C     4: assume the same |matrix element|**2/s for B+B <-
          /// deuteron+meson C     at the same sqrt(s)-threshold:
          sbbdpi = fnndpi(snew) * pfinal / pinitial / 6.f * pifactor;
        }
      } else if (idxsec == 3) {
        /// C     3: assume the same |matrix element|**2/s for B+B <-
        /// deuteron+meson C     at the same sqrt(s):
        sbbdpi = fs * pfinal / pinitial / 6.f * pifactor;
      }
      /// C
    }
  }
  /// C
  /// C     d rho: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
  const float xmrho = 0.770f;
  if (srt > (xmd + xmrho)) {
    pfinal = fem::sqrt((s - fem::pow2((xmd + xmrho))) *
                       (s - fem::pow2((xmd - xmrho)))) /
             2.f / srt;
    if (idxsec == 1) {
      sbbdrho = fs * pfinal / pinitial * 3.f / 16.f;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmd + xmrho, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sbbdrho = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 4) {
        /// C     The spin- and isospin-averaged factor is 3-times larger for
        /// rho:
        sbbdrho = fnndpi(snew) * pfinal / pinitial / 6.f * (pifactor * 3.f);
      }
    } else if (idxsec == 3) {
      sbbdrho = fs * pfinal / pinitial / 6.f * (pifactor * 3.f);
    }
  }
  /// C
  /// C     d omega: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
  const float xmomega = 0.782f;
  if (srt > (xmd + xmomega)) {
    pfinal = fem::sqrt((s - fem::pow2((xmd + xmomega))) *
                       (s - fem::pow2((xmd - xmomega)))) /
             2.f / srt;
    if (idxsec == 1) {
      sbbdomega = fs * pfinal / pinitial * 3.f / 16.f;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmd + xmomega, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sbbdomega = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 4) {
        sbbdomega = fnndpi(snew) * pfinal / pinitial / 6.f * pifactor;
      }
    } else if (idxsec == 3) {
      sbbdomega = fs * pfinal / pinitial / 6.f * pifactor;
    }
  }
  /// C
  /// C     d eta: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
  const float xmeta = 0.548f;
  if (srt > (xmd + xmeta)) {
    pfinal = fem::sqrt((s - fem::pow2((xmd + xmeta))) *
                       (s - fem::pow2((xmd - xmeta)))) /
             2.f / srt;
    if (idxsec == 1) {
      sbbdeta = fs * pfinal / pinitial * 3.f / 16.f;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmd + xmeta, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sbbdeta = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f;
      } else if (idxsec == 4) {
        sbbdeta = fnndpi(snew) * pfinal / pinitial / 6.f * (pifactor / 3.f);
      }
    } else if (idxsec == 3) {
      sbbdeta = fs * pfinal / pinitial / 6.f * (pifactor / 3.f);
    }
  }
  /// C
  sdprod = sbbdpi + sbbdrho + sbbdomega + sbbdeta;
  /// Ctest off
  /// C      write(99,111) srt,sbbdpi,sbbdrho,sbbdomega,sbbdeta,sdprod
  /// C 111  format(6(f8.2,1x))
  /// C
  if (sdprod <= 0) {
    return;
  }
  /// C
  /// C     choose final state and assign masses here:
  x1 = ranart(nseed);
  if (x1 <= sbbdpi / sdprod) {
    /// C     use the above-determined lbm and xmm.
  } else if (x1 <= (sbbdpi + sbbdrho) / sdprod) {
    lbm = 25 + fem::fint(3 * ranart(nseed));
    xmm = xmrho;
  } else if (x1 <= (sbbdpi + sbbdrho + sbbdomega) / sdprod) {
    lbm = 28;
    xmm = xmomega;
  } else {
    lbm = 0;
    xmm = xmeta;
  }
  /// C
}

struct bbdangle_save {
  float c1;
  float ct1;
  float dprob;
  float s1;
  float st1;
  float t1;

  bbdangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dprob(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C
/// C     Generate angular distribution of Deuteron in the CMS frame:
void bbdangle(common& cmn, float& pxd, float& pyd, float& pzd, int const& nt,
              int const& ipert1, int const& ianti, int const& idloop,
              float const& pfinal, float const& dprob1, int const& lbm) {
  FEM_CMN_SVE(bbdangle);
  common_write write(cmn);
  /// COMMON leadng
  int& lb1 = cmn.lb1;
  /// COMMON dpi
  int& lb2 = cmn.lb2;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON para8
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  /// COMMON arevt
  int& iaevt = cmn.iaevt;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dprob = sve.dprob;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzd = pfinal * c1;
  pxd = pfinal * s1 * ct1;
  pyd = pfinal * s1 * st1;
  /// Clin-5/2008 track the number of produced deuterons:
  if (idpert == 1 && npertd >= 1) {
    dprob = dprob1;
  } else if (idpert == 2 && npertd >= 1) {
    dprob = 1.f / fem::ffloat(npertd);
  }
  if (ianti == 0) {
    if (idpert == 0 || (idpert == 1 && ipert1 == 0) ||
        (idpert == 2 && idloop == (npertd + 1))) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm, " (regular d prodn) @evt#",
          iaevt, " @nt=", nt;
    } else if ((idpert == 1 || idpert == 2) && idloop == npertd) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm, " (pert d prodn) @evt#",
          iaevt, " @nt=", nt, " @prob=", dprob;
    }
  } else {
    if (idpert == 0 || (idpert == 1 && ipert1 == 0) ||
        (idpert == 2 && idloop == (npertd + 1))) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm,
          " (regular dbar prodn) @evt#", iaevt, " @nt=", nt;
    } else if ((idpert == 1 || idpert == 2) && idloop == npertd) {
      write(91, star), lb1, " *", lb2, " ->d+", lbm, " (pert dbar prodn) @evt#",
          iaevt, " @nt=", nt, " @prob=", dprob;
    }
  }
  /// C
}

struct crnn_save {
  static const int npdmax = 10000;

  float a;
  float ada;
  float ak0;
  float akp;
  float al;
  float amrho;
  float ana;
  float aomega;
  float arho;
  float as;
  float c1;
  float c2;
  float cc1;
  float ct1;
  float ct2;
  float dm;
  float dm1;
  float dm1n;
  float dm2;
  float dm2n;
  float dm3;
  float dm4;
  float dmax;
  float dmin;
  float dprob1;
  float e1cm;
  float e1dcm;
  float e2cm;
  float e2picm;
  float epcm;
  float es;
  float eti1;
  float eti2;
  float fm;
  int ianti;
  int ic;
  int icou1;
  int id1;
  int idloop;
  int ipertd;
  int lbd;
  int lbi1;
  int lbi2;
  int lbm;
  arr<int> lbpd;
  int m12;
  int n12;
  int ndloop;
  int ntry1;
  int ntry2;
  float p1beta;
  float p1dbeta;
  float p2beta;
  float p2pibeta;
  float pfinal;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float ppbeta;
  arr<float, 2> ppd;
  float ppx;
  float ppy;
  float ppz;
  float pr;
  float pr2;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px3;
  float px4;
  float pxd;
  float pxi1;
  float pxi2;
  float py3;
  float py4;
  float pyd;
  float pyi1;
  float pyi2;
  float pz2;
  float pz3;
  float pz4;
  float pzd;
  float pzi1;
  float pzi2;
  float s1;
  float s2;
  float s4pi;
  float scheck;
  float sdprod;
  float sig1;
  float sig2;
  float sig3;
  float sig4;
  float sigk;
  float signd;
  float somega;
  float srho;
  float ss;
  float st1;
  float st2;
  float t1;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float ta;
  float transf;
  float x;
  float x1;
  float x1535;
  float xdir;
  float xdmass;
  float xfinal;
  float xmass;
  float xmm;
  float xptr;
  float xsk1;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;

  crnn_save()
      : a(fem::float0),
        ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        amrho(fem::float0),
        ana(fem::float0),
        aomega(fem::float0),
        arho(fem::float0),
        as(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        dm(fem::float0),
        dm1(fem::float0),
        dm1n(fem::float0),
        dm2(fem::float0),
        dm2n(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        dprob1(fem::float0),
        e1cm(fem::float0),
        e1dcm(fem::float0),
        e2cm(fem::float0),
        e2picm(fem::float0),
        epcm(fem::float0),
        es(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fm(fem::float0),
        ianti(fem::int0),
        ic(fem::int0),
        icou1(fem::int0),
        id1(fem::int0),
        idloop(fem::int0),
        ipertd(fem::int0),
        lbd(fem::int0),
        lbi1(fem::int0),
        lbi2(fem::int0),
        lbm(fem::int0),
        lbpd(dimension(npdmax), fem::fill0),
        m12(fem::int0),
        n12(fem::int0),
        ndloop(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        p1beta(fem::float0),
        p1dbeta(fem::float0),
        p2beta(fem::float0),
        p2pibeta(fem::float0),
        pfinal(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        ppbeta(fem::float0),
        ppd(dimension(3, npdmax), fem::fill0),
        ppx(fem::float0),
        ppy(fem::float0),
        ppz(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px3(fem::float0),
        px4(fem::float0),
        pxd(fem::float0),
        pxi1(fem::float0),
        pxi2(fem::float0),
        py3(fem::float0),
        py4(fem::float0),
        pyd(fem::float0),
        pyi1(fem::float0),
        pyi2(fem::float0),
        pz2(fem::float0),
        pz3(fem::float0),
        pz4(fem::float0),
        pzd(fem::float0),
        pzi1(fem::float0),
        pzi2(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        s4pi(fem::float0),
        scheck(fem::float0),
        sdprod(fem::float0),
        sig1(fem::float0),
        sig2(fem::float0),
        sig3(fem::float0),
        sig4(fem::float0),
        sigk(fem::float0),
        signd(fem::float0),
        somega(fem::float0),
        srho(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        ta(fem::float0),
        transf(fem::float0),
        x(fem::float0),
        x1(fem::float0),
        x1535(fem::float0),
        xdir(fem::float0),
        xdmass(fem::float0),
        xfinal(fem::float0),
        xmass(fem::float0),
        xmm(fem::float0),
        xptr(fem::float0),
        xsk1(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0) {}
};

const int crnn_save::npdmax;

/// C***************************************
/// C                                                                      *
void crnn(common& cmn, int const& irun, float& px, float& py, float& pz,
          float const& srt, int const& i1, int const& i2, int& iblock,
          int& ntag, float const& signn, float const& sig, int const& nt,
          int const& ipert1) {
  FEM_CMN_SVE(crnn);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  float& dir = cmn.dir;
  int& nnn = cmn.nnn;
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& iseed = cmn.iseed;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  int& nseed = cmn.nseed;
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  ///
  float& a = sve.a;
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& amrho = sve.amrho;
  float& ana = sve.ana;
  float& aomega = sve.aomega;
  float& arho = sve.arho;
  float& as = sve.as;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& dm = sve.dm;
  float& dm1 = sve.dm1;
  float& dm1n = sve.dm1n;
  float& dm2 = sve.dm2;
  float& dm2n = sve.dm2n;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& dprob1 = sve.dprob1;
  float& e1cm = sve.e1cm;
  float& e1dcm = sve.e1dcm;
  float& e2cm = sve.e2cm;
  float& e2picm = sve.e2picm;
  float& epcm = sve.epcm;
  float& es = sve.es;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fm = sve.fm;
  int& ianti = sve.ianti;
  int& ic = sve.ic;
  int& icou1 = sve.icou1;
  int& id1 = sve.id1;
  int& idloop = sve.idloop;
  int& ipertd = sve.ipertd;
  int& lbd = sve.lbd;
  int& lbi1 = sve.lbi1;
  int& lbi2 = sve.lbi2;
  int& lbm = sve.lbm;
  const int npdmax = 10000;
  arr_ref<int> lbpd(sve.lbpd, dimension(npdmax));
  int& n12 = sve.n12;
  int& ndloop = sve.ndloop;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& p1beta = sve.p1beta;
  float& p1dbeta = sve.p1dbeta;
  float& p2beta = sve.p2beta;
  float& p2pibeta = sve.p2pibeta;
  float& pfinal = sve.pfinal;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& ppbeta = sve.ppbeta;
  arr_ref<float, 2> ppd(sve.ppd, dimension(3, npdmax));
  float& ppx = sve.ppx;
  float& ppy = sve.ppy;
  float& ppz = sve.ppz;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px3 = sve.px3;
  float& px4 = sve.px4;
  float& pxd = sve.pxd;
  float& pxi1 = sve.pxi1;
  float& pxi2 = sve.pxi2;
  float& py3 = sve.py3;
  float& py4 = sve.py4;
  float& pyd = sve.pyd;
  float& pyi1 = sve.pyi1;
  float& pyi2 = sve.pyi2;
  float& pz2 = sve.pz2;
  float& pz3 = sve.pz3;
  float& pz4 = sve.pz4;
  float& pzd = sve.pzd;
  float& pzi1 = sve.pzi1;
  float& pzi2 = sve.pzi2;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& s4pi = sve.s4pi;
  float& scheck = sve.scheck;
  float& sdprod = sve.sdprod;
  float& sig1 = sve.sig1;
  float& sig2 = sve.sig2;
  float& sig3 = sve.sig3;
  float& sig4 = sve.sig4;
  float& sigk = sve.sigk;
  float& signd = sve.signd;
  float& somega = sve.somega;
  float& srho = sve.srho;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2 = sve.t2;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& ta = sve.ta;
  float& transf = sve.transf;
  float& x = sve.x;
  float& x1 = sve.x1;
  float& x1535 = sve.x1535;
  float& xdir = sve.xdir;
  float& xdmass = sve.xdmass;
  float& xfinal = sve.xfinal;
  float& xmass = sve.xmass;
  float& xmm = sve.xmm;
  float& xptr = sve.xptr;
  float& xsk1 = sve.xsk1;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  const float pi = 3.1415926f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  const float avmass = 0.9383f;
  const float amp = 0.93828f;
  const float ap1 = 0.13496f;
  const float ap2 = 0.13957f;
  const float xmd = 1.8756f;
  const float aka = 0.498f;
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH NUCLEON-NUCLEON COLLISIONS                    *
  /// C     NOTE   :                                                         *
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  /// C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      0-> COLLISION CANNOT HAPPEN                     *
  /// C                      1-> N-N ELASTIC COLLISION                       *
  /// C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  /// C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  /// C                      4-> N+N->D+D+pion reaction
  /// C                     43->N+N->D(N*)+D(N*) reaction
  /// C                     44->N+N->D+D+rho reaction
  /// C                     45->N+N->N+N+rho
  /// C                     46->N+N->N+N+omega
  /// C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  /// C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  /// C                      N12,                                            *
  /// C                      M12=1 FOR p+n-->delta(+)+ n                     *
  /// C                          2     p+n-->delta(0)+ p                     *
  /// C                          3     p+p-->delta(++)+n                     *
  /// C                          4     p+p-->delta(+)+p                      *
  /// C                          5     n+n-->delta(0)+n                      *
  /// C                          6     n+n-->delta(-)+p                      *
  /// C                          7     n+p-->N*(0)(1440)+p                   *
  /// C                          8     n+p-->N*(+)(1440)+n                   *
  /// C                        9     p+p-->N*(+)(1535)+p                     *
  /// C                        10    n+n-->N*(0)(1535)+n                     *
  /// C                         11    n+p-->N*(+)(1535)+n                     *
  /// C                        12    n+p-->N*(0)(1535)+p
  /// C                        13    D(++)+D(-)-->N*(+)(1440)+n
  /// C                         14    D(++)+D(-)-->N*(0)(1440)+p
  /// C                        15    D(+)+D(0)--->N*(+)(1440)+n
  /// C                        16    D(+)+D(0)--->N*(0)(1440)+p
  /// C                        17    D(++)+D(0)-->N*(+)(1535)+p
  /// C                        18    D(++)+D(-)-->N*(0)(1535)+p
  /// C                        19    D(++)+D(-)-->N*(+)(1535)+n
  /// C                        20    D(+)+D(+)-->N*(+)(1535)+p
  /// C                        21    D(+)+D(0)-->N*(+)(1535)+n
  /// C                        22    D(+)+D(0)-->N*(0)(1535)+p
  /// C                        23    D(+)+D(-)-->N*(0)(1535)+n
  /// C                        24    D(0)+D(0)-->N*(0)(1535)+n
  /// C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  /// C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  /// C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  /// C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  /// C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  /// C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  /// C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  /// C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  /// C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  /// C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  /// C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  /// C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  /// C                        ++    see the note book for more listing
  /// C
  /// C     NOTE ABOUT N*(1440) RESORANCE IN Nucleon+NUCLEON COLLISION:      *
  /// C     As it has been discussed in VerWest's paper,I= 1(initial isospin)*
  /// C     channel can all be attributed to delta resorance while I= 0      *
  /// C     channel can all be  attribured to N* resorance.Only in n+p       *
  /// C     one can have I=0 channel so is the N*(1440) resonance            *
  /// C                                                                      *
  /// C                             REFERENCES:                            *
  /// C                    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)    *
  /// C                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
  /// C                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
  /// C                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615;       *
  /// C                                     Nucl phys A552 (1993) 349.       *
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /TABLE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /RNDF77/
  /// C-----------------------------------------------------------------------
  n12 = 0;
  sve.m12 = 0;
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  c2 = pz / pr;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 && lb(i2) < 0) {
    ianti = 1;
  }
  sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
  /// Clin-5/2008 Production of perturbative deuterons for idpert=1:
  if (idpert == 1 && ipert1 == 1) {
    if (srt < 2.012f) {
      return;
    }
    if ((fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i1)) == 2) &&
        (fem::iabs(lb(i2)) == 1 || fem::iabs(lb(i2)) == 2)) {
      goto statement_108;
    } else {
      return;
    }
  }
  /// C
  /// C-----------------------------------------------------------------------
  /// CCOM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
  /// C      N-DELTA OR N*-N* or N*-Delta)
  /// C      IF (X1 .LE. SIGNN/SIG) THEN
  if (x1 <= (signn / sig)) {
    /// CCOM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
    as = fem::pow((3.65f * (srt - 1.8766f)), 6);
    a = 6.0f * as / (1.0f + as);
    ta = -2.0f * fem::pow2(pr);
    x = ranart(nseed);
    /// Clin-10/24/02        T1  = DLOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /
    /// A
    t1 = fem::sngl(fem::dlog(fem::dble(1.f - x) *
                                 fem::dexp(fem::dble(a) * fem::dble(ta)) +
                             fem::dble(x))) /
         a;
    c1 = 1.0f - t1 / ta;
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 1;
    goto statement_107;
  } else {
    /// CCOM: TEST FOR INELASTIC SCATTERING
    /// C     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
    /// C     CAN HAPPEN ANY MORE ==> RETURN (2.012 = 2*AVMASS + PI-MASS)
    /// Clin-5/2008: Mdeuteron+Mpi=2.0106 to 2.0152 GeV/c2, so we can still use
    /// this:
    if (srt < 2.012f) {
      return;
    }
    /// C     calculate the N*(1535) production cross section in N+N collisions
    /// C     note that the cross sections in this subroutine are in units of mb
    /// C     as only ratios of the cross sections are used to determine the
    /// C     reaction channels
    n1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
    /// CCOM: HERE WE HAVE A PROCESS N+N ==> N+DELTA,OR N+N==>N+N*(144) or
    /// N*(1535) C     OR C 3 pi channel : N+N==>d1+d2+PION
    sig3 = 3.f * (x3pi(cmn, srt) + x33pi(cmn, srt));
    /// C 2 pi channel : N+N==>d1+d2+d1*n*+n*n*
    sig4 = 4.f * x2pi(cmn, srt);
    /// C 4 pi channel : N+N==>d1+d2+rho
    s4pi = x4pi(cmn, srt);
    /// C N+N-->NN+rho channel
    srho = xrho(cmn, srt);
    /// C N+N-->NN+omega
    somega = omega(cmn, srt);
    /// C CROSS SECTION FOR KAON PRODUCTION from the four channels
    /// C for NLK channel
    akp = 0.498f;
    sve.ak0 = 0.498f;
    ana = 0.94f;
    ada = 1.232f;
    al = 1.1157f;
    as = 1.1197f;
    xsk1 = 0;
    xsk2 = 0;
    xsk3 = 0;
    xsk4 = 0;
    xsk5 = 0;
    t1nlk = ana + al + akp;
    if (srt <= t1nlk) {
      goto statement_222;
    }
    xsk1 = 1.5f * pplpk(cmn, srt);
    /// C for DLK channel
    t1dlk = ada + al + akp;
    t2dlk = ada + al - akp;
    if (srt <= t1dlk) {
      goto statement_222;
    }
    es = srt;
    pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
             (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
    sve.pmdlk = fem::sqrt(pmdlk2);
    xsk3 = 1.5f * pplpk(cmn, srt);
    /// C for NSK channel
    t1nsk = ana + as + akp;
    t2nsk = ana + as - akp;
    if (srt <= t1nsk) {
      goto statement_222;
    }
    pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
             (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
    sve.pmnsk = fem::sqrt(pmnsk2);
    xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    /// C for DSK channel
    t1dsk = ada + as + akp;
    t2dsk = ada + as - akp;
    if (srt <= t1dsk) {
      goto statement_222;
    }
    pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
             (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
    sve.pmdsk = fem::sqrt(pmdsk2);
    xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    /// Csp11/21/01
    /// C phi production
    if (srt <= (2.f * amn + aphi)) {
      goto statement_222;
    }
    /// C  !! mb put the correct form
    xsk5 = 0.0001f;
  /// Csp11/21/01 end
  /// C
  /// C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
  statement_222:
    sigk = xsk1 + xsk2 + xsk3 + xsk4;
    /// C
    /// Cbz3/7/99 neutralk
    xsk1 = 2.0f * xsk1;
    xsk2 = 2.0f * xsk2;
    xsk3 = 2.0f * xsk3;
    xsk4 = 2.0f * xsk4;
    sigk = 2.0f * sigk + xsk5;
    /// Cbz3/7/99 neutralk end
    /// C
    /// C* FOR P+P or L/S+L/S COLLISION:
    /// C       lb1=lb(i1)
    /// C       lb2=lb(i2)
    lb1 = fem::iabs(lb(i1));
    lb2 = fem::iabs(lb(i2));
    if ((lb(i1) * lb(i2) == 1) ||
        ((lb1 <= 17 && lb1 >= 14) && (lb2 <= 17 && lb2 >= 14)) ||
        ((lb1 <= 2) && (lb2 <= 17 && lb2 >= 14)) ||
        ((lb2 <= 2) && (lb1 <= 17 && lb1 >= 14))) {
      /// Clin-8/2008 PP->d+meson here:
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      sig1 = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sig2 = 1.5f * sigma(cmn, srt, 1, 1, 1);
      signd = sig1 + sig2 + sig3 + sig4 + x1535 + sigk + s4pi + srho + somega;
      /// Clin-5/2008:
      /// C           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      dir = sig3 / signd;
      if (ranart(nseed) <= dir) {
        goto statement_106;
      }
      if (ranart(nseed) <=
          sigk / (sigk + x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_306;
      }
      if (ranart(nseed) <=
          s4pi / (x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_307;
      }
      if (ranart(nseed) <=
          srho / (x1535 + sig4 + sig2 + sig1 + srho + somega)) {
        goto statement_308;
      }
      if (ranart(nseed) <= somega / (x1535 + sig4 + sig2 + sig1 + somega)) {
        goto statement_309;
      }
      if (ranart(nseed) <= x1535 / (sig1 + sig2 + sig4 + x1535)) {
        /// C N*(1535) production
        n12 = 9;
      } else {
        if (ranart(nseed) <= sig4 / (sig1 + sig2 + sig4)) {
          /// C DOUBLE DELTA PRODUCTION
          n12 = 66;
          goto statement_1012;
        } else {
          /// CDELTA PRODUCTION
          n12 = 3;
          if (ranart(nseed) > sig1 / (sig1 + sig2)) {
            n12 = 4;
          }
        }
      }
      goto statement_1011;
    }
    /// C* FOR N+N COLLISION:
    if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
      /// Clin-8/2008 NN->d+meson here:
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      sig1 = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sig2 = 1.5f * sigma(cmn, srt, 1, 1, 1);
      signd = sig1 + sig2 + x1535 + sig3 + sig4 + sigk + s4pi + srho + somega;
      /// Clin-5/2008:
      /// C           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      dir = sig3 / signd;
      if (ranart(nseed) <= dir) {
        goto statement_106;
      }
      if (ranart(nseed) <=
          sigk / (sigk + x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_306;
      }
      if (ranart(nseed) <=
          s4pi / (x1535 + sig4 + sig2 + sig1 + s4pi + srho + somega)) {
        goto statement_307;
      }
      if (ranart(nseed) <=
          srho / (x1535 + sig4 + sig2 + sig1 + srho + somega)) {
        goto statement_308;
      }
      if (ranart(nseed) <= somega / (x1535 + sig4 + sig2 + sig1 + somega)) {
        goto statement_309;
      }
      if (ranart(nseed) <= x1535 / (x1535 + sig1 + sig2 + sig4)) {
        /// C N*(1535) PRODUCTION
        n12 = 10;
      } else {
        if (ranart(nseed) <= sig4 / (sig1 + sig2 + sig4)) {
          /// C double delta production
          n12 = 67;
          goto statement_1013;
        } else {
          /// C DELTA PRODUCTION
          n12 = 6;
          if (ranart(nseed) > sig1 / (sig1 + sig2)) {
            n12 = 5;
          }
        }
      }
      goto statement_1011;
    }
    /// C* FOR N+P COLLISION
    if (lb(i1) * lb(i2) == 2) {
      /// Clin-5/2008 NP->d+meson here:
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      sig1 = 0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
      if (cmn.nstar == 1) {
        sig2 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      } else {
        sig2 = 0.f;
      }
      signd = 2.f * (sig1 + sig2 + x1535) + sig3 + sig4 + sigk + s4pi + srho +
              somega;
      /// Clin-5/2008:
      /// C           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      dir = sig3 / signd;
      if (ranart(nseed) <= dir) {
        goto statement_106;
      }
      if (ranart(nseed) <= sigk / (signd - sig3)) {
        goto statement_306;
      }
      if (ranart(nseed) <= s4pi / (signd - sig3 - sigk)) {
        goto statement_307;
      }
      if (ranart(nseed) <= srho / (signd - sig3 - sigk - s4pi)) {
        goto statement_308;
      }
      if (ranart(nseed) <= somega / (signd - sig3 - sigk - s4pi - srho)) {
        goto statement_309;
      }
      if (ranart(nseed) < x1535 / (sig1 + sig2 + x1535 + 0.5f * sig4)) {
        /// C N*(1535) PRODUCTION
        n12 = 11;
        if (ranart(nseed) <= 0.5f) {
          n12 = 12;
        }
      } else {
        if (ranart(nseed) <= sig4 / (sig4 + 2.f * (sig1 + sig2))) {
          /// C double resonance production
          n12 = 68;
          goto statement_1014;
        } else {
          if (ranart(nseed) <= sig1 / (sig1 + sig2)) {
            /// C DELTA PRODUCTION
            n12 = 2;
            if (ranart(nseed) >= 0.5f) {
              n12 = 1;
            }
          } else {
            /// C N*(1440) PRODUCTION
            n12 = 8;
            if (ranart(nseed) >= 0.5f) {
              n12 = 7;
            }
          }
        }
      }
    }
  statement_1011:
    iblock = 2;
    /// CPARAMETRIZATION OF THE SHAPE OF THE DELTA RESONANCE ACCORDING
    /// C     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
    /// C     FORMULA FOR N* RESORANCE
    /// C     DETERMINE DELTA MASS VIA REJECTION METHOD.
    dmax = srt - avmass - 0.005f;
    dmax = srt - avmass - 0.005f;
    dmin = 1.078f;
    if (n12 < 7) {
      /// C Delta(1232) production
      if (dmax < 1.232f) {
        fm = fde(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FDE():
        xdmass = 1.232f;
        /// C          FM=FDE(1.232,SRT,1.)
        fm = fde(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_10:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fde(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 30)) {
        goto statement_10;
      }
      /// C
      /// Clin-2/26/03 limit the Delta mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.47f) {
        goto statement_10;
      }
      /// C
      goto statement_13;
    }
    if ((n12 == 7) || (n12 == 8)) {
      /// C N*(1440) production
      if (dmax < 1.44f) {
        fm = fns(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.44f;
        /// C          FM=FNS(1.44,SRT,1.)
        fm = fns(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry2 = 0;
    statement_11:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry2++;
      if ((ranart(nseed) > fns(cmn, dm, srt, 1.f) / fm) && (ntry2 <= 10)) {
        goto statement_11;
      }
      /// C
      /// Clin-2/26/03 limit the N* mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 2.14f) {
        goto statement_11;
      }
      /// C
      goto statement_13;
    }
    if (n12 >= 17) {
      /// C N*(1535) production
      if (dmax < 1.535f) {
        fm = fd5(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.535f;
        /// C          FM=FD5(1.535,SRT,1.)
        fm = fd5(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_12:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fd5(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 10)) {
        goto statement_12;
      }
      /// C
      /// Clin-2/26/03 limit the N* mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.84f) {
        goto statement_12;
      }
      /// C
      goto statement_13;
    }
  /// C CALCULATE THE MASSES OF BARYON RESONANCES IN THE DOUBLE RESONANCE
  /// C PRODUCTION PROCESS AND RELABLE THE PARTICLES
  statement_1012:
    iblock = 43;
    rmasdd(cmn, srt, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
    rmasdd(cmn, srt, 1.232f, 1.44f, 1.08f, 1.08f, iseed, 3, dm1n, dm2n);
    if (n12 == 66) {
      /// C(1) PP-->DOUBLE RESONANCES
      /// C DETERMINE THE FINAL STATE
      xfinal = ranart(nseed);
      if (xfinal <= 0.25f) {
        /// C (1.1) D+++D0
        lb(i1) = 9;
        lb(i2) = 7;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if ((xfinal > 0.25f) && (xfinal <= 0.5f)) {
        /// C (1.2) D++D+
        lb(i1) = 8;
        lb(i2) = 8;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if ((xfinal > 0.5f) && (xfinal <= 0.75f)) {
        /// C (1.3) D+++N*0
        lb(i1) = 9;
        lb(i2) = 10;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if (xfinal > 0.75f) {
        /// C (1.4) D++N*+
        lb(i1) = 8;
        lb(i2) = 11;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
    }
  statement_1013:
    iblock = 43;
    rmasdd(cmn, srt, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
    rmasdd(cmn, srt, 1.232f, 1.44f, 1.08f, 1.08f, iseed, 3, dm1n, dm2n);
    if (n12 == 67) {
      /// C(2) NN-->DOUBLE RESONANCES
      /// C DETERMINE THE FINAL STATE
      xfinal = ranart(nseed);
      if (xfinal <= 0.25f) {
        /// C (2.1) D0+D0
        lb(i1) = 7;
        lb(i2) = 7;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if ((xfinal > 0.25f) && (xfinal <= 0.5f)) {
        /// C (2.2) D++D+
        lb(i1) = 6;
        lb(i2) = 8;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if ((xfinal > 0.5f) && (xfinal <= 0.75f)) {
        /// C (2.3) D0+N*0
        lb(i1) = 7;
        lb(i2) = 10;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if (xfinal > 0.75f) {
        /// C (2.4) D++N*+
        lb(i1) = 8;
        lb(i2) = 11;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
    }
  statement_1014:
    iblock = 43;
    rmasdd(cmn, srt, 1.232f, 1.232f, 1.08f, 1.08f, iseed, 1, dm1, dm2);
    rmasdd(cmn, srt, 1.232f, 1.44f, 1.08f, 1.08f, iseed, 3, dm1n, dm2n);
    if (n12 == 68) {
      /// C(3) NP-->DOUBLE RESONANCES
      /// C DETERMINE THE FINAL STATE
      xfinal = ranart(nseed);
      if (xfinal <= 0.25f) {
        /// C (3.1) D0+D+
        lb(i1) = 7;
        lb(i2) = 8;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if ((xfinal > 0.25f) && (xfinal <= 0.5f)) {
        /// C (3.2) D+++D-
        lb(i1) = 9;
        lb(i2) = 6;
        e(i1) = dm1;
        e(i2) = dm2;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if ((xfinal > 0.5f) && (xfinal <= 0.75f)) {
        /// C (3.3) D0+N*+
        lb(i1) = 7;
        lb(i2) = 11;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
      if (xfinal > 0.75f) {
        /// C (3.4) D++N*0
        lb(i1) = 8;
        lb(i2) = 10;
        e(i1) = dm1n;
        e(i2) = dm2n;
        goto statement_200;
        /// C go to 200 to set the new momentum
      }
    }
  statement_13:
    /// C-------------------------------------------------------
    /// C RELABLE BARYON I1 AND I2
    /// C1. p+n-->delta(+)+n
    if (n12 == 1) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i2) = 2;
        lb(i1) = 8;
        e(i1) = dm;
      } else {
        lb(i1) = 2;
        lb(i2) = 8;
        e(i2) = dm;
      }
      goto statement_200;
    }
    /// C2 p+n-->delta(0)+p
    if (n12 == 2) {
      if (fem::iabs(lb(i1)) == 2) {
        lb(i2) = 1;
        lb(i1) = 7;
        e(i1) = dm;
      } else {
        lb(i1) = 1;
        lb(i2) = 7;
        e(i2) = dm;
      }
      goto statement_200;
    }
    /// C3 p+p-->delta(++)+n
    if (n12 == 3) {
      lb(i1) = 9;
      e(i1) = dm;
      lb(i2) = 2;
      e(i2) = amn;
      goto statement_200;
    }
    /// C4 p+p-->delta(+)+p
    if (n12 == 4) {
      lb(i2) = 1;
      lb(i1) = 8;
      e(i1) = dm;
      goto statement_200;
    }
    /// C5 n+n--> delta(0)+n
    if (n12 == 5) {
      lb(i2) = 2;
      lb(i1) = 7;
      e(i1) = dm;
      goto statement_200;
    }
    /// C6 n+n--> delta(-)+p
    if (n12 == 6) {
      lb(i1) = 6;
      e(i1) = dm;
      lb(i2) = 1;
      e(i2) = amp;
      goto statement_200;
    }
    /// C7 n+p--> N*(0)+p
    if (n12 == 7) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i1) = 1;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_200;
    }
    /// C8 n+p--> N*(+)+n
    if (n12 == 8) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i2) = 2;
        lb(i1) = 11;
        e(i1) = dm;
      } else {
        lb(i1) = 2;
        lb(i2) = 11;
        e(i2) = dm;
      }
      goto statement_200;
    }
    /// C9 p+p--> N*(+)(1535)+p
    if (n12 == 9) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        lb(i1) = 13;
        e(i1) = dm;
      } else {
        lb(i1) = 1;
        lb(i2) = 13;
        e(i2) = dm;
      }
      goto statement_200;
    }
    /// C10 n+n--> N*(0)(1535)+n
    if (n12 == 10) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 2;
        lb(i1) = 12;
        e(i1) = dm;
      } else {
        lb(i1) = 2;
        lb(i2) = 12;
        e(i2) = dm;
      }
      goto statement_200;
    }
    /// C11 n+p--> N*(+)(1535)+n
    if (n12 == 11) {
      if (fem::iabs(lb(i1)) == 2) {
        lb(i1) = 2;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_200;
    }
    /// C12 n+p--> N*(0)(1535)+p
    if (n12 == 12) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i1) = 1;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        lb(i1) = 12;
        e(i1) = dm;
      }
    }
  }
/// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
/// C ENERGY CONSERVATION
statement_200:
  em1 = e(i1);
  em2 = e(i2);
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  if (srt <= 2.14f) {
    c1 = 1.0f - 2.0f * ranart(nseed);
  }
  if (srt > 2.14f && srt <= 2.4f) {
    c1 = ang(cmn, srt, iseed);
  }
  if (srt > 2.4f) {
    /// C
    /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
    xptr = 0.33f * pr;
    /// C         cc1=ptr(0.33*pr,iseed)
    cc1 = ptr(cmn, xptr, iseed);
    /// Clin-10/25/02-end
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = fem::pow2(pr) - fem::pow2(cc1);
    if (scheck < 0) {
      write(99, star), "scheck2: ", scheck;
      scheck = 0.f;
    }
    c1 = fem::sqrt(scheck) / pr;
    /// C             c1=sqrt(pr**2-cc1**2)/pr
    /// C
  }
  t1 = 2.0f * pi * ranart(nseed);
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
  }
  goto statement_107;
/// CFOR THE NN-->D1+D2+PI PROCESS, FIND MOMENTUM OF THE FINAL TWO
/// CDELTAS AND PION IN THE NUCLEUS-NUCLEUS CMS.
statement_106:
  ntry1 = 0;
statement_123:
  ddp2(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
       icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 40)) {
    goto statement_123;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  /// C (1) FOR P+P
  xdir = ranart(nseed);
  if (lb(i1) * lb(i2) == 1) {
    if (xdir <= 0.2f) {
      /// C (1.1)P+P-->D+++D0+PION(0)
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 9;
      lb(i2) = 7;
      goto statement_205;
    }
    /// C (1.2)P+P -->D++D+PION(0)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_205;
    }
    /// C (1.3)P+P-->D+++D+PION(-)
    if ((xdir <= 0.6f) && (xdir > 0.4f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_205;
    }
    if ((xdir <= 0.8f) && (xdir > 0.6f)) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 9;
      lb(i2) = 6;
      goto statement_205;
    }
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
  }
  /// C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    if (xdir <= 0.2f) {
      /// C (2.1)N+N-->D++D-+PION(0)
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 6;
      lb(i2) = 7;
      goto statement_205;
    }
    /// C (2.2)N+N -->D+++D-+PION(-)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_205;
    }
    /// C (2.3)P+P-->D0+D-+PION(+)
    if ((xdir > 0.4f) && (xdir <= 0.6f)) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_205;
    }
    /// C (2.4)P+P-->D0+D0+PION(0)
    if ((xdir > 0.6f) && (xdir <= 0.8f)) {
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 7;
      lb(i2) = 7;
      goto statement_205;
    }
    /// C (2.5)P+P-->D0+D++PION(-)
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
  }
  /// C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    if (xdir <= 0.17f) {
      /// C (3.1)N+P-->D+++D-+PION(0)
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_205;
    }
    /// C (3.2)N+P -->D+++D0+PION(-)
    if ((xdir <= 0.34f) && (xdir > 0.17f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 9;
      goto statement_205;
    }
    /// C (3.3)N+P-->D++D-+PION(+)
    if ((xdir > 0.34f) && (xdir <= 0.51f)) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
    /// C (3.4)N+P-->D++D++PION(-)
    if ((xdir > 0.51f) && (xdir <= 0.68f)) {
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_205;
    }
    /// C (3.5)N+P-->D0+D++PION(0)
    if ((xdir > 0.68f) && (xdir <= 0.85f)) {
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_205;
    }
    /// C (3.6)N+P-->D0+D0+PION(+)
    if (xdir > 0.85f) {
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lb(i1) = 7;
      lb(i2) = 7;
    }
  }
/// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
/// C NUCLEUS CMS. FRAME
/// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_205:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  /// C
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 3) {
      lpion(nnn, irun) = 5;
    } else if (lpion(nnn, irun) == 5) {
      lpion(nnn, irun) = 3;
    }
  }
  /// C
  lb1 = lb(i1);
  /// C FOR DELTA2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  /// C assign delta1 and delta2 to i1 or i2 to keep the leadng particle
  /// C behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 4;
  /// C GET PION'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008 do not allow smearing in position of produced particles
  /// C     to avoid immediate reinteraction with the particle I1, I2 or
  /// themselves: C2002        X01 = 1.0 - 2.0 * RANART(NSEED) C            Y01
  /// = 1.0 - 2.0 * RANART(NSEED) C            Z01 = 1.0 - 2.0 * RANART(NSEED) C
  /// IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2002 C
  /// RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01 C RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01 C
  /// RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  goto statement_90005;
/// Clin-5/2008 N+N->Deuteron+pi:
/// C     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_108:
  if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
    /// C     For idpert=1: we produce npertd pert deuterons:
    ndloop = npertd;
  } else if (idpert == 2 && npertd >= 1) {
    /// C     For idpert=2: we first save information for npertd pert deuterons;
    /// C     at the last ndloop we create the regular deuteron+pi
    /// C     and those pert deuterons:
    ndloop = npertd + 1;
  } else {
    /// C     Just create the regular deuteron+pi:
    ndloop = 1;
  }
  /// C
  dprob1 = sdprod / sig / fem::ffloat(npertd);
  FEM_DO_SAFE(idloop, 1, ndloop) {
    bbdangle(cmn, pxd, pyd, pzd, nt, ipert1, ianti, idloop, pfinal, dprob1,
             lbm);
    rotate(cmn, px, py, pz, pxd, pyd, pzd);
    /// C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
    /// STATE C     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME: C     For
    /// the Deuteron:
    xmass = xmd;
    e1dcm = fem::sqrt(fem::pow2(xmass) + fem::pow2(pxd) + fem::pow2(pyd) +
                      fem::pow2(pzd));
    p1dbeta = pxd * betax + pyd * betay + pzd * betaz;
    transf = gamma * (gamma * p1dbeta / (gamma + 1.f) + e1dcm);
    pxi1 = betax * transf + pxd;
    pyi1 = betay * transf + pyd;
    pzi1 = betaz * transf + pzd;
    if (ianti == 0) {
      lbd = 42;
    } else {
      lbd = -42;
    }
    if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
      /// Cccc  Perturbative production for idpert=1:
      nnn++;
      ppion(1, nnn, irun) = pxi1;
      ppion(2, nnn, irun) = pyi1;
      ppion(3, nnn, irun) = pzi1;
      epion(nnn, irun) = xmd;
      lpion(nnn, irun) = lbd;
      rpion(1, nnn, irun) = r(1, i1);
      rpion(2, nnn, irun) = r(2, i1);
      rpion(3, nnn, irun) = r(3, i1);
      /// Clin-5/2008 assign the perturbative probability:
      dppion(nnn, irun) = sdprod / sig / fem::ffloat(npertd);
    } else if (idpert == 2 && idloop <= npertd) {
      /// Clin-5/2008 For idpert=2, we produce NPERTD perturbative
      /// (anti)deuterons C     only when a regular (anti)deuteron+pi is
      /// produced in NN collisions. C     First save the info for the
      /// perturbative deuterons:
      ppd(1, idloop) = pxi1;
      ppd(2, idloop) = pyi1;
      ppd(3, idloop) = pzi1;
      lbpd(idloop) = lbd;
    } else {
      /// Cccc  Regular production:
      /// C     For the regular pion: do LORENTZ-TRANSFORMATION:
      e(i1) = xmm;
      e2picm = fem::sqrt(fem::pow2(xmm) + fem::pow2(pxd) + fem::pow2(pyd) +
                         fem::pow2(pzd));
      p2pibeta = -pxd * betax - pyd * betay - pzd * betaz;
      transf = gamma * (gamma * p2pibeta / (gamma + 1.f) + e2picm);
      pxi2 = betax * transf - pxd;
      pyi2 = betay * transf - pyd;
      pzi2 = betaz * transf - pzd;
      p(1, i1) = pxi2;
      p(2, i1) = pyi2;
      p(3, i1) = pzi2;
      /// C     Remove regular pion to check the equivalence
      /// C     between the perturbative and regular deuteron results:
      /// C                 E(i1)=0.
      /// C
      lb(i1) = lbm;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      id(i1) = 2;
      id1 = id(i1);
      cmn.e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                         fem::pow2(pz1));
      lb1 = lb(i1);
      /// C     For the regular deuteron:
      p(1, i2) = pxi1;
      p(2, i2) = pyi1;
      p(3, i2) = pzi1;
      lb(i2) = lbd;
      lb2 = lb(i2);
      e(i2) = xmd;
      eti2 = e(i2);
      id(i2) = 2;
      /// C     For idpert=2: create the perturbative deuterons:
      if (idpert == 2 && idloop == ndloop) {
        FEM_DO_SAFE(ipertd, 1, npertd) {
          nnn++;
          ppion(1, nnn, irun) = ppd(1, ipertd);
          ppion(2, nnn, irun) = ppd(2, ipertd);
          ppion(3, nnn, irun) = ppd(3, ipertd);
          epion(nnn, irun) = xmd;
          lpion(nnn, irun) = lbpd(ipertd);
          rpion(1, nnn, irun) = r(1, i1);
          rpion(2, nnn, irun) = r(2, i1);
          rpion(3, nnn, irun) = r(3, i1);
          /// Clin-5/2008 assign the perturbative probability:
          dppion(nnn, irun) = 1.f / fem::ffloat(npertd);
        }
      }
    }
  }
  iblock = 501;
  goto statement_90005;
/// Clin-5/2008 N+N->Deuteron+pi over
/// C FOR THE NN-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN
/// C THE NUCLEUS-NUCLEUS CMS.
statement_306:
  /// Csp11/21/01 phi production
  if (xsk5 / sigk > ranart(nseed)) {
    pz1 = p(3, i1);
    pz2 = p(3, i2);
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    nnn++;
    lpion(nnn, irun) = 29;
    epion(nnn, irun) = aphi;
    iblock = 222;
    goto statement_208;
  }
  /// C
  iblock = 9;
  if (ianti == 1) {
    iblock = -9;
  }
  /// C
  pz1 = p(3, i1);
  pz2 = p(3, i2);
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  nnn++;
  lpion(nnn, irun) = 23;
  epion(nnn, irun) = aka;
  if (srt <= 2.63f) {
    /// C only lambda production is possible
    /// C (1.1)P+P-->p+L+kaon+
    ic = 1;
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 14;
    goto statement_208;
  }
  if (srt <= 2.74f && srt > 2.63f) {
    /// C both Lambda and sigma production are possible
    if (xsk1 / (xsk1 + xsk2) > ranart(nseed)) {
      /// C lambda production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
    } else {
      /// C sigma production
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      ic = 2;
    }
    goto statement_208;
  }
  if (srt <= 2.77f && srt > 2.74f) {
    /// C then pp-->Delta lamda kaon can happen
    if (xsk1 / (xsk1 + xsk2 + xsk3) > ranart(nseed)) {
      /// C * (1.1)P+P-->p+L+kaon+
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk2 / (xsk2 + xsk3) > ranart(nseed)) {
        /// C pp-->psk
        ic = 2;
        lb(i1) = 1 + fem::fint(2 * ranart(nseed));
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      } else {
        /// C pp-->D+l+k
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
      }
      goto statement_208;
    }
  }
  if (srt > 2.77f) {
    /// C all four channels are possible
    if (xsk1 / (xsk1 + xsk2 + xsk3 + xsk4) > ranart(nseed)) {
      /// C p lambda k production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk3 / (xsk2 + xsk3 + xsk4) > ranart(nseed)) {
        /// C delta l K production
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
        goto statement_208;
      } else {
        if (xsk2 / (xsk2 + xsk4) > ranart(nseed)) {
          /// C n sigma k production
          lb(i1) = 1 + fem::fint(2 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          ic = 2;
        } else {
          ic = 4;
          lb(i1) = 6 + fem::fint(4 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        }
        goto statement_208;
      }
    }
  }
statement_208:
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 23) {
      lpion(nnn, irun) = 21;
    }
  }
  /// C KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
  ntry1 = 0;
statement_127:
  bbkaon(cmn, ic, srt, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_127;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  /// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
  /// C NUCLEUS CMS. FRAME
  /// C (1) for the necleon/delta
  /// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  lbi1 = lb(i1);
  /// C (2) for the lambda/sigma
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lbi2 = lb(i2);
  /// C GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(aka) + fem::pow2(ppx) + fem::pow2(ppy) +
                   fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008
  /// C2003        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2003
  /// C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  /// C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  /// C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  /// C assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the
  /// C leadng particle behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lbi1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lbi2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  goto statement_90005;
/// C FOR THE NN-->Delta+Delta+rho PROCESS, FIND MOMENTUM OF THE FINAL
/// C PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_307:
  ntry1 = 0;
statement_125:
  ddrho(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
        amrho, icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_125;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  arho = amrho;
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  /// C (1) FOR P+P
  xdir = ranart(nseed);
  if (lb(i1) * lb(i2) == 1) {
    if (xdir <= 0.2f) {
      /// C (1.1)P+P-->D+++D0+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 7;
      goto statement_2051;
    }
    /// C (1.2)P+P -->D++D+rho(0)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_2051;
    }
    /// C (1.3)P+P-->D+++D+arho(-)
    if ((xdir <= 0.6f) && (xdir > 0.4f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_2051;
    }
    if ((xdir <= 0.8f) && (xdir > 0.6f)) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 6;
      goto statement_2051;
    }
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
  }
  /// C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    if (xdir <= 0.2f) {
      /// C (2.1)N+N-->D++D-+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 6;
      lb(i2) = 7;
      goto statement_2051;
    }
    /// C (2.2)N+N -->D+++D-+rho(-)
    if ((xdir <= 0.4f) && (xdir > 0.2f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_2051;
    }
    /// C (2.3)P+P-->D0+D-+rho(+)
    if ((xdir > 0.4f) && (xdir <= 0.6f)) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 9;
      lb(i2) = 8;
      goto statement_2051;
    }
    /// C (2.4)P+P-->D0+D0+rho(0)
    if ((xdir > 0.6f) && (xdir <= 0.8f)) {
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 7;
      goto statement_2051;
    }
    /// C (2.5)P+P-->D0+D++rho(-)
    if (xdir > 0.8f) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
  }
  /// C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    if (xdir <= 0.17f) {
      /// C (3.1)N+P-->D+++D-+rho(0)
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 6;
      lb(i2) = 9;
      goto statement_2051;
    }
    /// C (3.2)N+P -->D+++D0+rho(-)
    if ((xdir <= 0.34f) && (xdir > 0.17f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 9;
      goto statement_2051;
    }
    /// C (3.3)N+P-->D++D-+rho(+)
    if ((xdir > 0.34f) && (xdir <= 0.51f)) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
    /// C (3.4)N+P-->D++D++rho(-)
    if ((xdir > 0.51f) && (xdir <= 0.68f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 8;
      lb(i2) = 8;
      goto statement_2051;
    }
    /// C (3.5)N+P-->D0+D++rho(0)
    if ((xdir > 0.68f) && (xdir <= 0.85f)) {
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 8;
      goto statement_2051;
    }
    /// C (3.6)N+P-->D0+D0+rho(+)
    if (xdir > 0.85f) {
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 7;
      lb(i2) = 7;
    }
  }
/// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
/// C NUCLEUS CMS. FRAME
/// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_2051:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  /// C
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 25) {
      lpion(nnn, irun) = 27;
    } else if (lpion(nnn, irun) == 27) {
      lpion(nnn, irun) = 25;
    }
  }
  /// C
  lb1 = lb(i1);
  /// C FOR DELTA2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  /// C assign delta1 and delta2 to i1 or i2 to keep the leadng particle
  /// C behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 44;
  /// C GET rho'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008:
  /// C2004        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2004
  /// C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  /// C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  /// C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  goto statement_90005;
/// C FOR THE NN-->N+N+rho PROCESS, FIND MOMENTUM OF THE FINAL
/// C PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_308:
  ntry1 = 0;
statement_126:
  pprho(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
        amrho, icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_126;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  arho = amrho;
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  /// C (1) FOR P+P
  xdir = ranart(nseed);
  if (lb(i1) * lb(i2) == 1) {
    if (xdir <= 0.5f) {
      /// C (1.1)P+P-->P+P+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 1;
      goto statement_2052;
    } else {
      /// C (1.2)P+P -->p+n+rho(+)
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 2;
      goto statement_2052;
    }
  }
  /// C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    if (xdir <= 0.5f) {
      /// C (2.1)N+N-->N+N+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 2;
      lb(i2) = 2;
      goto statement_2052;
    } else {
      /// C (2.2)N+N -->N+P+rho(-)
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 2;
      goto statement_2052;
    }
  }
  /// C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    if (xdir <= 0.33f) {
      /// C (3.1)N+P-->N+P+rho(0)
      lpion(nnn, irun) = 26;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 2;
      goto statement_2052;
      /// C (3.2)N+P -->P+P+rho(-)
    } else if ((xdir <= 0.67f) && (xdir > 0.34f)) {
      lpion(nnn, irun) = 25;
      epion(nnn, irun) = arho;
      lb(i1) = 1;
      lb(i2) = 1;
      goto statement_2052;
    } else {
      /// C (3.3)N+P-->N+N+rho(+)
      lpion(nnn, irun) = 27;
      epion(nnn, irun) = arho;
      lb(i1) = 2;
      lb(i2) = 2;
      goto statement_2052;
    }
  }
/// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
/// C NUCLEUS CMS. FRAME
/// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_2052:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  /// C
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 25) {
      lpion(nnn, irun) = 27;
    } else if (lpion(nnn, irun) == 27) {
      lpion(nnn, irun) = 25;
    }
  }
  /// C
  lb1 = lb(i1);
  /// C FOR p2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  /// C assign p1 and p2 to i1 or i2 to keep the leadng particle
  /// C behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 45;
  /// C GET rho'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008:
  /// C2005        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2005
  /// C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  /// C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  /// C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  goto statement_90005;
/// C FOR THE NN-->p+p+omega PROCESS, FIND MOMENTUM OF THE FINAL
/// C PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_309:
  ntry1 = 0;
statement_138:
  ppomga(cmn, srt, iseed, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_138;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  nnn++;
  aomega = 0.782f;
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  /// C (1) FOR P+P
  if (lb(i1) * lb(i2) == 1) {
    /// C (1.1)P+P-->P+P+omega(0)
    lpion(nnn, irun) = 28;
    epion(nnn, irun) = aomega;
    lb(i1) = 1;
    lb(i2) = 1;
    goto statement_2053;
  }
  /// C (2)FOR N+N
  if (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2) {
    /// C (2.1)N+N-->N+N+omega(0)
    lpion(nnn, irun) = 28;
    epion(nnn, irun) = aomega;
    lb(i1) = 2;
    lb(i2) = 2;
    goto statement_2053;
  }
  /// C (3)FOR N+P
  if (lb(i1) * lb(i2) == 2) {
    /// C (3.1)N+P-->N+P+omega(0)
    lpion(nnn, irun) = 28;
    epion(nnn, irun) = aomega;
    lb(i1) = 1;
    lb(i2) = 2;
    goto statement_2053;
  }
/// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
/// C NUCLEUS CMS. FRAME
/// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
statement_2053:
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
  }
  lb1 = lb(i1);
  /// C FOR DELTA2
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  lb2 = lb(i2);
  /// C assign delta1 and delta2 to i1 or i2 to keep the leadng particle
  /// C behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lb1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lb2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  iblock = 46;
  /// C GET omega'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppx) +
                   fem::pow2(ppy) + fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008:
  /// C2006        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2006
  /// C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  /// C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  /// C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  goto statement_90005;
/// C change phase space density FOR NUCLEONS AFTER THE PROCESS
/// C
/// Clin-10/25/02-comment out following, since there is no path to it:
/// Clin-8/16/02 used before set
/// C     IX1,IY1,IZ1,IPX1,IPY1,IPZ1, IX2,IY2,IZ2,IPX2,IPY2,IPZ2:
/// C                if ((abs(ix1).le.mx) .and. (abs(iy1).le.my) .and.
/// C     &              (abs(iz1).le.mz)) then
/// C                  ipx1p = nint(p(1,i1)/dpx)
/// C                  ipy1p = nint(p(2,i1)/dpy)
/// C                  ipz1p = nint(p(3,i1)/dpz)
/// C                  if ((ipx1p.ne.ipx1) .or. (ipy1p.ne.ipy1) .or.
/// C     &                (ipz1p.ne.ipz1)) then
/// C                    if ((abs(ipx1).le.mpx) .and. (abs(ipy1).le.my)
/// C     &                .and. (ipz1.ge.-mpz) .and. (ipz1.le.mpzp))
/// C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) =
/// C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) - 1.
/// C                    if ((abs(ipx1p).le.mpx) .and. (abs(ipy1p).le.my)
/// C     &                .and. (ipz1p.ge.-mpz).and. (ipz1p.le.mpzp))
/// C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) =
/// C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) + 1.
/// C                  end if
/// C                end if
/// C                if ((abs(ix2).le.mx) .and. (abs(iy2).le.my) .and.
/// C     &              (abs(iz2).le.mz)) then
/// C                  ipx2p = nint(p(1,i2)/dpx)
/// C                  ipy2p = nint(p(2,i2)/dpy)
/// C                  ipz2p = nint(p(3,i2)/dpz)
/// C                  if ((ipx2p.ne.ipx2) .or. (ipy2p.ne.ipy2) .or.
/// C     &                (ipz2p.ne.ipz2)) then
/// C                    if ((abs(ipx2).le.mpx) .and. (abs(ipy2).le.my)
/// C     &                .and. (ipz2.ge.-mpz) .and. (ipz2.le.mpzp))
/// C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) =
/// C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) - 1.
/// C                    if ((abs(ipx2p).le.mpx) .and. (abs(ipy2p).le.my)
/// C     &                .and. (ipz2p.ge.-mpz) .and. (ipz2p.le.mpzp))
/// C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) =
/// C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) + 1.
/// C                  end if
/// C                end if
/// Clin-10/25/02-end
/// C
statement_90005:
  return;
/// C-----------------------------------------------------------------------
/// CCOM: SET THE NEW MOMENTUM COORDINATES
statement_107:
  if (px == 0.0f && py == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py, px);
  }
  s1 = 1.0f - fem::pow2(c1);
  if (s1 <= 0) {
    s1 = 0;
  }
  s1 = fem::sqrt(s1);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck3: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  /// C       S2  =  SQRT( 1.0 - C2**2 )
  /// C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
  ss = c2 * s1 * ct1 + s2 * c1;
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
}

struct rhores_save {
  float dm;
  double e10;
  double e20;
  double p1;
  double p2;
  double p3;
  double scheck;

  rhores_save()
      : dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0) {}
};

/// C---------------------------------------------------------------------------
/// C PURPOSE : CALCULATE THE MASS AND MOMENTUM OF RHO RESONANCE
/// C           AFTER PION + PION COLLISION
/// C DATE    : NOV. 30,1994
void rhores(common& cmn, int const& i1, int const& i2) {
  FEM_CMN_SVE(rhores);
  common_write write(cmn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  ///
  /// SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  ///
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// C 1. DETERMINE THE MOMENTUM COMPONENT OF THE RHO IN THE CMS OF NN FRAME
  /// C    WE LET I1 TO BE THE RHO AND ABSORB I2
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  /// C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  /// C
  p(1, i1) += p(1, i2);
  p(2, i1) += p(2, i2);
  p(3, i1) += p(3, i2);
  /// C 2. DETERMINE THE MASS OF THE RHO BY USING THE REACTION KINEMATICS
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck18: ", scheck;
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  /// C        DM=SQRT((E10+E20)**2-P(1,I1)**2-P(2,I1)**2-P(3,I1)**2)
  /// C
  e(i1) = dm;
  e(i2) = 0;
}

struct bbarfs_save {
  int i;
  int ifs;
  float rd;
  float rd1;
  float rd2;
  float wsum;

  bbarfs_save()
      : i(fem::int0),
        ifs(fem::int0),
        rd(fem::float0),
        rd1(fem::float0),
        rd2(fem::float0),
        wsum(fem::float0) {}
};

/// C
/// C****************************************
/// C Generate final states for mm-->Bbar B *
void bbarfs(common& cmn, int& lbb1, int& lbb2, float& ei1, float& ei2,
            int& iblock, int const& /* iseed */) {
  FEM_CMN_SVE(bbarfs);
  arr_cref<float, 2> ppbm(cmn.ppbm, dimension(15, 2));
  arr_cref<float> weight(cmn.weight, dimension(15));
  int& nseed = cmn.nseed;
  ///
  int& i = sve.i;
  int& ifs = sve.ifs;
  float& rd = sve.rd;
  float& rd1 = sve.rd1;
  float& rd2 = sve.rd2;
  float& wsum = sve.wsum;
  /// C****************************************
  /// Cc      SAVE /ppbmas/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  /// C     determine which final BbarB channel occurs:
  rd = ranart(nseed);
  wsum = 0.f;
  FEM_DO_SAFE(i, 1, cmn.nstate) {
    wsum += weight(i);
    if (rd <= (wsum / cmn.wtot)) {
      ifs = i;
      ei1 = ppbm(i, 1);
      ei2 = ppbm(i, 2);
      goto statement_10;
    }
  }
statement_10:
  /// C
  /// C1    pbar p
  if (ifs == 1) {
    iblock = 1801;
    lbb1 = -1;
    lbb2 = 1;
  } else if (ifs == 2) {
    /// C2    pbar n
    if (ranart(nseed) <= 0.5f) {
      iblock = 18021;
      lbb1 = -1;
      lbb2 = 2;
      /// C2    nbar p
    } else {
      iblock = 18022;
      lbb1 = 1;
      lbb2 = -2;
    }
    /// C3    nbar n
  } else if (ifs == 3) {
    iblock = 1803;
    lbb1 = -2;
    lbb2 = 2;
    /// C4&5  (pbar nbar) Delta, (p n) anti-Delta
  } else if (ifs == 4 || ifs == 5) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      /// C     (pbar nbar) Delta
      if (ifs == 4) {
        iblock = 18041;
        lbb1 = -1;
      } else {
        iblock = 18051;
        lbb1 = -2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.25f) {
        lbb2 = 6;
      } else if (rd2 <= 0.5f) {
        lbb2 = 7;
      } else if (rd2 <= 0.75f) {
        lbb2 = 8;
      } else {
        lbb2 = 9;
      }
    } else {
      /// C     (p n) anti-Delta
      if (ifs == 4) {
        iblock = 18042;
        lbb1 = 1;
      } else {
        iblock = 18052;
        lbb1 = 2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.25f) {
        lbb2 = -6;
      } else if (rd2 <= 0.5f) {
        lbb2 = -7;
      } else if (rd2 <= 0.75f) {
        lbb2 = -8;
      } else {
        lbb2 = -9;
      }
    }
    /// C6&7  (pbar nbar) N*(1440), (p n) anti-N*(1440)
  } else if (ifs == 6 || ifs == 7) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      /// C     (pbar nbar) N*(1440)
      if (ifs == 6) {
        iblock = 18061;
        lbb1 = -1;
      } else {
        iblock = 18071;
        lbb1 = -2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = 10;
      } else {
        lbb2 = 11;
      }
    } else {
      /// C     (p n) anti-N*(1440)
      if (ifs == 6) {
        iblock = 18062;
        lbb1 = 1;
      } else {
        iblock = 18072;
        lbb1 = 2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = -10;
      } else {
        lbb2 = -11;
      }
    }
    /// C8    Delta anti-Delta
  } else if (ifs == 8) {
    iblock = 1808;
    rd1 = ranart(nseed);
    if (rd1 <= 0.25f) {
      lbb1 = 6;
    } else if (rd1 <= 0.5f) {
      lbb1 = 7;
    } else if (rd1 <= 0.75f) {
      lbb1 = 8;
    } else {
      lbb1 = 9;
    }
    rd2 = ranart(nseed);
    if (rd2 <= 0.25f) {
      lbb2 = -6;
    } else if (rd2 <= 0.5f) {
      lbb2 = -7;
    } else if (rd2 <= 0.75f) {
      lbb2 = -8;
    } else {
      lbb2 = -9;
    }
    /// C9&10 (pbar nbar) N*(1535), (p n) anti-N*(1535)
  } else if (ifs == 9 || ifs == 10) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      /// C     (pbar nbar) N*(1440)
      if (ifs == 9) {
        iblock = 18091;
        lbb1 = -1;
      } else {
        iblock = 18101;
        lbb1 = -2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = 12;
      } else {
        lbb2 = 13;
      }
    } else {
      /// C     (p n) anti-N*(1535)
      if (ifs == 9) {
        iblock = 18092;
        lbb1 = 1;
      } else {
        iblock = 18102;
        lbb1 = 2;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = -12;
      } else {
        lbb2 = -13;
      }
    }
    /// C11&12 anti-Delta N*, Delta anti-N*
  } else if (ifs == 11 || ifs == 12) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      /// C     anti-Delta N*
      rd1 = ranart(nseed);
      if (rd1 <= 0.25f) {
        lbb1 = -6;
      } else if (rd1 <= 0.5f) {
        lbb1 = -7;
      } else if (rd1 <= 0.75f) {
        lbb1 = -8;
      } else {
        lbb1 = -9;
      }
      if (ifs == 11) {
        iblock = 18111;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = 10;
        } else {
          lbb2 = 11;
        }
      } else {
        iblock = 18121;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = 12;
        } else {
          lbb2 = 13;
        }
      }
    } else {
      /// C     Delta anti-N*
      rd1 = ranart(nseed);
      if (rd1 <= 0.25f) {
        lbb1 = 6;
      } else if (rd1 <= 0.5f) {
        lbb1 = 7;
      } else if (rd1 <= 0.75f) {
        lbb1 = 8;
      } else {
        lbb1 = 9;
      }
      if (ifs == 11) {
        iblock = 18112;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = -10;
        } else {
          lbb2 = -11;
        }
      } else {
        iblock = 18122;
        rd2 = ranart(nseed);
        if (rd2 <= 0.5f) {
          lbb2 = -12;
        } else {
          lbb2 = -13;
        }
      }
    }
    /// C13   N*(1440) anti-N*(1440)
  } else if (ifs == 13) {
    iblock = 1813;
    rd1 = ranart(nseed);
    if (rd1 <= 0.5f) {
      lbb1 = 10;
    } else {
      lbb1 = 11;
    }
    rd2 = ranart(nseed);
    if (rd2 <= 0.5f) {
      lbb2 = -10;
    } else {
      lbb2 = -11;
    }
    /// C14   anti-N*(1440) N*(1535), N*(1440) anti-N*(1535)
  } else if (ifs == 14) {
    rd = ranart(nseed);
    if (rd <= 0.5f) {
      /// C     anti-N*(1440) N*(1535)
      iblock = 18141;
      rd1 = ranart(nseed);
      if (rd1 <= 0.5f) {
        lbb1 = -10;
      } else {
        lbb1 = -11;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = 12;
      } else {
        lbb2 = 13;
      }
    } else {
      /// C     N*(1440) anti-N*(1535)
      iblock = 18142;
      rd1 = ranart(nseed);
      if (rd1 <= 0.5f) {
        lbb1 = 10;
      } else {
        lbb1 = 11;
      }
      rd2 = ranart(nseed);
      if (rd2 <= 0.5f) {
        lbb2 = -12;
      } else {
        lbb2 = -13;
      }
    }
    /// C15   N*(1535) anti-N*(1535)
  } else if (ifs == 15) {
    iblock = 1815;
    rd1 = ranart(nseed);
    if (rd1 <= 0.5f) {
      lbb1 = 12;
    } else {
      lbb1 = 13;
    }
    rd2 = ranart(nseed);
    if (rd2 <= 0.5f) {
      lbb2 = -12;
    } else {
      lbb2 = -13;
    }
  } else {
  }
  /// C
}

/// C
/// C****************************************
/// C for pi pi <-> rho rho final states
void pi2ro2(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5) && (lb(i2) >= 3 && lb(i2) <= 5)) {
    iblock = 1850;
    ei1 = 0.77f;
    ei2 = 0.77f;
    /// C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    /// 2rho) C     thus the cross sections used are considered as the
    /// isospin-averaged ones.
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 25 + fem::fint(3 * ranart(nseed));
  } else if ((lb(i1) >= 25 && lb(i1) <= 27) && (lb(i2) >= 25 && lb(i2) <= 27)) {
    iblock = 1851;
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = ap2;
    ei2 = ap2;
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  /// C
}

/// C
/// C****************************************
/// C for pi pi <-> eta eta final states
void pi2et2(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  const float etam = 0.5475f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5) && (lb(i2) >= 3 && lb(i2) <= 5)) {
    iblock = 1860;
    ei1 = etam;
    ei2 = etam;
    /// C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    /// 2rho) C     thus the cross sections used are considered as the
    /// isospin-averaged ones.
    lbb1 = 0;
    lbb2 = 0;
  } else if (lb(i1) == 0 && lb(i2) == 0) {
    iblock = 1861;
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = ap2;
    ei2 = ap2;
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  /// C
}

/// C
/// C****************************************
/// C for pi pi <-> pi eta final states
void pi3eta(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  const float ap2 = 0.13957f;
  const float etam = 0.5475f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5) && (lb(i2) >= 3 && lb(i2) <= 5)) {
    iblock = 1870;
    ei1 = ap2;
    ei2 = etam;
    /// C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    /// 2rho) C     thus the cross sections used are considered as the
    /// isospin-averaged ones.
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    lbb2 = 0;
  } else if ((lb(i1) >= 3 && lb(i1) <= 5 && lb(i2) == 0) ||
             (lb(i2) >= 3 && lb(i2) <= 5 && lb(i1) == 0)) {
    iblock = 1871;
    lbb1 = 3 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = ap2;
    ei2 = ap2;
    if (lbb1 == 4) {
      ei1 = ap1;
    }
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  /// C
}

/// C
/// C****************************************
/// C for rho pi <-> rho eta final states
void rpiret(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  const float arho = 0.77f;
  const float etam = 0.5475f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 25 && lb(i1) <= 27 && lb(i2) >= 3 && lb(i2) <= 5) ||
      (lb(i1) >= 3 && lb(i1) <= 5 && lb(i2) >= 25 && lb(i2) <= 27)) {
    iblock = 1880;
    ei1 = arho;
    ei2 = etam;
    /// C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    /// 2rho) C     thus the cross sections used are considered as the
    /// isospin-averaged ones.
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 0;
  } else if ((lb(i1) >= 25 && lb(i1) <= 27 && lb(i2) == 0) ||
             (lb(i2) >= 25 && lb(i2) <= 27 && lb(i1) == 0)) {
    iblock = 1881;
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 3 + fem::fint(3 * ranart(nseed));
    ei1 = arho;
    ei2 = ap2;
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  /// C
}

/// C
/// C****************************************
/// C for omega pi <-> omega eta final states
void opioet(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  const float aomega = 0.782f;
  const float etam = 0.5475f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if ((lb(i1) >= 3 && lb(i1) <= 5 && lb(i2) == 28) ||
      (lb(i2) >= 3 && lb(i2) <= 5 && lb(i1) == 28)) {
    iblock = 1890;
    ei1 = aomega;
    ei2 = etam;
    /// C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    /// 2rho) C     thus the cross sections used are considered as the
    /// isospin-averaged ones.
    lbb1 = 28;
    lbb2 = 0;
  } else if ((lb(i1) == 28 && lb(i2) == 0) || (lb(i1) == 0 && lb(i2) == 28)) {
    iblock = 1891;
    lbb1 = 28;
    lbb2 = 3 + fem::fint(3 * ranart(cmn.nseed));
    ei1 = aomega;
    ei2 = ap2;
    if (lbb2 == 4) {
      ei2 = ap1;
    }
  }
  /// C
}

/// C
/// C****************************************
/// C for rho rho <-> eta eta final states
void ro2et2(common& cmn, int const& i1, int const& i2, int& lbb1, int& lbb2,
            float& ei1, float& ei2, int& iblock, int const& /* iseed */) {
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  const float etam = 0.5475f;
  const float arho = 0.77f;
  if (lb(i1) >= 25 && lb(i1) <= 27 && lb(i2) >= 25 && lb(i2) <= 27) {
    iblock = 1895;
    ei1 = etam;
    ei2 = etam;
    /// C     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 ->
    /// 2rho) C     thus the cross sections used are considered as the
    /// isospin-averaged ones.
    lbb1 = 0;
    lbb2 = 0;
  } else if (lb(i1) == 0 && lb(i2) == 0) {
    iblock = 1896;
    lbb1 = 25 + fem::fint(3 * ranart(nseed));
    lbb2 = 25 + fem::fint(3 * ranart(nseed));
    ei1 = arho;
    ei2 = arho;
  }
  /// C
}

struct crpp_save {
  float c1;
  float ct1;
  float ei1;
  float ei2;
  float em1;
  float em2;
  int lb1;
  int lb1i;
  int lb2;
  int lb2i;
  int lbb1;
  int lbb2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float ranpi;
  float s1;
  float st1;
  float t1;

  crpp_save()
      : c1(fem::float0),
        ct1(fem::float0),
        ei1(fem::float0),
        ei2(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        lb1(fem::int0),
        lb1i(fem::int0),
        lb2(fem::int0),
        lb2i(fem::int0),
        lbb1(fem::int0),
        lbb2(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        ranpi(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// Clin-5/2008 CRNN over
/// C
/// C*********************************
/// C                                                                      *
/// C
void crpp(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& ppel,
          float const& ppin, float const& spprho, int const& ipp) {
  FEM_CMN_SVE(crpp);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& iseed = cmn.iseed;
  float& pprr = cmn.pprr;
  float& ppee = cmn.ppee;
  float& pppe = cmn.pppe;
  float& rpre = cmn.rpre;
  float& xopoe = cmn.xopoe;
  float& rree = cmn.rree;
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& ei1 = sve.ei1;
  float& ei2 = sve.ei2;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  int& lbb1 = sve.lbb1;
  int& lbb2 = sve.lbb2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& ranpi = sve.ranpi;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  const float aka = 0.498f;
  const float aks = 0.895f;
  const float pi = 3.1415926f;
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH PION-PION COLLISIONS                        *
  /// C     NOTE   :                                                         *
  /// C           VALID ONLY FOR PION-PION-DISTANCES LESS THAN 2.5 FM        *
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     6-> Meson+Meson elastic
  /// C                     66-> Meson+meson-->K+K-
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /RNDF77/
  /// C
  sve.lb1i = lb(i1);
  sve.lb2i = lb(i2);
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  /// C-----------------------------------------------------------------------
  /// C check Meson+Meson inelastic collisions
  /// Clin-9/28/00
  /// C        if((srt.gt.1.).and.(ppin/(ppin+ppel).gt.RANART(NSEED)))then
  /// C        iblock=66
  /// C        e(i1)=0.498
  /// C        e(i2)=0.498
  /// C        lb(i1)=21
  /// C        lb(i2)=23
  /// C        go to 10
  /// Clin-11/07/00
  /// C        if(srt.gt.1.and.(ppin/(ppin+ppel)).gt.RANART(NSEED)) then
  /// Clin-4/03/02
  if (srt > (2 * aka) && (ppin / (ppin + ppel)) > ranart(nseed)) {
    /// C        if(ppin/(ppin+ppel).gt.RANART(NSEED)) then
    /// Clin-10/08/00
    /// C
    ranpi = ranart(nseed);
    if ((pprr / ppin) >= ranpi) {
      /// C
      /// C     1) pi pi <-> rho rho:
      pi2ro2(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
      /// C
      /// Clin-4/03/02 eta equilibration:
    } else if ((pprr + ppee) / ppin >= ranpi) {
      /// C     4) pi pi <-> eta eta:
      pi2et2(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe) / ppin) >= ranpi) {
      /// C     5) pi pi <-> pi eta:
      pi3eta(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe + rpre) / ppin) >= ranpi) {
      /// C     6) rho pi <-> pi eta:
      rpiret(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe + rpre + xopoe) / ppin) >= ranpi) {
      /// C     7) omega pi <-> omega eta:
      opioet(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
    } else if (((pprr + ppee + pppe + rpre + xopoe + rree) / ppin) >= ranpi) {
      /// C     8) rho rho <-> eta eta:
      ro2et2(cmn, i1, i2, lbb1, lbb2, ei1, ei2, iblock, iseed);
      /// Clin-4/03/02-end
      /// C
      /// C     2) BBbar production:
    } else if (((pprr + ppee + pppe + rpre + xopoe + rree + cmn.ppinnb) /
                ppin) >= ranpi) {
      /// C
      bbarfs(cmn, lbb1, lbb2, ei1, ei2, iblock, iseed);
      /// C     3) KKbar production:
    } else {
      iblock = 66;
      ei1 = aka;
      ei2 = aka;
      lbb1 = 21;
      lbb2 = 23;
      /// Clin-11/07/00 pi rho -> K* Kbar and K*bar K productions:
      lb1 = lb(i1);
      lb2 = lb(i2);
      /// Clin-2/13/03 include omega the same as rho, eta the same as pi:
      /// C        if(((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.25.and.lb2.le.27))
      /// C     1  .or.((lb2.ge.3.and.lb2.le.5).and.(lb1.ge.25.and.lb1.le.27)))
      if (((lb1 == 0 || (lb1 >= 3 && lb1 <= 5)) && (lb2 >= 25 && lb2 <= 28)) ||
          ((lb2 == 0 || (lb2 >= 3 && lb2 <= 5)) && (lb1 >= 25 && lb1 <= 28))) {
        ei1 = aks;
        ei2 = aka;
        if (ranart(nseed) >= 0.5f) {
          iblock = 366;
          lbb1 = 30;
          lbb2 = 21;
        } else {
          iblock = 367;
          lbb1 = -30;
          lbb2 = 23;
        }
      }
      /// Clin-11/07/00-end
    }
    /// Clin-ppbar-8/25/00
    e(i1) = ei1;
    e(i2) = ei2;
    lb(i1) = lbb1;
    lb(i2) = lbb2;
    /// Clin-10/08/00-end
    /// C
  } else {
    /// Cbzdbg10/15/99
    /// C.....for meson+meson elastic srt.le.2Mk, if not pi+pi collision return
    if ((lb(i1) < 3 || lb(i1) > 5) && (lb(i2) < 3 || lb(i2) > 5)) {
      return;
    }
    /// Cbzdbg10/15/99 end
    /// C
    /// C check Meson+Meson elastic collisions
    iblock = 6;
    /// C direct process
    if (ipp == 1 || ipp == 4 || ipp == 6) {
      goto statement_10;
    }
    if (spprho / ppel > ranart(nseed)) {
      goto statement_20;
    }
  }
statement_10:
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  /// C
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C for isotropic distribution no need to ROTATE THE MOMENTUM
  /// C
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
  /// C
  return;
statement_20:
  iblock = 666;
  /// C treat rho formation in pion+pion collisions
  /// C calculate the mass and momentum of rho in the nucleus-nucleus frame
  rhores(cmn, i1, i2);
  if (ipp == 2) {
    lb(i1) = 27;
  }
  if (ipp == 3) {
    lb(i1) = 26;
  }
  if (ipp == 5) {
    lb(i1) = 25;
  }
}

struct denom_save {
  float a1;
  float am0;
  float amax;
  float amin;
  float amn;
  float amp;
  float avpi;
  float dm;
  float dmass;
  float f;
  int i;
  int nmax;
  float p0;
  float p1;
  float q;
  float q2;
  float s;
  float sum;
  float tq;

  denom_save()
      : a1(fem::float0),
        am0(fem::float0),
        amax(fem::float0),
        amin(fem::float0),
        amn(fem::float0),
        amp(fem::float0),
        avpi(fem::float0),
        dm(fem::float0),
        dmass(fem::float0),
        f(fem::float0),
        i(fem::int0),
        nmax(fem::int0),
        p0(fem::float0),
        p1(fem::float0),
        q(fem::float0),
        q2(fem::float0),
        s(fem::float0),
        sum(fem::float0),
        tq(fem::float0) {}
};

/// C
/// C****************************
float denom(common& cmn, float const& srt, float const& con) {
  float return_value = fem::float0;
  FEM_CMN_SVE(denom);
  /// SAVE
  float& a1 = sve.a1;
  float& am0 = sve.am0;
  float& amax = sve.amax;
  float& amin = sve.amin;
  float& amn = sve.amn;
  float& amp = sve.amp;
  float& avpi = sve.avpi;
  float& dm = sve.dm;
  float& dmass = sve.dmass;
  float& f = sve.f;
  int& i = sve.i;
  int& nmax = sve.nmax;
  float& p0 = sve.p0;
  float& p1 = sve.p1;
  float& q = sve.q;
  float& q2 = sve.q2;
  float& s = sve.s;
  float& sum = sve.sum;
  float& tq = sve.tq;
  ///
  /// C NOTE: CON=1 FOR DELTA RESONANCE, CON=2 FOR N*(1440) RESONANCE
  /// C       con=-1 for N*(1535)
  /// C PURPOSE : CALCULATE THE INTEGRAL IN THE DETAILED BALANCE
  /// C
  /// C DATE : NOV. 15, 1991
  /// C******************************
  const float ap1 = 0.13496f;
  const float ap2 = 0.13957f;
  avpi = (ap1 + 2.f * ap2) / 3.f;
  am0 = 1.232f;
  const float avmass = 0.9383f;
  amn = avmass;
  amp = avpi;
  amax = srt - avmass;
  amin = avmass + avpi;
  nmax = 200;
  dmass = (amax - amin) / fem::ffloat(nmax);
  sum = 0.f;
  FEM_DO_SAFE(i, 1, nmax + 1) {
    dm = amin + fem::ffloat(i - 1) * dmass;
    if (con == 1.f) {
      q2 = fem::pow2(((fem::pow2(dm) - fem::pow2(amn) + fem::pow2(amp)) /
                      (2.f * dm))) -
           fem::pow2(amp);
      if (q2 > 0.f) {
        q = fem::sqrt(q2);
      } else {
        q = 1.e-06f;
      }
      tq = 0.47f * (fem::pow3(q)) /
           (fem::pow2(amp) * (1.f + 0.6f * fem::pow2((q / amp))));
    } else if (con == 2) {
      tq = 0.2f;
      am0 = 1.44f;
    } else if (con == -1.f) {
      tq = 0.1f;
      am0 = 1.535f;
    }
    a1 = 4.f * tq * fem::pow2(am0) /
         (fem::pow2(am0) * fem::pow2(tq) +
          fem::pow2((fem::pow2(dm) - fem::pow2(am0))));
    s = fem::pow2(srt);
    p0 = fem::pow2((s + fem::pow2(dm) - fem::pow2(amn))) / (4.f * s) -
         fem::pow2(dm);
    if (p0 <= 0.f) {
      p1 = 1.e-06f;
    } else {
      p1 = fem::sqrt(p0);
    }
    f = dm * a1 * p1;
    if ((i == 1) || (i == (nmax + 1))) {
      sum += f * 0.5f;
    } else {
      sum += f;
    }
  }
  const float pi = 3.1415926f;
  return_value = sum * dmass / (2.f * pi);
  return return_value;
}

struct m1535_save {
  float s0;
  float sigma;

  m1535_save() : s0(fem::float0), sigma(fem::float0) {}
};

/// C
/// C************************
/// C cross section for N*(1535) production in ND OR NN* collisions
/// C VARIABLES:
/// C LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
/// C SRT IS THE CMS ENERGY
/// C X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
/// C NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA
/// C PRODUCTION CROSS SECTION
/// C DATE: MAY 18, 1994
/// C ***********************
void m1535(common& cmn, int const& lb1, int const& lb2, float const& srt,
           float& x1535) {
  FEM_CMN_SVE(m1535);
  /// SAVE
  float& s0 = sve.s0;
  float& sigma = sve.sigma;
  ///
  s0 = 2.424f;
  x1535 = 0.f;
  if (srt <= s0) {
    return;
  }
  sigma = 2.f * 0.102f * (srt - s0) / (0.058f + fem::pow2((srt - s0)));
  /// C I N*(1535) PRODUCTION IN NUCLEON-DELTA COLLISIONS
  /// C(1) nD(++)->pN*(+)(1535), pD(-)->nN*(0)(1535),pD(+)-->N*(+)p
  /// Cbz11/25/98
  /// C       IF((LB1*LB2.EQ.18).OR.(LB1*LB2.EQ.6).
  /// C     1  or.(lb1*lb2).eq.8)then
  if ((lb1 * lb2 == 18 && (lb1 == 2 || lb2 == 2)) ||
      (lb1 * lb2 == 6 && (lb1 == 1 || lb2 == 1)) ||
      (lb1 * lb2 == 8 && (lb1 == 1 || lb2 == 1))) {
    /// Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  /// C(2) pD(0)->pN*(0)(1535),pD(0)->nN*(+)(1535)
  if (lb1 * lb2 == 7) {
    x1535 = 3.f * sigma;
    return;
  }
  /// C II N*(1535) PRODUCTION IN N*(1440)+NUCLEON REACTIONS
  /// C(3) N*(+)(1440)p->N*(0+)(1535)p, N*(0)(1440)n->N*(0)(1535)
  /// Cbz11/25/98
  /// C       IF((LB1*LB2.EQ.11).OR.(LB1*LB2.EQ.20))THEN
  if ((lb1 * lb2 == 11) || (lb1 * lb2 == 20 && (lb1 == 2 || lb2 == 2))) {
    /// Cbz11/25/98end
    x1535 = sigma;
    return;
  }
  /// C(4) N*(0)(1440)p->N*(0+) or N*(+)(1440)n->N*(0+)(1535)
  /// Cbz11/25/98
  /// C       IF((LB1*LB2.EQ.10).OR.(LB1*LB2.EQ.22))X1535=3.*SIGMA
  if ((lb1 * lb2 == 10 && (lb1 == 1 || lb2 == 1)) ||
      (lb1 * lb2 == 22 && (lb1 == 2 || lb2 == 2))) {
    x1535 = 3.f * sigma;
  }
  /// Cbz11/25/98end
}

struct crnd_save {
  static const int npdmax = 10000;

  float a;
  float am1;
  float am2;
  float as;
  float c1;
  float c2;
  float cc1;
  float ct1;
  float ct2;
  float deltam;
  float dm;
  float dm3;
  float dm4;
  float dmax;
  float dmin;
  float dprob1;
  float e1cm;
  float e1dcm;
  float e2cm;
  float e2picm;
  float epcm;
  float eti1;
  float eti2;
  float fm;
  int ianti;
  int ic;
  int icou1;
  int id1;
  int idloop;
  int ipertd;
  int lbd;
  int lbi1;
  int lbi2;
  int lbm;
  arr<int> lbpd;
  int m12;
  int n12;
  int ndloop;
  int ntag;
  int ntry1;
  int ntry2;
  float p1beta;
  float p1dbeta;
  float p2beta;
  float p2pibeta;
  float pf2;
  float pfinal;
  float ppbeta;
  arr<float, 2> ppd;
  float ppx;
  float ppy;
  float ppz;
  float pr;
  float prf;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px3;
  float px4;
  float pxd;
  float pxi1;
  float pxi2;
  float py3;
  float py4;
  float pyd;
  float pyi1;
  float pyi2;
  float pz2;
  float pz3;
  float pz4;
  float pzd;
  float pzi1;
  float pzi2;
  float renom;
  float renom1;
  float renomn;
  float s1;
  float s2;
  float scheck;
  float sdprod;
  float sigdn;
  float signd;
  float ss;
  float st1;
  float st2;
  float t1;
  float t2;
  float ta;
  float transf;
  float x;
  float x1;
  float x1440;
  float x1535;
  float xdmass;
  float xmass;
  float xmm;
  float xptr;

  crnd_save()
      : a(fem::float0),
        am1(fem::float0),
        am2(fem::float0),
        as(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        deltam(fem::float0),
        dm(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        dprob1(fem::float0),
        e1cm(fem::float0),
        e1dcm(fem::float0),
        e2cm(fem::float0),
        e2picm(fem::float0),
        epcm(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fm(fem::float0),
        ianti(fem::int0),
        ic(fem::int0),
        icou1(fem::int0),
        id1(fem::int0),
        idloop(fem::int0),
        ipertd(fem::int0),
        lbd(fem::int0),
        lbi1(fem::int0),
        lbi2(fem::int0),
        lbm(fem::int0),
        lbpd(dimension(npdmax), fem::fill0),
        m12(fem::int0),
        n12(fem::int0),
        ndloop(fem::int0),
        ntag(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        p1beta(fem::float0),
        p1dbeta(fem::float0),
        p2beta(fem::float0),
        p2pibeta(fem::float0),
        pf2(fem::float0),
        pfinal(fem::float0),
        ppbeta(fem::float0),
        ppd(dimension(3, npdmax), fem::fill0),
        ppx(fem::float0),
        ppy(fem::float0),
        ppz(fem::float0),
        pr(fem::float0),
        prf(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px3(fem::float0),
        px4(fem::float0),
        pxd(fem::float0),
        pxi1(fem::float0),
        pxi2(fem::float0),
        py3(fem::float0),
        py4(fem::float0),
        pyd(fem::float0),
        pyi1(fem::float0),
        pyi2(fem::float0),
        pz2(fem::float0),
        pz3(fem::float0),
        pz4(fem::float0),
        pzd(fem::float0),
        pzi1(fem::float0),
        pzi2(fem::float0),
        renom(fem::float0),
        renom1(fem::float0),
        renomn(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        scheck(fem::float0),
        sdprod(fem::float0),
        sigdn(fem::float0),
        signd(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t2(fem::float0),
        ta(fem::float0),
        transf(fem::float0),
        x(fem::float0),
        x1(fem::float0),
        x1440(fem::float0),
        x1535(fem::float0),
        xdmass(fem::float0),
        xmass(fem::float0),
        xmm(fem::float0),
        xptr(fem::float0) {}
};

const int crnd_save::npdmax;

/// C*********************************
/// C                                                                      *
void crnd(common& cmn, int const& irun, float& px, float& py, float& pz,
          float const& srt, int const& i1, int const& i2, int& iblock,
          float const& signn, float const& sig, float const& sigk,
          float const& xsk1, float const& xsk2, float const& xsk3,
          float const& xsk4, float const& xsk5, int const& nt,
          int const& ipert1) {
  FEM_CMN_SVE(crnd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nnn = cmn.nnn;
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& iseed = cmn.iseed;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  ///
  float& a = sve.a;
  float& as = sve.as;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& deltam = sve.deltam;
  float& dm = sve.dm;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& dprob1 = sve.dprob1;
  float& e1cm = sve.e1cm;
  float& e1dcm = sve.e1dcm;
  float& e2cm = sve.e2cm;
  float& e2picm = sve.e2picm;
  float& epcm = sve.epcm;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fm = sve.fm;
  int& ianti = sve.ianti;
  int& ic = sve.ic;
  int& icou1 = sve.icou1;
  int& id1 = sve.id1;
  int& idloop = sve.idloop;
  int& ipertd = sve.ipertd;
  int& lbd = sve.lbd;
  int& lbi1 = sve.lbi1;
  int& lbi2 = sve.lbi2;
  int& lbm = sve.lbm;
  const int npdmax = 10000;
  arr_ref<int> lbpd(sve.lbpd, dimension(npdmax));
  int& m12 = sve.m12;
  int& ndloop = sve.ndloop;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& p1beta = sve.p1beta;
  float& p1dbeta = sve.p1dbeta;
  float& p2beta = sve.p2beta;
  float& p2pibeta = sve.p2pibeta;
  float& pf2 = sve.pf2;
  float& pfinal = sve.pfinal;
  float& ppbeta = sve.ppbeta;
  arr_ref<float, 2> ppd(sve.ppd, dimension(3, npdmax));
  float& ppx = sve.ppx;
  float& ppy = sve.ppy;
  float& ppz = sve.ppz;
  float& pr = sve.pr;
  float& prf = sve.prf;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px3 = sve.px3;
  float& px4 = sve.px4;
  float& pxd = sve.pxd;
  float& pxi1 = sve.pxi1;
  float& pxi2 = sve.pxi2;
  float& py3 = sve.py3;
  float& py4 = sve.py4;
  float& pyd = sve.pyd;
  float& pyi1 = sve.pyi1;
  float& pyi2 = sve.pyi2;
  float& pz2 = sve.pz2;
  float& pz3 = sve.pz3;
  float& pz4 = sve.pz4;
  float& pzd = sve.pzd;
  float& pzi1 = sve.pzi1;
  float& pzi2 = sve.pzi2;
  float& renom = sve.renom;
  float& renom1 = sve.renom1;
  float& renomn = sve.renomn;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& scheck = sve.scheck;
  float& sdprod = sve.sdprod;
  float& sigdn = sve.sigdn;
  float& signd = sve.signd;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t2 = sve.t2;
  float& ta = sve.ta;
  float& transf = sve.transf;
  float& x = sve.x;
  float& x1 = sve.x1;
  float& x1440 = sve.x1440;
  float& x1535 = sve.x1535;
  float& xdmass = sve.xdmass;
  float& xmass = sve.xmass;
  float& xmm = sve.xmm;
  float& xptr = sve.xptr;
  const float pi = 3.1415926f;
  const float avmass = 0.9383f;
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  const float aka = 0.498f;
  const float xmd = 1.8756f;
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH NUCLEON-BARYON RESONANCE COLLISIONS         *
  /// C     NOTE   :                                                         *
  /// C           VALID ONLY FOR BARYON-BARYON-DISTANCES LESS THAN 1.32 FM   *
  /// C           (1.32 = 2 * HARD-CORE-RADIUS [HRC] )                       *
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  /// C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      0-> COLLISION CANNOT HAPPEN                     *
  /// C                      1-> N-N ELASTIC COLLISION                       *
  /// C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  /// C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  /// C                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
  /// C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  /// C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  /// C                      N12,                                            *
  /// C                      M12=1 FOR p+n-->delta(+)+ n                     *
  /// C                          2     p+n-->delta(0)+ p                     *
  /// C                          3     p+p-->delta(++)+n                     *
  /// C                          4     p+p-->delta(+)+p                      *
  /// C                          5     n+n-->delta(0)+n                      *
  /// C                          6     n+n-->delta(-)+p                      *
  /// C                          7     n+p-->N*(0)(1440)+p                   *
  /// C                          8     n+p-->N*(+)(1440)+n                   *
  /// C                        9     p+p-->N*(+)(1535)+p                     *
  /// C                        10    n+n-->N*(0)(1535)+n                     *
  /// C                         11    n+p-->N*(+)(1535)+n                     *
  /// C                        12    n+p-->N*(0)(1535)+p
  /// C                        13    D(++)+D(-)-->N*(+)(1440)+n
  /// C                         14    D(++)+D(-)-->N*(0)(1440)+p
  /// C                        15    D(+)+D(0)--->N*(+)(1440)+n
  /// C                        16    D(+)+D(0)--->N*(0)(1440)+p
  /// C                        17    D(++)+D(0)-->N*(+)(1535)+p
  /// C                        18    D(++)+D(-)-->N*(0)(1535)+p
  /// C                        19    D(++)+D(-)-->N*(+)(1535)+n
  /// C                        20    D(+)+D(+)-->N*(+)(1535)+p
  /// C                        21    D(+)+D(0)-->N*(+)(1535)+n
  /// C                        22    D(+)+D(0)-->N*(0)(1535)+p
  /// C                        23    D(+)+D(-)-->N*(0)(1535)+n
  /// C                        24    D(0)+D(0)-->N*(0)(1535)+n
  /// C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  /// C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  /// C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  /// C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  /// C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  /// C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  /// C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  /// C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  /// C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  /// C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  /// C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  /// C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  /// C                        ++    see the note book for more listing
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /RNDF77/
  /// C-----------------------------------------------------------------------
  sve.n12 = 0;
  m12 = 0;
  iblock = 0;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  c2 = pz / pr;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 && lb(i2) < 0) {
    ianti = 1;
  }
  /// C
  /// Clin-6/2008 Production of perturbative deuterons for idpert=1:
  sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
  if (idpert == 1 && ipert1 == 1) {
    if (srt < 2.012f) {
      return;
    }
    if ((fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i1)) == 2) &&
        (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
      goto statement_108;
    } else if ((fem::iabs(lb(i2)) == 1 || fem::iabs(lb(i2)) == 2) &&
               (fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13)) {
      goto statement_108;
    } else {
      return;
    }
  }
  /// C-----------------------------------------------------------------------
  /// CCOM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
  /// C      N-DELTA OR N*-N* or N*-Delta)
  if (x1 <= signn / sig) {
    /// CCOM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
    as = fem::pow((3.65f * (srt - 1.8766f)), 6);
    a = 6.0f * as / (1.0f + as);
    ta = -2.0f * fem::pow2(pr);
    x = ranart(nseed);
    /// Clin-10/24/02        T1  = ALOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /
    /// A
    t1 = fem::sngl(fem::dlog(fem::dble(1.f - x) *
                                 fem::dexp(fem::dble(a) * fem::dble(ta)) +
                             fem::dble(x))) /
         a;
    c1 = 1.0f - t1 / ta;
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 1;
    goto statement_107;
  } else {
    /// CCOM: TEST FOR INELASTIC SCATTERING
    /// C     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
    /// C     CAN HAPPEN ANY MORE ==> RETURN (2.04 = 2*AVMASS + PI-MASS+0.02)
    if (srt < 2.04f) {
      return;
    }
    /// Clin-6/2008 add d+meson production for n*N*(0)(1440) and p*N*(+)(1440)
    /// channels C     (they did not have any inelastic reactions before):
    if (((fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2) &&
         (lb(i1) * lb(i2)) == 20) ||
        (lb(i1) * lb(i2)) == 13) {
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
    }
    /// C
    /// C Resonance absorption or Delta + N-->N*(1440), N*(1535)
    /// C COM: TEST FOR DELTA OR N* ABSORPTION
    /// C      IN THE PROCESS DELTA+N-->NN, N*+N-->NN
    prf = fem::sqrt(0.25f * fem::pow2(srt) - fem::pow2(avmass));
    if (em1 > 1.f) {
      deltam = em1;
    } else {
      deltam = em2;
    }
    renom = deltam * fem::pow2(prf) / denom(cmn, srt, 1.f) / pr;
    renomn = deltam * fem::pow2(prf) / denom(cmn, srt, 2.f) / pr;
    renom1 = deltam * fem::pow2(prf) / denom(cmn, srt, -1.f) / pr;
    /// C avoid the inelastic collisions between n+delta- -->N+N
    /// C       and p+delta++ -->N+N due to charge conservation,
    /// C       but they can scatter to produce kaons
    if ((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) {
      renom = 0.f;
    }
    if ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) {
      renom = 0.f;
    }
    if ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) {
      renom = 0.f;
    }
    if ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9)) {
      renom = 0.f;
    }
    m1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
    x1440 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    /// C CROSS SECTION FOR KAON PRODUCTION from the four channels
    /// C for NLK channel
    /// C avoid the inelastic collisions between n+delta- -->N+N
    /// C       and p+delta++ -->N+N due to charge conservation,
    /// C       but they can scatter to produce kaons
    if (((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) ||
        ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) ||
        ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) ||
        ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9))) {
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C          IF((SIGK+SIGNN)/SIG.GE.X1)GO TO 306
      if ((sigk + signn + sdprod) / sig >= x1) {
        goto statement_306;
      }
      /// C
    }
    /// C WE DETERMINE THE REACTION CHANNELS IN THE FOLLOWING
    /// C FOR n+delta(++)-->p+p or n+delta(++)-->n+N*(+)(1440),n+N*(+)(1535)
    /// C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
    if (lb(i1) * lb(i2) == 18 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      /// C REABSORPTION:
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 3;
        goto statement_206;
      } else {
        /// C N* PRODUCTION
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          /// C N*(1440)
          m12 = 37;
        } else {
          /// C N*(1535)       M12=38
          /// Clin-2/26/03 why is the above commented out? leads to M12=0 but
          /// C     particle mass is changed after 204 (causes energy
          /// violation). C     replace by elastic process (return):
          return;
          /// C
        }
        goto statement_204;
      }
    }
    /// C FOR p+delta(-)-->n+n or p+delta(-)-->n+N*(0)(1440),n+N*(0)(1535)
    /// C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
    if (lb(i1) * lb(i2) == 6 &&
        ((fem::iabs(lb(i1)) == 1) || (fem::iabs(lb(i2)) == 1))) {
      signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF (X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      /// C REABSORPTION:
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 6;
        goto statement_206;
      } else {
        /// C N* PRODUCTION
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          /// C N*(1440)
          m12 = 47;
        } else {
          /// C N*(1535)       M12=48
          /// Clin-2/26/03 causes energy violation, replace by elastic process
          /// (return):
          return;
          /// C
        }
        goto statement_204;
      }
    }
    /// C FOR p+delta(+)-->p+p, N*(+)(144)+p, N*(+)(1535)+p
    if (lb(i1) * lb(i2) == 8 &&
        (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
      signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 4;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          /// C N*(144)
          m12 = 39;
        } else {
          m12 = 40;
        }
        goto statement_204;
      }
    }
    /// C FOR n+delta(0)-->n+n, N*(0)(144)+n, N*(0)(1535)+n
    if (lb(i1) * lb(i2) == 14 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
      sigdn = 0.25f * signd * renom;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1440 + x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + x1440 + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1440 + x1535)) {
        m12 = 5;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          /// C N*(144)
          m12 = 48;
        } else {
          m12 = 49;
        }
        goto statement_204;
      }
    }
    /// C FOR n+delta(+)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
    /// C                       N*(+)(1535)+n,N*(0)(1535)+p
    if (lb(i1) * lb(i2) == 16 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd =
          0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
      sigdn = 0.5f * signd * renom;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK)/SIG)RETURN
      if (x1 >
          (signn + sigdn + 2.f * x1440 + 2.f * x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + 2 * x1440 + 2 * x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + 2.f * x1440 + 2.f * x1535)) {
        m12 = 1;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          m12 = 41;
          if (ranart(nseed) <= 0.5f) {
            m12 = 43;
          }
        } else {
          m12 = 42;
          if (ranart(nseed) <= 0.5f) {
            m12 = 44;
          }
        }
        goto statement_204;
      }
    }
    /// C FOR p+delta(0)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
    /// C                       N*(+)(1535)+n,N*(0)(1535)+p
    if (lb(i1) * lb(i2) == 7) {
      signd =
          0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
      sigdn = 0.5f * signd * renom;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK)/SIG)RETURN
      if (x1 >
          (signn + sigdn + 2.f * x1440 + 2.f * x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + 2 * x1440 + 2 * x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + 2.f * x1440 + 2.f * x1535)) {
        m12 = 2;
        goto statement_206;
      } else {
        if (ranart(nseed) < x1440 / (x1440 + x1535)) {
          m12 = 50;
          if (ranart(nseed) <= 0.5f) {
            m12 = 51;
          }
        } else {
          m12 = 52;
          if (ranart(nseed) <= 0.5f) {
            m12 = 53;
          }
        }
        goto statement_204;
      }
    }
    /// C FOR p+N*(0)(14)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
    /// C OR  P+N*(0)(14)-->D(+)+N, D(0)+P,
    if (lb(i1) * lb(i2) == 10 &&
        (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
      signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      sigdn = signd * renomn;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1535)) {
        m12 = 7;
        goto statement_206;
      } else {
        m12 = 54;
        if (ranart(nseed) <= 0.5f) {
          m12 = 55;
        }
      }
      goto statement_204;
    }
    /// C FOR n+N*(+)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
    if (lb(i1) * lb(i2) == 22 &&
        (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
      signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      sigdn = signd * renomn;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + x1535 + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn + x1535) > ranart(nseed)) {
        goto statement_306;
      }
      if (ranart(nseed) < sigdn / (sigdn + x1535)) {
        m12 = 8;
        goto statement_206;
      } else {
        m12 = 56;
        if (ranart(nseed) <= 0.5f) {
          m12 = 57;
        }
      }
      goto statement_204;
    }
    /// C FOR N*(1535)+N-->N+N COLLISIONS
    if ((fem::iabs(lb(i1)) == 12) || (fem::iabs(lb(i1)) == 13) ||
        (fem::iabs(lb(i2)) == 12) || (fem::iabs(lb(i2)) == 13)) {
      signd = x1535;
      sigdn = signd * renom1;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGDN+SIGK)/SIG)RETURN
      if (x1 > (signn + sigdn + sigk + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (sigk + sigdn) > ranart(nseed)) {
        goto statement_306;
      }
      if (lb(i1) * lb(i2) == 24) {
        m12 = 10;
      }
      if (lb(i1) * lb(i2) == 12) {
        m12 = 12;
      }
      if (lb(i1) * lb(i2) == 26) {
        m12 = 11;
      }
      if (lb(i1) * lb(i2) == 13) {
        m12 = 9;
      }
      goto statement_206;
    }
  statement_204:
    /// C (1) GENERATE THE MASS FOR THE N*(1440) AND N*(1535)
    /// C (2) CALCULATE THE FINAL MOMENTUM OF THE n+N* SYSTEM
    /// C (3) RELABLE THE FINAL STATE PARTICLES
    /// CPARAMETRIZATION OF THE SHAPE OF THE N* RESONANCE ACCORDING
    /// C     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
    /// C     FORMULA FOR N* RESORANCE
    /// C     DETERMINE DELTA MASS VIA REJECTION METHOD.
    dmax = srt - avmass - 0.005f;
    dmin = 1.078f;
    if ((m12 == 37) || (m12 == 39) || (m12 == 41) || (m12 == 43) ||
        (m12 == 46) || (m12 == 48) || (m12 == 50) || (m12 == 51)) {
      /// C N*(1440) production
      if (dmax < 1.44f) {
        fm = fns(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.44f;
        /// C          FM=FNS(1.44,SRT,1.)
        fm = fns(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry2 = 0;
    statement_11:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry2++;
      if ((ranart(nseed) > fns(cmn, dm, srt, 1.f) / fm) && (ntry2 <= 10)) {
        goto statement_11;
      }
      /// C
      /// Clin-2/26/03 limit the N* mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 2.14f) {
        goto statement_11;
      }
      /// C
      goto statement_13;
    } else {
      /// C N*(1535) production
      if (dmax < 1.535f) {
        fm = fd5(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.535f;
        /// C          FM=FD5(1.535,SRT,1.)
        fm = fd5(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_12:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fd5(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 10)) {
        goto statement_12;
      }
      /// C
      /// Clin-2/26/03 limit the N* mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.84f) {
        goto statement_12;
      }
      /// C
    }
  statement_13:
    /// C (2) DETERMINE THE FINAL MOMENTUM
    prf = 0.f;
    pf2 = fem::pow2(((fem::pow2(srt) - fem::pow2(dm) + fem::pow2(avmass)) /
                     (2.f * srt))) -
          fem::pow2(avmass);
    if (pf2 > 0.f) {
      prf = fem::sqrt(pf2);
    }
    /// C (3) RELABLE FINAL STATE PARTICLES
    /// C 37 D(++)+n-->N*(+)(14)+p
    if (m12 == 37) {
      if (fem::iabs(lb(i1)) == 9) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 38 D(++)+n-->N*(+)(15)+p
    if (m12 == 38) {
      if (fem::iabs(lb(i1)) == 9) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 39 D(+)+P-->N*(+)(14)+p
    if (m12 == 39) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 40 D(+)+P-->N*(+)(15)+p
    if (m12 == 40) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 41 D(+)+N-->N*(+)(14)+N
    if (m12 == 41) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 42 D(+)+N-->N*(+)(15)+N
    if (m12 == 42) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 43 D(+)+N-->N*(0)(14)+P
    if (m12 == 43) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 44 D(+)+N-->N*(0)(15)+P
    if (m12 == 44) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 46 D(-)+P-->N*(0)(14)+N
    if (m12 == 46) {
      if (fem::iabs(lb(i1)) == 6) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 47 D(-)+P-->N*(0)(15)+N
    if (m12 == 47) {
      if (fem::iabs(lb(i1)) == 6) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 48 D(0)+N-->N*(0)(14)+N
    if (m12 == 48) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 49 D(0)+N-->N*(0)(15)+N
    if (m12 == 49) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 50 D(0)+P-->N*(0)(14)+P
    if (m12 == 50) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 10;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 10;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 51 D(0)+P-->N*(+)(14)+N
    if (m12 == 51) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 11;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 11;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 52 D(0)+P-->N*(0)(15)+P
    if (m12 == 52) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 53 D(0)+P-->N*(+)(15)+N
    if (m12 == 53) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 54 N*(0)(14)+P-->N*(+)(15)+N
    if (m12 == 54) {
      if (fem::iabs(lb(i1)) == 10) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 55 N*(0)(14)+P-->N*(0)(15)+P
    if (m12 == 55) {
      if (fem::iabs(lb(i1)) == 10) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 56 N*(+)(14)+N-->N*(+)(15)+N
    if (m12 == 56) {
      if (fem::iabs(lb(i1)) == 11) {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 13;
        e(i2) = dm;
      } else {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 13;
        e(i1) = dm;
      }
      goto statement_207;
    }
    /// C 57 N*(+)(14)+N-->N*(0)(15)+P
    if (m12 == 57) {
      if (fem::iabs(lb(i1)) == 11) {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 12;
        e(i2) = dm;
      } else {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 12;
        e(i1) = dm;
      }
    }
    goto statement_207;
  /// C------------------------------------------------
  /// C RELABLE NUCLEONS AFTER DELTA OR N* BEING ABSORBED
  /// C(1) n+delta(+)-->n+p
  statement_206:
    if (m12 == 1) {
      if (fem::iabs(lb(i1)) == 8) {
        lb(i2) = 2;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 2;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_207;
    }
    /// C(2) p+delta(0)-->p+n
    if (m12 == 2) {
      if (fem::iabs(lb(i1)) == 7) {
        lb(i2) = 1;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_207;
    }
    /// C(3) n+delta(++)-->p+p
    if (m12 == 3) {
      lb(i1) = 1;
      lb(i2) = 1;
      e(i1) = amp;
      e(i2) = amp;
      goto statement_207;
    }
    /// C(4) p+delta(+)-->p+p
    if (m12 == 4) {
      lb(i1) = 1;
      lb(i2) = 1;
      e(i1) = amp;
      e(i2) = amp;
      goto statement_207;
    }
    /// C(5) n+delta(0)-->n+n
    if (m12 == 5) {
      lb(i1) = 2;
      lb(i2) = 2;
      e(i1) = amn;
      e(i2) = amn;
      goto statement_207;
    }
    /// C(6) p+delta(-)-->n+n
    if (m12 == 6) {
      lb(i1) = 2;
      lb(i2) = 2;
      e(i1) = amn;
      e(i2) = amn;
      goto statement_207;
    }
    /// C(7) p+N*(0)-->n+p
    if (m12 == 7) {
      if (fem::iabs(lb(i1)) == 1) {
        lb(i1) = 1;
        lb(i2) = 2;
        e(i1) = amp;
        e(i2) = amn;
      } else {
        lb(i1) = 2;
        lb(i2) = 1;
        e(i1) = amn;
        e(i2) = amp;
      }
      goto statement_207;
    }
    /// C(8) n+N*(+)-->n+p
    if (m12 == 8) {
      if (fem::iabs(lb(i1)) == 2) {
        lb(i1) = 2;
        lb(i2) = 1;
        e(i1) = amn;
        e(i2) = amp;
      } else {
        lb(i1) = 1;
        lb(i2) = 2;
        e(i1) = amp;
        e(i2) = amn;
      }
      goto statement_207;
    }
    /// Clin-6/2008
    /// C*(9) N*(+)p-->pp
    /// C(9) N*(+)(1535) p-->pp
    if (m12 == 9) {
      lb(i1) = 1;
      lb(i2) = 1;
      e(i1) = amp;
      e(i2) = amp;
      goto statement_207;
    }
    /// C(12) N*(0)P-->nP
    if (m12 == 12) {
      lb(i1) = 2;
      lb(i2) = 1;
      e(i1) = amn;
      e(i2) = amp;
      goto statement_207;
    }
    /// C(11) N*(+)n-->nP
    if (m12 == 11) {
      lb(i1) = 2;
      lb(i2) = 1;
      e(i1) = amn;
      e(i2) = amp;
      goto statement_207;
    }
    /// Clin-6/2008
    /// C*(12) N*(0)p-->Np
    /// C(12) N*(0)(1535) p-->Np
    if (m12 == 12) {
      lb(i1) = 1;
      lb(i2) = 2;
      e(i1) = amp;
      e(i2) = amn;
    }
  /// C----------------------------------------------
  statement_207:
    pr = prf;
    c1 = 1.0f - 2.0f * ranart(nseed);
    if (srt <= 2.14f) {
      c1 = 1.0f - 2.0f * ranart(nseed);
    }
    if (srt > 2.14f && srt <= 2.4f) {
      c1 = ang(cmn, srt, iseed);
    }
    if (srt > 2.4f) {
      /// C
      /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
      xptr = 0.33f * pr;
      /// C         cc1=ptr(0.33*pr,iseed)
      cc1 = ptr(cmn, xptr, iseed);
      /// Clin-10/25/02-end
      /// C
      /// Clin-9/2012: check argument in sqrt():
      scheck = fem::pow2(pr) - fem::pow2(cc1);
      if (scheck < 0) {
        write(99, star), "scheck4: ", scheck;
        scheck = 0.f;
      }
      c1 = fem::sqrt(scheck) / pr;
      /// C         c1=sqrt(pr**2-cc1**2)/pr
      /// C
    }
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 3;
  }
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
  }
/// C
/// C-----------------------------------------------------------------------
/// CCOM: SET THE NEW MOMENTUM COORDINATES
statement_107:
  if (px == 0.0f && py == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py, px);
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c1);
  if (scheck < 0) {
    write(99, star), "scheck5: ", scheck;
    scheck = 0.f;
  }
  s1 = fem::sqrt(scheck);
  /// C      S1   = SQRT( 1.0 - C1**2 )
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck6: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  /// C      S2  =  SQRT( 1.0 - C2**2 )
  /// C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
  ss = c2 * s1 * ct1 + s2 * c1;
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
  return;
/// C FOR THE NN-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN
/// C THE NUCLEUS-NUCLEUS CMS.
statement_306:
  /// Csp11/21/01 phi production
  if (xsk5 / sigk > ranart(nseed)) {
    pz1 = p(3, i1);
    pz2 = p(3, i2);
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    nnn++;
    lpion(nnn, irun) = 29;
    epion(nnn, irun) = aphi;
    iblock = 222;
    goto statement_208;
  }
  /// Csp11/21/01 end
  iblock = 11;
  if (ianti == 1) {
    iblock = -11;
  }
  /// C
  pz1 = p(3, i1);
  pz2 = p(3, i2);
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  nnn++;
  lpion(nnn, irun) = 23;
  epion(nnn, irun) = aka;
  if (srt <= 2.63f) {
    /// C only lambda production is possible
    /// C (1.1)P+P-->p+L+kaon+
    ic = 1;
    /// C
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 14;
    goto statement_208;
  }
  if (srt <= 2.74f && srt > 2.63f) {
    /// C both Lambda and sigma production are possible
    if (xsk1 / (xsk1 + xsk2) > ranart(nseed)) {
      /// C lambda production
      ic = 1;
      /// C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
    } else {
      /// C sigma production
      /// C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      ic = 2;
    }
    goto statement_208;
  }
  if (srt <= 2.77f && srt > 2.74f) {
    /// C then pp-->Delta lamda kaon can happen
    if (xsk1 / (xsk1 + xsk2 + xsk3) > ranart(nseed)) {
      /// C * (1.1)P+P-->p+L+kaon+
      ic = 1;
      /// C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk2 / (xsk2 + xsk3) > ranart(nseed)) {
        /// C pp-->psk
        ic = 2;
        /// C
        lb(i1) = 1 + fem::fint(2 * ranart(nseed));
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        /// C
      } else {
        /// C pp-->D+l+k
        ic = 3;
        /// C
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
      }
      goto statement_208;
    }
  }
  if (srt > 2.77f) {
    /// C all four channels are possible
    if (xsk1 / (xsk1 + xsk2 + xsk3 + xsk4) > ranart(nseed)) {
      /// C p lambda k production
      ic = 1;
      /// C
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk3 / (xsk2 + xsk3 + xsk4) > ranart(nseed)) {
        /// C delta l K production
        ic = 3;
        /// C
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
        goto statement_208;
      } else {
        if (xsk2 / (xsk2 + xsk4) > ranart(nseed)) {
          /// C n sigma k production
          /// C
          lb(i1) = 1 + fem::fint(2 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          /// C
          ic = 2;
        } else {
          ic = 4;
          /// C
          lb(i1) = 6 + fem::fint(4 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          /// C
        }
        goto statement_208;
      }
    }
  }
statement_208:
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 23) {
      lpion(nnn, irun) = 21;
    }
  }
  lbi1 = lb(i1);
  lbi2 = lb(i2);
  /// C KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
  ntry1 = 0;
statement_128:
  bbkaon(cmn, ic, srt, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_128;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  /// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
  /// C NUCLEUS CMS. FRAME
  /// C (1) for the necleon/delta
  /// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  /// C (2) for the lambda/sigma
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  /// C GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(aka) + fem::pow2(ppx) + fem::pow2(ppy) +
                   fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008:
  /// C2008        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2008
  /// C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  /// C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  /// C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  /// C assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the
  /// C leadng particle behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lbi1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lbi2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  if (lpion(nnn, irun) != 29) {
    iblock = 11;
  }
  lb1 = lb(i1);
  lb2 = lb(i2);
  sve.am1 = em1;
  sve.am2 = em2;
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  return;
/// C
/// Clin-6/2008 N+D->Deuteron+pi:
/// C     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_108:
  if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
    /// C     For idpert=1: we produce npertd pert deuterons:
    ndloop = npertd;
  } else if (idpert == 2 && npertd >= 1) {
    /// C     For idpert=2: we first save information for npertd pert deuterons;
    /// C     at the last ndloop we create the regular deuteron+pi
    /// C     and those pert deuterons:
    ndloop = npertd + 1;
  } else {
    /// C     Just create the regular deuteron+pi:
    ndloop = 1;
  }
  /// C
  dprob1 = sdprod / sig / fem::ffloat(npertd);
  FEM_DO_SAFE(idloop, 1, ndloop) {
    bbdangle(cmn, pxd, pyd, pzd, nt, ipert1, ianti, idloop, pfinal, dprob1,
             lbm);
    rotate(cmn, px, py, pz, pxd, pyd, pzd);
    /// C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
    /// STATE C     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME: C     For
    /// the Deuteron:
    xmass = xmd;
    e1dcm = fem::sqrt(fem::pow2(xmass) + fem::pow2(pxd) + fem::pow2(pyd) +
                      fem::pow2(pzd));
    p1dbeta = pxd * betax + pyd * betay + pzd * betaz;
    transf = gamma * (gamma * p1dbeta / (gamma + 1.f) + e1dcm);
    pxi1 = betax * transf + pxd;
    pyi1 = betay * transf + pyd;
    pzi1 = betaz * transf + pzd;
    if (ianti == 0) {
      lbd = 42;
    } else {
      lbd = -42;
    }
    if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
      /// Cccc  Perturbative production for idpert=1:
      nnn++;
      ppion(1, nnn, irun) = pxi1;
      ppion(2, nnn, irun) = pyi1;
      ppion(3, nnn, irun) = pzi1;
      epion(nnn, irun) = xmd;
      lpion(nnn, irun) = lbd;
      rpion(1, nnn, irun) = r(1, i1);
      rpion(2, nnn, irun) = r(2, i1);
      rpion(3, nnn, irun) = r(3, i1);
      /// Clin-6/2008 assign the perturbative probability:
      dppion(nnn, irun) = sdprod / sig / fem::ffloat(npertd);
    } else if (idpert == 2 && idloop <= npertd) {
      /// Clin-6/2008 For idpert=2, we produce NPERTD perturbative
      /// (anti)deuterons C     only when a regular (anti)deuteron+pi is
      /// produced in NN collisions. C     First save the info for the
      /// perturbative deuterons:
      ppd(1, idloop) = pxi1;
      ppd(2, idloop) = pyi1;
      ppd(3, idloop) = pzi1;
      lbpd(idloop) = lbd;
    } else {
      /// Cccc  Regular production:
      /// C     For the regular pion: do LORENTZ-TRANSFORMATION:
      e(i1) = xmm;
      e2picm = fem::sqrt(fem::pow2(xmm) + fem::pow2(pxd) + fem::pow2(pyd) +
                         fem::pow2(pzd));
      p2pibeta = -pxd * betax - pyd * betay - pzd * betaz;
      transf = gamma * (gamma * p2pibeta / (gamma + 1.f) + e2picm);
      pxi2 = betax * transf - pxd;
      pyi2 = betay * transf - pyd;
      pzi2 = betaz * transf - pzd;
      p(1, i1) = pxi2;
      p(2, i1) = pyi2;
      p(3, i1) = pzi2;
      /// C     Remove regular pion to check the equivalence
      /// C     between the perturbative and regular deuteron results:
      /// C                 E(i1)=0.
      /// C
      lb(i1) = lbm;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      id(i1) = 2;
      id1 = id(i1);
      e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                     fem::pow2(pz1));
      lb1 = lb(i1);
      /// C     For the regular deuteron:
      p(1, i2) = pxi1;
      p(2, i2) = pyi1;
      p(3, i2) = pzi1;
      lb(i2) = lbd;
      lb2 = lb(i2);
      e(i2) = xmd;
      eti2 = e(i2);
      id(i2) = 2;
      /// C     For idpert=2: create the perturbative deuterons:
      if (idpert == 2 && idloop == ndloop) {
        FEM_DO_SAFE(ipertd, 1, npertd) {
          nnn++;
          ppion(1, nnn, irun) = ppd(1, ipertd);
          ppion(2, nnn, irun) = ppd(2, ipertd);
          ppion(3, nnn, irun) = ppd(3, ipertd);
          epion(nnn, irun) = xmd;
          lpion(nnn, irun) = lbpd(ipertd);
          rpion(1, nnn, irun) = r(1, i1);
          rpion(2, nnn, irun) = r(2, i1);
          rpion(3, nnn, irun) = r(3, i1);
          /// Clin-6/2008 assign the perturbative probability:
          dppion(nnn, irun) = 1.f / fem::ffloat(npertd);
        }
      }
    }
  }
  iblock = 501;
  /// Clin-6/2008 N+D->Deuteron+pi over
  /// C
}

struct reab2d_save {
  float ed1;
  float ed2;
  float factor;
  int lb1;
  int lb2;
  float pin2;
  float pout2;
  float xpro;

  reab2d_save()
      : ed1(fem::float0),
        ed2(fem::float0),
        factor(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pin2(fem::float0),
        pout2(fem::float0),
        xpro(fem::float0) {}
};

/// C*****************************************
/// C for the reabsorption of two resonances
/// C This function calculates the cross section for
/// C DD-->NN, N*N*-->NN and DN*-->NN
/// C      real*4 function reab2d(i1,i2,srt)
float reab2d(common& cmn, int const& i1, int const& i2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(reab2d);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& ed1 = sve.ed1;
  float& ed2 = sve.ed2;
  float& factor = sve.factor;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pin2 = sve.pin2;
  float& pout2 = sve.pout2;
  float& xpro = sve.xpro;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  reab   = cross section in mb
  /// C***************************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /EE/
  return_value = 0;
  lb1 = fem::iabs(lb(i1));
  lb2 = fem::iabs(lb(i2));
  ed1 = e(i1);
  ed2 = e(i2);
  const float amn = 0.938f;
  pin2 = fem::pow2((srt / 2.f)) - fem::pow2(amn);
  pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(ed1) - fem::pow2(ed2)) /
                     (2.f * srt))) -
          fem::pow2(ed1);
  if (pout2 <= 0) {
    return return_value;
  }
  xpro = x2pi(cmn, srt);
  factor = 1 / 4.f;
  if ((lb1 >= 10 && lb1 <= 13) && (lb2 >= 10 && lb2 <= 13)) {
    factor = 1.f;
  }
  if ((lb1 >= 6 && lb1 <= 9) && (lb2 > 10 && lb2 <= 13)) {
    factor = 1 / 2.f;
  }
  if ((lb2 >= 6 && lb2 <= 9) && (lb1 > 10 && lb1 <= 13)) {
    factor = 1 / 2.f;
  }
  return_value = factor * pin2 / pout2 * xpro;
  return return_value;
}

struct crdd_save {
  static const int npdmax = 10000;

  float a;
  float ada;
  float ak0;
  float akp;
  float al;
  float am1;
  float am2;
  float ana;
  float as;
  float c1;
  float c2;
  float cc1;
  float ct1;
  float ct2;
  float dm;
  float dm3;
  float dm4;
  float dmax;
  float dmin;
  float dprob1;
  float e1cm;
  float e1dcm;
  float e2cm;
  float e2picm;
  float epcm;
  float es;
  float eti1;
  float eti2;
  float fm;
  int ianti;
  int ic;
  int ich;
  int icou1;
  int id1;
  int idd;
  int idloop;
  int ipertd;
  int lbd;
  int lbi1;
  int lbi2;
  int lbm;
  arr<int> lbpd;
  int m12;
  int n12;
  int ndloop;
  int ntry1;
  int ntry2;
  float p1beta;
  float p1dbeta;
  float p2beta;
  float p2pibeta;
  float pfinal;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float ppbeta;
  arr<float, 2> ppd;
  float ppx;
  float ppy;
  float ppz;
  float pr;
  float pr2;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px3;
  float px4;
  float pxd;
  float pxi1;
  float pxi2;
  float py3;
  float py4;
  float pyd;
  float pyi1;
  float pyi2;
  float pz2;
  float pz3;
  float pz4;
  float pzd;
  float pzi1;
  float pzi2;
  float s1;
  float s2;
  float s2d;
  float scheck;
  float sdprod;
  float sig2;
  float sigk;
  float signd;
  float ss;
  float st1;
  float st2;
  float t1;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float ta;
  float transf;
  float x;
  float x1;
  float x1535;
  float xdmass;
  float xmass;
  float xmm;
  float xptr;
  float xsk1;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;

  crdd_save()
      : a(fem::float0),
        ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        am1(fem::float0),
        am2(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        ct2(fem::float0),
        dm(fem::float0),
        dm3(fem::float0),
        dm4(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        dprob1(fem::float0),
        e1cm(fem::float0),
        e1dcm(fem::float0),
        e2cm(fem::float0),
        e2picm(fem::float0),
        epcm(fem::float0),
        es(fem::float0),
        eti1(fem::float0),
        eti2(fem::float0),
        fm(fem::float0),
        ianti(fem::int0),
        ic(fem::int0),
        ich(fem::int0),
        icou1(fem::int0),
        id1(fem::int0),
        idd(fem::int0),
        idloop(fem::int0),
        ipertd(fem::int0),
        lbd(fem::int0),
        lbi1(fem::int0),
        lbi2(fem::int0),
        lbm(fem::int0),
        lbpd(dimension(npdmax), fem::fill0),
        m12(fem::int0),
        n12(fem::int0),
        ndloop(fem::int0),
        ntry1(fem::int0),
        ntry2(fem::int0),
        p1beta(fem::float0),
        p1dbeta(fem::float0),
        p2beta(fem::float0),
        p2pibeta(fem::float0),
        pfinal(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        ppbeta(fem::float0),
        ppd(dimension(3, npdmax), fem::fill0),
        ppx(fem::float0),
        ppy(fem::float0),
        ppz(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px3(fem::float0),
        px4(fem::float0),
        pxd(fem::float0),
        pxi1(fem::float0),
        pxi2(fem::float0),
        py3(fem::float0),
        py4(fem::float0),
        pyd(fem::float0),
        pyi1(fem::float0),
        pyi2(fem::float0),
        pz2(fem::float0),
        pz3(fem::float0),
        pz4(fem::float0),
        pzd(fem::float0),
        pzi1(fem::float0),
        pzi2(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        s2d(fem::float0),
        scheck(fem::float0),
        sdprod(fem::float0),
        sig2(fem::float0),
        sigk(fem::float0),
        signd(fem::float0),
        ss(fem::float0),
        st1(fem::float0),
        st2(fem::float0),
        t1(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        ta(fem::float0),
        transf(fem::float0),
        x(fem::float0),
        x1(fem::float0),
        x1535(fem::float0),
        xdmass(fem::float0),
        xmass(fem::float0),
        xmm(fem::float0),
        xptr(fem::float0),
        xsk1(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0) {}
};

const int crdd_save::npdmax;

/// C*********************************
/// C                                                                      *
void crdd(common& cmn, int const& irun, float& px, float& py, float& pz,
          float const& srt, int const& i1, int const& i2, int& iblock,
          int& ntag, float const& signn, float const& sig, int const& nt,
          int const& ipert1) {
  FEM_CMN_SVE(crdd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nnn = cmn.nnn;
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& iseed = cmn.iseed;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  int& idpert = cmn.idpert;
  int& npertd = cmn.npertd;
  ///
  float& a = sve.a;
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& ct2 = sve.ct2;
  float& dm = sve.dm;
  float& dm3 = sve.dm3;
  float& dm4 = sve.dm4;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& dprob1 = sve.dprob1;
  float& e1cm = sve.e1cm;
  float& e1dcm = sve.e1dcm;
  float& e2cm = sve.e2cm;
  float& e2picm = sve.e2picm;
  float& epcm = sve.epcm;
  float& es = sve.es;
  float& eti1 = sve.eti1;
  float& eti2 = sve.eti2;
  float& fm = sve.fm;
  int& ianti = sve.ianti;
  int& ic = sve.ic;
  int& ich = sve.ich;
  int& icou1 = sve.icou1;
  int& id1 = sve.id1;
  int& idd = sve.idd;
  int& idloop = sve.idloop;
  int& ipertd = sve.ipertd;
  int& lbd = sve.lbd;
  int& lbi1 = sve.lbi1;
  int& lbi2 = sve.lbi2;
  int& lbm = sve.lbm;
  const int npdmax = 10000;
  arr_ref<int> lbpd(sve.lbpd, dimension(npdmax));
  int& n12 = sve.n12;
  int& ndloop = sve.ndloop;
  int& ntry1 = sve.ntry1;
  int& ntry2 = sve.ntry2;
  float& p1beta = sve.p1beta;
  float& p1dbeta = sve.p1dbeta;
  float& p2beta = sve.p2beta;
  float& p2pibeta = sve.p2pibeta;
  float& pfinal = sve.pfinal;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& ppbeta = sve.ppbeta;
  arr_ref<float, 2> ppd(sve.ppd, dimension(3, npdmax));
  float& ppx = sve.ppx;
  float& ppy = sve.ppy;
  float& ppz = sve.ppz;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px3 = sve.px3;
  float& px4 = sve.px4;
  float& pxd = sve.pxd;
  float& pxi1 = sve.pxi1;
  float& pxi2 = sve.pxi2;
  float& py3 = sve.py3;
  float& py4 = sve.py4;
  float& pyd = sve.pyd;
  float& pyi1 = sve.pyi1;
  float& pyi2 = sve.pyi2;
  float& pz2 = sve.pz2;
  float& pz3 = sve.pz3;
  float& pz4 = sve.pz4;
  float& pzd = sve.pzd;
  float& pzi1 = sve.pzi1;
  float& pzi2 = sve.pzi2;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& s2d = sve.s2d;
  float& scheck = sve.scheck;
  float& sdprod = sve.sdprod;
  float& sig2 = sve.sig2;
  float& sigk = sve.sigk;
  float& signd = sve.signd;
  float& ss = sve.ss;
  float& st1 = sve.st1;
  float& st2 = sve.st2;
  float& t1 = sve.t1;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2 = sve.t2;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& ta = sve.ta;
  float& transf = sve.transf;
  float& x = sve.x;
  float& x1 = sve.x1;
  float& x1535 = sve.x1535;
  float& xdmass = sve.xdmass;
  float& xmass = sve.xmass;
  float& xmm = sve.xmm;
  float& xptr = sve.xptr;
  float& xsk1 = sve.xsk1;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  const float pi = 3.1415926f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  const float avmass = 0.9383f;
  const float amp = 0.93828f;
  const float aka = 0.498f;
  const float xmd = 1.8756f;
  /// C     1NTAG,SIGNN,SIG)
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH BARYON RESONANCE-BARYON RESONANCE COLLISIONS*
  /// C     NOTE   :                                                         *
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  /// C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      0-> COLLISION CANNOT HAPPEN                     *
  /// C                      1-> N-N ELASTIC COLLISION                       *
  /// C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  /// C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  /// C                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
  /// C                     5-> DELTA(N*)+DELTA(N*)   TOTAL   COLLISIONS    *
  /// C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  /// C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  /// C                      N12,                                            *
  /// C                      M12=1 FOR p+n-->delta(+)+ n                     *
  /// C                          2     p+n-->delta(0)+ p                     *
  /// C                          3     p+p-->delta(++)+n                     *
  /// C                          4     p+p-->delta(+)+p                      *
  /// C                          5     n+n-->delta(0)+n                      *
  /// C                          6     n+n-->delta(-)+p                      *
  /// C                          7     n+p-->N*(0)(1440)+p                   *
  /// C                          8     n+p-->N*(+)(1440)+n                   *
  /// C                        9     p+p-->N*(+)(1535)+p                     *
  /// C                        10    n+n-->N*(0)(1535)+n                     *
  /// C                         11    n+p-->N*(+)(1535)+n                     *
  /// C                        12    n+p-->N*(0)(1535)+p
  /// C                        13    D(++)+D(-)-->N*(+)(1440)+n
  /// C                         14    D(++)+D(-)-->N*(0)(1440)+p
  /// C                        15    D(+)+D(0)--->N*(+)(1440)+n
  /// C                        16    D(+)+D(0)--->N*(0)(1440)+p
  /// C                        17    D(++)+D(0)-->N*(+)(1535)+p
  /// C                        18    D(++)+D(-)-->N*(0)(1535)+p
  /// C                        19    D(++)+D(-)-->N*(+)(1535)+n
  /// C                        20    D(+)+D(+)-->N*(+)(1535)+p
  /// C                        21    D(+)+D(0)-->N*(+)(1535)+n
  /// C                        22    D(+)+D(0)-->N*(0)(1535)+p
  /// C                        23    D(+)+D(-)-->N*(0)(1535)+n
  /// C                        24    D(0)+D(0)-->N*(0)(1535)+n
  /// C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  /// C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  /// C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  /// C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  /// C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  /// C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  /// C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  /// C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  /// C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  /// C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  /// C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  /// C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  /// C                        +++
  /// C               AND MORE CHANNELS AS LISTED IN THE NOTE BOOK
  /// C
  /// C NOTE ABOUT N*(1440) RESORANCE:                                       *
  /// C     As it has been discussed in VerWest's paper,I= 1 (initial isospin)
  /// C     channel can all be attributed to delta resorance while I= 0      *
  /// C     channel can all be  attribured to N* resorance.Only in n+p       *
  /// C     one can have I=0 channel so is the N*(1440) resorance            *
  /// C REFERENCES:    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)        *
  /// C                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
  /// C                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
  /// C                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615        *
  /// C                    CUTOFF = 2 * AVMASS + 20 MEV                      *
  /// C                                                                      *
  /// C       for N*(1535) we use the parameterization by Gy. Wolf et al     *
  /// C       Nucl phys A552 (1993) 349, added May 18, 1994                  *
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /RNDF77/
  /// C-----------------------------------------------------------------------
  n12 = 0;
  sve.m12 = 0;
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  c2 = pz / pr;
  if (px == 0.0f && py == 0.0f) {
    t2 = 0.0f;
  } else {
    t2 = fem::atan2(py, px);
  }
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 && lb(i2) < 0) {
    ianti = 1;
  }
  /// C
  /// Clin-6/2008 Production of perturbative deuterons for idpert=1:
  sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
  if (idpert == 1 && ipert1 == 1) {
    if (srt < 2.012f) {
      return;
    }
    if ((fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13) &&
        (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
      goto statement_108;
    } else {
      return;
    }
  }
  /// C
  /// C-----------------------------------------------------------------------
  /// CCOM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
  /// C      N-DELTA OR N*-N* or N*-Delta)
  if (x1 <= signn / sig) {
    /// CCOM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
    as = fem::pow((3.65f * (srt - 1.8766f)), 6);
    a = 6.0f * as / (1.0f + as);
    ta = -2.0f * fem::pow2(pr);
    x = ranart(nseed);
    /// Clin-10/24/02        T1  = DLOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /
    /// A
    t1 = fem::sngl(fem::dlog(fem::dble(1.f - x) *
                                 fem::dexp(fem::dble(a) * fem::dble(ta)) +
                             fem::dble(x))) /
         a;
    c1 = 1.0f - t1 / ta;
    t1 = 2.0f * pi * ranart(nseed);
    iblock = 20;
    goto statement_107;
  } else {
    /// CCOM: TEST FOR INELASTIC SCATTERING
    /// C     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
    /// C     CAN HAPPEN ANY MORE ==> RETURN (2.15 = 2*AVMASS +2*PI-MASS)
    if (srt < 2.15f) {
      return;
    }
    /// C     IF THERE WERE 2 N*(1535) AND THEY DIDN'T SCATT. ELAST.,
    /// C     ALLOW THEM TO PRODUCE KAONS. NO OTHER INELASTIC CHANNELS
    /// C     ARE KNOWN
    /// C       if((lb(i1).ge.12).and.(lb(i2).ge.12))return
    /// C     ALL the inelastic collisions between N*(1535) and Delta as well
    /// C     as N*(1440) TO PRODUCE KAONS, NO OTHER CHANNELS ARE KNOWN
    /// C       if((lb(i1).ge.12).and.(lb(i2).ge.3))return
    /// C       if((lb(i2).ge.12).and.(lb(i1).ge.3))return
    /// C     calculate the N*(1535) production cross section in I1+I2
    /// collisions
    n1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
    /// C
    /// C for Delta+Delta-->N*(1440 OR 1535)+N AND
    /// N*(1440)+N*(1440)-->N*(1535)+X C     AND DELTA+N*(1440)-->N*(1535)+X C
    /// WE ASSUME THEY HAVE THE SAME CROSS SECTIONS as CORRESPONDING N+N
    /// COLLISION): C FOR D++D0,
    /// D+D+,D+D-,D0D0,N*+N*+,N*0N*0,N*(+)D+,N*(+)D(-),N*(0)D(0) C N*(1535)
    /// production, kaon production and reabsorption through C D(N*)+D(N*)-->NN
    /// are ALLOWED. C CROSS SECTION FOR KAON PRODUCTION from the four channels
    /// are C for NLK channel
    akp = 0.498f;
    sve.ak0 = 0.498f;
    ana = 0.938f;
    ada = 1.232f;
    al = 1.1157f;
    as = 1.1197f;
    xsk1 = 0;
    xsk2 = 0;
    xsk3 = 0;
    xsk4 = 0;
    xsk5 = 0;
    t1nlk = ana + al + akp;
    if (srt <= t1nlk) {
      goto statement_222;
    }
    xsk1 = 1.5f * pplpk(cmn, srt);
    /// C for DLK channel
    t1dlk = ada + al + akp;
    t2dlk = ada + al - akp;
    if (srt <= t1dlk) {
      goto statement_222;
    }
    es = srt;
    pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
             (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
    sve.pmdlk = fem::sqrt(pmdlk2);
    xsk3 = 1.5f * pplpk(cmn, srt);
    /// C for NSK channel
    t1nsk = ana + as + akp;
    t2nsk = ana + as - akp;
    if (srt <= t1nsk) {
      goto statement_222;
    }
    pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
             (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
    sve.pmnsk = fem::sqrt(pmnsk2);
    xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    /// C for DSK channel
    t1dsk = ada + as + akp;
    t2dsk = ada + as - akp;
    if (srt <= t1dsk) {
      goto statement_222;
    }
    pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
             (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
    sve.pmdsk = fem::sqrt(pmdsk2);
    xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
    /// Csp11/21/01
    /// C phi production
    if (srt <= (2.f * amn + aphi)) {
      goto statement_222;
    }
    /// C  !! mb put the correct form
    xsk5 = 0.0001f;
  /// Csp11/21/01 end
  /// C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
  statement_222:
    sigk = xsk1 + xsk2 + xsk3 + xsk4;
    /// C
    /// Cbz3/7/99 neutralk
    xsk1 = 2.0f * xsk1;
    xsk2 = 2.0f * xsk2;
    xsk3 = 2.0f * xsk3;
    xsk4 = 2.0f * xsk4;
    sigk = 2.0f * sigk + xsk5;
    /// Cbz3/7/99 neutralk end
    /// C
    /// C The reabsorption cross section for the process
    /// C D(N*)D(N*)-->NN is
    s2d = reab2d(cmn, i1, i2, srt);
    /// C
    /// Cbz3/16/99 pion
    s2d = 0.f;
    /// Cbz3/16/99 pion end
    /// C
    /// C(1) N*(1535)+D(N*(1440)) reactions
    /// C    we allow kaon production and reabsorption only
    if (((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 12)) ||
        ((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 6)) ||
        ((fem::iabs(lb(i2)) >= 12) && (fem::iabs(lb(i1)) >= 6))) {
      signd = sigk + s2d;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C       if(x1.gt.(signd+signn)/sig)return
      if (x1 > (signd + signn + sdprod) / sig) {
        return;
      }
      /// C
      /// C if kaon production
      /// Clin-6/2008
      /// C       IF(SIGK/SIG.GE.RANART(NSEED))GO TO 306
      if ((sigk + sdprod) / sig >= ranart(nseed)) {
        goto statement_306;
      }
      /// C
      /// C if reabsorption
      goto statement_1012;
    }
    idd = fem::iabs(lb(i1) * lb(i2));
    /// C channels have the same charge as pp
    if ((idd == 63) || (idd == 64) || (idd == 48) || (idd == 49) ||
        (idd == 11 * 11) || (idd == 10 * 10) || (idd == 88) || (idd == 66) ||
        (idd == 90) || (idd == 70)) {
      signd = x1535 + sigk + s2d;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      /// C
      /// C if kaon production
      if (sigk / signd > ranart(nseed)) {
        goto statement_306;
      }
      /// C if reabsorption
      if (s2d / (x1535 + s2d) > ranart(nseed)) {
        goto statement_1012;
      }
      /// C if N*(1535) production
      if (idd == 63) {
        n12 = 17;
      }
      if (idd == 64) {
        n12 = 20;
      }
      if (idd == 48) {
        n12 = 23;
      }
      if (idd == 49) {
        n12 = 24;
      }
      if (idd == 121) {
        n12 = 25;
      }
      if (idd == 100) {
        n12 = 26;
      }
      if (idd == 88) {
        n12 = 29;
      }
      if (idd == 66) {
        n12 = 31;
      }
      if (idd == 90) {
        n12 = 32;
      }
      if (idd == 70) {
        n12 = 35;
      }
      goto statement_1011;
    }
    /// C IN DELTA+N*(1440) and N*(1440)+N*(1440) COLLISIONS,
    /// C N*(1535), kaon production and reabsorption are ALLOWED
    /// C IN N*(1440)+N*(1440) COLLISIONS, ONLY N*(1535) IS ALLOWED
    if ((idd == 110) || (idd == 77) || (idd == 80)) {
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C       IF(X1.GT.(SIGNN+X1535+SIGK+s2d)/SIG)RETURN
      if (x1 > (signn + x1535 + sigk + s2d + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / (x1535 + sigk + s2d) > ranart(nseed)) {
        goto statement_306;
      }
      if (s2d / (x1535 + s2d) > ranart(nseed)) {
        goto statement_1012;
      }
      if (idd == 77) {
        n12 = 30;
      }
      if ((idd == 77) && (ranart(nseed) <= 0.5f)) {
        n12 = 36;
      }
      if (idd == 80) {
        n12 = 34;
      }
      if ((idd == 80) && (ranart(nseed) <= 0.5f)) {
        n12 = 35;
      }
      if (idd == 110) {
        n12 = 27;
      }
      if ((idd == 110) && (ranart(nseed) <= 0.5f)) {
        n12 = 28;
      }
      goto statement_1011;
    }
    if ((idd == 54) || (idd == 56)) {
      /// C LIKE FOR N+P COLLISION,
      /// C IN DELTA+DELTA COLLISIONS BOTH N*(1440) AND N*(1535) CAN BE PRODUCED
      sig2 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
      signd = 2.f * (sig2 + x1535) + sigk + s2d;
      /// Clin-6/2008
      if (x1 <= ((signn + sdprod) / sig)) {
        goto statement_108;
      }
      /// C        IF(X1.GT.(SIGNN+SIGND)/SIG)RETURN
      if (x1 > (signn + signd + sdprod) / sig) {
        return;
      }
      /// C
      if (sigk / signd > ranart(nseed)) {
        goto statement_306;
      }
      if (s2d / (2.f * (sig2 + x1535) + s2d) > ranart(nseed)) {
        goto statement_1012;
      }
      if (ranart(nseed) < x1535 / (sig2 + x1535)) {
        /// C N*(1535) PRODUCTION
        if (idd == 54) {
          n12 = 18;
        }
        if ((idd == 54) && (ranart(nseed) <= 0.5f)) {
          n12 = 19;
        }
        if (idd == 56) {
          n12 = 21;
        }
        if ((idd == 56) && (ranart(nseed) <= 0.5f)) {
          n12 = 22;
        }
      } else {
        /// C N*(144) PRODUCTION
        if (idd == 54) {
          n12 = 13;
        }
        if ((idd == 54) && (ranart(nseed) <= 0.5f)) {
          n12 = 14;
        }
        if (idd == 56) {
          n12 = 15;
        }
        if ((idd == 56) && (ranart(nseed) <= 0.5f)) {
          n12 = 16;
        }
      }
    }
  statement_1011:
    iblock = 5;
    /// CPARAMETRIZATION OF THE SHAPE OF THE N*(1440) AND N*(1535)
    /// C RESONANCE ACCORDING
    /// C     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
    /// C     FORMULA FOR N* RESORANCE
    /// C     DETERMINE DELTA MASS VIA REJECTION METHOD.
    dmax = srt - avmass - 0.005f;
    dmin = 1.078f;
    if ((n12 >= 13) && (n12 <= 16)) {
      /// C N*(1440) production
      if (dmax < 1.44f) {
        fm = fns(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.44f;
        /// C          FM=FNS(1.44,SRT,1.)
        fm = fns(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry2 = 0;
    statement_11:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry2++;
      if ((ranart(nseed) > fns(cmn, dm, srt, 1.f) / fm) && (ntry2 <= 10)) {
        goto statement_11;
      }
      /// C
      /// Clin-2/26/03 limit the N* mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 2.14f) {
        goto statement_11;
      }
      /// C
      goto statement_13;
    }
    if ((n12 >= 17) && (n12 <= 36)) {
      /// C N*(1535) production
      if (dmax < 1.535f) {
        fm = fd5(cmn, dmax, srt, 0.f);
      } else {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in FNS():
        xdmass = 1.535f;
        /// C          FM=FD5(1.535,SRT,1.)
        fm = fd5(cmn, xdmass, srt, 1.f);
        /// Clin-10/25/02-end
        /// C
      }
      if (fm == 0.f) {
        fm = 1.e-09f;
      }
      ntry1 = 0;
    statement_12:
      dm = ranart(nseed) * (dmax - dmin) + dmin;
      ntry1++;
      if ((ranart(nseed) > fd5(cmn, dm, srt, 1.f) / fm) && (ntry1 <= 10)) {
        goto statement_12;
      }
      /// C
      /// Clin-2/26/03 limit the N* mass below a certain value
      /// C     (here taken as its central value + 2* B-W fullwidth):
      if (dm > 1.84f) {
        goto statement_12;
      }
      /// C
    }
  statement_13:
    /// C-------------------------------------------------------
    /// C RELABLE BARYON I1 AND I2
    /// C13 D(++)+D(-)--> N*(+)(14)+n
    if (n12 == 13) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 11;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 11;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C14 D(++)+D(-)--> N*(0)(14)+P
    if (n12 == 14) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 10;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 10;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C15 D(+)+D(0)--> N*(+)(14)+n
    if (n12 == 15) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 11;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 11;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C16 D(+)+D(0)--> N*(0)(14)+P
    if (n12 == 16) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 10;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 10;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C17 D(++)+D(0)--> N*(+)(14)+P
    if (n12 == 17) {
      lb(i2) = 13;
      e(i2) = dm;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C18 D(++)+D(-)--> N*(0)(15)+P
    if (n12 == 18) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C19 D(++)+D(-)--> N*(+)(15)+N
    if (n12 == 19) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C20 D(+)+D(+)--> N*(+)(15)+P
    if (n12 == 20) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C21 D(+)+D(0)--> N*(+)(15)+N
    if (n12 == 21) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C22 D(+)+D(0)--> N*(0)(15)+P
    if (n12 == 22) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C23 D(+)+D(-)--> N*(0)(15)+N
    if (n12 == 23) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C24 D(0)+D(0)--> N*(0)(15)+N
    if (n12 == 24) {
      lb(i2) = 12;
      e(i2) = dm;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C25 N*(+)+N*(+)--> N*(0)(15)+P
    if (n12 == 25) {
      lb(i2) = 12;
      e(i2) = dm;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C26 N*(0)+N*(0)--> N*(0)(15)+N
    if (n12 == 26) {
      lb(i2) = 12;
      e(i2) = dm;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C27 N*(+)+N*(0)--> N*(+)(15)+N
    if (n12 == 27) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C28 N*(+)+N*(0)--> N*(0)(15)+P
    if (n12 == 28) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C27 N*(+)+N*(0)--> N*(+)(15)+N
    if (n12 == 27) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C29 N*(+)+D(+)--> N*(+)(15)+P
    if (n12 == 29) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C30 N*(+)+D(0)--> N*(+)(15)+N
    if (n12 == 30) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C31 N*(+)+D(-)--> N*(0)(15)+N
    if (n12 == 31) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C32 N*(0)+D(++)--> N*(+)(15)+P
    if (n12 == 32) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C33 N*(0)+D(+)--> N*(+)(15)+N
    if (n12 == 33) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 13;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 13;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C34 N*(0)+D(+)--> N*(0)(15)+P
    if (n12 == 34) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    /// C35 N*(0)+D(0)--> N*(0)(15)+N
    if (n12 == 35) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C36 N*(+)+D(0)--> N*(0)(15)+P
    if (n12 == 36) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 12;
        e(i2) = dm;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 12;
        e(i1) = dm;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
  statement_1012:
    iblock = 55;
    lb1 = lb(i1);
    lb2 = lb(i2);
    ich = fem::iabs(lb1 * lb2);
    /// C-------------------------------------------------------
    /// C RELABLE BARYON I1 AND I2 in the reabsorption processes
    /// C37 D(++)+D(-)--> n+p
    if (ich == 9 * 6) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C38 D(+)+D(0)--> n+p
    if (ich == 8 * 7) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C39 D(++)+D(0)--> p+p
    if (ich == 9 * 7) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C40 D(+)+D(+)--> p+p
    if (ich == 8 * 8) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C41 D(+)+D(-)--> n+n
    if (ich == 8 * 6) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C42 D(0)+D(0)--> n+n
    if (ich == 6 * 6) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C43 N*(+)+N*(+)--> p+p
    if (ich == 11 * 11 || ich == 13 * 13 || ich == 11 * 13) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C44 N*(0)(1440)+N*(0)--> n+n
    if (ich == 10 * 10 || ich == 12 * 12 || ich == 10 * 12) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C45 N*(+)+N*(0)--> n+p
    if (ich == 10 * 11 || ich == 12 * 13 || ich == 10 * 13 || ich == 11 * 12) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C46 N*(+)+D(+)--> p+p
    if (ich == 11 * 8 || ich == 13 * 8) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C47 N*(+)+D(0)--> n+p
    if (ich == 11 * 7 || ich == 13 * 7) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 1;
        e(i2) = amp;
        lb(i1) = 2;
        e(i1) = amn;
      } else {
        lb(i1) = 1;
        e(i1) = amp;
        lb(i2) = 2;
        e(i2) = amn;
      }
      goto statement_200;
    }
    /// C48 N*(+)+D(-)--> n+n
    if (ich == 11 * 6 || ich == 13 * 6) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C49 N*(0)+D(++)--> p+p
    if (ich == 10 * 9 || ich == 12 * 9) {
      lb(i2) = 1;
      e(i2) = amp;
      lb(i1) = 1;
      e(i1) = amp;
      goto statement_200;
    }
    /// C50 N*(0)+D(0)--> n+n
    if (ich == 10 * 7 || ich == 12 * 7) {
      lb(i2) = 2;
      e(i2) = amn;
      lb(i1) = 2;
      e(i1) = amn;
      goto statement_200;
    }
    /// C51 N*(0)+D(+)--> n+p
    if (ich == 10 * 8 || ich == 12 * 8) {
      if (ranart(nseed) <= 0.5f) {
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 1;
        e(i1) = amp;
      } else {
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 1;
        e(i2) = amp;
      }
      goto statement_200;
    }
    lb(i1) = 1;
    e(i1) = amp;
    lb(i2) = 2;
    e(i2) = amn;
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  /// C resonance production or absorption in resonance+resonance collisions is
  /// C assumed to have the same pt distribution as pp
  statement_200:
    em1 = e(i1);
    em2 = e(i2);
    pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
          4.0f * fem::pow2((em1 * em2));
    if (pr2 <= 0.f) {
      pr2 = 1.e-09f;
    }
    pr = fem::sqrt(pr2) / (2.f * srt);
    if (srt <= 2.14f) {
      c1 = 1.0f - 2.0f * ranart(nseed);
    }
    if (srt > 2.14f && srt <= 2.4f) {
      c1 = ang(cmn, srt, iseed);
    }
    if (srt > 2.4f) {
      /// C
      /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
      xptr = 0.33f * pr;
      /// C         cc1=ptr(0.33*pr,iseed)
      cc1 = ptr(cmn, xptr, iseed);
      /// Clin-10/25/02-end
      /// C
      /// Clin-9/2012: check argument in sqrt():
      scheck = fem::pow2(pr) - fem::pow2(cc1);
      if (scheck < 0) {
        write(99, star), "scheck7: ", scheck;
        scheck = 0.f;
      }
      c1 = fem::sqrt(scheck) / pr;
      /// C         c1=sqrt(pr**2-cc1**2)/pr
      /// C
    }
    t1 = 2.0f * pi * ranart(nseed);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(i1) = -lb(i1);
      lb(i2) = -lb(i2);
    }
  }
/// CCOM: SET THE NEW MOMENTUM COORDINATES
/// C
/// Clin-9/2012: check argument in sqrt():
statement_107:
  scheck = 1.0f - fem::pow2(c1);
  if (scheck < 0) {
    write(99, star), "scheck8: ", scheck;
    scheck = 0.f;
  }
  s1 = fem::sqrt(scheck);
  /// C107   S1   = SQRT( 1.0 - C1**2 )
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1.0f - fem::pow2(c2);
  if (scheck < 0) {
    write(99, star), "scheck9: ", scheck;
    scheck = 0.f;
  }
  s2 = fem::sqrt(scheck);
  /// C      S2  =  SQRT( 1.0 - C2**2 )
  /// C
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  ct2 = fem::cos(t2);
  st2 = fem::sin(t2);
  pz = pr * (c1 * c2 - s1 * s2 * ct1);
  ss = c2 * s1 * ct1 + s2 * c1;
  px = pr * (ss * ct2 - s1 * st1 * st2);
  py = pr * (ss * st2 + s1 * st1 * ct2);
  return;
/// C FOR THE DD-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN
/// C THE NUCLEUS-NUCLEUS CMS.
statement_306:
  /// Csp11/21/01 phi production
  if (xsk5 / sigk > ranart(nseed)) {
    pz1 = p(3, i1);
    pz2 = p(3, i2);
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    nnn++;
    lpion(nnn, irun) = 29;
    epion(nnn, irun) = aphi;
    iblock = 222;
    goto statement_208;
  }
  iblock = 10;
  if (ianti == 1) {
    iblock = -10;
  }
  pz1 = p(3, i1);
  pz2 = p(3, i2);
  /// C DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  nnn++;
  lpion(nnn, irun) = 23;
  epion(nnn, irun) = aka;
  if (srt <= 2.63f) {
    /// C only lambda production is possible
    /// C (1.1)P+P-->p+L+kaon+
    ic = 1;
    lb(i1) = 1 + fem::fint(2 * ranart(nseed));
    lb(i2) = 14;
    goto statement_208;
  }
  if (srt <= 2.74f && srt > 2.63f) {
    /// C both Lambda and sigma production are possible
    if (xsk1 / (xsk1 + xsk2) > ranart(nseed)) {
      /// C lambda production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
    } else {
      /// C sigma production
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      ic = 2;
    }
    goto statement_208;
  }
  if (srt <= 2.77f && srt > 2.74f) {
    /// C then pp-->Delta lamda kaon can happen
    if (xsk1 / (xsk1 + xsk2 + xsk3) > ranart(nseed)) {
      /// C * (1.1)P+P-->p+L+kaon+
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk2 / (xsk2 + xsk3) > ranart(nseed)) {
        /// C pp-->psk
        ic = 2;
        lb(i1) = 1 + fem::fint(2 * ranart(nseed));
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      } else {
        /// C pp-->D+l+k
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
      }
      goto statement_208;
    }
  }
  if (srt > 2.77f) {
    /// C all four channels are possible
    if (xsk1 / (xsk1 + xsk2 + xsk3 + xsk4) > ranart(nseed)) {
      /// C p lambda k production
      ic = 1;
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      lb(i2) = 14;
      goto statement_208;
    } else {
      if (xsk3 / (xsk2 + xsk3 + xsk4) > ranart(nseed)) {
        /// C delta l K production
        ic = 3;
        lb(i1) = 6 + fem::fint(4 * ranart(nseed));
        lb(i2) = 14;
        goto statement_208;
      } else {
        if (xsk2 / (xsk2 + xsk4) > ranart(nseed)) {
          /// C n sigma k production
          lb(i1) = 1 + fem::fint(2 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
          ic = 2;
        } else {
          /// C D sigma K
          ic = 4;
          lb(i1) = 6 + fem::fint(4 * ranart(nseed));
          lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        }
        goto statement_208;
      }
    }
  }
statement_208:
  if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
    lb(i1) = -lb(i1);
    lb(i2) = -lb(i2);
    if (lpion(nnn, irun) == 23) {
      lpion(nnn, irun) = 21;
    }
  }
  lbi1 = lb(i1);
  lbi2 = lb(i2);
  /// C KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
  ntry1 = 0;
statement_129:
  bbkaon(cmn, ic, srt, px3, py3, pz3, dm3, px4, py4, pz4, dm4, ppx, ppy, ppz,
         icou1);
  ntry1++;
  if ((icou1 < 0) && (ntry1 <= 20)) {
    goto statement_129;
  }
  /// C       if(icou1.lt.0)return
  /// C ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  rotate(cmn, px, py, pz, px3, py3, pz3);
  rotate(cmn, px, py, pz, px4, py4, pz4);
  rotate(cmn, px, py, pz, ppx, ppy, ppz);
  /// C FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
  /// C NUCLEUS CMS. FRAME
  /// C (1) for the necleon/delta
  /// C             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
  e1cm = fem::sqrt(fem::pow2(dm3) + fem::pow2(px3) + fem::pow2(py3) +
                   fem::pow2(pz3));
  p1beta = px3 * betax + py3 * betay + pz3 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  pt1i1 = betax * transf + px3;
  pt2i1 = betay * transf + py3;
  pt3i1 = betaz * transf + pz3;
  eti1 = dm3;
  /// C (2) for the lambda/sigma
  e2cm = fem::sqrt(fem::pow2(dm4) + fem::pow2(px4) + fem::pow2(py4) +
                   fem::pow2(pz4));
  p2beta = px4 * betax + py4 * betay + pz4 * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf + px4;
  pt2i2 = betay * transf + py4;
  pt3i2 = betaz * transf + pz4;
  eti2 = dm4;
  /// C GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
  epcm = fem::sqrt(fem::pow2(aka) + fem::pow2(ppx) + fem::pow2(ppy) +
                   fem::pow2(ppz));
  ppbeta = ppx * betax + ppy * betay + ppz * betaz;
  transf = gamma * (gamma * ppbeta / (gamma + 1.f) + epcm);
  ppion(1, nnn, irun) = betax * transf + ppx;
  ppion(2, nnn, irun) = betay * transf + ppy;
  ppion(3, nnn, irun) = betaz * transf + ppz;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
  /// Clin-5/2008:
  /// C2007        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2007
  /// C                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
  /// C                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
  /// C                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
  rpion(1, nnn, irun) = r(1, i1);
  rpion(2, nnn, irun) = r(2, i1);
  rpion(3, nnn, irun) = r(3, i1);
  /// C
  /// C assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the
  /// C leadng particle behaviour
  /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  e(i1) = eti1;
  lb(i1) = lbi1;
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  e(i2) = eti2;
  lb(i2) = lbi2;
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  id(i1) = 2;
  id(i2) = 2;
  id1 = id(i1);
  lb1 = lb(i1);
  lb2 = lb(i2);
  sve.am1 = em1;
  sve.am2 = em2;
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  return;
/// C
/// Clin-6/2008 D+D->Deuteron+pi:
/// C     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
statement_108:
  if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
    /// C     For idpert=1: we produce npertd pert deuterons:
    ndloop = npertd;
  } else if (idpert == 2 && npertd >= 1) {
    /// C     For idpert=2: we first save information for npertd pert deuterons;
    /// C     at the last ndloop we create the regular deuteron+pi
    /// C     and those pert deuterons:
    ndloop = npertd + 1;
  } else {
    /// C     Just create the regular deuteron+pi:
    ndloop = 1;
  }
  /// C
  dprob1 = sdprod / sig / fem::ffloat(npertd);
  FEM_DO_SAFE(idloop, 1, ndloop) {
    bbdangle(cmn, pxd, pyd, pzd, nt, ipert1, ianti, idloop, pfinal, dprob1,
             lbm);
    rotate(cmn, px, py, pz, pxd, pyd, pzd);
    /// C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
    /// STATE C     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME: C     For
    /// the Deuteron:
    xmass = xmd;
    e1dcm = fem::sqrt(fem::pow2(xmass) + fem::pow2(pxd) + fem::pow2(pyd) +
                      fem::pow2(pzd));
    p1dbeta = pxd * betax + pyd * betay + pzd * betaz;
    transf = gamma * (gamma * p1dbeta / (gamma + 1.f) + e1dcm);
    pxi1 = betax * transf + pxd;
    pyi1 = betay * transf + pyd;
    pzi1 = betaz * transf + pzd;
    if (ianti == 0) {
      lbd = 42;
    } else {
      lbd = -42;
    }
    if (idpert == 1 && ipert1 == 1 && npertd >= 1) {
      /// Cccc  Perturbative production for idpert=1:
      nnn++;
      ppion(1, nnn, irun) = pxi1;
      ppion(2, nnn, irun) = pyi1;
      ppion(3, nnn, irun) = pzi1;
      epion(nnn, irun) = xmd;
      lpion(nnn, irun) = lbd;
      rpion(1, nnn, irun) = r(1, i1);
      rpion(2, nnn, irun) = r(2, i1);
      rpion(3, nnn, irun) = r(3, i1);
      /// Clin-6/2008 assign the perturbative probability:
      dppion(nnn, irun) = sdprod / sig / fem::ffloat(npertd);
    } else if (idpert == 2 && idloop <= npertd) {
      /// Clin-6/2008 For idpert=2, we produce NPERTD perturbative
      /// (anti)deuterons C     only when a regular (anti)deuteron+pi is
      /// produced in NN collisions. C     First save the info for the
      /// perturbative deuterons:
      ppd(1, idloop) = pxi1;
      ppd(2, idloop) = pyi1;
      ppd(3, idloop) = pzi1;
      lbpd(idloop) = lbd;
    } else {
      /// Cccc  Regular production:
      /// C     For the regular pion: do LORENTZ-TRANSFORMATION:
      e(i1) = xmm;
      e2picm = fem::sqrt(fem::pow2(xmm) + fem::pow2(pxd) + fem::pow2(pyd) +
                         fem::pow2(pzd));
      p2pibeta = -pxd * betax - pyd * betay - pzd * betaz;
      transf = gamma * (gamma * p2pibeta / (gamma + 1.f) + e2picm);
      pxi2 = betax * transf - pxd;
      pyi2 = betay * transf - pyd;
      pzi2 = betaz * transf - pzd;
      p(1, i1) = pxi2;
      p(2, i1) = pyi2;
      p(3, i1) = pzi2;
      /// C     Remove regular pion to check the equivalence
      /// C     between the perturbative and regular deuteron results:
      /// C                 E(i1)=0.
      /// C
      lb(i1) = lbm;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      id(i1) = 2;
      id1 = id(i1);
      e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                     fem::pow2(pz1));
      lb1 = lb(i1);
      /// C     For the regular deuteron:
      p(1, i2) = pxi1;
      p(2, i2) = pyi1;
      p(3, i2) = pzi1;
      lb(i2) = lbd;
      lb2 = lb(i2);
      e(i2) = xmd;
      eti2 = e(i2);
      id(i2) = 2;
      /// C     For idpert=2: create the perturbative deuterons:
      if (idpert == 2 && idloop == ndloop) {
        FEM_DO_SAFE(ipertd, 1, npertd) {
          nnn++;
          ppion(1, nnn, irun) = ppd(1, ipertd);
          ppion(2, nnn, irun) = ppd(2, ipertd);
          ppion(3, nnn, irun) = ppd(3, ipertd);
          epion(nnn, irun) = xmd;
          lpion(nnn, irun) = lbpd(ipertd);
          rpion(1, nnn, irun) = r(1, i1);
          rpion(2, nnn, irun) = r(2, i1);
          rpion(3, nnn, irun) = r(3, i1);
          /// Clin-6/2008 assign the perturbative probability:
          dppion(nnn, irun) = 1.f / fem::ffloat(npertd);
        }
      }
    }
  }
  iblock = 501;
  /// Clin-6/2008 D+D->Deuteron+pi over
  /// C
}

struct dkine_save {
  float am;
  float bdx;
  float bdy;
  float bdz;
  float bpn;
  float bpp;
  float devio;
  float dm;
  float edelta;
  float en;
  float ep;
  float fgd;
  float gd;
  float pm;
  float px;
  float pxn;
  float pxp;
  float py;
  float pyn;
  float pyp;
  float pz;
  float pzn;
  float pzp;
  float q;
  float q2;
  float qs;
  float qx;
  float qy;
  float qz;
  float rx;
  float ry;
  float rz;
  float tau0;
  float taudcy;

  dkine_save()
      : am(fem::float0),
        bdx(fem::float0),
        bdy(fem::float0),
        bdz(fem::float0),
        bpn(fem::float0),
        bpp(fem::float0),
        devio(fem::float0),
        dm(fem::float0),
        edelta(fem::float0),
        en(fem::float0),
        ep(fem::float0),
        fgd(fem::float0),
        gd(fem::float0),
        pm(fem::float0),
        px(fem::float0),
        pxn(fem::float0),
        pxp(fem::float0),
        py(fem::float0),
        pyn(fem::float0),
        pyp(fem::float0),
        pz(fem::float0),
        pzn(fem::float0),
        pzp(fem::float0),
        q(fem::float0),
        q2(fem::float0),
        qs(fem::float0),
        qx(fem::float0),
        qy(fem::float0),
        qz(fem::float0),
        rx(fem::float0),
        ry(fem::float0),
        rz(fem::float0),
        tau0(fem::float0),
        taudcy(fem::float0) {}
};

/// C
/// C-------------------------------------------------------------------
/// C PURPOSE:
/// C         CALCULATE THE MOMENTUM OF NUCLEON AND PION (OR ETA)
/// C         IN THE LAB. FRAME AFTER DELTA OR N* DECAY
/// C DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA PRODUCTION
void dkine(common& cmn, int const& irun, int const& i, int const& nnn,
           int const& nlab, int const& /* iseed */, float const& wid,
           int const& nt) {
  FEM_CMN_SVE(dkine);
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_cref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  float& am = sve.am;
  float& bdx = sve.bdx;
  float& bdy = sve.bdy;
  float& bdz = sve.bdz;
  float& bpn = sve.bpn;
  float& bpp = sve.bpp;
  float& dm = sve.dm;
  float& edelta = sve.edelta;
  float& en = sve.en;
  float& ep = sve.ep;
  float& fgd = sve.fgd;
  float& gd = sve.gd;
  float& pm = sve.pm;
  float& px = sve.px;
  float& pxn = sve.pxn;
  float& pxp = sve.pxp;
  float& py = sve.py;
  float& pyn = sve.pyn;
  float& pyp = sve.pyp;
  float& pz = sve.pz;
  float& pzn = sve.pzn;
  float& pzp = sve.pzp;
  float& q = sve.q;
  float& q2 = sve.q2;
  float& qs = sve.qs;
  float& qx = sve.qx;
  float& qy = sve.qy;
  float& qz = sve.qz;
  float& tau0 = sve.tau0;
  float& taudcy = sve.taudcy;
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  const float hbarc = 0.19733f;
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /tdecay/
  /// Cc      SAVE /INPUT2/
  /// Cc      SAVE /RNDF77/
  /// C READ IN THE COORDINATES OF DELTA OR N* UNDERGOING DECAY
  px = p(1, i);
  py = p(2, i);
  pz = p(3, i);
  sve.rx = r(1, i);
  sve.ry = r(2, i);
  sve.rz = r(3, i);
  dm = e(i);
  edelta =
      fem::sqrt(fem::pow2(dm) + fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  pm = epion(nnn, irun);
  am = amp;
  if (nlab == 2) {
    am = amn;
  }
  /// C FIND OUT THE MOMENTUM AND ENERGY OF PION AND NUCLEON IN DELTA REST FRAME
  /// C THE MAGNITUDE OF MOMENTUM IS DETERMINED BY ENERGY CONSERVATION ,THE
  /// FORMULA C CAN BE FOUND ON PAGE 716,W BAUER P.R.C40,1989 C THE DIRECTION OF
  /// THE MOMENTUM IS ASSUMED ISOTROPIC. NOTE THAT P(PION)=-P(N)
  q2 = fem::pow2(
           ((fem::pow2(dm) - fem::pow2(am) + fem::pow2(pm)) / (2.f * dm))) -
       fem::pow2(pm);
  if (q2 <= 0.f) {
    q2 = 1.e-09f;
  }
  q = fem::sqrt(q2);
statement_11:
  qx = 1.f - 2.f * ranart(nseed);
  qy = 1.f - 2.f * ranart(nseed);
  qz = 1.f - 2.f * ranart(nseed);
  qs = fem::pow2(qx) + fem::pow2(qy) + fem::pow2(qz);
  if (qs > 1.f) {
    goto statement_11;
  }
  pxp = q * qx / fem::sqrt(qs);
  pyp = q * qy / fem::sqrt(qs);
  pzp = q * qz / fem::sqrt(qs);
  ep = fem::sqrt(fem::pow2(q) + fem::pow2(pm));
  pxn = -pxp;
  pyn = -pyp;
  pzn = -pzp;
  en = fem::sqrt(fem::pow2(q) + fem::pow2(am));
  /// C TRANSFORM INTO THE LAB. FRAME. THE GENERAL LORENTZ TRANSFORMATION CAN
  /// C BE FOUND ON PAGE 34 OF R. HAGEDORN " RELATIVISTIC KINEMATICS"
  gd = edelta / dm;
  fgd = gd / (1.f + gd);
  bdx = px / edelta;
  bdy = py / edelta;
  bdz = pz / edelta;
  bpp = bdx * pxp + bdy * pyp + bdz * pzp;
  bpn = bdx * pxn + bdy * pyn + bdz * pzn;
  p(1, i) = pxn + bdx * gd * (fgd * bpn + en);
  p(2, i) = pyn + bdy * gd * (fgd * bpn + en);
  p(3, i) = pzn + bdz * gd * (fgd * bpn + en);
  e(i) = am;
  /// C WE ASSUME THAT THE SPACIAL COORDINATE OF THE NUCLEON
  /// C IS THAT OF THE DELTA
  ppion(1, nnn, irun) = pxp + bdx * gd * (fgd * bpp + ep);
  ppion(2, nnn, irun) = pyp + bdy * gd * (fgd * bpp + ep);
  ppion(3, nnn, irun) = pzp + bdz * gd * (fgd * bpp + ep);
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i);
  /// C WE ASSUME THE PION OR ETA COMING FROM DELTA DECAY IS LOCATED ON THE
  /// SPHERE C OF RADIUS 0.5FM AROUND DELTA, THIS POINT NEED TO BE CHECKED C AND
  /// OTHER CRIERTION MAY BE TRIED Clin-2/20/03 no additional smearing for
  /// position of decay daughters: C200         X0 = 1.0 - 2.0 * RANART(NSEED) C
  /// Y0 = 1.0 - 2.0 * RANART(NSEED) C            Z0 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 200
  /// C        RPION(1,NNN,IRUN)=R(1,I)+0.5*x0
  /// C        RPION(2,NNN,IRUN)=R(2,I)+0.5*y0
  /// C        RPION(3,NNN,IRUN)=R(3,I)+0.5*z0
  rpion(1, nnn, irun) = r(1, i);
  rpion(2, nnn, irun) = r(2, i);
  rpion(3, nnn, irun) = r(3, i);
  /// C
  sve.devio =
      fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppion(1, nnn, irun)) +
                fem::pow2(ppion(2, nnn, irun)) +
                fem::pow2(ppion(3, nnn, irun))) +
      fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                fem::pow2(p(3, i))) -
      e1;
  /// C        if(abs(devio).gt.0.02) write(93,*) 'decay(): nt=',nt,devio,lb1
  /// C
  /// C     add decay time to daughter's formation time at the last timestep:
  if (nt == cmn.ntmax) {
    tau0 = hbarc / wid;
    taudcy = tau0 * (-1.f) * fem::alog(1.f - ranart(nseed));
    /// C     lorentz boost:
    taudcy = taudcy * e1 / cmn.em1;
    tfnl += taudcy;
    xfnl += px1 / e1 * taudcy;
    yfnl += py1 / e1 * taudcy;
    zfnl += pz1 / e1 * taudcy;
    r(1, i) = xfnl;
    r(2, i) = yfnl;
    r(3, i) = zfnl;
    tfdcy(i) = tfnl;
    rpion(1, nnn, irun) = xfnl;
    rpion(2, nnn, irun) = yfnl;
    rpion(3, nnn, irun) = zfnl;
    tfdpi(nnn, irun) = tfnl;
  }
  /// C
}

struct decay_save {
  float ctrl;
  float dm;
  float dpsave;
  int lbanti;
  int lbi;
  int lbm;
  int lbsave;
  int nalb;
  int nlab;
  float pxsave;
  float pysave;
  float pzsave;
  float x3;
  float x4;
  float x5;
  float x6;
  float x8;
  float xmsave;

  decay_save()
      : ctrl(fem::float0),
        dm(fem::float0),
        dpsave(fem::float0),
        lbanti(fem::int0),
        lbi(fem::int0),
        lbm(fem::int0),
        lbsave(fem::int0),
        nalb(fem::int0),
        nlab(fem::int0),
        pxsave(fem::float0),
        pysave(fem::float0),
        pzsave(fem::float0),
        x3(fem::float0),
        x4(fem::float0),
        x5(fem::float0),
        x6(fem::float0),
        x8(fem::float0),
        xmsave(fem::float0) {}
};

/// C-----------------------------------------------------------------------------
/// C PURPOSE:1. SORT N*(1440) and N*(1535) 2-body DECAY PRODUCTS
/// C         2. DETERMINE THE MOMENTUM AND COORDINATES OF NUCLEON AND PION
/// C            AFTER THE DELTA OR N* DECAYING
/// C DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA
void decay(common& cmn, int const& irun, int const& i, int const& nnn,
           int const& iseed, float const& wid, int const& nt) {
  FEM_CMN_SVE(decay);
  /// COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON pb
  const int maxr = 1;
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  /// COMMON pc
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  /// COMMON pd
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON dpert
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  /// SAVE
  float& ctrl = sve.ctrl;
  float& dm = sve.dm;
  float& dpsave = sve.dpsave;
  int& lbanti = sve.lbanti;
  int& lbi = sve.lbi;
  int& lbm = sve.lbm;
  int& lbsave = sve.lbsave;
  int& nalb = sve.nalb;
  int& nlab = sve.nlab;
  float& pxsave = sve.pxsave;
  float& pysave = sve.pysave;
  float& pzsave = sve.pzsave;
  float& x3 = sve.x3;
  float& x4 = sve.x4;
  float& x5 = sve.x5;
  float& x6 = sve.x6;
  float& x8 = sve.x8;
  float& xmsave = sve.xmsave;
  ///
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /INPUT2/
  /// Cc      SAVE /RNDF77/
  lbanti = lb(i);
  /// C
  dm = e(i);
  /// C1. FOR N*+(1440) DECAY
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  const float etam = 0.5475f;
  if (fem::iabs(lb(i)) == 11) {
    x3 = ranart(nseed);
    if (x3 > (1.f / 3.f)) {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
    } else {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
    }
    /// C2. FOR N*0(1440) DECAY
  } else if (fem::iabs(lb(i)) == 10) {
    x4 = ranart(nseed);
    if (x4 > (1.f / 3.f)) {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
    } else {
      lb(i) = 2;
      nalb = 2;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
    }
    /// C N*(1535) CAN DECAY TO A PION OR AN ETA IF DM > 1.49 GeV
    /// C3 N*(0)(1535) DECAY
  } else if (fem::iabs(lb(i)) == 12) {
    ctrl = 0.65f;
    if (dm <= 1.49f) {
      ctrl = -1.f;
    }
    x5 = ranart(nseed);
    if (x5 >= ctrl) {
      /// C DECAY TO PION+NUCLEON
      x6 = ranart(nseed);
      if (x6 > (1.f / 3.f)) {
        lb(i) = 1;
        nlab = 1;
        lpion(nnn, irun) = 3;
        epion(nnn, irun) = ap2;
      } else {
        lb(i) = 2;
        nalb = 2;
        lpion(nnn, irun) = 4;
        epion(nnn, irun) = ap1;
      }
    } else {
      /// C DECAY TO ETA+NEUTRON
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 0;
      epion(nnn, irun) = etam;
    }
    /// C4. FOR N*+(1535) DECAY
  } else if (fem::iabs(lb(i)) == 13) {
    ctrl = 0.65f;
    if (dm <= 1.49f) {
      ctrl = -1.f;
    }
    x5 = ranart(nseed);
    if (x5 >= ctrl) {
      /// C DECAY TO PION+NUCLEON
      x8 = ranart(nseed);
      if (x8 > (1.f / 3.f)) {
        lb(i) = 2;
        nlab = 2;
        lpion(nnn, irun) = 5;
        epion(nnn, irun) = ap2;
      } else {
        lb(i) = 1;
        nlab = 1;
        lpion(nnn, irun) = 4;
        epion(nnn, irun) = ap1;
      }
    } else {
      /// C DECAY TO ETA+NUCLEON
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 0;
      epion(nnn, irun) = etam;
    }
  }
  /// C
  dkine(cmn, irun, i, nnn, nlab, iseed, wid, nt);
  /// C
  /// C     anti-particle ID for anti-N* decays:
  if (lbanti < 0) {
    lbi = lb(i);
    if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    } else if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    }
    lb(i) = lbi;
    /// C
    lbi = lpion(nnn, irun);
    if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    } else if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    }
    lpion(nnn, irun) = lbi;
  }
  /// C
  if (nt == cmn.ntmax) {
    /// C     at the last timestep, assign rho or eta (decay daughter)
    /// C     to lb(i1) only (not to lpion) in order to decay them again:
    lbm = lpion(nnn, irun);
    if (lbm == 0 || lbm == 25 || lbm == 26 || lbm == 27) {
      /// C     switch rho or eta with baryon, positions are the same (no change
      /// needed):
      lbsave = lbm;
      xmsave = epion(nnn, irun);
      pxsave = ppion(1, nnn, irun);
      pysave = ppion(2, nnn, irun);
      pzsave = ppion(3, nnn, irun);
      /// Clin-5/2008:
      dpsave = dppion(nnn, irun);
      lpion(nnn, irun) = lb(i);
      epion(nnn, irun) = e(i);
      ppion(1, nnn, irun) = p(1, i);
      ppion(2, nnn, irun) = p(2, i);
      ppion(3, nnn, irun) = p(3, i);
      /// Clin-5/2008:
      dppion(nnn, irun) = dpertp(i);
      lb(i) = lbsave;
      e(i) = xmsave;
      p(1, i) = pxsave;
      p(2, i) = pysave;
      p(3, i) = pzsave;
      /// Clin-5/2008:
      dpertp(i) = dpsave;
    }
  }
  /// C
}

struct dkine2_save {
  float am;
  float bdx;
  float bdy;
  float bdz;
  float betax;
  float betay;
  float betaz;
  float bp0;
  float bpn;
  float bpn1;
  float bpp;
  float bpp1;
  float css;
  float devio;
  float dm;
  float edelta;
  float en;
  float enucl;
  float ep;
  float ep0;
  float epion1;
  float epion2;
  float epn;
  float epp;
  float fai;
  float fgd;
  float fgd1;
  float gd;
  float gd1;
  float p1m;
  float p1p;
  float p2m;
  float p2p;
  float p3m;
  float p3p;
  float pm1;
  float pm2;
  float pmax;
  float pmax2;
  float px;
  float px0;
  float pxn;
  float pxp;
  float py;
  float py0;
  float pyn;
  float pyp;
  float pz;
  float pz0;
  float pzn;
  float pzp;
  float q;
  float q2;
  float qs;
  float qx;
  float qy;
  float qz;
  float rx;
  float ry;
  float rz;
  float scheck;
  float sss;
  float tau0;
  float taudcy;

  dkine2_save()
      : am(fem::float0),
        bdx(fem::float0),
        bdy(fem::float0),
        bdz(fem::float0),
        betax(fem::float0),
        betay(fem::float0),
        betaz(fem::float0),
        bp0(fem::float0),
        bpn(fem::float0),
        bpn1(fem::float0),
        bpp(fem::float0),
        bpp1(fem::float0),
        css(fem::float0),
        devio(fem::float0),
        dm(fem::float0),
        edelta(fem::float0),
        en(fem::float0),
        enucl(fem::float0),
        ep(fem::float0),
        ep0(fem::float0),
        epion1(fem::float0),
        epion2(fem::float0),
        epn(fem::float0),
        epp(fem::float0),
        fai(fem::float0),
        fgd(fem::float0),
        fgd1(fem::float0),
        gd(fem::float0),
        gd1(fem::float0),
        p1m(fem::float0),
        p1p(fem::float0),
        p2m(fem::float0),
        p2p(fem::float0),
        p3m(fem::float0),
        p3p(fem::float0),
        pm1(fem::float0),
        pm2(fem::float0),
        pmax(fem::float0),
        pmax2(fem::float0),
        px(fem::float0),
        px0(fem::float0),
        pxn(fem::float0),
        pxp(fem::float0),
        py(fem::float0),
        py0(fem::float0),
        pyn(fem::float0),
        pyp(fem::float0),
        pz(fem::float0),
        pz0(fem::float0),
        pzn(fem::float0),
        pzp(fem::float0),
        q(fem::float0),
        q2(fem::float0),
        qs(fem::float0),
        qx(fem::float0),
        qy(fem::float0),
        qz(fem::float0),
        rx(fem::float0),
        ry(fem::float0),
        rz(fem::float0),
        scheck(fem::float0),
        sss(fem::float0),
        tau0(fem::float0),
        taudcy(fem::float0) {}
};

/// C-------------------------------------------------------------------
/// C--------------------------------------------------------------------------
/// C         CALCULATE THE MOMENTUM OF NUCLEON AND PION (OR ETA)
/// C         IN THE LAB. FRAME AFTER DELTA OR N* DECAY
/// C DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA PRODUCTION
/// C--------------------------------------------------------------------------
void dkine2(common& cmn, int const& irun, int const& i, int const& nnn,
            int const& nlab, int const& /* iseed */, float const& wid,
            int const& nt) {
  FEM_CMN_SVE(dkine2);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_cref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  float& am = sve.am;
  float& bdx = sve.bdx;
  float& bdy = sve.bdy;
  float& bdz = sve.bdz;
  float& betax = sve.betax;
  float& betay = sve.betay;
  float& betaz = sve.betaz;
  float& bp0 = sve.bp0;
  float& bpn = sve.bpn;
  float& bpn1 = sve.bpn1;
  float& bpp = sve.bpp;
  float& bpp1 = sve.bpp1;
  float& css = sve.css;
  float& dm = sve.dm;
  float& edelta = sve.edelta;
  float& en = sve.en;
  float& ep = sve.ep;
  float& ep0 = sve.ep0;
  float& epn = sve.epn;
  float& epp = sve.epp;
  float& fai = sve.fai;
  float& fgd = sve.fgd;
  float& fgd1 = sve.fgd1;
  float& gd = sve.gd;
  float& gd1 = sve.gd1;
  float& p1m = sve.p1m;
  float& p1p = sve.p1p;
  float& p2m = sve.p2m;
  float& p2p = sve.p2p;
  float& p3m = sve.p3m;
  float& p3p = sve.p3p;
  float& pm1 = sve.pm1;
  float& pm2 = sve.pm2;
  float& pmax = sve.pmax;
  float& pmax2 = sve.pmax2;
  float& px = sve.px;
  float& px0 = sve.px0;
  float& pxn = sve.pxn;
  float& pxp = sve.pxp;
  float& py = sve.py;
  float& py0 = sve.py0;
  float& pyn = sve.pyn;
  float& pyp = sve.pyp;
  float& pz = sve.pz;
  float& pz0 = sve.pz0;
  float& pzn = sve.pzn;
  float& pzp = sve.pzp;
  float& q = sve.q;
  float& q2 = sve.q2;
  float& qs = sve.qs;
  float& qx = sve.qx;
  float& qy = sve.qy;
  float& qz = sve.qz;
  float& scheck = sve.scheck;
  float& sss = sve.sss;
  float& tau0 = sve.tau0;
  float& taudcy = sve.taudcy;
  const float amn = 0.939457f;
  const float amp = 0.93828f;
  const float pi = 3.1415926f;
  const float hbarc = 0.19733f;
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /tdecay/
  /// Cc      SAVE /INPUT2/
  /// Cc      SAVE /RNDF77/
  /// C
  /// C READ IN THE COORDINATES OF THE N*(1440) UNDERGOING DECAY
  px = p(1, i);
  py = p(2, i);
  pz = p(3, i);
  sve.rx = r(1, i);
  sve.ry = r(2, i);
  sve.rz = r(3, i);
  dm = e(i);
  edelta =
      fem::sqrt(fem::pow2(dm) + fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  pm1 = epion(nnn, irun);
  pm2 = epion(nnn + 1, irun);
  am = amn;
  if (nlab == 1) {
    am = amp;
  }
  /// C THE MAXIMUM MOMENTUM OF THE NUCLEON FROM THE DECAY OF A N*
  pmax2 = (fem::pow2(dm) - fem::pow2((am + pm1 + pm2))) *
          (fem::pow2(dm) - fem::pow2((am - pm1 - pm2))) / 4 / fem::pow2(dm);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = pmax2;
  if (scheck < 0) {
    write(99, star), "scheck15: ", scheck;
    scheck = 0.f;
  }
  pmax = fem::sqrt(scheck);
  /// C       PMAX=SQRT(PMAX2)
  /// C
  /// C GENERATE THE MOMENTUM OF THE NUCLEON IN THE N* REST FRAME
  css = 1.f - 2.f * ranart(nseed);
  sss = fem::sqrt(1 - fem::pow2(css));
  fai = 2 * pi * ranart(nseed);
  px0 = pmax * sss * fem::cos(fai);
  py0 = pmax * sss * fem::sin(fai);
  pz0 = pmax * css;
  ep0 = fem::sqrt(fem::pow2(px0) + fem::pow2(py0) + fem::pow2(pz0) +
                  fem::pow2(am));
  /// Clin-5/23/01 bug: P0 for pion0 is equal to PMAX, leaving pion+ and pion-
  /// C     without no relative momentum, thus producing them with equal
  /// momenta, C BETA AND GAMMA OF THE CMS OF PION+-PION-
  betax = -px0 / (dm - ep0);
  betay = -py0 / (dm - ep0);
  betaz = -pz0 / (dm - ep0);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = 1 - fem::pow2(betax) - fem::pow2(betay) - fem::pow2(betaz);
  if (scheck <= 0) {
    write(99, star), "scheck16: ", scheck;
    FEM_STOP(0);
  }
  gd1 = 1.f / fem::sqrt(scheck);
  /// C       GD1=1./SQRT(1-BETAX**2-BETAY**2-BETAZ**2)
  /// C
  fgd1 = gd1 / (1 + gd1);
  /// C GENERATE THE MOMENTA OF PIONS IN THE CMS OF PION+PION-
  q2 = fem::pow2(((dm - ep0) / (2.f * gd1))) - fem::pow2(pm1);
  if (q2 <= 0.f) {
    q2 = 1.e-09f;
  }
  q = fem::sqrt(q2);
statement_11:
  qx = 1.f - 2.f * ranart(nseed);
  qy = 1.f - 2.f * ranart(nseed);
  qz = 1.f - 2.f * ranart(nseed);
  qs = fem::pow2(qx) + fem::pow2(qy) + fem::pow2(qz);
  if (qs > 1.f) {
    goto statement_11;
  }
  pxp = q * qx / fem::sqrt(qs);
  pyp = q * qy / fem::sqrt(qs);
  pzp = q * qz / fem::sqrt(qs);
  ep = fem::sqrt(fem::pow2(q) + fem::pow2(pm1));
  pxn = -pxp;
  pyn = -pyp;
  pzn = -pzp;
  en = fem::sqrt(fem::pow2(q) + fem::pow2(pm2));
  /// C TRANSFORM THE MOMENTA OF PION+PION- INTO THE N* REST FRAME
  bpp1 = betax * pxp + betay * pyp + betaz * pzp;
  bpn1 = betax * pxn + betay * pyn + betaz * pzn;
  /// C FOR PION-
  p1m = pxn + betax * gd1 * (fgd1 * bpn1 + en);
  p2m = pyn + betay * gd1 * (fgd1 * bpn1 + en);
  p3m = pzn + betaz * gd1 * (fgd1 * bpn1 + en);
  epn = fem::sqrt(fem::pow2(p1m) + fem::pow2(p2m) + fem::pow2(p3m) +
                  fem::pow2(pm2));
  /// C FOR PION+
  p1p = pxp + betax * gd1 * (fgd1 * bpp1 + ep);
  p2p = pyp + betay * gd1 * (fgd1 * bpp1 + ep);
  p3p = pzp + betaz * gd1 * (fgd1 * bpp1 + ep);
  epp = fem::sqrt(fem::pow2(p1p) + fem::pow2(p2p) + fem::pow2(p3p) +
                  fem::pow2(pm1));
  /// C TRANSFORM MOMENTA OF THE THREE PIONS INTO THE
  /// C THE NUCLEUS-NUCLEUS CENTER OF MASS  FRAME.
  /// C THE GENERAL LORENTZ TRANSFORMATION CAN
  /// C BE FOUND ON PAGE 34 OF R. HAGEDORN " RELATIVISTIC KINEMATICS"
  gd = edelta / dm;
  fgd = gd / (1.f + gd);
  bdx = px / edelta;
  bdy = py / edelta;
  bdz = pz / edelta;
  bp0 = bdx * px0 + bdy * py0 + bdz * pz0;
  bpp = bdx * p1p + bdy * p2p + bdz * p3p;
  bpn = bdx * p1m + bdy * p2m + bdz * p3m;
  /// C FOR THE NUCLEON
  p(1, i) = px0 + bdx * gd * (fgd * bp0 + ep0);
  p(2, i) = py0 + bdy * gd * (fgd * bp0 + ep0);
  p(3, i) = pz0 + bdz * gd * (fgd * bp0 + ep0);
  e(i) = am;
  id(i) = 0;
  sve.enucl = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                        fem::pow2(p(3, i)) + fem::pow2(e(i)));
  /// C WE ASSUME THAT THE SPACIAL COORDINATE OF THE PION0
  /// C IS in a sphere of radius 0.5 fm around N*
  /// C FOR PION+
  ppion(1, nnn, irun) = p1p + bdx * gd * (fgd * bpp + epp);
  ppion(2, nnn, irun) = p2p + bdy * gd * (fgd * bpp + epp);
  ppion(3, nnn, irun) = p3p + bdz * gd * (fgd * bpp + epp);
  sve.epion1 = fem::sqrt(
      fem::pow2(ppion(1, nnn, irun)) + fem::pow2(ppion(2, nnn, irun)) +
      fem::pow2(ppion(3, nnn, irun)) + fem::pow2(epion(nnn, irun)));
  /// Clin-2/20/03 no additional smearing for position of decay daughters:
  /// C200         X0 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y0 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z0 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 200
  /// C        RPION(1,NNN,IRUN)=R(1,I)+0.5*x0
  /// C        RPION(2,NNN,IRUN)=R(2,I)+0.5*y0
  /// C        RPION(3,NNN,IRUN)=R(3,I)+0.5*z0
  rpion(1, nnn, irun) = r(1, i);
  rpion(2, nnn, irun) = r(2, i);
  rpion(3, nnn, irun) = r(3, i);
  /// C FOR PION-
  ppion(1, nnn + 1, irun) = p1m + bdx * gd * (fgd * bpn + epn);
  ppion(2, nnn + 1, irun) = p2m + bdy * gd * (fgd * bpn + epn);
  ppion(3, nnn + 1, irun) = p3m + bdz * gd * (fgd * bpn + epn);
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i);
  dppion(nnn + 1, irun) = dpertp(i);
  /// C
  sve.epion2 = fem::sqrt(
      fem::pow2(ppion(1, nnn + 1, irun)) + fem::pow2(ppion(2, nnn + 1, irun)) +
      fem::pow2(ppion(3, nnn + 1, irun)) + fem::pow2(epion(nnn + 1, irun)));
  /// Clin-2/20/03 no additional smearing for position of decay daughters:
  /// C300         X0 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y0 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z0 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 300
  /// C        RPION(1,NNN+1,IRUN)=R(1,I)+0.5*x0
  /// C        RPION(2,NNN+1,IRUN)=R(2,I)+0.5*y0
  /// C        RPION(3,NNN+1,IRUN)=R(3,I)+0.5*z0
  rpion(1, nnn + 1, irun) = r(1, i);
  rpion(2, nnn + 1, irun) = r(2, i);
  rpion(3, nnn + 1, irun) = r(3, i);
  /// C
  /// C check energy conservation in the decay
  /// C       efinal=enucl+epion1+epion2
  /// C       DEEE=(EDELTA-EFINAL)/EDELTA
  /// C       IF(ABS(DEEE).GE.1.E-03)write(6,*)1,edelta,efinal
  /// C
  sve.devio =
      fem::sqrt(fem::pow2(epion(nnn, irun)) + fem::pow2(ppion(1, nnn, irun)) +
                fem::pow2(ppion(2, nnn, irun)) +
                fem::pow2(ppion(3, nnn, irun))) +
      fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                fem::pow2(p(3, i))) +
      fem::sqrt(fem::pow2(epion(nnn + 1, irun)) +
                fem::pow2(ppion(1, nnn + 1, irun)) +
                fem::pow2(ppion(2, nnn + 1, irun)) +
                fem::pow2(ppion(3, nnn + 1, irun))) -
      e1;
  /// C        if(abs(devio).gt.0.02) write(93,*) 'decay2(): nt=',nt,devio,lb1
  /// C
  /// C     add decay time to daughter's formation time at the last timestep:
  if (nt == cmn.ntmax) {
    tau0 = hbarc / wid;
    taudcy = tau0 * (-1.f) * fem::alog(1.f - ranart(nseed));
    /// C     lorentz boost:
    taudcy = taudcy * e1 / cmn.em1;
    tfnl += taudcy;
    xfnl += px1 / e1 * taudcy;
    yfnl += py1 / e1 * taudcy;
    zfnl += pz1 / e1 * taudcy;
    r(1, i) = xfnl;
    r(2, i) = yfnl;
    r(3, i) = zfnl;
    tfdcy(i) = tfnl;
    rpion(1, nnn, irun) = xfnl;
    rpion(2, nnn, irun) = yfnl;
    rpion(3, nnn, irun) = zfnl;
    tfdpi(nnn, irun) = tfnl;
    rpion(1, nnn + 1, irun) = xfnl;
    rpion(2, nnn + 1, irun) = yfnl;
    rpion(3, nnn + 1, irun) = zfnl;
    tfdpi(nnn + 1, irun) = tfnl;
  }
  /// C
}

struct decay2_save {
  float dm;
  int lbanti;
  int lbi;
  int nlab;
  float x3;

  decay2_save()
      : dm(fem::float0),
        lbanti(fem::int0),
        lbi(fem::int0),
        nlab(fem::int0),
        x3(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------------
/// C PURPOSE:1. N*-->N+PION+PION  DECAY PRODUCTS
/// C         2. DETERMINE THE MOMENTUM AND COORDINATES OF NUCLEON AND PION
/// C            AFTER THE DELTA OR N* DECAYING
/// C DATE   : NOV.7,1994
/// C----------------------------------------------------------------------------
void decay2(common& cmn, int const& irun, int const& i, int const& nnn,
            int const& iseed, float const& wid, int const& nt) {
  FEM_CMN_SVE(decay2);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON pc
  const int maxr = 1;
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  /// COMMON pd
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  int& lbanti = sve.lbanti;
  int& lbi = sve.lbi;
  int& nlab = sve.nlab;
  float& x3 = sve.x3;
  ///
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /RNDF77/
  /// C
  lbanti = lb(i);
  /// C
  sve.dm = e(i);
  /// C DETERMINE THE DECAY PRODUCTS
  /// C FOR N*+(1440) DECAY
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  if (fem::iabs(lb(i)) == 11) {
    x3 = ranart(nseed);
    if (x3 < (1.f / 3)) {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    } else if (x3 < 2.f / 3 && x3 > 1.f / 3.f) {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 3;
      epion(nnn + 1, irun) = ap2;
    } else {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    }
    /// C FOR N*0(1440) DECAY
  } else if (fem::iabs(lb(i)) == 10) {
    x3 = ranart(nseed);
    if (x3 < (1.f / 3)) {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 4;
      epion(nnn, irun) = ap1;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    } else if (x3 < 2.f / 3 && x3 > 1.f / 3.f) {
      lb(i) = 1;
      nlab = 1;
      lpion(nnn, irun) = 3;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 4;
      epion(nnn + 1, irun) = ap1;
    } else {
      lb(i) = 2;
      nlab = 2;
      lpion(nnn, irun) = 5;
      epion(nnn, irun) = ap2;
      lpion(nnn + 1, irun) = 3;
      epion(nnn + 1, irun) = ap2;
    }
  }
  /// C
  dkine2(cmn, irun, i, nnn, nlab, iseed, wid, nt);
  /// C
  /// C     anti-particle ID for anti-N* decays:
  if (lbanti < 0) {
    lbi = lb(i);
    if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    } else if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    }
    lb(i) = lbi;
    /// C
    lbi = lpion(nnn, irun);
    if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    } else if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    }
    lpion(nnn, irun) = lbi;
    /// C
    lbi = lpion(nnn + 1, irun);
    if (lbi == 3) {
      lbi = 5;
    } else if (lbi == 5) {
      lbi = 3;
    } else if (lbi == 1 || lbi == 2) {
      lbi = -lbi;
    }
    lpion(nnn + 1, irun) = lbi;
  }
  /// C
}

struct dreson_save {
  float dm;
  double e10;
  double e20;
  int i;
  double p1;
  double p2;
  double p3;
  double scheck;

  dreson_save()
      : dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        i(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0) {}
};

/// C---------------------------------------------------------------------------
/// C PURPOSE : CALCULATE THE MASS AND MOMENTUM OF BARYON RESONANCE
/// C           AFTER PION OR ETA BEING ABSORBED BY A NUCLEON
/// C NOTE    :
/// C
/// C DATE    : JAN.29,1990
void dreson(common& cmn, int const& i1, int const& i2) {
  FEM_CMN_SVE(dreson);
  common_write write(cmn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  int& i = sve.i;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  ///
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// C 1. DETERMINE THE MOMENTUM COMPONENT OF DELTA/N* IN THE LAB. FRAME
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  /// C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  /// C
  if (fem::iabs(lb(i2)) == 1 || fem::iabs(lb(i2)) == 2 ||
      (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 17)) {
    e(i1) = 0.f;
    i = i2;
  } else {
    e(i2) = 0.f;
    i = i1;
  }
  p(1, i) = p(1, i1) + p(1, i2);
  p(2, i) = p(2, i1) + p(2, i2);
  p(3, i) = p(3, i1) + p(3, i2);
  /// C 2. DETERMINE THE MASS OF DELTA/N* BY USING THE REACTION KINEMATICS
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck17: ", scheck;
    write(99, star), "scheck17", scheck, e10, e20, p(1, i), p(2, i), p(3, i);
    write(99, star), "scheck17-1", e(i1), p(1, i1), p(2, i1), p(3, i1);
    write(99, star), "scheck17-2", e(i2), p(1, i2), p(2, i2), p(3, i2);
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  /// C        DM=SQRT((E10+E20)**2-P(1,I)**2-P(2,I)**2-P(3,I)**2)
  /// C
  e(i) = dm;
}

struct xnpi_save {
  float avmass;
  float avpi;
  float dm;
  double e10;
  double e20;
  float f1;
  float gam;
  double p1;
  double p2;
  double p3;
  float pdelt2;
  float pstar2;
  double scheck;

  xnpi_save()
      : avmass(fem::float0),
        avpi(fem::float0),
        dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        f1(fem::float0),
        gam(fem::float0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        pdelt2(fem::float0),
        pstar2(fem::float0),
        scheck(fem::double0) {}
};

/// C---------------------------------------------------------------------------
/// C PURPOSE : CALCULATE THE PION+NUCLEON CROSS SECTION ACCORDING TO THE
/// C           BREIT-WIGNER FORMULA/(p*)**2
/// C VARIABLE : LA = 1 FOR DELTA RESONANCE
/// C            LA = 0 FOR N*(1440) RESONANCE
/// C            LA = 2 FRO N*(1535) RESONANCE
/// C DATE    : JAN.29,1990
float xnpi(common& cmn, int const& i1, int const& i2, int const& la,
           float const& xmax) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xnpi);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  ///
  float& avmass = sve.avmass;
  float& avpi = sve.avpi;
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  float& f1 = sve.f1;
  float& gam = sve.gam;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  float& pdelt2 = sve.pdelt2;
  float& pstar2 = sve.pstar2;
  double& scheck = sve.scheck;
  const float amn = 0.939457f;
  const float amp = 0.93828f;
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  avmass = 0.5f * (amn + amp);
  avpi = (2.f * ap2 + ap1) / 3.f;
  /// C 1. DETERMINE THE MOMENTUM COMPONENT OF DELTA IN THE LAB. FRAME
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  /// C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  /// C        P1=P(1,I1)+P(1,I2)
  /// C        P2=P(2,I1)+P(2,I2)
  /// C        P3=P(3,I1)+P(3,I2)
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  /// C
  /// C 2. DETERMINE THE MASS OF DELTA BY USING OF THE REACTION KINEMATICS
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck19: ", scheck;
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  /// C        DM=SQRT((E10+E20)**2-P1**2-P2**2-P3**2)
  /// C
  if (dm <= 1.1f) {
    return_value = 1.e-09f;
    return return_value;
  }
  /// C 3. DETERMINE THE PION+NUCLEON CROSS SECTION ACCORDING TO THE
  /// C    BREIT-WIGNER FORMULA IN UNIT OF FM**2
  if (la == 1) {
    gam = width(cmn, dm);
    f1 = 0.25f * fem::pow2(gam) /
         (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.232f)));
    pdelt2 = 0.051622f;
    goto statement_10;
  }
  if (la == 0) {
    gam = w1440(cmn, dm);
    f1 = 0.25f * fem::pow2(gam) /
         (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.440f)));
    pdelt2 = 0.157897f;
    goto statement_10;
  }
  if (la == 2) {
    gam = w1535(cmn, dm);
    f1 = 0.25f * fem::pow2(gam) /
         (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.535f)));
    pdelt2 = 0.2181f;
  }
statement_10:
  pstar2 = fem::pow2(((fem::pow2(dm) - fem::pow2(avmass) + fem::pow2(avpi)) /
                      (2.f * dm))) -
           fem::pow2(avpi);
  if (pstar2 <= 0.f) {
    return_value = 1.e-09f;
  } else {
    /// C give the cross section in unit of fm**2
    return_value = f1 * (pdelt2 / pstar2) * xmax / 10.f;
  }
  return return_value;
}

struct pnlka_save {
  float aka;
  float ala;
  float ana;
  float sbbk;
  float t1;

  pnlka_save()
      : aka(fem::float0),
        ala(fem::float0),
        ana(fem::float0),
        sbbk(fem::float0),
        t1(fem::float0) {}
};

/// C--------------------------------------------------------------------------
/// C****subprogram * kaon production from pi+B collisions *******************
float pnlka(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pnlka);
  /// SAVE
  float& aka = sve.aka;
  float& ala = sve.ala;
  float& sbbk = sve.sbbk;
  float& t1 = sve.t1;
  ///
  /// C units: fm**2
  /// C**********************************C
  ala = 1.116f;
  aka = 0.498f;
  sve.ana = 0.939f;
  t1 = ala + aka;
  if (srt <= t1) {
    return_value = 0;
  } else {
    if (srt < 1.7f) {
      sbbk = (0.9f / 0.091f) * (srt - t1);
    }
    if (srt >= 1.7f) {
      sbbk = 0.09f / (srt - 1.6f);
    }
    return_value = 0.25f * sbbk;
    /// C give the cross section in units of fm**2
    return_value = return_value / 10.f;
  }
  return return_value;
}

struct pnska_save {
  float aka;
  float ala;
  float ana;
  float asa;
  float sbb1;
  float sbb2;
  float t1;

  pnska_save()
      : aka(fem::float0),
        ala(fem::float0),
        ana(fem::float0),
        asa(fem::float0),
        sbb1(fem::float0),
        sbb2(fem::float0),
        t1(fem::float0) {}
};

/// C-------------------------------------------------------------------------
/// C****subprogram * kaon production from pi+B collisions *******************
float pnska(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pnska);
  /// SAVE
  float& aka = sve.aka;
  float& asa = sve.asa;
  float& sbb1 = sve.sbb1;
  float& sbb2 = sve.sbb2;
  float& t1 = sve.t1;
  ///
  /// C**********************************
  if (srt > 3.0f) {
    return_value = 0;
    return return_value;
  }
  sve.ala = 1.116f;
  aka = 0.498f;
  sve.ana = 0.939f;
  asa = 1.197f;
  t1 = asa + aka;
  if (srt <= t1) {
    return_value = 0;
    return return_value;
  }
  if (srt < 1.9f) {
    sbb1 = (0.7f / 0.218f) * (srt - t1);
  }
  if (srt >= 1.9f) {
    sbb1 = 0.14f / (srt - 1.7f);
  }
  sbb2 = 0.f;
  if (srt > 1.682f) {
    sbb2 = 0.5f * (1.f - 0.75f * (srt - 1.682f));
  }
  return_value = 0.25f * (sbb1 + sbb2);
  /// C give the cross section in fm**2
  return_value = return_value / 10.f;
  return return_value;
}

struct wida1_save {
  float coupa;
  float epi;
  float epirho;
  float erho;
  int icount;
  float pimass;
  float qqp;
  float qqp2;
  float rhomax;

  wida1_save()
      : coupa(fem::float0),
        epi(fem::float0),
        epirho(fem::float0),
        erho(fem::float0),
        icount(fem::int0),
        pimass(fem::float0),
        qqp(fem::float0),
        qqp2(fem::float0),
        rhomax(fem::float0) {}
};

/// C***********************************
/// C FUNCTION WA1(DMASS) GIVES THE A1 DECAY WIDTH
/// C
void wida1(common& cmn, float const& dmass, float& rhomp, float& wa1,
           int const& iseed) {
  FEM_CMN_SVE(wida1);
  float& coupa = sve.coupa;
  float& epi = sve.epi;
  float& epirho = sve.epirho;
  float& erho = sve.erho;
  int& icount = sve.icount;
  float& pimass = sve.pimass;
  float& qqp = sve.qqp;
  float& qqp2 = sve.qqp2;
  float& rhomax = sve.rhomax;
  /// C
  pimass = 0.137265f;
  coupa = 14.8f;
  /// C
  rhomax = dmass - pimass - 0.02f;
  if (rhomax <= 0) {
    rhomp = 0.f;
    /// C   !! no decay
    wa1 = -10.f;
  }
  icount = 0;
statement_711:
  rhomp = rhomas(cmn, rhomax, iseed);
  icount++;
  if (dmass <= (pimass + rhomp)) {
    if (icount <= 100) {
      goto statement_711;
    } else {
      rhomp = 0.f;
      /// C   !! no decay
      wa1 = -10.f;
      return;
    }
  }
  qqp2 = (fem::pow2(dmass) - fem::pow2((rhomp + pimass))) *
         (fem::pow2(dmass) - fem::pow2((rhomp - pimass)));
  qqp = fem::sqrt(qqp2) / (2.0f * dmass);
  epi = fem::sqrt(fem::pow2(pimass) + fem::pow2(qqp));
  erho = fem::sqrt(fem::pow2(rhomp) + fem::pow2(qqp));
  epirho = 2.0f * fem::pow2((epi * erho + fem::pow2(qqp))) +
           fem::pow2(rhomp) * fem::pow2(epi);
  wa1 = fem::pow2(coupa) * qqp * epirho / (24.0f * 3.1416f * fem::pow2(dmass));
}

struct xn1535_save {
  float avmass;
  float avpi;
  float dm;
  double e10;
  double e20;
  float f1;
  float gam;
  float gam0;
  double p1;
  double p2;
  double p3;
  double scheck;
  float xmax;

  xn1535_save()
      : avmass(fem::float0),
        avpi(fem::float0),
        dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        f1(fem::float0),
        gam(fem::float0),
        gam0(fem::float0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0),
        xmax(fem::float0) {}
};

/// C***************
/// C PURPOSE : CALCULATE THE PION(ETA)+NUCLEON CROSS SECTION
/// C           ACCORDING TO THE BREIT-WIGNER FORMULA,
/// C           NOTE THAT N*(1535) IS S_11
/// C VARIABLE : LA = 1 FOR PI+N
/// C            LA = 0 FOR ETA+N
/// C DATE    : MAY 16, 1994
/// C***************
float xn1535(common& cmn, int const& i1, int const& i2, int const& la) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xn1535);
  common_write write(cmn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  ///
  /// SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  float& f1 = sve.f1;
  float& gam = sve.gam;
  float& gam0 = sve.gam0;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  float& xmax = sve.xmax;
  ///
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  const float amn = 0.939457f;
  const float amp = 0.93828f;
  sve.avmass = 0.5f * (amn + amp);
  const float ap2 = 0.13957f;
  const float ap1 = 0.13496f;
  sve.avpi = (2.f * ap2 + ap1) / 3.f;
  /// C 1. DETERMINE THE MOMENTUM COMPONENT OF N*(1535) IN THE LAB. FRAME
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  /// C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  /// C        P1=P(1,I1)+P(1,I2)
  /// C        P2=P(2,I1)+P(2,I2)
  /// C        P3=P(3,I1)+P(3,I2)
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  /// C
  /// C 2. DETERMINE THE MASS OF DELTA BY USING OF THE REACTION KINEMATICS
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck21: ", scheck;
    scheck = 0.e0;
  }
  dm = fem::sqrt(fem::sngl(scheck));
  /// C        DM=SQRT((E10+E20)**2-P1**2-P2**2-P3**2)
  /// C
  if (dm <= 1.1f) {
    return_value = 1.e-06f;
    return return_value;
  }
  /// C 3. DETERMINE THE PION(ETA)+NUCLEON->N*(1535) CROSS SECTION ACCORDING TO
  /// THE C    BREIT-WIGNER FORMULA IN UNIT OF FM**2
  gam = w1535(cmn, dm);
  gam0 = 0.15f;
  f1 = 0.25f * fem::pow2(gam0) /
       (0.25f * fem::pow2(gam) + fem::pow2((dm - 1.535f)));
  if (la == 1) {
    xmax = 11.3f;
  } else {
    xmax = 74.f;
  }
  return_value = f1 * xmax / 10.f;
  return return_value;
}

struct pp2_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmax;
  float pmin;
  float scheck;

  pp2_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0),
        scheck(fem::float0) {}
};

/// C*****************************************
/// C for pp-->elastic
/// C      real*4 function pp2(srt)
float pp2(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pp2);
  common_write write(cmn);
  /// SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  float& scheck = sve.scheck;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (scheck < 0) {
    write(99, star), "scheck33: ", scheck;
    scheck = 0.f;
  }
  plab = fem::sqrt(scheck);
  /// C      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
  /// C
  pmin = 2.f;
  pmax = 2050;
  if (plab > pmax) {
    return_value = 8.f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 25.f;
    return return_value;
  }
  /// C* fit parameters
  a = 11.2f;
  b = 25.5f;
  c = 0.151f;
  d = -1.62f;
  an = -1.12f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0;
  }
  return return_value;
}

struct ppt_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmax;
  float pmin;
  float scheck;

  ppt_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0),
        scheck(fem::float0) {}
};

/// C
/// C*****************************************
/// C for pp-->total
/// C      real*4 function ppt(srt)
float ppt(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppt);
  common_write write(cmn);
  /// SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  float& scheck = sve.scheck;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2(((fem::pow2(srt) - 2.f * fem::pow2(pmass)) / (2.f * pmass))) -
      fem::pow2(pmass);
  if (scheck < 0) {
    write(99, star), "scheck34: ", scheck;
    scheck = 0.f;
  }
  plab = fem::sqrt(scheck);
  /// C      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
  /// C
  pmin = 3.f;
  pmax = 2100;
  if ((plab < pmin) || (plab > pmax)) {
    return_value = 55.f;
    return return_value;
  }
  /// C* fit parameters
  a = 45.6f;
  b = 219.0f;
  c = 0.410f;
  d = -3.41f;
  an = -4.23f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0.0f;
  }
  return return_value;
}

struct ppxs_save {
  float d00;
  float d11;
  float d20;
  float erh;
  float erho;
  float esi;
  float esigma;
  float q;
  float s0;
  float s1;
  float s2;
  float trho;
  float tsigma;

  ppxs_save()
      : d00(fem::float0),
        d11(fem::float0),
        d20(fem::float0),
        erh(fem::float0),
        erho(fem::float0),
        esi(fem::float0),
        esigma(fem::float0),
        q(fem::float0),
        s0(fem::float0),
        s1(fem::float0),
        s2(fem::float0),
        trho(fem::float0),
        tsigma(fem::float0) {}
};

/// C****************************
void ppxs(common& cmn, int const& lb1, int const& lb2, float const& srt,
          float& ppsig, float& spprho, int& ipp) {
  FEM_CMN_SVE(ppxs);
  float& d00 = sve.d00;
  float& d11 = sve.d11;
  float& d20 = sve.d20;
  float& erh = sve.erh;
  float& erho = sve.erho;
  float& esi = sve.esi;
  float& esigma = sve.esigma;
  float& q = sve.q;
  float& s0 = sve.s0;
  float& s1 = sve.s1;
  float& s2 = sve.s2;
  float& trho = sve.trho;
  float& tsigma = sve.tsigma;
  const float amp = 0.14f;
  const float pi = 3.1415926f;
  /// C purpose: this subroutine gives the cross section for pion+pion
  /// C          elastic collision
  /// C variables:
  /// C       input: lb1,lb2 and srt are the labels and srt for I1 and I2
  /// C       output: ppsig: pp xsection
  /// C               ipp: label for the pion+pion channel
  /// C               Ipp=0 NOTHING HAPPEND
  /// C                  1 for Pi(+)+PI(+) DIRECT
  /// C                   2     PI(+)+PI(0) FORMING RHO(+)
  /// C                  3     PI(+)+PI(-) FORMING RHO(0)
  /// C                   4     PI(0)+PI(O) DIRECT
  /// C                  5     PI(0)+PI(-) FORMING RHO(-)
  /// C                  6     PI(-)+PI(-) DIRECT
  /// C reference: G.F. Bertsch, Phys. Rev. D37 (1988) 1202.
  /// C date : Aug 29, 1994
  /// C****************************
  ppsig = 0.0f;
  /// C
  /// Cbzdbg10/15/99
  spprho = 0.0f;
  /// Cbzdbg10/15/99 end
  /// C
  ipp = 0;
  if (srt <= 0.3f) {
    return;
  }
  q = fem::sqrt(fem::pow2((srt / 2)) - fem::pow2(amp));
  esigma = 5.8f * amp;
  tsigma = 2.06f * q;
  erho = 0.77f;
  trho = 0.095f * q * fem::pow2((q / amp / (1.f + fem::pow2((q / erho)))));
  esi = esigma - srt;
  if (esi == 0) {
    d00 = pi / 2.f;
    goto statement_10;
  }
  d00 = fem::atan(tsigma / 2.f / esi);
statement_10:
  erh = erho - srt;
  if (erh == 0.f) {
    d11 = pi / 2.f;
    goto statement_20;
  }
  d11 = fem::atan(trho / 2.f / erh);
statement_20:
  d20 = -0.12f * q / amp;
  s0 = 8.f * pi * fem::pow2(fem::sin(d00)) / fem::pow2(q);
  s1 = 8 * pi * 3 * fem::pow2(fem::sin(d11)) / fem::pow2(q);
  s2 = 8 * pi * 5 * fem::pow2(fem::sin(d20)) / fem::pow2(q);
  /// C    !! GeV^-2 to mb
  s0 = s0 * fem::pow2(0.197f) * 10.f;
  s1 = s1 * fem::pow2(0.197f) * 10.f;
  s2 = s2 * fem::pow2(0.197f) * 10.f;
  /// C       ppXS=s0/9.+s1/3.+s2*0.56
  /// C       if(ppxs.le.0)ppxs=0.00001
  spprho = s1 / 2.f;
  /// C (1) PI(+)+PI(+)
  if (lb1 == 5 && lb2 == 5) {
    ipp = 1;
    ppsig = s2;
    return;
  }
  /// C (2) PI(+)+PI(0)
  if ((lb1 == 5 && lb2 == 4) || (lb1 == 4 && lb2 == 5)) {
    ipp = 2;
    ppsig = s2 / 2.f + s1 / 2.f;
    return;
  }
  /// C (3) PI(+)+PI(-)
  if ((lb1 == 5 && lb2 == 3) || (lb1 == 3 && lb2 == 5)) {
    ipp = 3;
    ppsig = s2 / 6.f + s1 / 2.f + s0 / 3.f;
    return;
  }
  /// C (4) PI(0)+PI(0)
  if (lb1 == 4 && lb2 == 4) {
    ipp = 4;
    ppsig = 2 * s2 / 3.f + s0 / 3.f;
    return;
  }
  /// C (5) PI(0)+PI(-)
  if ((lb1 == 4 && lb2 == 3) || (lb1 == 3 && lb2 == 4)) {
    ipp = 5;
    ppsig = s2 / 2.f + s1 / 2.f;
    return;
  }
  /// C (6) PI(-)+PI(-)
  if (lb1 == 3 && lb2 == 3) {
    ipp = 6;
    ppsig = s2;
  }
}

struct twopi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  float pmass1;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  twopi_save()
      : earray(dimension(19), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        xarray(dimension(19), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for ppi(+)-->DELTA+pi
/// C      real*4 function TWOPI(srt)
float twopi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(twopi);
  /// SAVE
  arr_ref<float> earray(sve.earray, dimension(19));
  int& ie = sve.ie;
  float& plab = sve.plab;
  arr_ref<float> xarray(sve.xarray, dimension(19));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {
          0.300e-05f, 0.187e+01f, 0.110e+02f, 0.149e+02f, 0.935e+01f,
          0.765e+01f, 0.462e+01f, 0.345e+01f, 0.241e+01f, 0.185e+01f,
          0.165e+01f, 0.150e+01f, 0.132e+01f, 0.117e+01f, 0.116e+01f,
          0.100e+01f, 0.856e+00f, 0.745e+00f, 0.300e-05f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {
          0.122e+01f, 0.147e+01f, 0.172e+01f, 0.197e+01f, 0.222e+01f,
          0.247e+01f, 0.272e+01f, 0.297e+01f, 0.322e+01f, 0.347e+01f,
          0.372e+01f, 0.397e+01f, 0.422e+01f, 0.447e+01f, 0.472e+01f,
          0.497e+01f, 0.522e+01f, 0.547e+01f, 0.572e+01f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  This function contains the experimental pi+p-->DELTA+PION cross
  /// sections
  /// * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb
  /// * C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  /// C      real*4   xarray(19), earray(19)
  /// C
  sve.pmass = 0.14f;
  sve.pmass1 = 0.938f;
  return_value = 0.000001f;
  if (srt <= 1.22f) {
    return return_value;
  }
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  plab = srt;
  if (plab < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 19) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct threpi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  float pmass1;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  threpi_save()
      : earray(dimension(15), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        xarray(dimension(15), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for ppi(+)-->DELTA+RHO
/// C      real*4 function THREPI(srt)
float threpi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(threpi);
  /// SAVE
  arr_ref<float> earray(sve.earray, dimension(15));
  int& ie = sve.ie;
  float& plab = sve.plab;
  arr_ref<float> xarray(sve.xarray, dimension(15));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {
          8.0000000e-06f, 6.1999999e-05f, 1.881940f, 5.025690f, 11.80154f,
          13.92114f,      15.07308f,      11.79571f, 11.53772f, 10.01197f,
          9.792673f,      9.465264f,      8.970490f, 7.944254f, 6.886320f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {
          0.122e+01f, 0.147e+01f, 0.172e+01f, 0.197e+01f, 0.222e+01f,
          0.247e+01f, 0.272e+01f, 0.297e+01f, 0.322e+01f, 0.347e+01f,
          0.372e+01f, 0.397e+01f, 0.422e+01f, 0.447e+01f, 0.472e+01f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  This function contains the experimental pi+p-->DELTA + rho cross
  /// sections  * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross
  /// section in mb                                    * C  earray =
  /// EXPerimental table with proton energies in MeV                    * C
  /// xarray = EXPerimental table with cross sections in mb (curve to guide eye)
  /// * C * C***************************************** C      real*4 xarray(15),
  /// earray(15)
  /// C
  sve.pmass = 0.14f;
  sve.pmass1 = 0.938f;
  return_value = 0.000001f;
  if (srt <= 1.36f) {
    return return_value;
  }
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  plab = srt;
  if (plab < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 15) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct fourpi_save {
  arr<float> earray;
  int ie;
  float plab;
  float pmass;
  float pmass1;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  fourpi_save()
      : earray(dimension(10), fem::fill0),
        ie(fem::int0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        xarray(dimension(10), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for ppi(+)-->DELTA+omega
/// C      real*4 function FOURPI(srt)
float fourpi(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fourpi);
  /// SAVE
  arr_ref<float> earray(sve.earray, dimension(10));
  int& ie = sve.ie;
  float& plab = sve.plab;
  arr_ref<float> xarray(sve.xarray, dimension(10));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {0.0001f,   1.986597f, 6.411932f, 7.636956f,
                                     9.598362f, 9.889740f, 10.24317f, 10.80138f,
                                     11.86988f, 12.83925f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {
          2.468f,     2.718f,     2.968f,     0.322e+01f, 0.347e+01f,
          0.372e+01f, 0.397e+01f, 0.422e+01f, 0.447e+01f, 0.472e+01f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  This function contains the experimental pi+p-->DELTA+PION cross
  /// sections
  /// * C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb
  /// * C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  /// C      real*4   xarray(10), earray(10)
  /// C
  sve.pmass = 0.14f;
  sve.pmass1 = 0.938f;
  return_value = 0.000001f;
  if (srt <= 1.52f) {
    return return_value;
  }
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  plab = srt;
  if (plab < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 10) {
    if (earray(ie) == plab) {
      return_value = xarray(ie);
      return return_value;
    } else if (earray(ie) > plab) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(plab) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return return_value;
    }
  }
  return return_value;
}

struct crpn_save {
  float ameson;
  float aomega;
  float arho;
  float c1;
  float cc1;
  float ct1;
  float dm;
  float dmax;
  float em1;
  float em2;
  int ianti;
  int ii;
  int ipi;
  int jj;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float x1;
  float x2;
  float xptr;

  crpn_save()
      : ameson(fem::float0),
        aomega(fem::float0),
        arho(fem::float0),
        c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        dm(fem::float0),
        dmax(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        ii(fem::int0),
        ipi(fem::int0),
        jj(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xptr(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crpn(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& xkaon0,
          float const& xkaon, float const& xphi, float const& xphin) {
  FEM_CMN_SVE(crpn);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& iseed = cmn.iseed;
  int& nseed = cmn.nseed;
  ///
  float& ameson = sve.ameson;
  float& aomega = sve.aomega;
  float& arho = sve.arho;
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& dm = sve.dm;
  float& dmax = sve.dmax;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kaonc = sve.kaonc;
  int& ntag = sve.ntag;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xptr = sve.xptr;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float aphi = 1.020f;
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  /// C     PURPOSE:                                                         *
  /// C           DEALING WITH PION+N-->L/S+KAON PROCESS AND PION PRODUCTION *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     7  PION+N-->L/S+KAON
  /// C           iblock   - 77 pion+N-->Delta+pion
  /// C           iblock   - 78 pion+N-->Delta+RHO
  /// C           iblock   - 79 pion+N-->Delta+OMEGA
  /// C           iblock   - 222 pion+N-->Phi
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
  }
  if (xkaon0 / (xkaon + xphi) >= x1) {
    /// C kaon production
    /// C-----------------------------------------------------------------------
    iblock = 7;
    if (ianti == 1) {
      iblock = -7;
    }
    ntag = 0;
    /// C RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
    /// C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
    /// C MOMENTA FOR PARTICLES IN THE FINAL STATE.
    kaonc = 0;
    if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
      kaonc = 1;
    }
    if (e(i1) <= 0.2f) {
      lb(i1) = 23;
      e(i1) = aka;
      if (kaonc == 1) {
        lb(i2) = 14;
        e(i2) = ala;
      } else {
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        e(i2) = asa;
      }
      if (ianti == 1) {
        lb(i1) = 21;
        lb(i2) = -lb(i2);
      }
    } else {
      lb(i2) = 23;
      e(i2) = aka;
      if (kaonc == 1) {
        lb(i1) = 14;
        e(i1) = ala;
      } else {
        lb(i1) = 15 + fem::fint(3 * ranart(nseed));
        e(i1) = asa;
      }
      if (ianti == 1) {
        lb(i2) = 21;
        lb(i1) = -lb(i1);
      }
    }
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
    /// C to gererate the momentum for the kaon and L/S
  } else if (xphi / (xkaon + xphi) >= x1) {
    iblock = 222;
    if (xphin / xphi >= ranart(nseed)) {
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      e(i1) = amn;
    } else {
      lb(i1) = 6 + fem::fint(4 * ranart(nseed));
      e(i1) = am0;
    }
    /// C  !! at present only baryon
    if (ianti == 1) {
      lb(i1) = -lb(i1);
    }
    lb(i2) = 29;
    e(i2) = aphi;
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
  } else {
    /// C CHECK WHAT KIND OF PION PRODUCTION PROCESS HAS HAPPENED
    if (ranart(nseed) <= twopi(cmn, srt) / (twopi(cmn, srt) + threpi(cmn, srt) +
                                            fourpi(cmn, srt))) {
      iblock = 77;
    } else {
      if (threpi(cmn, srt) / (threpi(cmn, srt) + fourpi(cmn, srt)) >
          ranart(nseed)) {
        iblock = 78;
      } else {
        iblock = 79;
      }
    }
    ntag = 0;
    /// C pion production (Delta+pion/rho/omega in the final state)
    /// C generate the mass of the delta resonance
    x2 = ranart(nseed);
    /// C relable the particles
    if (iblock == 77) {
      /// C GENERATE THE DELTA MASS
      dmax = srt - ap1 - 0.02f;
      dm = rmass(cmn, dmax, iseed);
      /// C pion+baryon-->pion+delta
      /// C Relable particles, I1 is assigned to the Delta and I2 is assigned to
      /// the C meson C(1) for pi(+)+p-->D(+)+P(+) OR D(++)+p(0)
      if (((lb(i1) == 1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          } else {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 4;
            sve.ipi = 4;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          } else {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      /// C(2) for pi(-)+p-->D(0)+P(0) OR D(+)+p(-),or D(-)+p(+)
      if (((lb(i1) == 1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      /// C(3) for pi(+)+n-->D(+)+Pi(0) OR D(++)+p(-) or D(0)+pi(+)
      if (((lb(i1) == 2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      /// C(4) for pi(0)+p-->D(+)+Pi(0) OR D(++)+p(-) or D(0)+pi(+)
      if ((fem::iabs(lb(i1)) == 1 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 1)) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      /// C(5) for pi(-)+n-->D(-)+P(0) OR D(0)+p(-)
      if (((lb(i1) == 2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          } else {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          } else {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
      /// C(6) for pi(0)+n-->D(0)+P(0), D(-)+p(+) or D(+)+p(-)
      if ((fem::iabs(lb(i1)) == 2 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 2)) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 4;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 <= 0.67f && x2 > 0.33f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 5;
            e(i2) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 3;
            e(i2) = ap1;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 4;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 <= 0.67f && x2 > 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 5;
            e(i1) = ap1;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 3;
            e(i1) = ap1;
            goto statement_40;
          }
        }
      }
    }
    if (iblock == 78) {
      rmasdd(cmn, srt, 1.232f, 0.77f, 1.08f, 0.28f, iseed, 4, dm, ameson);
      arho = ameson;
      /// C pion+baryon-->Rho+delta
      /// C(1) for pi(+)+p-->D(+)+rho(+) OR D(++)+rho(0)
      if (((lb(i1) == 1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          } else {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          } else {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      /// C(2) for pi(-)+p-->D(+)+rho(-) OR D(0)+rho(0) or D(-)+rho(+)
      if (((lb(i1) == 1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      /// C(3) for pi(+)+n-->D(+)+rho(0) OR D(++)+rho(-) or D(0)+rho(+)
      if (((lb(i1) == 2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      /// C(4) for pi(0)+p-->D(+)+rho(0) OR D(++)+rho(-) or D(0)+rho(+)
      if ((fem::iabs(lb(i1)) == 1 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 1)) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 9;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 9;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      /// C(5) for pi(-)+n-->D(-)+rho(0) OR D(0)+rho(-)
      if (((lb(i1) == 2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.5f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          } else {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
            goto statement_40;
          }
        } else {
          ii = i2;
          if (x2 <= 0.5f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          } else {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
            goto statement_40;
          }
        }
      }
      /// C(6) for pi(0)+n-->D(0)+rho(0), D(-)+rho(+) and D(+)+rho(-)
      if ((fem::iabs(lb(i1)) == 2 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 2)) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          if (x2 <= 0.33f) {
            lb(i1) = 7;
            e(i1) = dm;
            lb(i2) = 26;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.33f && x2 <= 0.67f) {
            lb(i1) = 6;
            e(i1) = dm;
            lb(i2) = 27;
            e(i2) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i1) = 8;
            e(i1) = dm;
            lb(i2) = 25;
            e(i2) = arho;
          }
        } else {
          ii = i2;
          if (x2 <= 0.33f) {
            lb(i2) = 7;
            e(i2) = dm;
            lb(i1) = 26;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 <= 0.67f && x2 > 0.33f) {
            lb(i2) = 6;
            e(i2) = dm;
            lb(i1) = 27;
            e(i1) = arho;
            goto statement_40;
          }
          if (x2 > 0.67f) {
            lb(i2) = 8;
            e(i2) = dm;
            lb(i1) = 25;
            e(i1) = arho;
          }
        }
      }
    }
    if (iblock == 79) {
      aomega = 0.782f;
      /// C GENERATE THE DELTA MASS
      dmax = srt - 0.782f - 0.02f;
      dm = rmass(cmn, dmax, iseed);
      /// C pion+baryon-->omega+delta
      /// C(1) for pi(+)+p-->D(++)+omega(0)
      if (((lb(i1) == 1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          lb(i1) = 9;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 9;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      /// C(2) for pi(-)+p-->D(0)+omega(0)
      if (((lb(i1) == 1 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 1)) ||
          ((lb(i1) == -1 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -1))) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          lb(i1) = 7;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 7;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      /// C(3) for pi(+)+n-->D(+)+omega(0)
      if (((lb(i1) == 2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          lb(i1) = 8;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 8;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      /// C(4) for pi(0)+p-->D(+)+omega(0)
      if ((fem::iabs(lb(i1)) == 1 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 1)) {
        if (fem::iabs(lb(i1)) == 1) {
          ii = i1;
          lb(i1) = 8;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 8;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
          goto statement_40;
        }
      }
      /// C(5) for pi(-)+n-->D(-)+omega(0)
      if (((lb(i1) == 2 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 2)) ||
          ((lb(i1) == -2 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -2))) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          lb(i1) = 6;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 6;
          e(i2) = dm;
          lb(i1) = 28;
          e(i1) = aomega;
        }
      }
      /// C(6) for pi(0)+n-->D(0)+omega(0)
      if ((fem::iabs(lb(i1)) == 2 && lb(i2) == 4) ||
          (lb(i1) == 4 && fem::iabs(lb(i2)) == 2)) {
        if (fem::iabs(lb(i1)) == 2) {
          ii = i1;
          lb(i1) = 7;
          e(i1) = dm;
          lb(i2) = 28;
          e(i2) = aomega;
          goto statement_40;
        } else {
          ii = i2;
          lb(i2) = 7;
          e(i2) = dm;
          lb(i1) = 26;
          e(i1) = arho;
          goto statement_40;
        }
      }
    }
  statement_40:
    em1 = e(i1);
    em2 = e(i2);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(ii) = -lb(ii);
      jj = i2;
      if (ii == i2) {
        jj = i1;
      }
      if (iblock == 77) {
        if (lb(jj) == 3) {
          lb(jj) = 5;
        } else if (lb(jj) == 5) {
          lb(jj) = 3;
        }
      } else if (iblock == 78) {
        if (lb(jj) == 25) {
          lb(jj) = 27;
        } else if (lb(jj) == 27) {
          lb(jj) = 25;
        }
      }
    }
  }
/// C-----------------------------------------------------------------------
/// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
/// C ENERGY CONSERVATION
statement_50:
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 0.00000001f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C here we use the same transverse momentum distribution as for
  /// C pp collisions, it might be necessary to use a different distribution
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  /// C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, iseed);
  /// Clin-10/25/02-end
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck36: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  /// C         c1=sqrt(pr**2-cc1**2)/pr
  /// C
  /// C          C1   = 1.0 - 2.0 * RANART(NSEED)
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct cren_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ianti;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  cren_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void cren(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(cren);
  /// COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& kaonc = sve.kaonc;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH ETA+N-->L/S+KAON PROCESS                   *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     7  ETA+N-->L/S+KAON
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  sve.ntag = 0;
  iblock = 7;
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
    iblock = -7;
  }
  /// C RELABLE PARTICLES FOR THE PROCESS eta+n-->LAMBDA K OR SIGMA k
  /// C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
  /// C MOMENTA FOR PARTICLES IN THE FINAL STATE.
  kaonc = 0;
  if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
    kaonc = 1;
  }
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  if (e(i1) <= 0.6f) {
    lb(i1) = 23;
    e(i1) = aka;
    if (kaonc == 1) {
      lb(i2) = 14;
      e(i2) = ala;
    } else {
      lb(i2) = 15 + fem::fint(3 * ranart(nseed));
      e(i2) = asa;
    }
    if (ianti == 1) {
      lb(i1) = 21;
      lb(i2) = -lb(i2);
    }
  } else {
    lb(i2) = 23;
    e(i2) = aka;
    if (kaonc == 1) {
      lb(i1) = 14;
      e(i1) = ala;
    } else {
      lb(i1) = 15 + fem::fint(3 * ranart(nseed));
      e(i1) = asa;
    }
    if (ianti == 1) {
      lb(i2) = 21;
      lb(i1) = -lb(i1);
    }
  }
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crdir_save {
  float c1;
  float cc1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float xptr;

  crdir_save()
      : c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        xptr(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
/// C      SUBROUTINE Crdir(PX,PY,PZ,SRT,I1,I2)
void crdir(common& cmn, float& px, float& py, float& pz, float const& srt,
           int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crdir);
  common_write write(cmn);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& xptr = sve.xptr;
  ///
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH pion+N-->pion+N PROCESS                   *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 999;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  /// C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, cmn.iseed);
  /// Clin-10/25/02-end
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck37: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  /// C         c1=sqrt(pr**2-cc1**2)/pr
  /// C
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(cmn.nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE the momentum
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crpd_save {
  float c1;
  float cc1;
  float ct1;
  float em1;
  float em2;
  int ianti;
  int ii;
  int jj;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float x1;
  float x2;
  float xptr;

  crpd_save()
      : c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xptr(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crpd(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& xkaon0,
          float const& xkaon, float const& xphi, float const& xphin) {
  FEM_CMN_SVE(crpd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kaonc = sve.kaonc;
  int& ntag = sve.ntag;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xptr = sve.xptr;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float aphi = 1.020f;
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  /// C     PURPOSE:                                                         *
  /// C     DEALING WITH PION+D(N*)-->PION +N OR
  /// C                                             L/S+KAON PROCESS         *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     7  PION+D(N*)-->L/S+KAON
  /// C           iblock   - 80 pion+D(N*)-->pion+N
  /// C           iblock   - 81 RHO+D(N*)-->PION+N
  /// C           iblock   - 82 OMEGA+D(N*)-->PION+N
  /// C                     222  PION+D --> PHI
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  x1 = ranart(nseed);
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
  }
  if (xkaon0 / (xkaon + xphi) >= x1) {
    /// C kaon production
    /// C-----------------------------------------------------------------------
    iblock = 7;
    if (ianti == 1) {
      iblock = -7;
    }
    ntag = 0;
    /// C RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
    /// C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
    /// C MOMENTA FOR PARTICLES IN THE FINAL STATE.
    kaonc = 0;
    if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
      kaonc = 1;
    }
    /// Clin-8/17/00     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
    if (e(i1) <= 0.2f) {
      lb(i1) = 23;
      e(i1) = aka;
      if (kaonc == 1) {
        lb(i2) = 14;
        e(i2) = ala;
      } else {
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        e(i2) = asa;
      }
      if (ianti == 1) {
        lb(i1) = 21;
        lb(i2) = -lb(i2);
      }
    } else {
      lb(i2) = 23;
      e(i2) = aka;
      if (kaonc == 1) {
        lb(i1) = 14;
        e(i1) = ala;
      } else {
        lb(i1) = 15 + fem::fint(3 * ranart(nseed));
        e(i1) = asa;
      }
      if (ianti == 1) {
        lb(i2) = 21;
        lb(i1) = -lb(i1);
      }
    }
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
    /// C to gererate the momentum for the kaon and L/S
    /// C
    /// C* Phi production
  } else if (xphi / (xkaon + xphi) >= x1) {
    iblock = 222;
    if (xphin / xphi >= ranart(nseed)) {
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      e(i1) = amn;
    } else {
      lb(i1) = 6 + fem::fint(4 * ranart(nseed));
      e(i1) = am0;
    }
    /// C   !! at present only baryon
    if (ianti == 1) {
      lb(i1) = -lb(i1);
    }
    lb(i2) = 29;
    e(i2) = aphi;
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
  } else {
    /// C PION REABSORPTION HAS HAPPENED
    x2 = ranart(nseed);
    iblock = 80;
    ntag = 0;
    /// C Relable particles, I1 is assigned to the nucleon
    /// C and I2 is assigned to the pion
    /// C for the reverse of the following process
    /// C(1) for D(+)+P(+)-->p+pion(+)
    if (((lb(i1) == 8 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C
    /// C(2) for D(0)+P(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 7 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 7)) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(3) for D(+)+Pi(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 8 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 8)) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(4) for D(-)+Pi(0)-->n+pi(-)
    if ((fem::iabs(lb(i1)) == 6 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 6)) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(5) for D(+)+Pi(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 8 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(6) D(0)+P(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 7 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(7) for D(0)+Pi(-)-->n+pi(-)
    if (((lb(i1) == 7 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(8) D(-)+P(+)-->n+pi(0) or p+pi(-)
    if (((lb(i1) == 6 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 6)) ||
        ((lb(i1) == -6 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -6))) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C
    /// C(9) D(++)+P(-)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 9 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 9)) ||
        ((lb(i1) == -9 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -9))) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(10) for D(++)+Pi(0)-->p+pi(+)
    if ((fem::iabs(lb(i1)) == 9 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 9)) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(11) for N*(1440)(+)or N*(1535)(+)+P(+)-->p+pion(+)
    if (((lb(i1) == 11 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 11) ||
         (lb(i1) == 13 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -11) ||
         (lb(i1) == -13 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(12) for N*(1440) or N*(1535)(0)+P(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 10 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 10) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 12) ||
        (lb(i2) == 4 && fem::iabs(lb(i1)) == 12)) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(13) for N*(1440) or N*(1535)(+)+Pi(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 11 && lb(i2) == 4) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 11) ||
        (lb(i1) == 4 && fem::iabs(lb(i2)) == 13) ||
        (lb(i2) == 4 && fem::iabs(lb(i1)) == 13)) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(14) for N*(1440) or N*(1535)(+)+Pi(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 11 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 11) ||
         (lb(i1) == 3 && lb(i2) == 13) || (lb(i2) == 3 && lb(i1) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -11) ||
         (lb(i1) == 5 && lb(i2) == -13) || (lb(i2) == 5 && lb(i1) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(15) N*(1440) or N*(1535)(0)+P(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 10 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 10) ||
         (lb(i1) == 12 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == 12)) ||
        ((lb(i1) == -10 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -10) ||
         (lb(i1) == -12 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == -12))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(16) for N*(1440) or N*(1535) (0)+Pi(-)-->n+pi(-)
    if (((lb(i1) == 10 && lb(i2) == 3) || (lb(i1) == 3 && lb(i2) == 10) ||
         (lb(i1) == 3 && lb(i2) == 12) || (lb(i1) == 12 && lb(i2) == 3)) ||
        ((lb(i1) == -10 && lb(i2) == 5) || (lb(i1) == 5 && lb(i2) == -10) ||
         (lb(i1) == 5 && lb(i2) == -12) || (lb(i1) == -12 && lb(i2) == 5))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
  statement_40:
    em1 = e(i1);
    em2 = e(i2);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(ii) = -lb(ii);
      jj = i2;
      if (ii == i2) {
        jj = i1;
      }
      if (lb(jj) == 3) {
        lb(jj) = 5;
      } else if (lb(jj) == 5) {
        lb(jj) = 3;
      }
    }
  }
/// C-----------------------------------------------------------------------
/// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
/// C ENERGY CONSERVATION
statement_50:
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  /// C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, cmn.iseed);
  /// Clin-10/25/02-end
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck38: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  /// C         c1=sqrt(pr**2-cc1**2)/pr
  /// C
  /// C         C1   = 1.0 - 2.0 * RANART(NSEED)
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C rotate the momentum
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crrd_save {
  float c1;
  float cc1;
  float ct1;
  float em1;
  float em2;
  int ianti;
  int ii;
  int jj;
  int kaonc;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float scheck;
  float st1;
  float t1;
  float x1;
  float x2;
  float xptr;

  crrd_save()
      : c1(fem::float0),
        cc1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ianti(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        kaonc(fem::int0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xptr(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crrd(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock, float const& xkaon0,
          float const& xkaon, float const& xphi, float const& xphin) {
  FEM_CMN_SVE(crrd);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& cc1 = sve.cc1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& ianti = sve.ianti;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kaonc = sve.kaonc;
  int& ntag = sve.ntag;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xptr = sve.xptr;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float asa = 1.1974f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float aphi = 1.02f;
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  /// C     PURPOSE:                                                         *
  /// C     DEALING WITH rho(omega)+N or D(N*)-->PION +N OR
  /// C                                             L/S+KAON PROCESS         *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     7  rho(omega)+N or D(N*)-->L/S+KAON
  /// C           iblock   - 80 pion+D(N*)-->pion+N
  /// C           iblock   - 81 RHO+D(N*)-->PION+N
  /// C           iblock   - 82 OMEGA+D(N*)-->PION+N
  /// C           iblock   - 222 pion+N-->Phi
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1;
  ianti = 0;
  if (lb(i1) < 0 || lb(i2) < 0) {
    ianti = 1;
  }
  x1 = ranart(nseed);
  if (xkaon0 / (xkaon + xphi) >= x1) {
    /// C kaon production
    /// C-----------------------------------------------------------------------
    iblock = 7;
    if (ianti == 1) {
      iblock = -7;
    }
    ntag = 0;
    /// C RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
    /// C DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
    /// C MOMENTA FOR PARTICLES IN THE FINAL STATE.
    kaonc = 0;
    if (pnlka(cmn, srt) / (pnlka(cmn, srt) + pnska(cmn, srt)) > ranart(nseed)) {
      kaonc = 1;
    }
    /// Clin-8/17/00     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
    if (e(i1) <= 0.92f) {
      lb(i1) = 23;
      e(i1) = aka;
      if (kaonc == 1) {
        lb(i2) = 14;
        e(i2) = ala;
      } else {
        lb(i2) = 15 + fem::fint(3 * ranart(nseed));
        e(i2) = asa;
      }
      if (ianti == 1) {
        lb(i1) = 21;
        lb(i2) = -lb(i2);
      }
    } else {
      lb(i2) = 23;
      e(i2) = aka;
      if (kaonc == 1) {
        lb(i1) = 14;
        e(i1) = ala;
      } else {
        lb(i1) = 15 + fem::fint(3 * ranart(nseed));
        e(i1) = asa;
      }
      if (ianti == 1) {
        lb(i2) = 21;
        lb(i1) = -lb(i1);
      }
    }
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
    /// C to gererate the momentum for the kaon and L/S
    /// C
    /// C* Phi production
  } else if (xphi / (xkaon + xphi) >= x1) {
    iblock = 222;
    if (xphin / xphi >= ranart(nseed)) {
      lb(i1) = 1 + fem::fint(2 * ranart(nseed));
      e(i1) = amn;
    } else {
      lb(i1) = 6 + fem::fint(4 * ranart(nseed));
      e(i1) = am0;
    }
    /// C   !! at present only baryon
    if (ianti == 1) {
      lb(i1) = -lb(i1);
    }
    lb(i2) = 29;
    e(i2) = aphi;
    em1 = e(i1);
    em2 = e(i2);
    goto statement_50;
  } else {
    /// C rho(omega) REABSORPTION HAS HAPPENED
    x2 = ranart(nseed);
    iblock = 81;
    ntag = 0;
    if (lb(i1) == 28 || lb(i2) == 28) {
      goto statement_60;
    }
    /// C we treat Rho reabsorption in the following
    /// C Relable particles, I1 is assigned to the Delta
    /// C and I2 is assigned to the meson
    /// C for the reverse of the following process
    /// C(1) for D(+)+rho(+)-->p+pion(+)
    if (((lb(i1) == 8 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(2) for D(0)+rho(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 7 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 7)) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(3) for D(+)+rho(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 8 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 8)) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(4) for D(-)+rho(0)-->n+pi(-)
    if ((fem::iabs(lb(i1)) == 6 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 6)) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(5) for D(+)+rho(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 8 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 8)) ||
        ((lb(i1) == -8 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -8))) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(6) D(0)+rho(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 7 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(7) for D(0)+rho(-)-->n+pi(-)
    if (((lb(i1) == 7 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 7)) ||
        ((lb(i1) == -7 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -7))) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(8) D(-)+rho(+)-->n+pi(0) or p+pi(-)
    if (((lb(i1) == 6 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 6)) ||
        ((lb(i1) == -6 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -6))) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(9) D(++)+rho(-)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 9 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 9)) ||
        ((lb(i1) == -9 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -9))) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(10) for D(++)+rho(0)-->p+pi(+)
    if ((fem::iabs(lb(i1)) == 9 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 9)) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(11) for N*(1440)(+)or N*(1535)(+)+rho(+)-->p+pion(+)
    if (((lb(i1) == 11 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 11) ||
         (lb(i1) == 13 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -11) ||
         (lb(i1) == -13 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(12) for N*(1440) or N*(1535)(0)+rho(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 10 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 10) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 12) ||
        (lb(i2) == 26 && fem::iabs(lb(i1)) == 12)) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(13) for N*(1440) or N*(1535)(+)+rho(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 11 && lb(i2) == 26) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 11) ||
        (lb(i1) == 26 && fem::iabs(lb(i2)) == 13) ||
        (lb(i2) == 26 && fem::iabs(lb(i1)) == 13)) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(14) for N*(1440) or N*(1535)(+)+rho(-)-->pi(0)+n or pi(-)+p
    if (((lb(i1) == 11 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 11) ||
         (lb(i1) == 25 && lb(i2) == 13) || (lb(i2) == 25 && lb(i1) == 13)) ||
        ((lb(i1) == -11 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -11) ||
         (lb(i1) == 27 && lb(i2) == -13) || (lb(i2) == 27 && lb(i1) == -13))) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(15) N*(1440) or N*(1535)(0)+rho(+)-->n+pi(+) or p+pi(0)
    if (((lb(i1) == 10 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 10) ||
         (lb(i1) == 12 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == 12)) ||
        ((lb(i1) == -10 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -10) ||
         (lb(i1) == -12 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == -12))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(16) for N*(1440) or N*(1535) (0)+rho(-)-->n+pi(-)
    if (((lb(i1) == 10 && lb(i2) == 25) || (lb(i1) == 25 && lb(i2) == 10) ||
         (lb(i1) == 25 && lb(i2) == 12) || (lb(i1) == 12 && lb(i2) == 25)) ||
        ((lb(i1) == -10 && lb(i2) == 27) || (lb(i1) == 27 && lb(i2) == -10) ||
         (lb(i1) == 27 && lb(i2) == -12) || (lb(i1) == -12 && lb(i2) == 27))) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
  statement_60:
    iblock = 82;
    /// C FOR OMEGA REABSORPTION
    /// C Relable particles, I1 is assigned to the Delta
    /// C and I2 is assigned to the meson
    /// C for the reverse of the following process
    /// C(1) for D(0)+OMEGA(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 7 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 7)) {
      if (fem::iabs(lb(i1)) == 7) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(2) for D(+)+OMEGA(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 8 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 8)) {
      if (fem::iabs(lb(i1)) == 8) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(3) for D(-)+OMEGA(0)-->n+pi(-)
    if ((fem::iabs(lb(i1)) == 6 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 6)) {
      if (fem::iabs(lb(i1)) == 6) {
        ii = i1;
        lb(i1) = 2;
        e(i1) = amn;
        lb(i2) = 3;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 2;
        e(i2) = amn;
        lb(i1) = 3;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(4) for D(++)+OMEGA(0)-->p+pi(+)
    if ((fem::iabs(lb(i1)) == 9 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 9)) {
      if (fem::iabs(lb(i1)) == 9) {
        ii = i1;
        lb(i1) = 1;
        e(i1) = amn;
        lb(i2) = 5;
        e(i2) = ap1;
        goto statement_40;
      } else {
        ii = i2;
        lb(i2) = 1;
        e(i2) = amn;
        lb(i1) = 5;
        e(i1) = ap1;
        goto statement_40;
      }
    }
    /// C(5) for N*(1440) or N*(1535)(0)+omega(0)-->n+pi(0) or p+pi(-)
    if ((fem::iabs(lb(i1)) == 10 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 10) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 12) ||
        (lb(i2) == 28 && fem::iabs(lb(i1)) == 12)) {
      if (fem::iabs(lb(i1)) == 10 || fem::iabs(lb(i1)) == 12) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 3;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 3;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
    /// C(6) for N*(1440) or N*(1535)(+)+omega(0)-->pi(+)+n or pi(0)+p
    if ((fem::iabs(lb(i1)) == 11 && lb(i2) == 28) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 11) ||
        (lb(i1) == 28 && fem::iabs(lb(i2)) == 13) ||
        (lb(i2) == 28 && fem::iabs(lb(i1)) == 13)) {
      if (fem::iabs(lb(i1)) == 11 || fem::iabs(lb(i1)) == 13) {
        ii = i1;
        if (x2 <= 0.5f) {
          lb(i1) = 2;
          e(i1) = amn;
          lb(i2) = 5;
          e(i2) = ap1;
          goto statement_40;
        } else {
          lb(i1) = 1;
          e(i1) = amn;
          lb(i2) = 4;
          e(i2) = ap1;
          goto statement_40;
        }
      } else {
        ii = i2;
        if (x2 <= 0.5f) {
          lb(i2) = 2;
          e(i2) = amn;
          lb(i1) = 5;
          e(i1) = ap1;
          goto statement_40;
        } else {
          lb(i2) = 1;
          e(i2) = amn;
          lb(i1) = 4;
          e(i1) = ap1;
          goto statement_40;
        }
      }
    }
  statement_40:
    em1 = e(i1);
    em2 = e(i2);
    if (ianti == 1 && lb(i1) >= 1 && lb(i2) >= 1) {
      lb(ii) = -lb(ii);
      jj = i2;
      if (ii == i2) {
        jj = i1;
      }
      if (lb(jj) == 3) {
        lb(jj) = 5;
      } else if (lb(jj) == 5) {
        lb(jj) = 3;
      }
    }
  }
/// C-----------------------------------------------------------------------
/// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
/// C ENERGY CONSERVATION
statement_50:
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C          C1   = 1.0 - 2.0 * RANART(NSEED)
  /// C
  /// Clin-10/25/02 get rid of argument usage mismatch in PTR():
  xptr = 0.33f * pr;
  /// C         cc1=ptr(0.33*pr,iseed)
  cc1 = ptr(cmn, xptr, cmn.iseed);
  /// Clin-10/25/02-end
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(pr) - fem::pow2(cc1);
  if (scheck < 0) {
    write(99, star), "scheck39: ", scheck;
    scheck = 0.f;
  }
  c1 = fem::sqrt(scheck) / pr;
  /// C         c1=sqrt(pr**2-cc1**2)/pr
  /// C
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE THE MOMENTUM
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crlaba_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float rrr;
  float s1;
  float st1;
  float t1;

  crlaba_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        rrr(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C*********************************
/// C sp 03/19/01                                                          *
/// C                                                                      *
void crlaba(common& cmn, float& px, float& py, float& pz, float const& srt,
            float const& brel, float const& brsgm, int const& i1, int const& i2,
            int const& /* nt */, int& iblock, int const& nchrg,
            int const& icase) {
  FEM_CMN_SVE(crlaba);
  /// COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& rrr = sve.rrr;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     PURPOSE:                                                         *
  /// C            DEALING WITH   K+ + N(D,N*)-bar <-->  La(Si)-bar + pi     *
  /// C     NOTE   :                                                         *
  /// C                                                                      *
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     8-> elastic scatt                               *
  /// C                     100-> K+ + N-bar -> Sigma-bar + PI
  /// C                     102-> PI + Sigma(Lambda)-bar -> K+ + N-bar
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  /// C
  const float asa = 1.1974f;
  const float ala = 1.1157f;
  if (icase == 3) {
    rrr = ranart(nseed);
    if (rrr < brel) {
      /// C            !! elastic scat.  (avoid in reverse process)
      iblock = 8;
    } else {
      iblock = 100;
      if (rrr < (brel + brsgm)) {
        /// C*    K+ + N-bar -> Sigma-bar + PI
        lb(i1) = -15 - fem::fint(3 * ranart(nseed));
        /// C
        e(i1) = asa;
      } else {
        /// C*    K+ + N-bar -> Lambda-bar + PI
        lb(i1) = -14;
        e(i1) = ala;
      }
      lb(i2) = 3 + fem::fint(3 * ranart(nseed));
      e(i2) = 0.138f;
    }
  }
  /// C
  const float aka = 0.498f;
  if (icase == 4) {
    rrr = ranart(nseed);
    if (rrr < brel) {
      /// C            !! elastic scat.
      iblock = 8;
    } else {
      iblock = 102;
      /// C    PI + Sigma(Lambda)-bar -> K+ + N-bar
      /// C         ! K+
      lb(i1) = 23;
      lb(i2) = -1 - fem::fint(2 * ranart(nseed));
      if (nchrg == -2) {
        lb(i2) = -6;
      }
      if (nchrg == 1) {
        lb(i2) = -9;
      }
      e(i1) = aka;
      e(i2) = 0.938f;
      if (nchrg == -2 || nchrg == 1) {
        e(i2) = 1.232f;
      }
    }
  }
  /// C
  em1 = e(i1);
  em2 = e(i2);
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crkn_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crkn_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crkn(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crkn);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH kaON+N/pi-->KAON +N/pi elastic PROCESS      *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     8-> PION+N-->L/S+KAON
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  /// C-----------------------------------------------------------------------
  iblock = 8;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
}

struct pbarfs_save {
  float ene;
  arr<float> factor;
  int n;
  int ntry;
  float pmax;
  arr<float> pnpi;
  float thisp;

  pbarfs_save()
      : ene(fem::float0),
        factor(dimension(6), fem::fill0),
        n(fem::int0),
        ntry(fem::int0),
        pmax(fem::float0),
        pnpi(dimension(6), fem::fill0),
        thisp(fem::float0) {}
};

/// Cbali1/16/99 end
/// C*********************************
/// Cbali2/6/99
/// C*******************************************
/// C Purpose: To generate randomly the no. of pions in the final
/// C          state of pp_bar annihilation according to a statistical
/// C          model by using of the rejection method.
/// Cbz2/25/99
/// C      real*4 function pbarfs(srt,npion,iseed)
void pbarfs(common& cmn, float const& srt, int& npion, int const& /* iseed */) {
  FEM_CMN_SVE(pbarfs);
  int& nseed = cmn.nseed;
  ///
  float& ene = sve.ene;
  arr_ref<float> factor(sve.factor, dimension(6));
  int& n = sve.n;
  int& ntry = sve.ntry;
  float& pmax = sve.pmax;
  arr_ref<float> pnpi(sve.pnpi, dimension(6));
  float& thisp = sve.thisp;
  const float pimass = 0.140f;
  const float pi = 3.1415926f;
  /// Cbz2/25/99end
  /// C Quantities:
  /// C  srt: DSQRT(s) in GeV * C  npion: No. of pions produced in the
  /// annihilation of ppbar at srt        * C  nmax=6, cutoff of the maximum no.
  /// of n the code can handle
  /// C
  /// C  Reference: C.M. Ko and R. Yuan, Phys. Lett. B192 (1987) 31      *
  /// C
  /// C*****************************************
  /// Cc      SAVE /RNDF77/
  /// C the factorial coefficients in the pion no. distribution
  /// C from n=2 to 6 calculated use the formula in the reference
  factor(2) = 1.f;
  factor(3) = 1.17e-01f;
  factor(4) = 3.27e-03f;
  factor(5) = 3.58e-05f;
  factor(6) = 1.93e-07f;
  ene = fem::pow3((srt / pimass)) / (6.f * fem::pow2(pi));
  /// C the relative probability from n=2 to 6
  FEM_DO_SAFE(n, 2, 6) { pnpi(n) = fem::pow(ene, n) * factor(n); }
  /// C find the maximum of the probabilities, I checked a
  /// C Fortan manual: max() returns the maximum value of
  /// C the same type as in the argument list
  pmax = fem::max(pnpi(2), pnpi(3), pnpi(4), pnpi(5), pnpi(6));
  /// C randomly generate n between 2 and 6
  ntry = 0;
statement_10:
  npion = 2 + fem::fint(5 * ranart(nseed));
  /// Clin-4/2008 check bounds:
  if (npion > 6) {
    goto statement_10;
  }
  thisp = pnpi(npion) / pmax;
  ntry++;
  /// C decide whether to take this npion according to the distribution
  /// C using rejection method.
  if ((thisp < ranart(nseed)) && (ntry <= 20)) {
    goto statement_10;
  }
  /// C now take the last generated npion and return
}

struct crppba_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int nchrg1;
  int nchrg2;
  int npion;
  float pmass1;
  float pmass2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crppba_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        nchrg1(fem::int0),
        nchrg2(fem::int0),
        npion(fem::int0),
        pmass1(fem::float0),
        pmass2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crppba(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crppba);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& nchrg1 = sve.nchrg1;
  int& nchrg2 = sve.nchrg2;
  int& npion = sve.npion;
  float& pmass1 = sve.pmass1;
  float& pmass2 = sve.pmass2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  const float ap1 = 0.13496f;
  const float ap2 = 0.13957f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  const float pi = 3.1415926f;
  /// C     PURPOSE:                                                         *
  /// C
  /// Clin-8/29/00*             DEALING WITH anti-nucleon annihilation with
  /// C             DEALING WITH anti-baryon annihilation with
  /// C
  /// C             nucleons or baryon resonances
  /// C             Determine:                                               *
  /// C             (1) no. of pions in the final state
  /// C             (2) relable particles in the final state
  /// C             (3) new momenta of final state particles                 *
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - INFORMATION about the reaction channel          *
  /// C
  /// C           iblock   - 1902 annihilation-->pion(+)+pion(-)   (2 pion)
  /// C           iblock   - 1903 annihilation-->pion(+)+rho(-)    (3 pion)
  /// C           iblock   - 1904 annihilation-->rho(+)+rho(-)     (4 pion)
  /// C           iblock   - 1905 annihilation-->rho(0)+omega      (5 pion)
  /// C           iblock   - 1906 annihilation-->omega+omega       (6 pion)
  /// C       charge conservation is enforced in relabling particles
  /// C       in the final state (note: at the momentum we don't check the
  /// C       initial charges while dealing with annihilation, since some
  /// C       annihilation channels between antinucleons and nucleons (baryon
  /// C       resonances) might be forbiden by charge conservation, this effect
  /// C       should be small, but keep it in mind.
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  /// C determine the no. of pions in the final state using a
  /// C statistical model
  pbarfs(cmn, srt, npion, cmn.iseed);
  /// C find the masses of the final state particles before calculate
  /// C their momenta, and relable them. The masses of rho and omega
  /// C will be generated according to the Breit Wigner formula       (NOTE!!!
  /// C NOT DONE YET, AT THE MOMENT LET US USE FIXED RHO AND OMEGA MAEES)
  /// Cbali2/22/99
  /// C Here we generate two stes of integer random numbers (3,4,5)
  /// C one or both of them are used directly as the lables of pions
  /// C similarly, 22+nchrg1 and 22+nchrg2 are used directly
  /// C to label rhos
  nchrg1 = 3 + fem::fint(3 * ranart(nseed));
  nchrg2 = 3 + fem::fint(3 * ranart(nseed));
  /// C the corresponding masses of pions
  pmass1 = ap1;
  pmass2 = ap1;
  if (nchrg1 == 3 || nchrg1 == 5) {
    pmass1 = ap2;
  }
  if (nchrg2 == 3 || nchrg2 == 5) {
    pmass2 = ap2;
  }
  /// C (1) for 2 pion production
  if (npion == 2) {
    iblock = 1902;
    /// C randomly generate the charges of final state particles,
    lb(i1) = nchrg1;
    e(i1) = pmass1;
    lb(i2) = nchrg2;
    e(i2) = pmass2;
    /// C TO CALCULATE THE FINAL MOMENTA
    goto statement_50;
  }
  /// C (2) FOR 3 PION PRODUCTION
  if (npion == 3) {
    iblock = 1903;
    lb(i1) = nchrg1;
    e(i1) = pmass1;
    lb(i2) = 22 + nchrg2;
    e(i2) = amrho;
    goto statement_50;
  }
  /// C (3) FOR 4 PION PRODUCTION
  /// C we allow both rho+rho and pi+omega with 50-50% probability
  if (npion == 4) {
    iblock = 1904;
    /// C determine rho+rho or pi+omega
    if (ranart(nseed) >= 0.5f) {
      /// C rho+rho
      lb(i1) = 22 + nchrg1;
      e(i1) = amrho;
      lb(i2) = 22 + nchrg2;
      e(i2) = amrho;
    } else {
      /// C pion+omega
      lb(i1) = nchrg1;
      e(i1) = pmass1;
      lb(i2) = 28;
      e(i2) = amomga;
    }
    goto statement_50;
  }
  /// C (4) FOR 5 PION PRODUCTION
  if (npion == 5) {
    iblock = 1905;
    /// C RHO AND OMEGA
    lb(i1) = 22 + nchrg1;
    e(i1) = amrho;
    lb(i2) = 28;
    e(i2) = amomga;
    goto statement_50;
  }
  /// C (5) FOR 6 PION PRODUCTION
  if (npion == 6) {
    iblock = 1906;
    /// C OMEGA AND OMEGA
    lb(i1) = 28;
    e(i1) = amomga;
    lb(i2) = 28;
    e(i2) = amomga;
  }
/// Cbali2/22/99
statement_50:
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crkhyp_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;
  float x1;

  crkhyp_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0) {}
};

/// C*********************************
/// C     PURPOSE:                                                         *
/// C             DEALING WITH K+Y -> piN scattering
/// C
void crkhyp(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, float const& xky1, float& xky2,
            float& xky3, float& xky4, float& xky5, float& xky6, float& xky7,
            float& xky8, float& xky9, float& xky10, float& xky11, float& xky12,
            float& xky13, float& xky14, float& xky15, float& xky16,
            float const& /* xky17 */, float const& sigk, int const& ikmp,
            int& iblock) {
  FEM_CMN_SVE(crkhyp);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  const float pimass = 0.140f;
  const float amp = 0.93828f;
  const float am0 = 1.232f;
  const float am1440 = 1.44f;
  const float am1535 = 1.535f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  const float ameta = 0.5473f;
  const float aphi = 1.02f;
  const float amn = 0.939457f;
  const float pi = 3.1415926f;
  /// C
  /// C             Determine:                                               *
  /// C             (1) relable particles in the final state                 *
  /// C             (2) new momenta of final state particles                 *
  /// C                                                                        *
  /// C     QUANTITIES:                                                    *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - INFORMATION about the reaction channel          *
  /// C                                                                     *
  /// C             iblock   - 1908                                          *
  /// C             iblock   - 222   !! phi                                  *
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 1908;
  /// C
  x1 = ranart(nseed) * sigk;
  xky2 += xky1;
  xky3 += xky2;
  xky4 += xky3;
  xky5 += xky4;
  xky6 += xky5;
  xky7 += xky6;
  xky8 += xky7;
  xky9 += xky8;
  xky10 += xky9;
  xky11 += xky10;
  xky12 += xky11;
  xky13 += xky12;
  xky14 += xky13;
  xky15 += xky14;
  xky16 += xky15;
  if (x1 <= xky1) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky3) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky4) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = pimass;
    e(i2) = am1535;
    goto statement_100;
  } else if (x1 <= xky5) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky6) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky7) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky8) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = am1535;
    goto statement_100;
  } else if (x1 <= xky9) {
    lb(i1) = 28;
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky10) {
    lb(i1) = 28;
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky11) {
    lb(i1) = 28;
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky12) {
    lb(i1) = 28;
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = amomga;
    e(i2) = am1535;
    goto statement_100;
  } else if (x1 <= xky13) {
    lb(i1) = 0;
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = amp;
    goto statement_100;
  } else if (x1 <= xky14) {
    lb(i1) = 0;
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xky15) {
    lb(i1) = 0;
    lb(i2) = 10 + fem::fint(2 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = am1440;
    goto statement_100;
  } else if (x1 <= xky16) {
    lb(i1) = 0;
    lb(i2) = 12 + fem::fint(2 * ranart(nseed));
    e(i1) = ameta;
    e(i2) = am1535;
    goto statement_100;
  } else {
    lb(i1) = 29;
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = aphi;
    e(i2) = amn;
    iblock = 222;
    goto statement_100;
  }
/// C
statement_100:
  if (ikmp == -1) {
    lb(i2) = -lb(i2);
  }
  /// C
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct crlan_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crlan_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crlan(common& cmn, float& px, float& py, float& pz, float const& srt,
           int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crlan);
  /// COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     PURPOSE:                                                         *
  /// C      DEALING WITH La/Si-bar + N --> K+ + pi PROCESS                  *
  /// C                   La/Si + N-bar --> K- + pi                          *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      71
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  iblock = 71;
  sve.ntag = 0;
  if ((lb(i1) >= 14 && lb(i1) <= 17) || (lb(i2) >= 14 && lb(i2) <= 17)) {
    lb(i1) = 21;
  } else {
    lb(i1) = 23;
  }
  lb(i2) = 3 + fem::fint(3 * ranart(nseed));
  const float aka = 0.498f;
  e(i1) = aka;
  e(i2) = 0.138f;
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crkpla_save {
  float c1;
  float ct1;
  float dskn;
  float dsknr;
  int ic;
  float pdd;
  float pff;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float randu;
  float s1;
  float scheck;
  float sig1;
  float sig2;
  float sigkp;
  float sigm;
  float sigpik;
  float st1;
  float t1;
  float xkp0;
  float xkp1;
  float xkp10;
  float xkp2;
  float xkp3;
  float xkp4;
  float xkp5;
  float xkp6;
  float xkp7;
  float xkp8;
  float xkp9;

  crkpla_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        ic(fem::int0),
        pdd(fem::float0),
        pff(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        randu(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        sig1(fem::float0),
        sig2(fem::float0),
        sigkp(fem::float0),
        sigm(fem::float0),
        sigpik(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        xkp0(fem::float0),
        xkp1(fem::float0),
        xkp10(fem::float0),
        xkp2(fem::float0),
        xkp3(fem::float0),
        xkp4(fem::float0),
        xkp5(fem::float0),
        xkp6(fem::float0),
        xkp7(fem::float0),
        xkp8(fem::float0),
        xkp9(fem::float0) {}
};

/// Csp11/03/01 end
/// C*********************************
/// C                                                                      *
void crkpla(common& cmn, float& px, float& py, float& pz, float const& ec,
            float const& srt, float const& spika, float& emm1, float& emm2,
            int& lbp1, int& lbp2, int const& i1, int const& i2, int& icase,
            float const& srhoks) {
  FEM_CMN_SVE(crkpla);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  int& ic = sve.ic;
  float& pdd = sve.pdd;
  float& pff = sve.pff;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& randu = sve.randu;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& sig1 = sve.sig1;
  float& sig2 = sve.sig2;
  float& sigkp = sve.sigkp;
  float& sigm = sve.sigm;
  float& sigpik = sve.sigpik;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& xkp0 = sve.xkp0;
  float& xkp1 = sve.xkp1;
  float& xkp10 = sve.xkp10;
  float& xkp2 = sve.xkp2;
  float& xkp3 = sve.xkp3;
  float& xkp4 = sve.xkp4;
  float& xkp5 = sve.xkp5;
  float& xkp6 = sve.xkp6;
  float& xkp7 = sve.xkp7;
  float& xkp8 = sve.xkp8;
  float& xkp9 = sve.xkp9;
  const float aka = 0.498f;
  const float ap1 = 0.13496f;
  const float ala = 1.1157f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float am1440 = 1.44f;
  const float am1535 = 1.535f;
  const float asa = 1.1974f;
  const float aphi = 1.02f;
  const float pi = 3.1415926f;
  const float aks = 0.895f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  /// C
  /// C     PURPOSE:                                                         *
  /// C     DEALING WITH  K+ + Pi ---> La/Si-bar + B, phi+K, phi+K* OR  K* *
  /// C                   K- + Pi ---> La/Si + B-bar  OR   K*-bar          *
  /// C
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      71
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  emm1 = 0.f;
  emm2 = 0.f;
  lbp1 = 0;
  lbp2 = 0;
  xkp0 = spika;
  xkp1 = 0.f;
  xkp2 = 0.f;
  xkp3 = 0.f;
  xkp4 = 0.f;
  xkp5 = 0.f;
  xkp6 = 0.f;
  xkp7 = 0.f;
  xkp8 = 0.f;
  xkp9 = 0.f;
  xkp10 = 0.f;
  sigm = 15.f;
  /// C         if(lb(i1).eq.21.or.lb(i2).eq.21)sigm=10.
  pdd = (fem::pow2(srt) - fem::pow2((aka + ap1))) *
        (fem::pow2(srt) - fem::pow2((aka - ap1)));
  /// C
  if (srt < (ala + amn)) {
    goto statement_70;
  }
  xkp1 = sigm * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + amn))) *
         (fem::pow2(srt) - fem::pow2((ala - amn))) / pdd;
  if (srt > (ala + am0)) {
    xkp2 = sigm * (16.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + am0))) *
           (fem::pow2(srt) - fem::pow2((ala - am0))) / pdd;
  }
  if (srt > (ala + am1440)) {
    xkp3 = sigm * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + am1440))) *
           (fem::pow2(srt) - fem::pow2((ala - am1440))) / pdd;
  }
  if (srt > (ala + am1535)) {
    xkp4 = sigm * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((ala + am1535))) *
           (fem::pow2(srt) - fem::pow2((ala - am1535))) / pdd;
  }
  /// C
  if (srt > (asa + amn)) {
    xkp5 = sigm * 4.f * (fem::pow2(srt) - fem::pow2((asa + amn))) *
           (fem::pow2(srt) - fem::pow2((asa - amn))) / pdd;
  }
  if (srt > (asa + am0)) {
    xkp6 = sigm * 16.f * (fem::pow2(srt) - fem::pow2((asa + am0))) *
           (fem::pow2(srt) - fem::pow2((asa - am0))) / pdd;
  }
  if (srt > (asa + am1440)) {
    xkp7 = sigm * 4.f * (fem::pow2(srt) - fem::pow2((asa + am1440))) *
           (fem::pow2(srt) - fem::pow2((asa - am1440))) / pdd;
  }
  if (srt > (asa + am1535)) {
    xkp8 = sigm * 4.f * (fem::pow2(srt) - fem::pow2((asa + am1535))) *
           (fem::pow2(srt) - fem::pow2((asa - am1535))) / pdd;
  }
statement_70:
  sig1 = 195.639f;
  sig2 = 372.378f;
  if (srt > aphi + aka) {
    pff = fem::sqrt((fem::pow2(srt) - fem::pow2((aphi + aka))) *
                    (fem::pow2(srt) - fem::pow2((aphi - aka))));
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = pdd;
    if (scheck <= 0) {
      write(99, star), "scheck40: ", scheck;
      FEM_STOP(0);
    }
    /// C
    xkp9 = sig1 * pff / fem::sqrt(pdd) * 1.f / 32.f / pi / fem::pow2(srt);
    if (srt > aphi + aks) {
      pff = fem::sqrt((fem::pow2(srt) - fem::pow2((aphi + aks))) *
                      (fem::pow2(srt) - fem::pow2((aphi - aks))));
      /// C
      /// Clin-9/2012: check argument in sqrt():
      scheck = pdd;
      if (scheck <= 0) {
        write(99, star), "scheck41: ", scheck;
        FEM_STOP(0);
      }
      /// C
      xkp10 = sig2 * pff / fem::sqrt(pdd) * 3.f / 32.f / pi / fem::pow2(srt);
    }
  }
  /// C
  /// Clin-8/15/02 K pi -> K* (rho omega), from detailed balance,
  /// C neglect rho and omega mass difference for now:
  sigpik = 0.f;
  if (srt > (amrho + aks)) {
    sigpik = srhoks * 9.f * (fem::pow2(srt) - fem::pow2((0.77f - aks))) *
             (fem::pow2(srt) - fem::pow2((0.77f + aks))) / 4 / fem::pow2(srt) /
             (fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
    if (srt > (amomga + aks)) {
      sigpik = sigpik * 12.f / 9.f;
    }
  }
  /// C
  sigkp = xkp0 + xkp1 + xkp2 + xkp3 + xkp4 + xkp5 + xkp6 + xkp7 + xkp8 + xkp9 +
          xkp10 + sigpik;
  icase = 0;
  dskn = fem::sqrt(sigkp / pi / 10.f);
  dsknr = dskn + 0.1f;
  distce(cmn, i1, i2, dsknr, dskn, cmn.dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  /// C
  randu = ranart(nseed) * sigkp;
  xkp1 += xkp0;
  xkp2 += xkp1;
  xkp3 += xkp2;
  xkp4 += xkp3;
  xkp5 += xkp4;
  xkp6 += xkp5;
  xkp7 += xkp6;
  xkp8 += xkp7;
  xkp9 += xkp8;
  /// C
  xkp10 += xkp9;
  /// C
  /// C   !! K* formation
  if (randu <= xkp0) {
    icase = 1;
    return;
  } else {
    /// C La/Si-bar + B formation
    icase = 2;
    if (randu <= xkp1) {
      lbp1 = -14;
      lbp2 = 1 + fem::fint(2 * ranart(nseed));
      emm1 = ala;
      emm2 = amn;
      goto statement_60;
    } else if (randu <= xkp2) {
      lbp1 = -14;
      lbp2 = 6 + fem::fint(4 * ranart(nseed));
      emm1 = ala;
      emm2 = am0;
      goto statement_60;
    } else if (randu <= xkp3) {
      lbp1 = -14;
      lbp2 = 10 + fem::fint(2 * ranart(nseed));
      emm1 = ala;
      emm2 = am1440;
      goto statement_60;
    } else if (randu <= xkp4) {
      lbp1 = -14;
      lbp2 = 12 + fem::fint(2 * ranart(nseed));
      emm1 = ala;
      emm2 = am1535;
      goto statement_60;
    } else if (randu <= xkp5) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 1 + fem::fint(2 * ranart(nseed));
      emm1 = asa;
      emm2 = amn;
      goto statement_60;
    } else if (randu <= xkp6) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 6 + fem::fint(4 * ranart(nseed));
      emm1 = asa;
      emm2 = am0;
      goto statement_60;
    } else if (randu < xkp7) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 10 + fem::fint(2 * ranart(nseed));
      emm1 = asa;
      emm2 = am1440;
      goto statement_60;
    } else if (randu < xkp8) {
      lbp1 = -15 - fem::fint(3 * ranart(nseed));
      lbp2 = 12 + fem::fint(2 * ranart(nseed));
      emm1 = asa;
      emm2 = am1535;
      goto statement_60;
    } else if (randu < xkp9) {
      /// C       !! phi +K  formation (iblock=224)
      icase = 3;
      lbp1 = 29;
      lbp2 = 23;
      emm1 = aphi;
      emm2 = aka;
      if (lb(i1) == 21 || lb(i2) == 21) {
        /// C         !! phi +K-bar  formation (iblock=124)
        lbp2 = 21;
        icase = -3;
      }
      goto statement_60;
    } else if (randu < xkp10) {
      /// C       !! phi +K* formation (iblock=226)
      icase = 4;
      lbp1 = 29;
      lbp2 = 30;
      emm1 = aphi;
      emm2 = aks;
      if (lb(i1) == 21 || lb(i2) == 21) {
        lbp2 = -30;
        icase = -4;
      }
      goto statement_60;
      /// C
    } else {
      /// C       !! (rho,omega) +K* formation (iblock=88)
      icase = 5;
      lbp1 = 25 + fem::fint(3 * ranart(nseed));
      lbp2 = 30;
      emm1 = amrho;
      emm2 = aks;
      if (srt > (amomga + aks) && ranart(nseed) < 0.25f) {
        lbp1 = 28;
        emm1 = amomga;
      }
      if (lb(i1) == 21 || lb(i2) == 21) {
        lbp2 = -30;
        icase = -5;
      }
      /// C
    }
  }
/// C
statement_60:
  if (icase == 2 && (lb(i1) == 21 || lb(i2) == 21)) {
    lbp1 = -lbp1;
    lbp2 = -lbp2;
  }
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(emm1) - fem::pow2(emm2))) -
        4.0f * fem::pow2((emm1 * emm2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crkkpi_save {
  float x1;

  crkkpi_save() : x1(fem::float0) {}
};

/// Cbali2/7/99end
/// Cbali3/5/99
/// C*********************************
/// C     PURPOSE:                                                         *
/// C     assign final states for K+K- --> light mesons
/// C
void crkkpi(common& cmn, int const& i1, int const& i2, float const& xsk1,
            float& xsk2, float& xsk3, float& xsk4, float& xsk5, float& xsk6,
            float& xsk7, float& xsk8, float& xsk9, float& xsk10,
            float const& /* xsk11 */, float const& sigk, int& iblock, int& lbp1,
            int& lbp2, float& emm1, float& emm2) {
  FEM_CMN_SVE(crkkpi);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& x1 = sve.x1;
  const float ap2 = 0.13957f;
  const float amrho = 0.769f;
  const float amomga = 0.782f;
  const float ameta = 0.5473f;
  /// C
  /// C     QUANTITIES:                                                     *
  /// C           IBLOCK   - INFORMATION about the reaction channel          *
  /// C
  /// C             iblock   - 1907
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  iblock = 1907;
  x1 = ranart(nseed) * sigk;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  xsk5 += xsk4;
  xsk6 += xsk5;
  xsk7 += xsk6;
  xsk8 += xsk7;
  xsk9 += xsk8;
  xsk10 += xsk9;
  if (x1 <= xsk1) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 3 + fem::fint(3 * ranart(nseed));
    e(i1) = ap2;
    e(i2) = ap2;
    goto statement_100;
  } else if (x1 <= xsk2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = ap2;
    e(i2) = amrho;
    goto statement_100;
  } else if (x1 <= xsk3) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 28;
    e(i1) = ap2;
    e(i2) = amomga;
    goto statement_100;
  } else if (x1 <= xsk4) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 0;
    e(i1) = ap2;
    e(i2) = ameta;
    goto statement_100;
  } else if (x1 <= xsk5) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = amrho;
    e(i2) = amrho;
    goto statement_100;
  } else if (x1 <= xsk6) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 28;
    e(i1) = amrho;
    e(i2) = amomga;
    goto statement_100;
  } else if (x1 <= xsk7) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 0;
    e(i1) = amrho;
    e(i2) = ameta;
    goto statement_100;
  } else if (x1 <= xsk8) {
    lb(i1) = 28;
    lb(i2) = 28;
    e(i1) = amomga;
    e(i2) = amomga;
    goto statement_100;
  } else if (x1 <= xsk9) {
    lb(i1) = 28;
    lb(i2) = 0;
    e(i1) = amomga;
    e(i2) = ameta;
    goto statement_100;
  } else if (x1 <= xsk10) {
    lb(i1) = 0;
    lb(i2) = 0;
    e(i1) = ameta;
    e(i2) = ameta;
  } else {
    iblock = 222;
    rhores(cmn, i1, i2);
    /// C     !! phi
    lb(i1) = 29;
    /// C          return
    e(i2) = 0.f;
  }
/// C
statement_100:
  lbp1 = lb(i1);
  lbp2 = lb(i2);
  emm1 = e(i1);
  emm2 = e(i2);
  /// C
}

struct pipik_save {
  arr<float> earray;
  int ie;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  pipik_save()
      : earray(dimension(5), fem::fill0),
        ie(fem::int0),
        pmass(fem::float0),
        xarray(dimension(5), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C for pion+pion-->K+K-
/// C      real*4 function pipik(srt)
float pipik(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pipik);
  arr_ref<float> earray(sve.earray, dimension(5));
  int& ie = sve.ie;
  arr_ref<float> xarray(sve.xarray, dimension(5));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {0.001f, 0.7f, 1.5f, 1.7f, 2.0f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
    {
      static const float values[] = {1.f, 1.2f, 1.6f, 2.0f, 2.4f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
  }
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in mb *
  /// C  NOTE: DEVIDE THE CROSS SECTION TO OBTAIN K+ PRODUCTION *
  /// C*****************************************
  /// C      real*4   xarray(5), earray(5)
  /// C
  sve.pmass = 0.9383f;
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  return_value = 0.f;
  if (srt <= 1.f) {
    return return_value;
  }
  if (srt > 2.4f) {
    return_value = 2.0f / 2.f;
    return return_value;
  }
  if (srt < earray(1)) {
    return_value = xarray(1) / 2.f;
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 5) {
    if (earray(ie) == srt) {
      return_value = xarray(ie);
      goto statement_10;
    } else if (earray(ie) > srt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(srt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      goto statement_10;
    }
  }
statement_10:
  return_value = return_value / 2.f;
  return return_value;
}

struct xkkann_save {
  float fwdp;
  float pf2;
  float pi2;
  float pkaon;
  float s;
  float scheck;
  float xm1;
  float xm2;
  float xpion0;

  xkkann_save()
      : fwdp(fem::float0),
        pf2(fem::float0),
        pi2(fem::float0),
        pkaon(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        xm1(fem::float0),
        xm2(fem::float0),
        xpion0(fem::float0) {}
};

/// C*********************************
/// Cbali2/6/99 end
/// Cbz3/9/99 kkbar
/// Cbali3/5/99
/// C*****************************************
/// C purpose: Xsection for K+ K- to pi+ pi-
/// C      real*4 function xkkpi(srt)
/// C  srt    = DSQRT(s) in GeV                                  *
/// C  xkkpi   = xsection in mb obtained from
/// C           the detailed balance                             *
/// C ******************************************
/// C          parameter (pimass=0.140,aka=0.498)
/// C       xkkpi=1.e-08
/// C       ppi2=(srt/2)**2-pimass**2
/// C       pk2=(srt/2)**2-aka**2
/// C       if(ppi2.le.0.or.pk2.le.0)return
/// Cbz3/9/99 kkbar
/// C       xkkpi=ppi2/pk2*pipik(srt)
/// C       xkkpi=9.0 / 4.0 * ppi2/pk2*pipik(srt)
/// C        xkkpi = 2.0 * xkkpi
/// Cbz3/9/99 kkbar end
/// C
/// Cbz3/9/99 kkbar
/// C       end
/// C       return
/// C        END
/// Cbz3/9/99 kkbar end
/// C
/// Cbali3/5/99 end
/// Cbz3/9/99 kkbar end
/// C
/// Cbz3/9/99 kkbar
/// C****************************
/// C purpose: Xsection for K+ K- to pi+ pi-
void xkkann(common& cmn, float const& srt, float& xsk1, float& xsk2,
            float& xsk3, float& xsk4, float& xsk5, float& xsk6, float& xsk7,
            float& xsk8, float& xsk9, float& xsk10, float& xsk11, float& sigk,
            float const& rrkk) {
  FEM_CMN_SVE(xkkann);
  common_write write(cmn);
  /// SAVE
  float& fwdp = sve.fwdp;
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& pkaon = sve.pkaon;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& xm1 = sve.xm1;
  float& xm2 = sve.xm2;
  float& xpion0 = sve.xpion0;
  ///
  /// C  srt    = DSQRT(s) in GeV                                       *
  /// C  xsk1   = annihilation into pi pi                               *
  /// C  xsk2   = annihilation into pi rho (shifted to XKKSAN)         *
  /// C  xsk3   = annihilation into pi omega (shifted to XKKSAN)       *
  /// C  xsk4   = annihilation into pi eta                              *
  /// C  xsk5   = annihilation into rho rho                             *
  /// C  xsk6   = annihilation into rho omega                           *
  /// C  xsk7   = annihilation into rho eta (shifted to XKKSAN)        *
  /// C  xsk8   = annihilation into omega omega                         *
  /// C  xsk9   = annihilation into omega eta (shifted to XKKSAN)      *
  /// C  xsk10  = annihilation into eta eta                             *
  /// C  sigk   = xsection in mb obtained from                          *
  /// C           the detailed balance                                  *
  /// C ***************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /DD/
  /// C
  s = fem::pow2(srt);
  sigk = 1.e-08f;
  xsk1 = 0.0f;
  xsk2 = 0.0f;
  xsk3 = 0.0f;
  xsk4 = 0.0f;
  xsk5 = 0.0f;
  xsk6 = 0.0f;
  xsk7 = 0.0f;
  xsk8 = 0.0f;
  xsk9 = 0.0f;
  xsk10 = 0.0f;
  xsk11 = 0.0f;
  /// C
  xpion0 = pipik(cmn, srt);
  /// C.....take into account both K+ and K0
  xpion0 = 2.0f * xpion0;
  const float aka = 0.498f;
  pi2 = s * (s - 4.0f * fem::pow2(aka));
  if (pi2 <= 0.0f) {
    return;
  }
  /// C
  const float pimass = 0.140f;
  xm1 = pimass;
  xm2 = pimass;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk1 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  /// Clin-8/28/00 (pi eta) eta -> K+K- is assumed the same as pi pi -> K+K-:
  xm1 = pimass;
  const float etam = 0.5473f;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk4 = 3.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  xm1 = etam;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk10 = 1.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  xpion0 = rrkk;
  /// C
  /// Clin-11/07/00: (pi eta) (rho omega) -> K* Kbar (or K*bar K) instead to K
  /// Kbar: C        XM1 = PIMASS C        XM2 = RHOM C        PF2 = (S - (XM1 +
  /// XM2) ** 2) * (S - (XM1 - XM2) ** 2) C        IF (PF2 .GT. 0.0) THEN C XSK2
  /// = 27.0 / 4.0 * PF2 / PI2 * XPION0 C        END IF
  /// C
  /// C        XM1 = PIMASS
  /// C        XM2 = OMEGAM
  /// C        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
  /// C        IF (PF2 .GT. 0.0) THEN
  /// C           XSK3 = 9.0 / 4.0 * PF2 / PI2 * XPION0
  /// C        END IF
  /// C
  const float rhom = 0.770f;
  xm1 = rhom;
  xm2 = rhom;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk5 = 81.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  xm1 = rhom;
  const float omegam = 0.7819f;
  xm2 = omegam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk6 = 27.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  /// C        XM1 = RHOM
  /// C        XM2 = ETAM
  /// C        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
  /// C        IF (PF2 .GT. 0.0) THEN
  /// C           XSK7 = 9.0 / 4.0 * PF2 / PI2 * XPION0
  /// C        END IF
  /// C
  xm1 = omegam;
  xm2 = omegam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xsk8 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  /// C        XM1 = OMEGAM
  /// C        XM2 = ETAM
  /// C        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
  /// C        IF (PF2 .GT. 0.0) THEN
  /// C           XSK9 = 3.0 / 4.0 * PF2 / PI2 * XPION0
  /// C        END IF
  /// C
  /// C* K+ + K- --> phi
  const float aphi = 1.02f;
  fwdp = 1.68f * fem::pow((fem::pow2(aphi) - 4.f * fem::pow2(aka)), 1.5f) /
         6.f / aphi / aphi;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(srt) - 4.0f * fem::pow2(aka);
  if (scheck <= 0) {
    write(99, star), "scheck47: ", scheck;
    FEM_STOP(0);
  }
  pkaon = 0.5f * fem::sqrt(scheck);
  /// C          pkaon=0.5*sqrt(srt**2-4.0*aka**2)
  /// C
  xsk11 = 30.f * 3.14159f * fem::pow2(0.1973f) * fem::pow2((aphi * fwdp)) /
          (fem::pow2((fem::pow2(srt) - fem::pow2(aphi))) +
           fem::pow2((aphi * fwdp))) /
          fem::pow2(pkaon);
  /// C
  sigk = xsk1 + xsk2 + xsk3 + xsk4 + xsk5 + xsk6 + xsk7 + xsk8 + xsk9 + xsk10 +
         xsk11;
  /// C
}

struct xkksan_save {
  float pf2;
  float pi2;
  float s;
  float xm1;
  float xm2;
  float xpion0;

  xkksan_save()
      : pf2(fem::float0),
        pi2(fem::float0),
        s(fem::float0),
        xm1(fem::float0),
        xm2(fem::float0),
        xpion0(fem::float0) {}
};

/// C
/// C****************************
/// C purpose: Xsection for K* Kbar or K*bar K to pi(eta) rho(omega)
void xkksan(common& cmn, int const& i1, int const& i2, float const& srt,
            float& sigks1, float& sigks2, float& sigks3, float& sigks4,
            float& sigk, float const& prkk) {
  FEM_CMN_SVE(xkksan);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  ///
  /// SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s = sve.s;
  float& xm1 = sve.xm1;
  float& xm2 = sve.xm2;
  float& xpion0 = sve.xpion0;
  ///
  /// C  srt    = DSQRT(s) in GeV                                       *
  /// C  sigk   = xsection in mb obtained from                          *
  /// C           the detailed balance                                  *
  /// C ***************************
  /// Cc      SAVE /CC/
  /// C
  s = fem::pow2(srt);
  sigks1 = 1.e-08f;
  sigks2 = 1.e-08f;
  sigks3 = 1.e-08f;
  sigks4 = 1.e-08f;
  /// C
  xpion0 = prkk;
  /// Clin note that prkk is for pi (rho omega) -> K* Kbar (AND!) K*bar K:
  xpion0 = xpion0 / 2;
  /// C
  /// Cc
  /// C        PI2 = (S - (aks + AKA) ** 2) * (S - (aks - AKA) ** 2)
  pi2 = (s - fem::pow2((e(i1) + e(i2)))) * (s - fem::pow2((e(i1) - e(i2))));
  sigk = 1.e-08f;
  if (pi2 <= 0.0f) {
    return;
  }
  /// C
  const float pimass = 0.140f;
  xm1 = pimass;
  const float rhom = 0.770f;
  xm2 = rhom;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pi2 > 0.0f && pf2 > 0.0f) {
    sigks1 = 27.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  xm1 = pimass;
  const float omegam = 0.7819f;
  xm2 = omegam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pi2 > 0.0f && pf2 > 0.0f) {
    sigks2 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  xm1 = rhom;
  const float etam = 0.5473f;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    sigks3 = 9.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  xm1 = omegam;
  xm2 = etam;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    sigks4 = 3.0f / 4.0f * pf2 / pi2 * xpion0;
  }
  /// C
  sigk = sigks1 + sigks2 + sigks3 + sigks4;
  /// C
}

struct crkspi_save {
  float x1;

  crkspi_save() : x1(fem::float0) {}
};

/// C
/// C*********************************
/// C     PURPOSE:                                                         *
/// C     assign final states for KK*bar or K*Kbar --> light mesons
/// C
/// C      SUBROUTINE Crkspi(PX,PY,PZ,SRT,I1,I2,IBLOCK)
void crkspi(common& cmn, int const& i1, int const& i2, float const& xsk1,
            float& xsk2, float& xsk3, float& xsk4, float const& sigk,
            int& iblock, int& lbp1, int& lbp2, float& emm1, float& emm2) {
  FEM_CMN_SVE(crkspi);
  /// COMMON cc
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& x1 = sve.x1;
  ///
  /// C             iblock   - 466
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  iblock = 466;
  /// C charges of final state mesons:
  /// C
  x1 = ranart(nseed) * sigk;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  const float ap2 = 0.13957f;
  const float rhom = 0.770f;
  const float amomga = 0.782f;
  const float aeta = 0.548f;
  if (x1 <= xsk1) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = ap2;
    e(i2) = rhom;
  } else if (x1 <= xsk2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 28;
    e(i1) = ap2;
    e(i2) = amomga;
  } else if (x1 <= xsk3) {
    lb(i1) = 0;
    lb(i2) = 25 + fem::fint(3 * ranart(nseed));
    e(i1) = aeta;
    e(i2) = rhom;
  } else {
    lb(i1) = 0;
    lb(i2) = 28;
    e(i1) = aeta;
    e(i2) = amomga;
  }
  /// C
  const float ap1 = 0.13496f;
  if (lb(i1) == 4) {
    e(i1) = ap1;
  }
  lbp1 = lb(i1);
  lbp2 = lb(i2);
  emm1 = e(i1);
  emm2 = e(i2);
  /// C
}

struct crkphi_save {
  float c1;
  float ct1;
  float dnr;
  float dskn;
  float dsknr;
  int ic;
  int lb1;
  int lb2;
  float pii;
  float pr;
  float pr2;
  float prkk0;
  float px0;
  float py0;
  float pz0;
  float ranx;
  float rrkk0;
  float s1;
  float sig;
  float sig1;
  float sig2;
  float sig3;
  float sigks;
  float sigks1;
  float sigks2;
  float sigks3;
  float sigks4;
  float sigm;
  float sigm0;
  float srr1;
  float srr2;
  float srr3;
  float srri;
  float srrt;
  float st1;
  float t1;
  float xsk1;
  float xsk10;
  float xsk11;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;
  float xsk6;
  float xsk7;
  float xsk8;
  float xsk9;

  crkphi_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dnr(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        ic(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        pii(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        prkk0(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        ranx(fem::float0),
        rrkk0(fem::float0),
        s1(fem::float0),
        sig(fem::float0),
        sig1(fem::float0),
        sig2(fem::float0),
        sig3(fem::float0),
        sigks(fem::float0),
        sigks1(fem::float0),
        sigks2(fem::float0),
        sigks3(fem::float0),
        sigks4(fem::float0),
        sigm(fem::float0),
        sigm0(fem::float0),
        srr1(fem::float0),
        srr2(fem::float0),
        srr3(fem::float0),
        srri(fem::float0),
        srrt(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        xsk1(fem::float0),
        xsk10(fem::float0),
        xsk11(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0),
        xsk6(fem::float0),
        xsk7(fem::float0),
        xsk8(fem::float0),
        xsk9(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void crkphi(common& cmn, float& px, float& py, float& pz, float const& ec,
            float const& srt, int& iblock, float& emm1, float& emm2, int& lbp1,
            int& lbp2, int const& i1, int const& i2, int& ikk, int& icase,
            float const& rrkk, float const& prkk) {
  FEM_CMN_SVE(crkphi);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dnr = sve.dnr;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  int& ic = sve.ic;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pii = sve.pii;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& prkk0 = sve.prkk0;
  float& ranx = sve.ranx;
  float& rrkk0 = sve.rrkk0;
  float& s1 = sve.s1;
  float& sig = sve.sig;
  float& sig1 = sve.sig1;
  float& sig2 = sve.sig2;
  float& sig3 = sve.sig3;
  float& sigks = sve.sigks;
  float& sigks1 = sve.sigks1;
  float& sigks2 = sve.sigks2;
  float& sigks3 = sve.sigks3;
  float& sigks4 = sve.sigks4;
  float& sigm = sve.sigm;
  float& sigm0 = sve.sigm0;
  float& srr1 = sve.srr1;
  float& srr2 = sve.srr2;
  float& srr3 = sve.srr3;
  float& srri = sve.srri;
  float& srrt = sve.srrt;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& xsk1 = sve.xsk1;
  float& xsk10 = sve.xsk10;
  float& xsk11 = sve.xsk11;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  float& xsk6 = sve.xsk6;
  float& xsk7 = sve.xsk7;
  float& xsk8 = sve.xsk8;
  float& xsk9 = sve.xsk9;
  ///
  /// C
  /// C     PURPOSE:                                                         *
  /// C     DEALING WITH   KKbar, KK*bar, KbarK*, K*K*bar --> Phi +
  /// pi(rho,omega) C     and KKbar --> (pi eta) (pi eta), (rho omega) (rho
  /// omega) C     and KK*bar or Kbar K* --> (pi eta) (rho omega)
  /// C
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      222
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  lb1 = lb(i1);
  lb2 = lb(i2);
  icase = 0;
  /// C
  /// C        if(srt .lt. aphi+ap1)return
  /// Cc        if(srt .lt. aphi+ap1) then
  const float aphi = 1.02f;
  const float ap1 = 0.13496f;
  const float aomega = 0.7819f;
  const float arho = 0.77f;
  if (srt < (aphi + ap1)) {
    sig1 = 0.f;
    sig2 = 0.f;
    sig3 = 0.f;
  } else {
    /// C
    if ((lb1 == 23 && lb2 == 21) || (lb2 == 23 && lb1 == 21)) {
      dnr = 4.f;
      ikk = 2;
    } else if ((lb1 == 21 && lb2 == 30) || (lb2 == 21 && lb1 == 30) ||
               (lb1 == 23 && lb2 == -30) || (lb2 == 23 && lb1 == -30)) {
      dnr = 12.f;
      ikk = 1;
    } else {
      dnr = 36.f;
      ikk = 0;
    }
    /// C
    sig1 = 0.f;
    sig2 = 0.f;
    sig3 = 0.f;
    srri = e(i1) + e(i2);
    srr1 = aphi + ap1;
    srr2 = aphi + aomega;
    srr3 = aphi + arho;
    /// C
    pii = (fem::pow2(srt) - fem::pow2((e(i1) + e(i2)))) *
          (fem::pow2(srt) - fem::pow2((e(i1) - e(i2))));
    srrt = srt - fem::amax1(srri, srr1);
    /// Cc   to avoid divergent/negative values at small srrt:
    /// C          if(srrt .lt. 0.3)then
    if (srrt < 0.3f && srrt > 0.01f) {
      sig = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
    } else {
      sig = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
    }
    sig1 = sig * (9.f / dnr) * (fem::pow2(srt) - fem::pow2((aphi + ap1))) *
           (fem::pow2(srt) - fem::pow2((aphi - ap1))) / pii;
    if (srt > aphi + aomega) {
      srrt = srt - fem::amax1(srri, srr2);
      /// Cc         if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        sig = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        sig = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
      sig2 = sig * (9.f / dnr) * (fem::pow2(srt) - fem::pow2((aphi + aomega))) *
             (fem::pow2(srt) - fem::pow2((aphi - aomega))) / pii;
    }
    if (srt > aphi + arho) {
      srrt = srt - fem::amax1(srri, srr3);
      /// Cc         if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        sig = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        sig = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
      sig3 = sig * (27.f / dnr) * (fem::pow2(srt) - fem::pow2((aphi + arho))) *
             (fem::pow2(srt) - fem::pow2((aphi - arho))) / pii;
    }
    /// C         sig1 = amin1(20.,sig1)
    /// C         sig2 = amin1(20.,sig2)
    /// C         sig3 = amin1(20.,sig3)
  }
  /// C
  rrkk0 = rrkk;
  prkk0 = prkk;
  sigm = 0.f;
  if ((lb1 == 23 && lb2 == 21) || (lb2 == 23 && lb1 == 21)) {
    xkkann(cmn, srt, xsk1, xsk2, xsk3, xsk4, xsk5, xsk6, xsk7, xsk8, xsk9,
           xsk10, xsk11, sigm, rrkk0);
  } else if ((lb1 == 21 && lb2 == 30) || (lb2 == 21 && lb1 == 30) ||
             (lb1 == 23 && lb2 == -30) || (lb2 == 23 && lb1 == -30)) {
    xkksan(cmn, i1, i2, srt, sigks1, sigks2, sigks3, sigks4, sigm, prkk0);
  } else {
  }
  /// C
  /// C         sigks = sig1 + sig2 + sig3
  sigm0 = sigm;
  sigks = sig1 + sig2 + sig3 + sigm;
  const float pi = 3.1415926f;
  dskn = fem::sqrt(sigks / pi / 10.f);
  dsknr = dskn + 0.1f;
  distce(cmn, i1, i2, dsknr, dskn, cmn.dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  icase = 1;
  ranx = ranart(nseed);
  /// C
  lbp1 = 29;
  emm1 = aphi;
  if (ranx <= sig1 / sigks) {
    lbp2 = 3 + fem::fint(3 * ranart(nseed));
    emm2 = ap1;
  } else if (ranx <= (sig1 + sig2) / sigks) {
    lbp2 = 28;
    emm2 = aomega;
  } else if (ranx <= (sig1 + sig2 + sig3) / sigks) {
    lbp2 = 25 + fem::fint(3 * ranart(nseed));
    emm2 = arho;
  } else {
    if ((lb1 == 23 && lb2 == 21) || (lb2 == 23 && lb1 == 21)) {
      crkkpi(cmn, i1, i2, xsk1, xsk2, xsk3, xsk4, xsk5, xsk6, xsk7, xsk8, xsk9,
             xsk10, xsk11, sigm0, iblock, lbp1, lbp2, emm1, emm2);
    } else if ((lb1 == 21 && lb2 == 30) || (lb2 == 21 && lb1 == 30) ||
               (lb1 == 23 && lb2 == -30) || (lb2 == 23 && lb1 == -30)) {
      crkspi(cmn, i1, i2, sigks1, sigks2, sigks3, sigks4, sigm0, iblock, lbp1,
             lbp2, emm1, emm2);
    } else {
    }
  }
  /// C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(emm1) - fem::pow2(emm2))) -
        4.0f * fem::pow2((emm1 * emm2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct crksph_save {
  float c1;
  float ct1;
  float dnr;
  float dskn;
  float dsknr;
  int ic;
  int lb1;
  int lb2;
  float pff;
  float pii;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float ranx;
  float s1;
  float scheck;
  float sig1;
  float sig11;
  float sig2;
  float sig22;
  float sigela;
  float sigkm;
  float sigks;
  float st1;
  float t1;

  crksph_save()
      : c1(fem::float0),
        ct1(fem::float0),
        dnr(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        ic(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        pff(fem::float0),
        pii(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        ranx(fem::float0),
        s1(fem::float0),
        scheck(fem::float0),
        sig1(fem::float0),
        sig11(fem::float0),
        sig2(fem::float0),
        sig22(fem::float0),
        sigela(fem::float0),
        sigkm(fem::float0),
        sigks(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// Csp11/21/01 end
/// C*********************************
/// C                                                                      *
void crksph(common& cmn, float& px, float& py, float& pz, float const& ec,
            float const& srt, float& emm1, float& emm2, int& lbp1, int& lbp2,
            int const& i1, int const& i2, int& ikkg, int& ikkl, int& iblock,
            int& icase, float const& srhoks) {
  FEM_CMN_SVE(crksph);
  common_write write(cmn);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& dnr = sve.dnr;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  int& ic = sve.ic;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pff = sve.pff;
  float& pii = sve.pii;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& ranx = sve.ranx;
  float& s1 = sve.s1;
  float& scheck = sve.scheck;
  float& sig1 = sve.sig1;
  float& sig11 = sve.sig11;
  float& sig2 = sve.sig2;
  float& sig22 = sve.sig22;
  float& sigela = sve.sigela;
  float& sigkm = sve.sigkm;
  float& sigks = sve.sigks;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C
  /// C     PURPOSE:                                                         *
  /// C     DEALING WITH   K + rho(omega) or K* + pi(rho,omega)
  /// C                    --> Phi + K(K*), pi + K* or pi + K, and elastic
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      222
  /// C                      223 --> phi + pi(rho,omega)
  /// C                      224 --> phi + K <-> K + pi(rho,omega)
  /// C                      225 --> phi + K <-> K* + pi(rho,omega)
  /// C                      226 --> phi + K* <-> K + pi(rho,omega)
  /// C                      227 --> phi + K* <-> K* + pi(rho,omega)
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  lb1 = lb(i1);
  lb2 = lb(i2);
  icase = 0;
  sigela = 10.f;
  sigkm = 0.f;
  /// C     K(K*) + rho(omega) -> pi K*(K)
  const float ap2 = 0.13957f;
  const float aks = 0.895f;
  if ((lb1 >= 25 && lb1 <= 28) || (lb2 >= 25 && lb2 <= 28)) {
    if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
      sigkm = srhoks;
      /// Clin-2/26/03 check whether (rho K) is above the (pi K*) thresh:
    } else if ((lb1 == 23 || lb1 == 21 || lb2 == 23 || lb2 == 21) &&
               srt > (ap2 + aks)) {
      sigkm = srhoks;
    }
  }
  /// C
  /// C        if(srt .lt. aphi+aka)return
  const float aphi = 1.02f;
  const float aka = 0.498f;
  const float pi = 3.1415926f;
  if (srt < (aphi + aka)) {
    sig11 = 0.f;
    sig22 = 0.f;
  } else {
    /// C
    /// C K*-bar +pi --> phi + (K,K*)-bar
    if ((fem::iabs(lb1) == 30 && (lb2 >= 3 && lb2 <= 5)) ||
        (fem::iabs(lb2) == 30 && (lb1 >= 3 && lb1 <= 5))) {
      dnr = 18.f;
      ikkl = 0;
      iblock = 225;
      /// C               sig1 = 15.0
      /// C               sig2 = 30.0
      /// Clin-2/06/03 these large values reduces to ~10 mb for sig11 or sig22
      /// C     due to the factors of ~1/(32*pi*s)~1/200:
      sig1 = 2047.042f;
      sig2 = 1496.692f;
      /// C K(-bar)+rho --> phi + (K,K*)-bar
    } else if ((lb1 == 23 || lb1 == 21 && (lb2 >= 25 && lb2 <= 27)) ||
               (lb2 == 23 || lb2 == 21 && (lb1 >= 25 && lb1 <= 27))) {
      dnr = 18.f;
      ikkl = 1;
      iblock = 224;
      /// C               sig1 = 3.5
      /// C               sig2 = 9.0
      sig1 = 526.702f;
      sig2 = 1313.960f;
      /// C K*(-bar) +rho
    } else if ((fem::iabs(lb1) == 30 && (lb2 >= 25 && lb2 <= 27)) ||
               (fem::iabs(lb2) == 30 && (lb1 >= 25 && lb1 <= 27))) {
      dnr = 54.f;
      ikkl = 0;
      iblock = 225;
      /// C               sig1 = 3.5
      /// C               sig2 = 9.0
      sig1 = 1371.257f;
      sig2 = 6999.840f;
      /// C K(-bar) + omega
    } else if (((lb1 == 23 || lb1 == 21) && lb2 == 28) ||
               ((lb2 == 23 || lb2 == 21) && lb1 == 28)) {
      dnr = 6.f;
      ikkl = 1;
      iblock = 224;
      /// C               sig1 = 3.5
      /// C               sig2 = 6.5
      sig1 = 355.429f;
      sig2 = 440.558f;
      /// C K*(-bar) +omega
    } else {
      dnr = 18.f;
      ikkl = 0;
      iblock = 225;
      /// C               sig1 = 3.5
      /// C               sig2 = 15.0
      sig1 = 482.292f;
      sig2 = 1698.903f;
    }
    /// C
    sig11 = 0.f;
    sig22 = 0.f;
    /// C         sig11=sig1*(6./dnr)*(srt**2-(aphi+aka)**2)*
    /// C    &           (srt**2-(aphi-aka)**2)/(srt**2-(e(i1)+e(i2))**2)/
    /// C    &           (srt**2-(e(i1)-e(i2))**2)
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = (fem::pow2(srt) - fem::pow2((e(i1) + e(i2)))) *
             (fem::pow2(srt) - fem::pow2((e(i1) - e(i2))));
    if (scheck <= 0) {
      write(99, star), "scheck42: ", scheck;
      FEM_STOP(0);
    }
    pii = fem::sqrt(scheck);
    /// C        pii = sqrt((srt**2-(e(i1)+e(i2))**2)*(srt**2-(e(i1)-e(i2))**2))
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = (fem::pow2(srt) - fem::pow2((aphi + aka))) *
             (fem::pow2(srt) - fem::pow2((aphi - aka)));
    if (scheck < 0) {
      write(99, star), "scheck43: ", scheck;
      scheck = 0.f;
    }
    pff = fem::sqrt(scheck);
    /// C        pff = sqrt((srt**2-(aphi+aka)**2)*(srt**2-(aphi-aka)**2))
    /// C
    sig11 = sig1 * pff / pii * 6.f / dnr / 32.f / pi / fem::pow2(srt);
    /// C
    if (srt > aphi + aks) {
      /// C         sig22=sig2*(18./dnr)*(srt**2-(aphi+aks)**2)*
      /// C    &           (srt**2-(aphi-aks)**2)/(srt**2-(e(i1)+e(i2))**2)/
      /// C    &           (srt**2-(e(i1)-e(i2))**2)
      pff = fem::sqrt((fem::pow2(srt) - fem::pow2((aphi + aks))) *
                      (fem::pow2(srt) - fem::pow2((aphi - aks))));
      sig22 = sig2 * pff / pii * 18.f / dnr / 32.f / pi / fem::pow2(srt);
    }
    /// C         sig11 = amin1(20.,sig11)
    /// C         sig22 = amin1(20.,sig22)
    /// C
  }
  /// C
  /// C         sigks = sig11 + sig22
  sigks = sig11 + sig22 + sigela + sigkm;
  /// C
  dskn = fem::sqrt(sigks / pi / 10.f);
  dsknr = dskn + 0.1f;
  distce(cmn, i1, i2, dsknr, dskn, cmn.dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  icase = 1;
  ranx = ranart(nseed);
  /// C
  if (ranx <= (sigela / sigks)) {
    lbp1 = lb1;
    emm1 = e(i1);
    lbp2 = lb2;
    emm2 = e(i2);
    iblock = 111;
  } else if (ranx <= ((sigela + sigkm) / sigks)) {
    lbp1 = 3 + fem::fint(3 * ranart(nseed));
    emm1 = 0.14f;
    if (lb1 == 23 || lb2 == 23) {
      lbp2 = 30;
      emm2 = aks;
    } else if (lb1 == 21 || lb2 == 21) {
      lbp2 = -30;
      emm2 = aks;
    } else if (lb1 == 30 || lb2 == 30) {
      lbp2 = 23;
      emm2 = aka;
    } else {
      lbp2 = 21;
      emm2 = aka;
    }
    iblock = 112;
  } else if (ranx <= ((sigela + sigkm + sig11) / sigks)) {
    lbp2 = 23;
    emm2 = aka;
    ikkg = 1;
    if (lb1 == 21 || lb2 == 21 || lb1 == -30 || lb2 == -30) {
      lbp2 = 21;
      iblock = iblock - 100;
    }
    lbp1 = 29;
    emm1 = aphi;
  } else {
    lbp2 = 30;
    emm2 = aks;
    ikkg = 0;
    iblock += 2;
    if (lb1 == 21 || lb2 == 21 || lb1 == -30 || lb2 == -30) {
      lbp2 = -30;
      iblock = iblock - 100;
    }
    lbp1 = 29;
    emm1 = aphi;
  }
  /// C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(emm1) - fem::pow2(emm2))) -
        4.0f * fem::pow2((emm1 * emm2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
}

struct pionpp_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmass1;
  float pmax;
  float pmin;

  pionpp_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0) {}
};

/// C*********************************
/// C TOTAL PION-P INELASTIC CROSS SECTION
/// C  from the CERN data book
/// C  date: Sept.2, 1994
/// C  for pion++p-->Delta+pion
/// C      real*4 function pionpp(srt)
float pionpp(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pionpp);
  /// SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmass1 = sve.pmass1;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in
  /// fm**2
  /// * C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C *
  /// C*****************************************
  pmass = 0.14f;
  pmass1 = 0.938f;
  return_value = 0.00001f;
  if (srt <= 1.22f) {
    return return_value;
  }
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - fem::pow2(pmass) - fem::pow2(pmass1)) /
                 (2.f * pmass1))) -
      fem::pow2(pmass));
  pmin = 0.3f;
  pmax = 25.0f;
  if (plab > pmax) {
    return_value = 20.f / 10.f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 0.f;
    return return_value;
  }
  /// C* fit parameters
  a = 24.3f;
  b = -12.3f;
  c = 0.324f;
  an = -1.91f;
  d = -2.44f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0;
  }
  return_value = return_value / 10.f;
  return return_value;
}

struct pipp1_save {
  float a;
  float an;
  float b;
  float c;
  float d;
  float plab;
  float pmass;
  float pmass1;
  float pmax;
  float pmin;

  pipp1_save()
      : a(fem::float0),
        an(fem::float0),
        b(fem::float0),
        c(fem::float0),
        d(fem::float0),
        plab(fem::float0),
        pmass(fem::float0),
        pmass1(fem::float0),
        pmax(fem::float0),
        pmin(fem::float0) {}
};

/// C*********************************
/// C elementary cross sections
/// C  from the CERN data book
/// C  date: Sept.2, 1994
/// C  for pion-+p-->INELASTIC
/// C      real*4 function pipp1(srt)
float pipp1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pipp1);
  /// SAVE
  float& a = sve.a;
  float& an = sve.an;
  float& b = sve.b;
  float& c = sve.c;
  float& d = sve.d;
  float& plab = sve.plab;
  float& pmass = sve.pmass;
  float& pmass1 = sve.pmass1;
  float& pmax = sve.pmax;
  float& pmin = sve.pmin;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xsec   = production cross section in
  /// fm**2
  /// * C  earray = EXPerimental table with proton energies in MeV * C  xarray =
  /// EXPerimental table with cross sections in mb (curve to guide eye) * C
  /// UNITS: FM**2 C*****************************************
  pmass = 0.14f;
  pmass1 = 0.938f;
  return_value = 0.0001f;
  if (srt <= 1.22f) {
    return return_value;
  }
  /// C 1.Calculate p(lab)  from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  /// C      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
  plab = fem::sqrt(
      fem::pow2(((fem::pow2(srt) - fem::pow2(pmass) - fem::pow2(pmass1)) /
                 (2.f * pmass1))) -
      fem::pow2(pmass));
  pmin = 0.3f;
  pmax = 25.0f;
  if (plab > pmax) {
    return_value = 20.f / 10.f;
    return return_value;
  }
  if (plab < pmin) {
    return_value = 0.f;
    return return_value;
  }
  /// C* fit parameters
  a = 26.6f;
  b = -7.18f;
  c = 0.327f;
  an = -1.86f;
  d = -2.81f;
  return_value = a + b * (fem::pow(plab, an)) +
                 c * fem::pow2((fem::alog(plab))) + d * fem::alog(plab);
  if (return_value <= 0) {
    return_value = 0;
  }
  return_value = return_value / 10.f;
  return return_value;
}

struct reab_save {
  float arho1;
  float ed;
  float factor;
  int lb1;
  int lb2;
  float pin2;
  float pout2;
  float xpro;

  reab_save()
      : arho1(fem::float0),
        ed(fem::float0),
        factor(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pin2(fem::float0),
        pout2(fem::float0),
        xpro(fem::float0) {}
};

/// C*****************************************
/// C for pion (rho or omega)+baryon resonance collisions
/// C      real*4 function reab(i1,i2,srt,ictrl)
float reab(common& cmn, int const& i1, int const& i2, float const& srt,
           int const& ictrl) {
  float return_value = fem::float0;
  FEM_CMN_SVE(reab);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& arho1 = sve.arho1;
  float& ed = sve.ed;
  float& factor = sve.factor;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pin2 = sve.pin2;
  float& pout2 = sve.pout2;
  float& xpro = sve.xpro;
  ///
  /// C  This function calculates the cross section for
  /// C  pi+Delta(N*)-->N+PION process * C  srt    = DSQRT(s) in GeV * C  reab =
  /// cross section in fm**2                                            * C
  /// ictrl=1,2,3 for pion, rho and omega+D(N*)
  /// C***************************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /EE/
  lb1 = lb(i1);
  lb2 = lb(i2);
  return_value = 0;
  const float amn = 0.938f;
  const float ap1 = 0.14f;
  if (ictrl == 1 && srt <= (amn + 2.f * ap1 + 0.02f)) {
    return return_value;
  }
  const float aomega = 0.782f;
  if (ictrl == 3 && srt <= (amn + ap1 + aomega + 0.02f)) {
    return return_value;
  }
  pin2 = fem::pow2(((fem::pow2(srt) + fem::pow2(ap1) - fem::pow2(amn)) /
                    (2.f * srt))) -
         fem::pow2(ap1);
  if (pin2 <= 0) {
    return return_value;
  }
  /// C for pion+D(N*)-->pion+N
  if (ictrl == 1) {
    if (e(i1) > 1) {
      ed = e(i1);
    } else {
      ed = e(i2);
    }
    pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(ap1) - fem::pow2(ed)) /
                       (2.f * srt))) -
            fem::pow2(ap1);
    if (pout2 <= 0) {
      return return_value;
    }
    xpro = twopi(cmn, srt) / 10.f;
    factor = 1 / 3.f;
    if (((lb1 == 8 && lb2 == 5) || (lb1 == 5 && lb2 == 8)) ||
        ((lb1 == -8 && lb2 == 3) || (lb1 == 3 && lb2 == -8))) {
      factor = 1 / 4.f;
    }
    if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
        (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
      factor = 1.f;
    }
    return_value = factor * pin2 / pout2 * xpro;
    return return_value;
  }
  /// C for rho reabsorption
  if (ictrl == 2) {
    if (lb(i2) >= 25) {
      ed = e(i1);
      arho1 = e(i2);
    } else {
      ed = e(i2);
      arho1 = e(i1);
    }
    if (srt <= (amn + ap1 + arho1 + 0.02f)) {
      return return_value;
    }
    pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(arho1) - fem::pow2(ed)) /
                       (2.f * srt))) -
            fem::pow2(arho1);
    if (pout2 <= 0) {
      return return_value;
    }
    xpro = threpi(cmn, srt) / 10.f;
    factor = 1 / 3.f;
    if (((lb1 == 8 && lb2 == 27) || (lb1 == 27 && lb2 == 8)) ||
        ((lb1 == -8 && lb2 == 25) || (lb1 == 25 && lb2 == -8))) {
      factor = 1 / 4.f;
    }
    if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
        (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
      factor = 1.f;
    }
    return_value = factor * pin2 / pout2 * xpro;
    return return_value;
  }
  /// C for omega reabsorption
  if (ictrl == 3) {
    if (e(i1) > 1) {
      ed = e(i1);
    }
    if (e(i2) > 1) {
      ed = e(i2);
    }
    pout2 = fem::pow2(((fem::pow2(srt) + fem::pow2(aomega) - fem::pow2(ed)) /
                       (2.f * srt))) -
            fem::pow2(aomega);
    if (pout2 <= 0) {
      return return_value;
    }
    xpro = fourpi(cmn, srt) / 10.f;
    factor = 1 / 6.f;
    if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
        (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
      factor = 1.f / 3.f;
    }
    return_value = factor * pin2 / pout2 * xpro;
  }
  return return_value;
}

struct xpp_save {
  arr<float> earray;
  float ekin;
  int ie;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  xpp_save()
      : earray(dimension(14), fem::fill0),
        ekin(fem::float0),
        ie(fem::int0),
        pmass(fem::float0),
        xarray(dimension(14), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
/// C      real*4 function Xpp(srt)
float xpp(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xpp);
  arr_ref<float> earray(sve.earray, dimension(14));
  float& ekin = sve.ekin;
  int& ie = sve.ie;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(14));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {20.f,  30.f,  40.f,  60.f,  80.f,
                                     100.f, 170.f, 250.f, 310.f, 350.f,
                                     460.f, 560.f, 660.f, 800.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      fem::data_values data;
      data.values, 150.f, 90.f, 80.6f, 48.0f, 36.6f, 31.6f, 25.9f, 24.0f;
      data.values, 23.1f, 24.0f, 28.3f, 33.6f, 41.5f, 47;
      data, xarray;
    }
  }
  /// C  This function contains the experimental total n-p cross sections * C
  /// srt = DSQRT(s) in GeV                                                   *
  /// C xsec = production cross section in mb * C earray = EXPerimental table
  /// with proton energies in MeV                    * C  xarray = EXPerimental
  /// table with cross sections in mb (curve to guide eye) * C  WITH A CUTOFF AT
  /// 55MB * C***************************************** C      real*4
  /// xarray(14), earray(14)
  /// C
  pmass = 0.9383f;
  /// C 1.Calculate E_kin(lab) [MeV] from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  ekin = 2000.f * pmass * (fem::pow2((srt / (2.f * pmass))) - 1.f);
  if (ekin < earray(1)) {
    return_value = xarray(1);
    if (return_value > 55) {
      return_value = 55;
    }
    return return_value;
  }
  if (ekin > earray(14)) {
    return_value = xarray(14);
    return return_value;
  }
  /// C
  /// C 2.Interpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 14) {
    if (earray(ie) == ekin) {
      return_value = xarray(ie);
      if (return_value > 55) {
        return_value = 55.f;
      }
      return return_value;
    }
    if (earray(ie) > ekin) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(ekin) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      if (return_value > 55) {
        return_value = 55.f;
      }
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct xnp_save {
  arr<float> earray;
  float ekin;
  int ie;
  float pmass;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  xnp_save()
      : earray(dimension(11), fem::fill0),
        ekin(fem::float0),
        ie(fem::int0),
        pmass(fem::float0),
        xarray(dimension(11), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
float xnp(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xnp);
  arr_ref<float> earray(sve.earray, dimension(11));
  float& ekin = sve.ekin;
  int& ie = sve.ie;
  float& pmass = sve.pmass;
  arr_ref<float> xarray(sve.xarray, dimension(11));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {20.f,  30.f,  40.f,  60.f,  90.f, 135.0f,
                                     200.f, 300.f, 400.f, 600.f, 800.f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {410.f, 270.f, 214.5f, 130.f, 78.f, 53.5f,
                                     41.6f, 35.9f, 34.2f,  34.3f, 34.9f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  /// C  This function contains the experimental total n-p cross sections * C
  /// srt = DSQRT(s) in GeV                                                   *
  /// C xsec = production cross section in mb * C earray = EXPerimental table
  /// with proton energies in MeV                    * C  xarray = EXPerimental
  /// table with cross sections in mb (curve to guide eye) * C  WITH  A CUTOFF
  /// AT 55MB * C***************************************** C      real*4
  /// xarray(11), earray(11)
  /// C
  pmass = 0.9383f;
  /// C 1.Calculate E_kin(lab) [MeV] from srt [GeV]
  /// C   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
  ekin = 2000.f * pmass * (fem::pow2((srt / (2.f * pmass))) - 1.f);
  if (ekin < earray(1)) {
    return_value = xarray(1);
    if (return_value > 55) {
      return_value = 55;
    }
    return return_value;
  }
  if (ekin > earray(11)) {
    return_value = xarray(11);
    return return_value;
  }
  /// C
  /// CInterpolate double logarithmically to find sigma(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 11) {
    if (earray(ie) == ekin) {
      return_value = xarray(ie);
      if (return_value > 55) {
        return_value = 55.f;
      }
      return return_value;
    }
    if (earray(ie) > ekin) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(ekin) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      if (return_value > 55) {
        return_value = 55;
      }
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct xnd_save {
  float ada;
  float ak0;
  float akp;
  float al;
  float ana;
  float as;
  float deltam;
  float em1;
  float em2;
  float es;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float pr;
  float prf;
  float renom;
  float renom1;
  float renomn;
  float sigdn;
  float signd;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float x1440;
  float x1535;

  xnd_save()
      : ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        deltam(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        es(fem::float0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        pr(fem::float0),
        prf(fem::float0),
        renom(fem::float0),
        renom1(fem::float0),
        renomn(fem::float0),
        sigdn(fem::float0),
        signd(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        x1440(fem::float0),
        x1535(fem::float0) {}
};

/// C
/// C*********************************
/// C                                                                      *
void xnd(common& cmn, float const& px, float const& py, float const& pz,
         float const& srt, int const& i1, int const& i2, float& xinel,
         float& sigk, float& xsk1, float& xsk2, float& xsk3, float& xsk4,
         float& xsk5) {
  FEM_CMN_SVE(xnd);
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& deltam = sve.deltam;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& es = sve.es;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& pr = sve.pr;
  float& prf = sve.prf;
  float& renom = sve.renom;
  float& renom1 = sve.renom1;
  float& renomn = sve.renomn;
  float& sigdn = sve.sigdn;
  float& signd = sve.signd;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& x1440 = sve.x1440;
  float& x1535 = sve.x1535;
  const float avmass = 0.9383f;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  /// C     PURPOSE:                                                         *
  /// C             calculate NUCLEON-BARYON RESONANCE inelatic Xsection     *
  /// C     NOTE   :                                                         *
  /// C     QUANTITIES:                                                 *
  /// C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  /// C                      N12,                                            *
  /// C                      M12=1 FOR p+n-->delta(+)+ n                     *
  /// C                          2     p+n-->delta(0)+ p                     *
  /// C                          3     p+p-->delta(++)+n                     *
  /// C                          4     p+p-->delta(+)+p                      *
  /// C                          5     n+n-->delta(0)+n                      *
  /// C                          6     n+n-->delta(-)+p                      *
  /// C                          7     n+p-->N*(0)(1440)+p                   *
  /// C                          8     n+p-->N*(+)(1440)+n                   *
  /// C                        9     p+p-->N*(+)(1535)+p                     *
  /// C                        10    n+n-->N*(0)(1535)+n                     *
  /// C                         11    n+p-->N*(+)(1535)+n                     *
  /// C                        12    n+p-->N*(0)(1535)+p
  /// C                        13    D(++)+D(-)-->N*(+)(1440)+n
  /// C                         14    D(++)+D(-)-->N*(0)(1440)+p
  /// C                        15    D(+)+D(0)--->N*(+)(1440)+n
  /// C                        16    D(+)+D(0)--->N*(0)(1440)+p
  /// C                        17    D(++)+D(0)-->N*(+)(1535)+p
  /// C                        18    D(++)+D(-)-->N*(0)(1535)+p
  /// C                        19    D(++)+D(-)-->N*(+)(1535)+n
  /// C                        20    D(+)+D(+)-->N*(+)(1535)+p
  /// C                        21    D(+)+D(0)-->N*(+)(1535)+n
  /// C                        22    D(+)+D(0)-->N*(0)(1535)+p
  /// C                        23    D(+)+D(-)-->N*(0)(1535)+n
  /// C                        24    D(0)+D(0)-->N*(0)(1535)+n
  /// C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  /// C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  /// C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  /// C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  /// C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  /// C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  /// C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  /// C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  /// C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  /// C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  /// C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  /// C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  /// C                            and more
  /// C**********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /input1/
  /// C
  /// C-----------------------------------------------------------------------
  xinel = 0.f;
  sigk = 0;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  xsk5 = 0;
  em1 = e(i1);
  em2 = e(i2);
  pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  /// C     CAN HAPPEN ANY MORE ==> RETURN (2.04 = 2*AVMASS + PI-MASS+0.02)
  if (srt < 2.04f) {
    return;
  }
  /// C Resonance absorption or Delta + N-->N*(1440), N*(1535)
  /// C COM: TEST FOR DELTA OR N* ABSORPTION
  /// C      IN THE PROCESS DELTA+N-->NN, N*+N-->NN
  prf = fem::sqrt(0.25f * fem::pow2(srt) - fem::pow2(avmass));
  if (em1 > 1.f) {
    deltam = em1;
  } else {
    deltam = em2;
  }
  renom = deltam * fem::pow2(prf) / denom(cmn, srt, 1.f) / pr;
  renomn = deltam * fem::pow2(prf) / denom(cmn, srt, 2.f) / pr;
  renom1 = deltam * fem::pow2(prf) / denom(cmn, srt, -1.f) / pr;
  /// C avoid the inelastic collisions between n+delta- -->N+N
  /// C       and p+delta++ -->N+N due to charge conservation,
  /// C       but they can scatter to produce kaons
  if ((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) {
    renom = 0.f;
  }
  if ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) {
    renom = 0.f;
  }
  if ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) {
    renom = 0.f;
  }
  if ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9)) {
    renom = 0.f;
  }
  m1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
  x1440 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
  /// C CROSS SECTION FOR KAON PRODUCTION from the four channels
  /// C for NLK channel
  akp = 0.498f;
  sve.ak0 = 0.498f;
  ana = 0.94f;
  ada = 1.232f;
  al = 1.1157f;
  as = 1.1197f;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  /// C      !! phi production
  xsk5 = 0;
  t1nlk = ana + al + akp;
  if (srt <= t1nlk) {
    goto statement_222;
  }
  xsk1 = 1.5f * pplpk(cmn, srt);
  /// C for DLK channel
  t1dlk = ada + al + akp;
  t2dlk = ada + al - akp;
  if (srt <= t1dlk) {
    goto statement_222;
  }
  es = srt;
  pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
           (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
  sve.pmdlk = fem::sqrt(pmdlk2);
  xsk3 = 1.5f * pplpk(cmn, srt);
  /// C for NSK channel
  t1nsk = ana + as + akp;
  t2nsk = ana + as - akp;
  if (srt <= t1nsk) {
    goto statement_222;
  }
  pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
           (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
  sve.pmnsk = fem::sqrt(pmnsk2);
  xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  /// C for DSK channel
  t1dsk = ada + as + akp;
  t2dsk = ada + as - akp;
  if (srt <= t1dsk) {
    goto statement_222;
  }
  pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
           (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
  sve.pmdsk = fem::sqrt(pmdsk2);
  xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  /// Csp11/21/01
  /// C phi production
  if (srt <= (2.f * amn + aphi)) {
    goto statement_222;
  }
  /// C  !! mb put the correct form
  xsk5 = 0.0001f;
/// Csp11/21/01 end
/// C
/// C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
statement_222:
  sigk = xsk1 + xsk2 + xsk3 + xsk4;
  /// C
  /// Cbz3/7/99 neutralk
  xsk1 = 2.0f * xsk1;
  xsk2 = 2.0f * xsk2;
  xsk3 = 2.0f * xsk3;
  xsk4 = 2.0f * xsk4;
  sigk = 2.0f * sigk + xsk5;
  /// Cbz3/7/99 neutralk end
  /// C
  /// C avoid the inelastic collisions between n+delta- -->N+N
  /// C       and p+delta++ -->N+N due to charge conservation,
  /// C       but they can scatter to produce kaons
  if (((fem::iabs(lb(i1)) == 2) && (fem::iabs(lb(i2)) == 6)) ||
      ((fem::iabs(lb(i2)) == 2) && (fem::iabs(lb(i1)) == 6)) ||
      ((fem::iabs(lb(i1)) == 1) && (fem::iabs(lb(i2)) == 9)) ||
      ((fem::iabs(lb(i2)) == 1) && (fem::iabs(lb(i1)) == 9))) {
    xinel = sigk;
    return;
  }
  /// C WE DETERMINE THE REACTION CHANNELS IN THE FOLLOWING
  /// C FOR n+delta(++)-->p+p or n+delta(++)-->n+N*(+)(1440),n+N*(+)(1535)
  /// C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
  if (lb(i1) * lb(i2) == 18 &&
      (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
    signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  /// C FOR p+delta(-)-->n+n or p+delta(-)-->n+N*(0)(1440),n+N*(0)(1535)
  /// C REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN,
  if (lb(i1) * lb(i2) == 6 &&
      (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
    signd = sigma(cmn, srt, 1, 1, 0) + 0.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  /// C FOR p+delta(+)-->p+p, N*(+)(144)+p, N*(+)(1535)+p
  /// Cbz11/25/98
  if (lb(i1) * lb(i2) == 8 &&
      (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
    signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  /// C FOR n+delta(0)-->n+n, N*(0)(144)+n, N*(0)(1535)+n
  if (lb(i1) * lb(i2) == 14 &&
      (fem::iabs(lb(i1)) == 2 && fem::iabs(lb(i2)) == 2)) {
    signd = 1.5f * sigma(cmn, srt, 1, 1, 1);
    sigdn = 0.25f * signd * renom;
    xinel = sigdn + x1440 + x1535 + sigk;
    return;
  }
  /// C FOR n+delta(+)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
  /// C                       N*(+)(1535)+n,N*(0)(1535)+p
  if (lb(i1) * lb(i2) == 16 &&
      (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
    signd = 0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
    sigdn = 0.5f * signd * renom;
    xinel = sigdn + 2.f * x1440 + 2.f * x1535 + sigk;
    return;
  }
  /// C FOR p+delta(0)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
  /// C                       N*(+)(1535)+n,N*(0)(1535)+p
  if (lb(i1) * lb(i2) == 7) {
    signd = 0.5f * sigma(cmn, srt, 1, 1, 1) + 0.25f * sigma(cmn, srt, 1, 1, 0);
    sigdn = 0.5f * signd * renom;
    xinel = sigdn + 2.f * x1440 + 2.f * x1535 + sigk;
    return;
  }
  /// C FOR p+N*(0)(14)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
  /// C OR  P+N*(0)(14)-->D(+)+N, D(0)+P,
  if (lb(i1) * lb(i2) == 10 &&
      (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1)) {
    signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    sigdn = signd * renomn;
    xinel = sigdn + x1535 + sigk;
    return;
  }
  /// C FOR n+N*(+)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
  if (lb(i1) * lb(i2) == 22 &&
      (fem::iabs(lb(i1)) == 2 || fem::iabs(lb(i2)) == 2)) {
    signd = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    sigdn = signd * renomn;
    xinel = sigdn + x1535 + sigk;
    return;
  }
  /// C FOR N*(1535)+N-->N+N COLLISIONS
  if ((fem::iabs(lb(i1)) == 12) || (fem::iabs(lb(i1)) == 13) ||
      (fem::iabs(lb(i2)) == 12) || (fem::iabs(lb(i2)) == 13)) {
    signd = x1535;
    sigdn = signd * renom1;
    xinel = sigdn + sigk;
    return;
  }
}

struct xddin_save {
  float ada;
  float ak0;
  float akp;
  float al;
  float ana;
  float as;
  float em1;
  float em2;
  float es;
  int idd;
  float pmdlk;
  float pmdlk2;
  float pmdsk;
  float pmdsk2;
  float pmnsk;
  float pmnsk2;
  float pr;
  float s2d;
  float sig2;
  float t1dlk;
  float t1dsk;
  float t1nlk;
  float t1nsk;
  float t2dlk;
  float t2dsk;
  float t2nsk;
  float x1535;

  xddin_save()
      : ada(fem::float0),
        ak0(fem::float0),
        akp(fem::float0),
        al(fem::float0),
        ana(fem::float0),
        as(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        es(fem::float0),
        idd(fem::int0),
        pmdlk(fem::float0),
        pmdlk2(fem::float0),
        pmdsk(fem::float0),
        pmdsk2(fem::float0),
        pmnsk(fem::float0),
        pmnsk2(fem::float0),
        pr(fem::float0),
        s2d(fem::float0),
        sig2(fem::float0),
        t1dlk(fem::float0),
        t1dsk(fem::float0),
        t1nlk(fem::float0),
        t1nsk(fem::float0),
        t2dlk(fem::float0),
        t2dsk(fem::float0),
        t2nsk(fem::float0),
        x1535(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void xddin(common& cmn, float const& px, float const& py, float const& pz,
           float const& srt, int const& i1, int const& i2, float& xinel,
           float& sigk, float& xsk1, float& xsk2, float& xsk3, float& xsk4,
           float& xsk5) {
  FEM_CMN_SVE(xddin);
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  float& ada = sve.ada;
  float& akp = sve.akp;
  float& al = sve.al;
  float& ana = sve.ana;
  float& as = sve.as;
  float& es = sve.es;
  int& idd = sve.idd;
  float& pmdlk2 = sve.pmdlk2;
  float& pmdsk2 = sve.pmdsk2;
  float& pmnsk2 = sve.pmnsk2;
  float& s2d = sve.s2d;
  float& sig2 = sve.sig2;
  float& t1dlk = sve.t1dlk;
  float& t1dsk = sve.t1dsk;
  float& t1nlk = sve.t1nlk;
  float& t1nsk = sve.t1nsk;
  float& t2dlk = sve.t2dlk;
  float& t2dsk = sve.t2dsk;
  float& t2nsk = sve.t2nsk;
  float& x1535 = sve.x1535;
  const float amn = 0.939457f;
  const float aphi = 1.020f;
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH BARYON RESONANCE-BARYON RESONANCE COLLISIONS*
  /// C     NOTE   :                                                         *
  /// C           VALID ONLY FOR BARYON-BARYON-DISTANCES LESS THAN 1.32 FM   *
  /// C           (1.32 = 2 * HARD-CORE-RADIUS [HRC] )                       *
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
  /// C           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      0-> COLLISION CANNOT HAPPEN                     *
  /// C                      1-> N-N ELASTIC COLLISION                       *
  /// C                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
  /// C                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
  /// C                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
  /// C                     5-> DELTA(N*)+DELTA(N*)   TOTAL   COLLISIONS    *
  /// C           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
  /// C                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
  /// C                      N12,                                            *
  /// C                      M12=1 FOR p+n-->delta(+)+ n                     *
  /// C                          2     p+n-->delta(0)+ p                     *
  /// C                          3     p+p-->delta(++)+n                     *
  /// C                          4     p+p-->delta(+)+p                      *
  /// C                          5     n+n-->delta(0)+n                      *
  /// C                          6     n+n-->delta(-)+p                      *
  /// C                          7     n+p-->N*(0)(1440)+p                   *
  /// C                          8     n+p-->N*(+)(1440)+n                   *
  /// C                        9     p+p-->N*(+)(1535)+p                     *
  /// C                        10    n+n-->N*(0)(1535)+n                     *
  /// C                         11    n+p-->N*(+)(1535)+n                     *
  /// C                        12    n+p-->N*(0)(1535)+p
  /// C                        13    D(++)+D(-)-->N*(+)(1440)+n
  /// C                         14    D(++)+D(-)-->N*(0)(1440)+p
  /// C                        15    D(+)+D(0)--->N*(+)(1440)+n
  /// C                        16    D(+)+D(0)--->N*(0)(1440)+p
  /// C                        17    D(++)+D(0)-->N*(+)(1535)+p
  /// C                        18    D(++)+D(-)-->N*(0)(1535)+p
  /// C                        19    D(++)+D(-)-->N*(+)(1535)+n
  /// C                        20    D(+)+D(+)-->N*(+)(1535)+p
  /// C                        21    D(+)+D(0)-->N*(+)(1535)+n
  /// C                        22    D(+)+D(0)-->N*(0)(1535)+p
  /// C                        23    D(+)+D(-)-->N*(0)(1535)+n
  /// C                        24    D(0)+D(0)-->N*(0)(1535)+n
  /// C                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
  /// C                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
  /// C                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
  /// C                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
  /// C                        29    N*(+)(14)+D+-->N*(+)(15)+p
  /// C                        30    N*(+)(14)+D0-->N*(+)(15)+n
  /// C                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
  /// C                        32    N*(0)(14)+D++--->N*(+)(15)+p
  /// C                        33    N*(0)(14)+D+--->N*(+)(15)+n
  /// C                        34    N*(0)(14)+D+--->N*(0)(15)+p
  /// C                        35    N*(0)(14)+D0-->N*(0)(15)+n
  /// C                        36    N*(+)(14)+D0--->N*(0)(15)+p
  /// C                        +++
  /// C               AND MORE CHANNELS AS LISTED IN THE NOTE BOOK
  /// C
  /// C NOTE ABOUT N*(1440) RESORANCE:                                       *
  /// C     As it has been discussed in VerWest's paper,I= 1 (initial isospin)
  /// C     channel can all be attributed to delta resorance while I= 0      *
  /// C     channel can all be  attribured to N* resorance.Only in n+p       *
  /// C     one can have I=0 channel so is the N*(1440) resorance            *
  /// C REFERENCES:    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)        *
  /// C                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
  /// C                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
  /// C                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615        *
  /// C                    CUTOFF = 2 * AVMASS + 20 MEV                      *
  /// C                                                                      *
  /// C       for N*(1535) we use the parameterization by Gy. Wolf et al     *
  /// C       Nucl phys A552 (1993) 349, added May 18, 1994                  *
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /input1/
  /// C-----------------------------------------------------------------------
  xinel = 0;
  sigk = 0;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  xsk5 = 0;
  sve.em1 = e(i1);
  sve.em2 = e(i2);
  sve.pr = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pz));
  /// C     IF THERE WERE 2 N*(1535) AND THEY DIDN'T SCATT. ELAST.,
  /// C     ALLOW THEM TO PRODUCE KAONS. NO OTHER INELASTIC CHANNELS
  /// C     ARE KNOWN
  /// C       if((lb(i1).ge.12).and.(lb(i2).ge.12))return
  /// C     ALL the inelastic collisions between N*(1535) and Delta as well
  /// C     as N*(1440) TO PRODUCE KAONS, NO OTHER CHANNELS ARE KNOWN
  /// C       if((lb(i1).ge.12).and.(lb(i2).ge.3))return
  /// C       if((lb(i2).ge.12).and.(lb(i1).ge.3))return
  /// C     calculate the N*(1535) production cross section in I1+I2 collisions
  n1535(cmn, fem::iabs(lb(i1)), fem::iabs(lb(i2)), srt, x1535);
  /// C
  /// C for Delta+Delta-->N*(1440 OR 1535)+N AND N*(1440)+N*(1440)-->N*(1535)+X
  /// C     AND DELTA+N*(1440)-->N*(1535)+X
  /// C WE ASSUME THEY HAVE THE SAME CROSS SECTIONS as CORRESPONDING N+N
  /// COLLISION): C FOR D++D0,
  /// D+D+,D+D-,D0D0,N*+N*+,N*0N*0,N*(+)D+,N*(+)D(-),N*(0)D(0) C N*(1535)
  /// production, kaon production and reabsorption through C D(N*)+D(N*)-->NN
  /// are ALLOWED. C CROSS SECTION FOR KAON PRODUCTION from the four channels
  /// are C for NLK channel
  akp = 0.498f;
  sve.ak0 = 0.498f;
  ana = 0.94f;
  ada = 1.232f;
  al = 1.1157f;
  as = 1.1197f;
  xsk1 = 0;
  xsk2 = 0;
  xsk3 = 0;
  xsk4 = 0;
  t1nlk = ana + al + akp;
  if (srt <= t1nlk) {
    goto statement_222;
  }
  xsk1 = 1.5f * pplpk(cmn, srt);
  /// C for DLK channel
  t1dlk = ada + al + akp;
  t2dlk = ada + al - akp;
  if (srt <= t1dlk) {
    goto statement_222;
  }
  es = srt;
  pmdlk2 = (fem::pow2(es) - fem::pow2(t1dlk)) *
           (fem::pow2(es) - fem::pow2(t2dlk)) / (4.f * fem::pow2(es));
  sve.pmdlk = fem::sqrt(pmdlk2);
  xsk3 = 1.5f * pplpk(cmn, srt);
  /// C for NSK channel
  t1nsk = ana + as + akp;
  t2nsk = ana + as - akp;
  if (srt <= t1nsk) {
    goto statement_222;
  }
  pmnsk2 = (fem::pow2(es) - fem::pow2(t1nsk)) *
           (fem::pow2(es) - fem::pow2(t2nsk)) / (4.f * fem::pow2(es));
  sve.pmnsk = fem::sqrt(pmnsk2);
  xsk2 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  /// C for DSK channel
  t1dsk = ada + as + akp;
  t2dsk = ada + as - akp;
  if (srt <= t1dsk) {
    goto statement_222;
  }
  pmdsk2 = (fem::pow2(es) - fem::pow2(t1dsk)) *
           (fem::pow2(es) - fem::pow2(t2dsk)) / (4.f * fem::pow2(es));
  sve.pmdsk = fem::sqrt(pmdsk2);
  xsk4 = 1.5f * (ppk1(cmn, srt) + ppk0(cmn, srt));
  /// Csp11/21/01
  /// C phi production
  if (srt <= (2.f * amn + aphi)) {
    goto statement_222;
  }
  /// C  !! mb put the correct form
  xsk5 = 0.0001f;
/// Csp11/21/01 end
/// C THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
statement_222:
  sigk = xsk1 + xsk2 + xsk3 + xsk4;
  /// C
  /// Cbz3/7/99 neutralk
  xsk1 = 2.0f * xsk1;
  xsk2 = 2.0f * xsk2;
  xsk3 = 2.0f * xsk3;
  xsk4 = 2.0f * xsk4;
  sigk = 2.0f * sigk + xsk5;
  /// Cbz3/7/99 neutralk end
  /// C
  idd = fem::iabs(lb(i1) * lb(i2));
  /// C The reabsorption cross section for the process
  /// C D(N*)D(N*)-->NN is
  s2d = reab2d(cmn, i1, i2, srt);
  /// C
  /// Cbz3/16/99 pion
  s2d = 0.f;
  /// Cbz3/16/99 pion end
  /// C
  /// C(1) N*(1535)+D(N*(1440)) reactions
  /// C    we allow kaon production and reabsorption only
  if (((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 12)) ||
      ((fem::iabs(lb(i1)) >= 12) && (fem::iabs(lb(i2)) >= 6)) ||
      ((fem::iabs(lb(i2)) >= 12) && (fem::iabs(lb(i1)) >= 6))) {
    xinel = sigk + s2d;
    return;
  }
  /// C channels have the same charge as pp
  if ((idd == 63) || (idd == 64) || (idd == 48) || (idd == 49) ||
      (idd == 11 * 11) || (idd == 10 * 10) || (idd == 88) || (idd == 66) ||
      (idd == 90) || (idd == 70)) {
    xinel = x1535 + sigk + s2d;
    return;
  }
  /// C IN DELTA+N*(1440) and N*(1440)+N*(1440) COLLISIONS,
  /// C N*(1535), kaon production and reabsorption are ALLOWED
  /// C IN N*(1440)+N*(1440) COLLISIONS, ONLY N*(1535) IS ALLOWED
  if ((idd == 110) || (idd == 77) || (idd == 80)) {
    xinel = x1535 + sigk + s2d;
    return;
  }
  if ((idd == 54) || (idd == 56)) {
    /// C LIKE FOR N+P COLLISION,
    /// C IN DELTA+DELTA COLLISIONS BOTH N*(1440) AND N*(1535) CAN BE PRODUCED
    sig2 = (3.f / 4.f) * sigma(cmn, srt, 2, 0, 1);
    xinel = 2.f * (sig2 + x1535) + sigk + s2d;
    return;
  }
}

struct dirct1_save {
  arr<float> earray;
  int ie;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  dirct1_save()
      : earray(dimension(122), fem::fill0),
        ie(fem::int0),
        xarray(dimension(122), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C*****************************************
float dirct1(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dirct1);
  arr_ref<float> earray(sve.earray, dimension(122));
  int& ie = sve.ie;
  arr_ref<float> xarray(sve.xarray, dimension(122));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {
          1.568300f, 1.578300f, 1.588300f, 1.598300f, 1.608300f, 1.618300f,
          1.628300f, 1.638300f, 1.648300f, 1.658300f, 1.668300f, 1.678300f,
          1.688300f, 1.698300f, 1.708300f, 1.718300f, 1.728300f, 1.738300f,
          1.748300f, 1.758300f, 1.768300f, 1.778300f, 1.788300f, 1.798300f,
          1.808300f, 1.818300f, 1.828300f, 1.838300f, 1.848300f, 1.858300f,
          1.868300f, 1.878300f, 1.888300f, 1.898300f, 1.908300f, 1.918300f,
          1.928300f, 1.938300f, 1.948300f, 1.958300f, 1.968300f, 1.978300f,
          1.988300f, 1.998300f, 2.008300f, 2.018300f, 2.028300f, 2.038300f,
          2.048300f, 2.058300f, 2.068300f, 2.078300f, 2.088300f, 2.098300f,
          2.108300f, 2.118300f, 2.128300f, 2.138300f, 2.148300f, 2.158300f,
          2.168300f, 2.178300f, 2.188300f, 2.198300f, 2.208300f, 2.218300f,
          2.228300f, 2.238300f, 2.248300f, 2.258300f, 2.268300f, 2.278300f,
          2.288300f, 2.298300f, 2.308300f, 2.318300f, 2.328300f, 2.338300f,
          2.348300f, 2.358300f, 2.368300f, 2.378300f, 2.388300f, 2.398300f,
          2.408300f, 2.418300f, 2.428300f, 2.438300f, 2.448300f, 2.458300f,
          2.468300f, 2.478300f, 2.488300f, 2.498300f, 2.508300f, 2.518300f,
          2.528300f, 2.538300f, 2.548300f, 2.558300f, 2.568300f, 2.578300f,
          2.588300f, 2.598300f, 2.608300f, 2.618300f, 2.628300f, 2.638300f,
          2.648300f, 2.658300f, 2.668300f, 2.678300f, 2.688300f, 2.698300f,
          2.708300f, 2.718300f, 2.728300f, 2.738300f, 2.748300f, 2.758300f,
          2.768300f, 2.778300f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {
          1.7764091e-02f, 0.5643668f, 0.8150568f, 1.045565f, 2.133695f,
          3.327922f,      4.206488f,  3.471242f,  4.486876f, 5.542213f,
          6.800052f,      7.192446f,  6.829848f,  6.580306f, 6.868410f,
          8.527946f,      10.15720f,  9.716511f,  9.298335f, 8.901310f,
          10.31213f,      10.52185f,  11.17630f,  11.61639f, 12.05577f,
          12.71596f,      13.46036f,  14.22060f,  14.65449f, 14.94775f,
          14.93310f,      15.32907f,  16.56481f,  16.29422f, 15.18548f,
          14.12658f,      13.72544f,  13.24488f,  13.31003f, 14.42680f,
          12.84423f,      12.49025f,  12.14858f,  11.81870f, 11.18993f,
          11.35816f,      11.09447f,  10.83873f,  10.61592f, 10.53754f,
          9.425521f,      8.195912f,  9.661075f,  9.696192f, 9.200142f,
          8.953734f,      8.715461f,  8.484999f,  8.320765f, 8.255512f,
          8.190969f,      8.127125f,  8.079508f,  8.073004f, 8.010611f,
          7.948909f,      7.887895f,  7.761005f,  7.626290f, 7.494696f,
          7.366132f,      7.530178f,  8.392097f,  9.046881f, 8.962544f,
          8.879403f,      8.797427f,  8.716601f,  8.636904f, 8.558312f,
          8.404368f,      8.328978f,  8.254617f,  8.181265f, 8.108907f,
          8.037527f,      7.967100f,  7.897617f,  7.829057f, 7.761405f,
          7.694647f,      7.628764f,  7.563742f,  7.499570f, 7.387562f,
          7.273281f,      7.161334f,  6.973375f,  6.529592f, 6.280323f,
          6.293136f,      6.305725f,  6.318097f,  6.330258f, 6.342214f,
          6.353968f,      6.365528f,  6.376895f,  6.388079f, 6.399081f,
          6.409906f,      6.420560f,  6.431045f,  6.441367f, 6.451529f,
          6.461533f,      6.471386f,  6.481091f,  6.490650f, 6.476413f,
          6.297259f,      6.097826f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  /// C  This function contains the experimental, direct pion(+) + p cross
  /// sections * C  srt    = DSQRT(s) in GeV * C  dirct1  = cross section in
  /// fm**2
  /// * C  earray = EXPerimental table with the srt C  xarray = EXPerimental
  /// table with cross sections in mb (curve to guide eye) *
  /// C*****************************************
  /// C      real*4   xarray(122), earray(122)
  /// C
  if (srt < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  if (srt > earray(122)) {
    return_value = xarray(122);
    return_value = return_value / 10.f;
    return return_value;
  }
  /// C
  /// CInterpolate double logarithmically to find xdirct2(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 122) {
    if (earray(ie) == srt) {
      return_value = xarray(ie);
      return_value = return_value / 10.f;
      return return_value;
    }
    if (earray(ie) > srt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(srt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return_value = return_value / 10.f;
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct dirct2_save {
  arr<float> earray;
  int ie;
  arr<float> xarray;
  float xmax;
  float xmin;
  float ymax;
  float ymin;

  dirct2_save()
      : earray(dimension(122), fem::fill0),
        ie(fem::int0),
        xarray(dimension(122), fem::fill0),
        xmax(fem::float0),
        xmin(fem::float0),
        ymax(fem::float0),
        ymin(fem::float0) {}
};

/// C******************************
/// C*****************************************
float dirct2(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dirct2);
  arr_ref<float> earray(sve.earray, dimension(122));
  int& ie = sve.ie;
  arr_ref<float> xarray(sve.xarray, dimension(122));
  float& xmax = sve.xmax;
  float& xmin = sve.xmin;
  float& ymax = sve.ymax;
  float& ymin = sve.ymin;
  if (is_called_first_time) {
    {
      static const float values[] = {
          1.568300f, 1.578300f, 1.588300f, 1.598300f, 1.608300f, 1.618300f,
          1.628300f, 1.638300f, 1.648300f, 1.658300f, 1.668300f, 1.678300f,
          1.688300f, 1.698300f, 1.708300f, 1.718300f, 1.728300f, 1.738300f,
          1.748300f, 1.758300f, 1.768300f, 1.778300f, 1.788300f, 1.798300f,
          1.808300f, 1.818300f, 1.828300f, 1.838300f, 1.848300f, 1.858300f,
          1.868300f, 1.878300f, 1.888300f, 1.898300f, 1.908300f, 1.918300f,
          1.928300f, 1.938300f, 1.948300f, 1.958300f, 1.968300f, 1.978300f,
          1.988300f, 1.998300f, 2.008300f, 2.018300f, 2.028300f, 2.038300f,
          2.048300f, 2.058300f, 2.068300f, 2.078300f, 2.088300f, 2.098300f,
          2.108300f, 2.118300f, 2.128300f, 2.138300f, 2.148300f, 2.158300f,
          2.168300f, 2.178300f, 2.188300f, 2.198300f, 2.208300f, 2.218300f,
          2.228300f, 2.238300f, 2.248300f, 2.258300f, 2.268300f, 2.278300f,
          2.288300f, 2.298300f, 2.308300f, 2.318300f, 2.328300f, 2.338300f,
          2.348300f, 2.358300f, 2.368300f, 2.378300f, 2.388300f, 2.398300f,
          2.408300f, 2.418300f, 2.428300f, 2.438300f, 2.448300f, 2.458300f,
          2.468300f, 2.478300f, 2.488300f, 2.498300f, 2.508300f, 2.518300f,
          2.528300f, 2.538300f, 2.548300f, 2.558300f, 2.568300f, 2.578300f,
          2.588300f, 2.598300f, 2.608300f, 2.618300f, 2.628300f, 2.638300f,
          2.648300f, 2.658300f, 2.668300f, 2.678300f, 2.688300f, 2.698300f,
          2.708300f, 2.718300f, 2.728300f, 2.738300f, 2.748300f, 2.758300f,
          2.768300f, 2.778300f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), earray;
    }
    {
      static const float values[] = {
          0.5773182f, 1.404156f, 2.578629f, 3.832013f, 4.906011f, 9.076963f,
          13.10492f,  10.65975f, 15.31156f, 19.77611f, 19.92874f, 18.68979f,
          19.80114f,  18.39536f, 14.34269f, 13.35353f, 13.58822f, 14.57031f,
          10.24686f,  11.23386f, 9.764803f, 10.35652f, 10.53539f, 10.07524f,
          9.582198f,  9.596469f, 9.818489f, 9.012848f, 9.378012f, 9.529244f,
          9.529698f,  8.835624f, 6.671396f, 8.797758f, 8.133437f, 7.866227f,
          7.823946f,  7.808504f, 7.791755f, 7.502062f, 7.417275f, 7.592349f,
          7.752028f,  7.910585f, 8.068122f, 8.224736f, 8.075289f, 7.895902f,
          7.721359f,  7.551512f, 7.386224f, 7.225343f, 7.068739f, 6.916284f,
          6.767842f,  6.623294f, 6.482520f, 6.345404f, 6.211833f, 7.339510f,
          7.531462f,  7.724824f, 7.919620f, 7.848021f, 7.639856f, 7.571083f,
          7.508881f,  7.447474f, 7.386855f, 7.327011f, 7.164454f, 7.001266f,
          6.842526f,  6.688094f, 6.537823f, 6.391583f, 6.249249f, 6.110689f,
          5.975790f,  5.894200f, 5.959503f, 6.024602f, 6.089505f, 6.154224f,
          6.218760f,  6.283128f, 6.347331f, 6.297411f, 6.120248f, 5.948606f,
          6.494864f,  6.357106f, 6.222824f, 6.091910f, 5.964267f, 5.839795f,
          5.718402f,  5.599994f, 5.499146f, 5.451325f, 5.404156f, 5.357625f,
          5.311721f,  5.266435f, 5.301964f, 5.343963f, 5.385833f, 5.427577f,
          5.469200f,  5.510702f, 5.552088f, 5.593359f, 5.634520f, 5.675570f,
          5.716515f,  5.757356f, 5.798093f, 5.838732f, 5.879272f, 5.919717f,
          5.960068f,  5.980941f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), xarray;
    }
  }
  /// C  This function contains the experimental, direct pion(-) + p cross
  /// sections * C  srt    = DSQRT(s) in GeV * C  dirct2 = cross section in
  /// fm**2 C  earray = EXPerimental table with the srt C  xarray = EXPerimental
  /// table with cross sections in mb (curve to guide eye) *
  /// C***************************************** C      real*4 xarray(122),
  /// earray(122)
  /// C
  if (srt < earray(1)) {
    return_value = 0.00001f;
    return return_value;
  }
  if (srt > earray(122)) {
    return_value = xarray(122);
    return_value = return_value / 10.f;
    return return_value;
  }
  /// C
  /// CInterpolate double logarithmically to find xdirct2(srt)
  /// C
  FEM_DO_SAFE(ie, 1, 122) {
    if (earray(ie) == srt) {
      return_value = xarray(ie);
      return_value = return_value / 10.f;
      return return_value;
    }
    if (earray(ie) > srt) {
      ymin = fem::alog(xarray(ie - 1));
      ymax = fem::alog(xarray(ie));
      xmin = fem::alog(earray(ie - 1));
      xmax = fem::alog(earray(ie));
      return_value = fem::exp(ymin + (fem::alog(srt) - xmin) * (ymax - ymin) /
                                         (xmax - xmin));
      return_value = return_value / 10.f;
      goto statement_50;
    }
  }
statement_50:
  return return_value;
}

struct fdr_save {
  float ak02;
  float ak2;
  float amd;
  float amp;
  float b;
  float q;
  float q0;

  fdr_save()
      : ak02(fem::float0),
        ak2(fem::float0),
        amd(fem::float0),
        amp(fem::float0),
        b(fem::float0),
        q(fem::float0),
        q0(fem::float0) {}
};

/// C**************************8
/// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
/// CKITAZOE'S FORMULA
/// C        REAL*4 FUNCTION FDR(DMASS,aj,al,width,widb0,srt,em1,em2)
float fdr(common& cmn, float const& dmass, float const& aj, float const& al,
          float const& width, float const& widb0, float const& srt,
          float const& em1, float const& em2) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fdr);
  /// SAVE
  float& ak02 = sve.ak02;
  float& ak2 = sve.ak2;
  float& amd = sve.amd;
  float& amp = sve.amp;
  float& b = sve.b;
  float& q = sve.q;
  float& q0 = sve.q0;
  ///
  amd = em1;
  amp = em2;
  ak02 =
      0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(amd) - fem::pow2(amp))) -
      fem::pow2((amp * amd));
  if (ak02 > 0.f) {
    q0 = fem::sqrt(ak02 / dmass);
  } else {
    q0 = 0.0f;
    return_value = 0;
    return return_value;
  }
  ak2 = 0.25f * fem::pow2((fem::pow2(srt) - fem::pow2(amd) - fem::pow2(amp))) -
        fem::pow2((amp * amd));
  if (ak2 > 0.f) {
    q = fem::sqrt(ak2 / dmass);
  } else {
    q = 0.00f;
    return_value = 0;
    return return_value;
  }
  b = widb0 * 1.2f * dmass / srt * fem::pow((q / q0), (2.f * al + 1)) /
      (1.f + 0.2f * fem::pow((q / q0), (2 * al)));
  return_value = (2.f * aj + 1) * fem::pow2(width) * b /
                 (fem::pow2((srt - dmass)) + 0.25f * fem::pow2(width)) /
                 (6.f * fem::pow2(q));
  return return_value;
}

struct erhon_save {
  arr<float> arrayb;
  arr<float> arrayj;
  arr<float> arrayl;
  arr<float> arraym;
  arr<float> arrayw;
  float branch;
  int ir;
  float pi;
  float xs;
  float xs0;

  erhon_save()
      : arrayb(dimension(19), fem::fill0),
        arrayj(dimension(19), fem::fill0),
        arrayl(dimension(19), fem::fill0),
        arraym(dimension(19), fem::fill0),
        arrayw(dimension(19), fem::fill0),
        branch(fem::float0),
        ir(fem::int0),
        pi(fem::float0),
        xs(fem::float0),
        xs0(fem::float0) {}
};

/// C******************************
/// C*****************************
/// C this program calculates the elastic cross section for rho+nucleon
/// C through higher resonances
/// C       real*4 function ErhoN(em1,em2,lb1,lb2,srt)
float erhon(common& cmn, float const& em1, float const& em2, int const& lb1,
            int const& lb2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(erhon);
  /// SAVE
  arr_ref<float> arrayb(sve.arrayb, dimension(19));
  arr_ref<float> arrayj(sve.arrayj, dimension(19));
  arr_ref<float> arrayl(sve.arrayl, dimension(19));
  arr_ref<float> arraym(sve.arraym, dimension(19));
  arr_ref<float> arrayw(sve.arrayw, dimension(19));
  float& branch = sve.branch;
  int& ir = sve.ir;
  float& pi = sve.pi;
  float& xs = sve.xs;
  float& xs0 = sve.xs0;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {0.5f, 1.5f, 0.5f, 0.5f, 2.5f, 2.5f, 1.5f,
                                     0.5f, 1.5f, 3.5f, 1.5f, 0.5f, 1.5f, 0.5f,
                                     2.5f, 0.5f, 1.5f, 2.5f, 3.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayj;
    }
    {
      static const int values[] = {1, 2, 0, 0, 2, 3, 2, 1, 1, 3,
                                   1, 0, 2, 0, 3, 1, 1, 2, 3};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), arrayl;
    }
    {
      static const float values[] = {1.44f,  1.52f, 1.535f, 1.65f, 1.675f,
                                     1.68f,  1.70f, 1.71f,  1.72f, 1.99f,
                                     1.60f,  1.62f, 1.70f,  1.90f, 1.905f,
                                     1.910f, 1.86f, 1.93f,  1.95f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arraym;
    }
    {
      static const float values[] = {0.2f,   0.125f, 0.15f, 0.15f, 0.155f,
                                     0.125f, 0.1f,   0.11f, 0.2f,  0.29f,
                                     0.25f,  0.16f,  0.28f, 0.15f, 0.3f,
                                     0.22f,  0.25f,  0.25f, 0.24f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayw;
    }
    {
      static const float values[] = {0.15f,  0.20f, 0.05f, 0.175f, 0.025f,
                                     0.125f, 0.1f,  0.20f, 0.53f,  0.34f,
                                     0.05f,  0.07f, 0.15f, 0.45f,  0.45f,
                                     0.058f, 0.08f, 0.12f, 0.08f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayb;
    }
  }
  /// C date : Dec. 19, 1994
  /// C ****************************
  /// C       implicit real*4 (a-h,o-z)
  /// C
  /// C the minimum energy for pion+delta collision
  pi = 3.1415926f;
  xs = 0;
  /// C include contribution from each resonance
  FEM_DO_SAFE(ir, 1, 19) {
    /// Cbz11/25/98
    if (ir <= 8) {
      /// C       if(lb1*lb2.eq.27.OR.LB1*LB2.EQ.25*2)branch=0.
      /// C       if(lb1*lb2.eq.26.OR.LB1*LB2.EQ.26*2)branch=1./3.
      /// C       if(lb1*lb2.eq.27*2.OR.LB1*LB2.EQ.25)branch=2./3.
      /// C       ELSE
      /// C       if(lb1*lb2.eq.27.OR.LB1*LB2.EQ.25*2)branch=1.
      /// C       if(lb1*lb2.eq.26.OR.LB1*LB2.EQ.26*2)branch=2./3.
      /// C       if(lb1*lb2.eq.27*2.OR.LB1*LB2.EQ.25)branch=1./3.
      /// C       ENDIF
      if (((lb1 * lb2 == 27 && (lb1 == 1 || lb2 == 1)) ||
           (lb1 * lb2 == 25 * 2 && (lb1 == 2 || lb2 == 2))) ||
          ((lb1 * lb2 == -25 && (lb1 == -1 || lb2 == -1)) ||
           (lb1 * lb2 == -27 * 2 && (lb1 == -2 || lb2 == -2)))) {
        branch = 0.f;
      }
      if ((fem::iabs(lb1 * lb2) == 26 &&
           (fem::iabs(lb1) == 1 || fem::iabs(lb2) == 1)) ||
          (fem::iabs(lb1 * lb2) == 26 * 2 &&
           (fem::iabs(lb1) == 2 || fem::iabs(lb2) == 2))) {
        branch = 1.f / 3.f;
      }
      if (((lb1 * lb2 == 27 * 2 && (lb1 == 2 || lb2 == 2)) ||
           (lb1 * lb2 == 25 && (lb1 == 1 || lb2 == 1))) ||
          ((lb1 * lb2 == -25 * 2 && (lb1 == -2 || lb2 == -2)) ||
           (lb1 * lb2 == -27 && (lb1 == -1 || lb2 == -1)))) {
        branch = 2.f / 3.f;
      }
    } else {
      if (((lb1 * lb2 == 27 && (lb1 == 1 || lb2 == 1)) ||
           (lb1 * lb2 == 25 * 2 && (lb1 == 2 || lb2 == 2))) ||
          ((lb1 * lb2 == -25 && (lb1 == -1 || lb2 == -1)) ||
           (lb1 * lb2 == -27 * 2 && (lb1 == -2 || lb2 == -2)))) {
        branch = 1.f;
      }
      if ((fem::iabs(lb1 * lb2) == 26 &&
           (fem::iabs(lb1) == 1 || fem::iabs(lb2) == 1)) ||
          (fem::iabs(lb1 * lb2) == 26 * 2 &&
           (fem::iabs(lb1) == 2 || fem::iabs(lb2) == 2))) {
        branch = 2.f / 3.f;
      }
      if (((lb1 * lb2 == 27 * 2 && (lb1 == 2 || lb2 == 2)) ||
           (lb1 * lb2 == 25 && (lb1 == 1 || lb2 == 1))) ||
          ((lb1 * lb2 == -25 * 2 && (lb1 == -2 || lb2 == -2)) ||
           (lb1 * lb2 == -27 && (lb1 == -1 || lb2 == -1)))) {
        branch = 1.f / 3.f;
      }
    }
    /// Cbz11/25/98end
    xs0 = fdr(cmn, arraym(ir), arrayj(ir), arrayl(ir), arrayw(ir), arrayb(ir),
              srt, em1, em2);
    xs += 1.3f * pi * branch * xs0 * fem::pow2((0.1973f));
  }
  return_value = xs;
  return return_value;
}

struct fd1_save {
  float ak02;
  float ak2;
  float amd;
  float amn;
  float amp;
  float b;
  float q;
  float q0;

  fd1_save()
      : ak02(fem::float0),
        ak2(fem::float0),
        amd(fem::float0),
        amn(fem::float0),
        amp(fem::float0),
        b(fem::float0),
        q(fem::float0),
        q0(fem::float0) {}
};

/// C**************************8
/// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
/// CKITAZOE'S FORMULA
/// C        REAL*4 FUNCTION FD1(DMASS,aj,al,width,widb0,srt)
float fd1(common& cmn, float const& dmass, float const& aj, float const& al,
          float const& width, float const& widb0, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fd1);
  /// SAVE
  float& ak02 = sve.ak02;
  float& ak2 = sve.ak2;
  float& amd = sve.amd;
  float& amn = sve.amn;
  float& amp = sve.amp;
  float& b = sve.b;
  float& q = sve.q;
  float& q0 = sve.q0;
  ///
  amn = 0.938f;
  amp = 0.138f;
  amd = amn;
  ak02 =
      0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(amd) - fem::pow2(amp))) -
      fem::pow2((amp * amd));
  if (ak02 > 0.f) {
    q0 = fem::sqrt(ak02 / dmass);
  } else {
    q0 = 0.0f;
    return_value = 0;
    return return_value;
  }
  ak2 = 0.25f * fem::pow2((fem::pow2(srt) - fem::pow2(amd) - fem::pow2(amp))) -
        fem::pow2((amp * amd));
  if (ak2 > 0.f) {
    q = fem::sqrt(ak2 / dmass);
  } else {
    q = 0.00f;
    return_value = 0;
    return return_value;
  }
  b = widb0 * 1.2f * dmass / srt * fem::pow((q / q0), (2.f * al + 1)) /
      (1.f + 0.2f * fem::pow((q / q0), (2 * al)));
  return_value = (2.f * aj + 1) * fem::pow2(width) * b /
                 (fem::pow2((srt - dmass)) + 0.25f * fem::pow2(width)) /
                 (2.f * fem::pow2(q));
  return return_value;
}

struct dirct3_save {
  float amn;
  float amp;
  arr<float> arrayb;
  arr<float> arrayj;
  arr<float> arrayl;
  arr<float> arraym;
  arr<float> arrayw;
  float branch;
  int ir;
  float pi;
  float xs;
  float xs0;

  dirct3_save()
      : amn(fem::float0),
        amp(fem::float0),
        arrayb(dimension(17), fem::fill0),
        arrayj(dimension(17), fem::fill0),
        arrayl(dimension(17), fem::fill0),
        arraym(dimension(17), fem::fill0),
        arrayw(dimension(17), fem::fill0),
        branch(fem::float0),
        ir(fem::int0),
        pi(fem::float0),
        xs(fem::float0),
        xs0(fem::float0) {}
};

/// C*****************************
/// C this program calculates the elastic cross section for pion+delta
/// C through higher resonances
/// C       REAL*4 FUNCTION DIRCT3(SRT)
float dirct3(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dirct3);
  /// SAVE
  arr_ref<float> arrayb(sve.arrayb, dimension(17));
  arr_ref<float> arrayj(sve.arrayj, dimension(17));
  arr_ref<float> arrayl(sve.arrayl, dimension(17));
  arr_ref<float> arraym(sve.arraym, dimension(17));
  arr_ref<float> arrayw(sve.arrayw, dimension(17));
  float& branch = sve.branch;
  int& ir = sve.ir;
  float& pi = sve.pi;
  float& xs = sve.xs;
  float& xs0 = sve.xs0;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {1.5f, 0.5f, 2.5f, 2.5f, 1.5f, 0.5f,
                                     1.5f, 3.5f, 1.5f, 0.5f, 1.5f, 0.5f,
                                     2.5f, 0.5f, 1.5f, 2.5f, 3.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayj;
    }
    {
      static const int values[] = {2, 0, 2, 3, 2, 1, 1, 3, 1,
                                   0, 2, 0, 3, 1, 1, 2, 3};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), arrayl;
    }
    {
      static const float values[] = {
          1.52f, 1.65f, 1.675f, 1.68f,  1.70f,  1.71f, 1.72f, 1.99f, 1.60f,
          1.62f, 1.70f, 1.90f,  1.905f, 1.910f, 1.86f, 1.93f, 1.95f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arraym;
    }
    {
      static const float values[] = {
          0.125f, 0.15f, 0.155f, 0.125f, 0.1f,  0.11f, 0.2f,  0.29f, 0.25f,
          0.16f,  0.28f, 0.15f,  0.3f,   0.22f, 0.25f, 0.25f, 0.24f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayw;
    }
    {
      static const float values[] = {0.55f, 0.6f,  0.375f, 0.6f,  0.1f,  0.15f,
                                     0.15f, 0.05f, 0.35f,  0.3f,  0.15f, 0.1f,
                                     0.1f,  0.22f, 0.2f,   0.09f, 0.4f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayb;
    }
  }
  /// C date : Dec. 19, 1994
  /// C ****************************
  /// C     implicit real*4 (a-h,o-z)
  /// C
  /// C the minimum energy for pion+delta collision
  pi = 3.1415926f;
  sve.amn = 0.938f;
  sve.amp = 0.138f;
  xs = 0;
  /// C include contribution from each resonance
  branch = 1.f / 3.f;
  FEM_DO_SAFE(ir, 1, 17) {
    if (ir > 8) {
      branch = 2.f / 3.f;
    }
    xs0 = fd1(cmn, arraym(ir), arrayj(ir), arrayl(ir), arrayw(ir), arrayb(ir),
              srt);
    xs += 1.3f * pi * branch * xs0 * fem::pow2((0.1973f));
  }
  return_value = xs;
  return return_value;
}

struct fd2_save {
  float ak02;
  float ak2;
  float amd;
  float amp;
  float b;
  float q;
  float q0;

  fd2_save()
      : ak02(fem::float0),
        ak2(fem::float0),
        amd(fem::float0),
        amp(fem::float0),
        b(fem::float0),
        q(fem::float0),
        q0(fem::float0) {}
};

/// C**************************8
/// CFUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
/// CKITAZOE'S FORMULA
/// C        REAL*4 FUNCTION FD2(DMASS,aj,al,width,widb0,EM1,EM2,srt)
float fd2(common& cmn, float const& dmass, float const& aj, float const& al,
          float const& width, float const& widb0, float const& em1,
          float const& em2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fd2);
  /// SAVE
  float& ak02 = sve.ak02;
  float& ak2 = sve.ak2;
  float& amd = sve.amd;
  float& amp = sve.amp;
  float& b = sve.b;
  float& q = sve.q;
  float& q0 = sve.q0;
  ///
  amp = em1;
  amd = em2;
  ak02 =
      0.25f * fem::pow2((fem::pow2(dmass) - fem::pow2(amd) - fem::pow2(amp))) -
      fem::pow2((amp * amd));
  if (ak02 > 0.f) {
    q0 = fem::sqrt(ak02 / dmass);
  } else {
    q0 = 0.0f;
    return_value = 0;
    return return_value;
  }
  ak2 = 0.25f * fem::pow2((fem::pow2(srt) - fem::pow2(amd) - fem::pow2(amp))) -
        fem::pow2((amp * amd));
  if (ak2 > 0.f) {
    q = fem::sqrt(ak2 / dmass);
  } else {
    q = 0.00f;
    return_value = 0;
    return return_value;
  }
  b = widb0 * 1.2f * dmass / srt * fem::pow((q / q0), (2.f * al + 1)) /
      (1.f + 0.2f * fem::pow((q / q0), (2 * al)));
  return_value = (2.f * aj + 1) * fem::pow2(width) * b /
                 (fem::pow2((srt - dmass)) + 0.25f * fem::pow2(width)) /
                 (4.f * fem::pow2(q));
  return return_value;
}

struct dpion_save {
  float amn;
  float amp;
  arr<float> arrayb;
  arr<float> arrayj;
  arr<float> arrayl;
  arr<float> arraym;
  arr<float> arrayw;
  float branch;
  int ir;
  float pi;
  float xs;
  float xs0;

  dpion_save()
      : amn(fem::float0),
        amp(fem::float0),
        arrayb(dimension(19), fem::fill0),
        arrayj(dimension(19), fem::fill0),
        arrayl(dimension(19), fem::fill0),
        arraym(dimension(19), fem::fill0),
        arrayw(dimension(19), fem::fill0),
        branch(fem::float0),
        ir(fem::int0),
        pi(fem::float0),
        xs(fem::float0),
        xs0(fem::float0) {}
};

/// C*****************************
/// C this program calculates the elastic cross section for pion+delta
/// C through higher resonances
/// C       REAL*4 FUNCTION DPION(EM1,EM2,LB1,LB2,SRT)
float dpion(common& cmn, float const& em1, float const& em2, int const& lb1,
            int const& lb2, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(dpion);
  /// SAVE
  arr_ref<float> arrayb(sve.arrayb, dimension(19));
  arr_ref<float> arrayj(sve.arrayj, dimension(19));
  arr_ref<float> arrayl(sve.arrayl, dimension(19));
  arr_ref<float> arraym(sve.arraym, dimension(19));
  arr_ref<float> arrayw(sve.arrayw, dimension(19));
  float& branch = sve.branch;
  int& ir = sve.ir;
  float& pi = sve.pi;
  float& xs = sve.xs;
  float& xs0 = sve.xs0;
  ///
  if (is_called_first_time) {
    {
      static const float values[] = {0.5f, 1.5f, 0.5f, 0.5f, 2.5f, 2.5f, 1.5f,
                                     0.5f, 1.5f, 3.5f, 1.5f, 0.5f, 1.5f, 0.5f,
                                     2.5f, 0.5f, 1.5f, 2.5f, 3.5f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayj;
    }
    {
      static const int values[] = {1, 2, 0, 0, 2, 3, 2, 1, 1, 3,
                                   1, 0, 2, 0, 3, 1, 1, 2, 3};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), arrayl;
    }
    {
      static const float values[] = {1.44f,  1.52f, 1.535f, 1.65f, 1.675f,
                                     1.68f,  1.70f, 1.71f,  1.72f, 1.99f,
                                     1.60f,  1.62f, 1.70f,  1.90f, 1.905f,
                                     1.910f, 1.86f, 1.93f,  1.95f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arraym;
    }
    {
      static const float values[] = {0.2f,   0.125f, 0.15f, 0.15f, 0.155f,
                                     0.125f, 0.1f,   0.11f, 0.2f,  0.29f,
                                     0.25f,  0.16f,  0.28f, 0.15f, 0.3f,
                                     0.22f,  0.25f,  0.25f, 0.24f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayw;
    }
    {
      static const float values[] = {0.15f,  0.25f,  0.f,     0.05f, 0.575f,
                                     0.125f, 0.379f, 0.10f,   0.10f, 0.062f,
                                     0.45f,  0.60f,  0.6984f, 0.05f, 0.25f,
                                     0.089f, 0.19f,  0.2f,    0.13f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), arrayb;
    }
  }
  /// C date : Dec. 19, 1994
  /// C ****************************
  /// C     implicit real*4 (a-h,o-z)
  /// C
  /// C the minimum energy for pion+delta collision
  pi = 3.1415926f;
  sve.amn = 0.94f;
  sve.amp = 0.14f;
  xs = 0;
  /// C include contribution from each resonance
  FEM_DO_SAFE(ir, 1, 19) {
    branch = 0.f;
    /// Cbz11/25/98
    if (ir <= 8) {
      /// C       IF(LB1*LB2.EQ.5*7.OR.LB1*LB2.EQ.3*8)branch=1./6.
      /// C       IF(LB1*LB2.EQ.4*7.OR.LB1*LB2.EQ.4*8)branch=1./3.
      /// C       IF(LB1*LB2.EQ.5*6.OR.LB1*LB2.EQ.3*9)branch=1./2.
      /// C       ELSE
      /// C       IF(LB1*LB2.EQ.5*8.OR.LB1*LB2.EQ.5*6)branch=2./5.
      /// C       IF(LB1*LB2.EQ.3*9.OR.LB1*LB2.EQ.3*7)branch=2./5.
      /// C       IF(LB1*LB2.EQ.5*7.OR.LB1*LB2.EQ.3*8)branch=8./15.
      /// C       IF(LB1*LB2.EQ.4*7.OR.LB1*LB2.EQ.4*8)branch=1./15.
      /// C       IF(LB1*LB2.EQ.4*9.OR.LB1*LB2.EQ.4*6)branch=3./5.
      /// C       ENDIF
      if (((lb1 * lb2 == 5 * 7 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 3 * 8 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -3 * 7 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -5 * 8 && (lb1 == 5 || lb2 == 5)))) {
        branch = 1.f / 6.f;
      }
      if ((fem::iabs(lb1 * lb2) == 4 * 7 && (lb1 == 4 || lb2 == 4)) ||
          (fem::iabs(lb1 * lb2) == 4 * 8 && (lb1 == 4 || lb2 == 4))) {
        branch = 1.f / 3.f;
      }
      if (((lb1 * lb2 == 5 * 6 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 3 * 9 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -3 * 6 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -5 * 9 && (lb1 == 5 || lb2 == 5)))) {
        branch = 1.f / 2.f;
      }
    } else {
      if (((lb1 * lb2 == 5 * 8 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 5 * 6 && (lb1 == 5 || lb2 == 5))) ||
          ((lb1 * lb2 == -3 * 8 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -3 * 6 && (lb1 == 3 || lb2 == 3)))) {
        branch = 2.f / 5.f;
      }
      if (((lb1 * lb2 == 3 * 9 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == 3 * 7 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -5 * 9 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == -5 * 7 && (lb1 == 5 || lb2 == 5)))) {
        branch = 2.f / 5.f;
      }
      if (((lb1 * lb2 == 5 * 7 && (lb1 == 5 || lb2 == 5)) ||
           (lb1 * lb2 == 3 * 8 && (lb1 == 3 || lb2 == 3))) ||
          ((lb1 * lb2 == -3 * 7 && (lb1 == 3 || lb2 == 3)) ||
           (lb1 * lb2 == -5 * 8 && (lb1 == 5 || lb2 == 5)))) {
        branch = 8.f / 15.f;
      }
      if ((fem::iabs(lb1 * lb2) == 4 * 7 && (lb1 == 4 || lb2 == 4)) ||
          (fem::iabs(lb1 * lb2) == 4 * 8 && (lb1 == 4 || lb2 == 4))) {
        branch = 1.f / 15.f;
      }
      if ((fem::iabs(lb1 * lb2) == 4 * 9 && (lb1 == 4 || lb2 == 4)) ||
          (fem::iabs(lb1 * lb2) == 4 * 6 && (lb1 == 4 || lb2 == 4))) {
        branch = 3.f / 5.f;
      }
    }
    /// Cbz11/25/98end
    xs0 = fd2(cmn, arraym(ir), arrayj(ir), arrayl(ir), arrayw(ir), arrayb(ir),
              em1, em2, srt);
    xs += 1.3f * pi * branch * xs0 * fem::pow2((0.1973f));
  }
  return_value = xs;
  return return_value;
}

struct xppbar_save {
  float plab;
  float plab2;

  xppbar_save() : plab(fem::float0), plab2(fem::float0) {}
};

/// Cbali1/16/99
/// C*******************************************
/// C Purpose: pp_bar annihilation cross section as a functon of their cms
/// energy C      real*4 function xppbar(srt)
float xppbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xppbar);
  /// SAVE
  float& plab = sve.plab;
  float& plab2 = sve.plab2;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  xppbar = pp_bar annihilation cross
  /// section in mb                           *
  /// C
  /// C  Reference: G.J. Wang, R. Bellwied, C. Pruneau and G. Welke
  /// C             Proc. of the 14th Winter Workshop on Nuclear Dynamics,
  /// C             Snowbird, Utah 31, Eds. W. Bauer and H.G. Ritter
  /// C             (Plenum Publishing, 1998)                             *
  /// C
  /// C*****************************************
  /// C Note:
  /// C (1) we introduce a new parameter xmax=400 mb:
  /// C     the maximum annihilation xsection
  /// C there are shadowing effects in pp_bar annihilation, with this parameter
  /// C we can probably look at these effects
  /// C (2) Calculate p(lab) from srt [GeV], since the formular in the
  /// C reference applies only to the case of a p_bar on a proton at rest
  /// C Formula used: srt**2=2.*pmass*(pmass+sqrt(pmass**2+plab**2))
  return_value = 1.e-06f;
  const float pmass = 0.9383f;
  plab2 =
      fem::pow2((fem::pow2(srt) / (2.f * pmass) - pmass)) - fem::pow2(pmass);
  const float xmax = 400.f;
  if (plab2 > 0) {
    plab = fem::sqrt(plab2);
    return_value = 67.f / (fem::pow(plab, 0.7f));
    if (return_value > xmax) {
      return_value = xmax;
    }
  }
  return return_value;
}

struct xphib_save {
  float srrt;
  float xsk6;

  xphib_save() : srrt(fem::float0), xsk6(fem::float0) {}
};

/// Cbz3/9/99 kkbar end
/// C
/// C****************************
/// C purpose: Xsection for Phi + B
void xphib(common& cmn, int const& lb1, int const& lb2, float const& em1,
           float const& em2, float const& srt, float& xsk1, float& xsk2,
           float& xsk3, float& xsk4, float& xsk5, float& sigp) {
  FEM_CMN_SVE(xphib);
  /// SAVE
  float& srrt = sve.srrt;
  float& xsk6 = sve.xsk6;
  ///
  /// C
  /// C ***************************
  /// C
  sigp = 1.e-08f;
  xsk1 = 0.0f;
  xsk2 = 0.0f;
  xsk3 = 0.0f;
  xsk4 = 0.0f;
  xsk5 = 0.0f;
  xsk6 = 0.0f;
  srrt = srt - (em1 + em2);
  /// C
  /// C* phi + N(D) -> elastic scattering
  /// C            XSK1 = 0.56  !! mb
  /// C  !! mb  (photo-production xsecn used)
  xsk1 = 8.00f;
  /// C
  /// C* phi + N(D) -> pi + N
  const float ap1 = 0.13496f;
  const float amn = 0.939457f;
  if (srt > (ap1 + amn)) {
    xsk2 = 0.0235f * fem::pow(srrt, (-0.519f));
  }
  /// C
  /// C* phi + N(D) -> pi + D
  const float am0 = 1.232f;
  if (srt > (ap1 + am0)) {
    if (srrt < 0.7f) {
      xsk3 = 0.0119f * fem::pow(srrt, (-0.534f));
    } else {
      xsk3 = 0.0130f * fem::pow(srrt, (-0.304f));
    }
  }
  /// C
  /// C* phi + N(D) -> rho + N
  const float arho = 0.77f;
  if (srt > (arho + amn)) {
    if (srrt < 0.7f) {
      xsk4 = 0.0166f * fem::pow(srrt, (-0.786f));
    } else {
      xsk4 = 0.0189f * fem::pow(srrt, (-0.277f));
    }
  }
  /// C
  /// C* phi + N(D) -> rho + D   (same as pi + D)
  if (srt > (arho + am0)) {
    if (srrt < 0.7f) {
      xsk5 = 0.0119f * fem::pow(srrt, (-0.534f));
    } else {
      xsk5 = 0.0130f * fem::pow(srrt, (-0.304f));
    }
  }
  /// C
  /// C* phi + N -> K+ + La
  const float aka = 0.498f;
  const float ala = 1.1157f;
  if ((lb1 >= 1 && lb1 <= 2) || (lb2 >= 1 && lb2 <= 2)) {
    if (srt > (aka + ala)) {
      xsk6 = 1.715f / (fem::pow2((srrt + 3.508f)) - 12.138f);
    }
  }
  sigp = xsk1 + xsk2 + xsk3 + xsk4 + xsk5 + xsk6;
}

struct crphib_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;
  float x1;

  crphib_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0) {}
};

/// C
/// C*********************************
/// C
void crphib(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, float const& xsk1, float& xsk2,
            float& xsk3, float& xsk4, float& xsk5, float const& sigp,
            int& iblock) {
  FEM_CMN_SVE(crphib);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  const float ap1 = 0.13496f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float arho = 0.77f;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float pi = 3.1415926f;
  /// C
  /// C     PURPOSE:                                                         *
  /// C             DEALING WITH PHI + N(D) --> pi+N(D), rho+N(D),  K+ + La
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - INFORMATION about the reaction channel          *
  /// C
  /// C             iblock   - 20  elastic
  /// C             iblock   - 221  K+ formation
  /// C             iblock   - 223  others
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  iblock = 223;
  /// C
  x1 = ranart(nseed) * sigp;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  xsk5 += xsk4;
  /// C
  /// C  !! elastic scatt.
  if (x1 <= xsk1) {
    iblock = 20;
    goto statement_100;
  } else if (x1 <= xsk2) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = ap1;
    e(i2) = amn;
    goto statement_100;
  } else if (x1 <= xsk3) {
    lb(i1) = 3 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = ap1;
    e(i2) = am0;
    goto statement_100;
  } else if (x1 <= xsk4) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 1 + fem::fint(2 * ranart(nseed));
    e(i1) = arho;
    e(i2) = amn;
    goto statement_100;
  } else if (x1 <= xsk5) {
    lb(i1) = 25 + fem::fint(3 * ranart(nseed));
    lb(i2) = 6 + fem::fint(4 * ranart(nseed));
    e(i1) = arho;
    e(i2) = am0;
    goto statement_100;
  } else {
    lb(i1) = 23;
    lb(i2) = 14;
    e(i1) = aka;
    e(i2) = ala;
    iblock = 221;
  }
statement_100:
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct pibphi_save {
  float sig;
  float srrt;
  float xphid;

  pibphi_save() : sig(fem::float0), srrt(fem::float0), xphid(fem::float0) {}
};

/// C
/// C****************************
/// C purpose: Xsection for Phi + B
/// C!! in fm^2
void pibphi(common& cmn, float const& srt, int const& lb1, int const& lb2,
            float const& em1, float const& em2, float& xphi, float& xphin) {
  FEM_CMN_SVE(pibphi);
  /// SAVE
  float& sig = sve.sig;
  float& srrt = sve.srrt;
  float& xphid = sve.xphid;
  ///
  /// C
  /// C      phi + N(D) <- pi + N
  /// C      phi + N(D) <- pi + D
  /// C      phi + N(D) <- rho + N
  /// C      phi + N(D) <- rho + D   (same as pi + D)
  /// C
  /// C ***************************
  /// C
  xphi = 0.0f;
  xphin = 0.0f;
  xphid = 0.0f;
  /// C
  const float aphi = 1.02f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  if ((lb1 >= 3 && lb1 <= 5) || (lb2 >= 3 && lb2 <= 5)) {
    /// C
    if ((fem::iabs(lb1) >= 1 && fem::iabs(lb1) <= 2) ||
        (fem::iabs(lb2) >= 1 && fem::iabs(lb2) <= 2)) {
      /// C* phi + N <- pi + N
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        sig = 0.0235f * fem::pow(srrt, (-0.519f));
        xphin = sig * 1.f * (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      /// C* phi + D <- pi + N
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        sig = 0.0235f * fem::pow(srrt, (-0.519f));
        xphid = sig * 4.f * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    } else {
      /// C* phi + N <- pi + D
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphin = sig * (1.f / 4.f) * (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      /// C* phi + D <- pi + D
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphid = sig * 1.f * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    }
    /// C
    /// C** for rho + N(D) colln
    /// C
  } else {
    /// C
    if ((fem::iabs(lb1) >= 1 && fem::iabs(lb1) <= 2) ||
        (fem::iabs(lb2) >= 1 && fem::iabs(lb2) <= 2)) {
      /// C
      /// C* phi + N <- rho + N
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        if (srrt < 0.7f) {
          sig = 0.0166f * fem::pow(srrt, (-0.786f));
        } else {
          sig = 0.0189f * fem::pow(srrt, (-0.277f));
        }
        xphin = sig * (1.f / 3.f) * (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      /// C* phi + D <- rho + N
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        if (srrt < 0.7f) {
          sig = 0.0166f * fem::pow(srrt, (-0.786f));
        } else {
          sig = 0.0189f * fem::pow(srrt, (-0.277f));
        }
        xphid = sig * (4.f / 3.f) * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    } else {
      /// C* phi + N <- rho + D  (same as pi+D->phi+N)
      if (srt > (aphi + amn)) {
        srrt = srt - (aphi + amn);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphin = sig * (1.f / 12.f) *
                (fem::pow2(srt) - fem::pow2((aphi + amn))) *
                (fem::pow2(srt) - fem::pow2((aphi - amn))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
      /// C* phi + D <- rho + D  (same as pi+D->phi+D)
      if (srt > (aphi + am0)) {
        srrt = srt - (aphi + am0);
        if (srrt < 0.7f) {
          sig = 0.0119f * fem::pow(srrt, (-0.534f));
        } else {
          sig = 0.0130f * fem::pow(srrt, (-0.304f));
        }
        xphid = sig * (1.f / 3.f) * (fem::pow2(srt) - fem::pow2((aphi + am0))) *
                (fem::pow2(srt) - fem::pow2((aphi - am0))) /
                (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                (fem::pow2(srt) - fem::pow2((em1 - em2)));
      }
    }
  }
  /// C   !! in fm^2
  xphin = xphin / 10.f;
  /// C   !! in fm^2
  xphid = xphid / 10.f;
  xphi = xphin + xphid;
  /// C
}

struct phimes_save {
  float akap;
  float em1;
  float em2;
  int lb1;
  int lb2;
  float pff;
  float pii;
  float s;
  float scheck;
  float srr;
  float srr1;
  float srr2;
  float srrt;

  phimes_save()
      : akap(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pff(fem::float0),
        pii(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        srr(fem::float0),
        srr1(fem::float0),
        srr2(fem::float0),
        srrt(fem::float0) {}
};

/// C
/// C****************************
/// C purpose: Xsection for phi +M to K+K etc
void phimes(common& cmn, int const& i1, int const& i2, float const& srt,
            float& xsk1, float& xsk2, float& xsk3, float& xsk4, float& xsk5,
            float& xsk6, float& xsk7, float& sigphi) {
  FEM_CMN_SVE(phimes);
  common_write write(cmn);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& akap = sve.akap;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pff = sve.pff;
  float& pii = sve.pii;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& srr = sve.srr;
  float& srr1 = sve.srr1;
  float& srr2 = sve.srr2;
  float& srrt = sve.srrt;
  ///
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      223 --> phi destruction
  /// C                      20 -->  elastic
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /EE/
  /// C
  s = fem::pow2(srt);
  sigphi = 1.e-08f;
  xsk1 = 0.0f;
  xsk2 = 0.0f;
  xsk3 = 0.0f;
  xsk4 = 0.0f;
  xsk5 = 0.0f;
  xsk6 = 0.0f;
  xsk7 = 0.0f;
  em1 = e(i1);
  em2 = e(i2);
  lb1 = lb(i1);
  lb2 = lb(i2);
  const float aka = 0.498f;
  akap = aka;
  /// C******
  /// C
  /// C   !! mb, elastic
  xsk1 = 5.0f;
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
  if (scheck <= 0) {
    write(99, star), "scheck48: ", scheck;
    FEM_STOP(0);
  }
  pii = fem::sqrt(scheck);
  /// C           pii = sqrt((S-(em1+em2)**2)*(S-(em1-em2)**2))
  /// C
  /// C phi + K(-bar) channel
  const float ap1 = 0.13496f;
  const float pi = 3.1415926f;
  const float arho = 0.77f;
  const float aomega = 0.7819f;
  const float aks = 0.895f;
  if (lb1 == 23 || lb2 == 23 || lb1 == 21 || lb2 == 21) {
    if (srt > (ap1 + akap)) {
      /// C             XSK2 = 2.5
      pff = fem::sqrt((s - fem::pow2((ap1 + akap))) *
                      (s - fem::pow2((ap1 - akap))));
      xsk2 = 195.639f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + akap)) {
      /// C              XSK3 = 3.5
      pff = fem::sqrt((s - fem::pow2((arho + akap))) *
                      (s - fem::pow2((arho - akap))));
      xsk3 = 526.702f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + akap)) {
      /// C               XSK4 = 3.5
      pff = fem::sqrt((s - fem::pow2((aomega + akap))) *
                      (s - fem::pow2((aomega - akap))));
      xsk4 = 355.429f * pff / pii / 32.f / pi / s;
    }
    if (srt > (ap1 + aks)) {
      /// C           XSK5 = 15.0
      pff = fem::sqrt((s - fem::pow2((ap1 + aks))) *
                      (s - fem::pow2((ap1 - aks))));
      xsk5 = 2047.042f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + aks)) {
      /// C            XSK6 = 3.5
      pff = fem::sqrt((s - fem::pow2((arho + aks))) *
                      (s - fem::pow2((arho - aks))));
      xsk6 = 1371.257f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + aks)) {
      /// C            XSK7 = 3.5
      pff = fem::sqrt((s - fem::pow2((aomega + aks))) *
                      (s - fem::pow2((aomega - aks))));
      xsk7 = 482.292f * pff / pii / 32.f / pi / s;
    }
    /// C
  } else if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
    /// C phi + K*(-bar) channel
    /// C
    if (srt > (ap1 + akap)) {
      /// C             XSK2 = 3.5
      pff = fem::sqrt((s - fem::pow2((ap1 + akap))) *
                      (s - fem::pow2((ap1 - akap))));
      xsk2 = 372.378f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + akap)) {
      /// C              XSK3 = 9.0
      pff = fem::sqrt((s - fem::pow2((arho + akap))) *
                      (s - fem::pow2((arho - akap))));
      xsk3 = 1313.960f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + akap)) {
      /// C               XSK4 = 6.5
      pff = fem::sqrt((s - fem::pow2((aomega + akap))) *
                      (s - fem::pow2((aomega - akap))));
      xsk4 = 440.558f * pff / pii / 32.f / pi / s;
    }
    if (srt > (ap1 + aks)) {
      /// C           XSK5 = 30.0 !wrong
      pff = fem::sqrt((s - fem::pow2((ap1 + aks))) *
                      (s - fem::pow2((ap1 - aks))));
      xsk5 = 1496.692f * pff / pii / 32.f / pi / s;
    }
    if (srt > (arho + aks)) {
      /// C            XSK6 = 9.0
      pff = fem::sqrt((s - fem::pow2((arho + aks))) *
                      (s - fem::pow2((arho - aks))));
      xsk6 = 6999.840f * pff / pii / 32.f / pi / s;
    }
    if (srt > (aomega + aks)) {
      /// C            XSK7 = 15.0
      pff = fem::sqrt((s - fem::pow2((aomega + aks))) *
                      (s - fem::pow2((aomega - aks))));
      xsk7 = 1698.903f * pff / pii / 32.f / pi / s;
    }
  } else {
    /// C
    /// C phi + rho(pi,omega) channel
    /// C
    srr1 = em1 + em2;
    if (srt > (akap + akap)) {
      srrt = srt - srr1;
      /// Cc          if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        xsk2 = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        xsk2 = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
    }
    if (srt > (akap + aks)) {
      srr2 = akap + aks;
      srr = fem::amax1(srr1, srr2);
      srrt = srt - srr;
      /// Cc          if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        xsk3 = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        xsk3 = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
    }
    if (srt > (aks + aks)) {
      srr2 = aks + aks;
      srr = fem::amax1(srr1, srr2);
      srrt = srt - srr;
      /// Cc          if(srrt .lt. 0.3)then
      if (srrt < 0.3f && srrt > 0.01f) {
        xsk4 = 1.69f / (fem::pow(srrt, 0.141f) - 0.407f);
      } else {
        xsk4 = 3.74f + 0.008f * fem::pow(srrt, 1.9f);
      }
    }
    /// C          xsk2 = amin1(20.,xsk2)
    /// C          xsk3 = amin1(20.,xsk3)
    /// C          xsk4 = amin1(20.,xsk4)
  }
  /// C
  sigphi = xsk1 + xsk2 + xsk3 + xsk4 + xsk5 + xsk6 + xsk7;
  /// C
}

struct crphim_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int iad1;
  int iad2;
  int lb1;
  int lb2;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;
  float x1;

  crphim_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        iad1(fem::int0),
        iad2(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        x1(fem::float0) {}
};

/// C
/// C*********************************
/// C     PURPOSE:                                                         *
/// C             DEALING WITH phi+M  scatt.
/// C
void crphim(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& i1, int const& i2, float const& xsk1, float& xsk2,
            float& xsk3, float& xsk4, float& xsk5, float& xsk6,
            float const& sigphi, int& ikkg, int& ikkl, int& iblock) {
  FEM_CMN_SVE(crphim);
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  int& iad1 = sve.iad1;
  int& iad2 = sve.iad2;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& x1 = sve.x1;
  const float ap1 = 0.13496f;
  const float aka = 0.498f;
  const float arho = 0.77f;
  const float aomega = 0.7819f;
  const float aks = 0.895f;
  const float pi = 3.1415926f;
  /// C
  /// C     QUANTITIES:                                                      *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                      20 -->  elastic
  /// C                      223 --> phi + pi(rho,omega)
  /// C                      224 --> phi + K -> K + pi(rho,omega)
  /// C                      225 --> phi + K -> K* + pi(rho,omega)
  /// C                      226 --> phi + K* -> K + pi(rho,omega)
  /// C                      227 --> phi + K* -> K* + pi(rho,omega)
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  lb1 = lb(i1);
  lb2 = lb(i2);
  /// C
  x1 = ranart(nseed) * sigphi;
  xsk2 += xsk1;
  xsk3 += xsk2;
  xsk4 += xsk3;
  xsk5 += xsk4;
  xsk6 += xsk5;
  if (x1 <= xsk1) {
    /// C        !! elastic scatt
    iblock = 20;
    goto statement_100;
  } else {
    /// C
    /// Cphi + (K,K*)-bar
    if (lb1 == 23 || lb1 == 21 || fem::iabs(lb1) == 30 || lb2 == 23 ||
        lb2 == 21 || fem::iabs(lb2) == 30) {
      /// C
      if (lb1 == 23 || lb2 == 23) {
        ikkl = 1;
        iblock = 224;
        iad1 = 23;
        iad2 = 30;
      } else if (lb1 == 30 || lb2 == 30) {
        ikkl = 0;
        iblock = 226;
        iad1 = 23;
        iad2 = 30;
      } else if (lb1 == 21 || lb2 == 21) {
        ikkl = 1;
        iblock = 124;
        iad1 = 21;
        iad2 = -30;
        /// C         !! -30
      } else {
        ikkl = 0;
        iblock = 126;
        iad1 = 21;
        iad2 = -30;
      }
      if (x1 <= xsk2) {
        lb(i1) = 3 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad1;
        e(i1) = ap1;
        e(i2) = aka;
        ikkg = 1;
        goto statement_100;
      } else if (x1 <= xsk3) {
        lb(i1) = 25 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad1;
        e(i1) = arho;
        e(i2) = aka;
        ikkg = 1;
        goto statement_100;
      } else if (x1 <= xsk4) {
        lb(i1) = 28;
        lb(i2) = iad1;
        e(i1) = aomega;
        e(i2) = aka;
        ikkg = 1;
        goto statement_100;
      } else if (x1 <= xsk5) {
        lb(i1) = 3 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad2;
        e(i1) = ap1;
        e(i2) = aks;
        ikkg = 0;
        iblock++;
        goto statement_100;
      } else if (x1 <= xsk6) {
        lb(i1) = 25 + fem::fint(3 * ranart(nseed));
        lb(i2) = iad2;
        e(i1) = arho;
        e(i2) = aks;
        ikkg = 0;
        iblock++;
        goto statement_100;
      } else {
        lb(i1) = 28;
        lb(i2) = iad2;
        e(i1) = aomega;
        e(i2) = aks;
        ikkg = 0;
        iblock++;
        goto statement_100;
      }
    } else {
      /// C      !! phi destruction via (pi,rho,omega)
      iblock = 223;
      /// Cphi + pi(rho,omega)
      if (x1 <= xsk2) {
        lb(i1) = 23;
        lb(i2) = 21;
        e(i1) = aka;
        e(i2) = aka;
        ikkg = 2;
        ikkl = 0;
        goto statement_100;
      } else if (x1 <= xsk3) {
        lb(i1) = 23;
        /// C           LB(I2) = 30
        lb(i2) = -30;
        /// Clin-2/10/03 currently take XSK3 to be the sum of KK*bar & KbarK*:
        if (ranart(nseed) <= 0.5f) {
          lb(i1) = 21;
          lb(i2) = 30;
        }
        /// C
        e(i1) = aka;
        e(i2) = aks;
        ikkg = 1;
        ikkl = 0;
        goto statement_100;
      } else if (x1 <= xsk4) {
        lb(i1) = 30;
        /// C           LB(I2) = 30
        lb(i2) = -30;
        e(i1) = aks;
        e(i2) = aks;
        ikkg = 0;
        ikkl = 0;
        goto statement_100;
      }
    }
  }
/// C
statement_100:
  em1 = e(i1);
  em2 = e(i2);
  /// C
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-08f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
}

struct xkhype_save {
  float ddf;
  int lb1;
  int lb2;
  float pf2;
  float pi2;
  float s;
  float sig;
  float srrt;
  float xkaon0;
  float xm1;
  float xm2;

  xkhype_save()
      : ddf(fem::float0),
        lb1(fem::int0),
        lb2(fem::int0),
        pf2(fem::float0),
        pi2(fem::float0),
        s(fem::float0),
        sig(fem::float0),
        srrt(fem::float0),
        xkaon0(fem::float0),
        xm1(fem::float0),
        xm2(fem::float0) {}
};

/// C*********************************
/// Cbz3/9/99 khyperon
/// C************************************
/// C purpose: Xsection for K+Y ->  piN                                       *
/// C          Xsection for K+Y-bar ->  piN-bar   !! sp03/29/01               *
/// C
void xkhype(common& cmn, int const& i1, int const& i2, float const& srt,
            float& xky1, float& xky2, float& xky3, float& xky4, float& xky5,
            float& xky6, float& xky7, float& xky8, float& xky9, float& xky10,
            float& xky11, float& xky12, float& xky13, float& xky14,
            float& xky15, float& xky16, float& xky17, float& sigk) {
  FEM_CMN_SVE(xkhype);
  /// COMMON ee
  const int maxstr = 150001;
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& ddf = sve.ddf;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s = sve.s;
  float& sig = sve.sig;
  float& srrt = sve.srrt;
  float& xkaon0 = sve.xkaon0;
  float& xm1 = sve.xm1;
  float& xm2 = sve.xm2;
  ///
  /// C      subroutine xkhype(i1, i2, srt, sigk)
  /// C  srt    = DSQRT(s) in GeV * C  xkkpi   = xsection in mb obtained from *
  /// C           the detailed balance * C ***********************************
  /// Cc      SAVE /EE/
  /// C
  s = fem::pow2(srt);
  sigk = 1.e-08f;
  xky1 = 0.0f;
  xky2 = 0.0f;
  xky3 = 0.0f;
  xky4 = 0.0f;
  xky5 = 0.0f;
  xky6 = 0.0f;
  xky7 = 0.0f;
  xky8 = 0.0f;
  xky9 = 0.0f;
  xky10 = 0.0f;
  xky11 = 0.0f;
  xky12 = 0.0f;
  xky13 = 0.0f;
  xky14 = 0.0f;
  xky15 = 0.0f;
  xky16 = 0.0f;
  xky17 = 0.0f;
  /// C
  lb1 = lb(i1);
  lb2 = lb(i2);
  const float aml = 1.116f;
  const float aka = 0.498f;
  const float ams = 1.193f;
  if (fem::iabs(lb1) == 14 || fem::iabs(lb2) == 14) {
    xkaon0 = pnlka(cmn, srt);
    xkaon0 = 2.0f * xkaon0;
    pi2 = (s - fem::pow2((aml + aka))) * (s - fem::pow2((aml - aka)));
  } else {
    xkaon0 = pnska(cmn, srt);
    xkaon0 = 2.0f * xkaon0;
    pi2 = (s - fem::pow2((ams + aka))) * (s - fem::pow2((ams - aka)));
  }
  if (pi2 <= 0.0f) {
    return;
  }
  /// C
  const float pimass = 0.140f;
  xm1 = pimass;
  const float amp = 0.93828f;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky1 = 3.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = pimass;
  const float am0 = 1.232f;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky2 = 12.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = pimass;
  const float am1440 = 1.44f;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky3 = 3.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = pimass;
  const float am1535 = 1.535f;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky4 = 3.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  const float amrho = 0.769f;
  xm1 = amrho;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky5 = 9.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = amrho;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky6 = 36.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = amrho;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky7 = 9.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = amrho;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky8 = 9.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  const float amomga = 0.782f;
  xm1 = amomga;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky9 = 3.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = amomga;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky10 = 12.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = amomga;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky11 = 3.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = amomga;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky12 = 3.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  const float ameta = 0.5473f;
  xm1 = ameta;
  xm2 = amp;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky13 = 1.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = ameta;
  xm2 = am0;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky14 = 4.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = ameta;
  xm2 = am1440;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky15 = 1.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  xm1 = ameta;
  xm2 = am1535;
  pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
  if (pf2 > 0.0f) {
    xky16 = 1.0f * pf2 / pi2 * xkaon0;
  }
  /// C
  /// Csp11/21/01  K+ + La --> phi + N
  const float aphi = 1.02f;
  const float amn = 0.939457f;
  if (lb1 == 14 || lb2 == 14) {
    if (srt > (aphi + amn)) {
      srrt = srt - (aphi + amn);
      sig = 1.715f / (fem::pow2((srrt + 3.508f)) - 12.138f);
      xm1 = amn;
      xm2 = aphi;
      pf2 = (s - fem::pow2((xm1 + xm2))) * (s - fem::pow2((xm1 - xm2)));
      /// C     ! fm^-1
      xky17 = 3.0f * pf2 / pi2 * sig / 10.f;
    }
  }
  /// Csp11/21/01  end
  /// C
  if ((fem::iabs(lb1) >= 15 && fem::iabs(lb1) <= 17) ||
      (fem::iabs(lb2) >= 15 && fem::iabs(lb2) <= 17)) {
    ddf = 3.0f;
    xky1 = xky1 / ddf;
    xky2 = xky2 / ddf;
    xky3 = xky3 / ddf;
    xky4 = xky4 / ddf;
    xky5 = xky5 / ddf;
    xky6 = xky6 / ddf;
    xky7 = xky7 / ddf;
    xky8 = xky8 / ddf;
    xky9 = xky9 / ddf;
    xky10 = xky10 / ddf;
    xky11 = xky11 / ddf;
    xky12 = xky12 / ddf;
    xky13 = xky13 / ddf;
    xky14 = xky14 / ddf;
    xky15 = xky15 / ddf;
    xky16 = xky16 / ddf;
  }
  /// C
  sigk = xky1 + xky2 + xky3 + xky4 + xky5 + xky6 + xky7 + xky8 + xky9 + xky10 +
         xky11 + xky12 + xky13 + xky14 + xky15 + xky16 + xky17;
  /// C
}

struct getnst_save {
  int i;
  float pf2;

  getnst_save() : i(fem::int0), pf2(fem::float0) {}
};

/// C
/// C****************************************
/// C get the number of BbarB states available for mm collisions of energy srt
void getnst(common& cmn, float const& srt) {
  FEM_CMN_SVE(getnst);
  /// COMMON ppbmas
  arr_cref<int> niso(cmn.niso, dimension(15));
  int& nstate = cmn.nstate;
  arr_cref<float, 2> ppbm(cmn.ppbm, dimension(15, 2));
  arr_cref<float> thresh(cmn.thresh, dimension(15));
  arr_ref<float> weight(cmn.weight, dimension(15));
  /// COMMON ppb1
  float& ene = cmn.ene;
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  float& wtot = cmn.wtot;
  ///
  /// SAVE
  int& i = sve.i;
  float& pf2 = sve.pf2;
  ///
  /// C  srt    = DSQRT(s) in GeV * C**************************************** Cc
  /// SAVE /ppbmas/ Cc      SAVE /ppb1/ Cc      SAVE /ppmm/
  /// C
  s = fem::pow2(srt);
  nstate = 0;
  wtot = 0.f;
  if (srt <= thresh(1)) {
    return;
  }
  FEM_DO_SAFE(i, 1, 15) {
    weight(i) = 0.f;
    if (srt > thresh(i)) {
      nstate = i;
    }
  }
  FEM_DO_SAFE(i, 1, nstate) {
    pf2 = (s - fem::pow2((ppbm(i, 1) + ppbm(i, 2)))) *
          (s - fem::pow2((ppbm(i, 1) - ppbm(i, 2)))) / 4 / s;
    weight(i) = pf2 * niso(i);
    wtot += weight(i);
  }
  const float pimass = 0.140f;
  const float pi = 3.1415926f;
  ene = fem::pow3((srt / pimass)) / (6.f * fem::pow2(pi));
  cmn.fsum = factr2(2) + factr2(3) * ene + factr2(4) * fem::pow2(ene) +
             factr2(5) * fem::pow3(ene) + factr2(6) * fem::pow4(ene);
  /// C
}

struct ppbbar_save {
  float pi2;
  float sppb2p;

  ppbbar_save() : pi2(fem::float0), sppb2p(fem::float0) {}
};

/// C
/// C****************************************
/// C for pion+pion-->Bbar B * C      real*4 function ppbbar(srt)
float ppbbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ppbbar);
  /// COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  ///
  /// SAVE
  float& pi2 = sve.pi2;
  float& sppb2p = sve.sppb2p;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  sppb2p = xppbar(cmn, srt) * factr2(2) / cmn.fsum;
  const float pimass = 0.140f;
  pi2 = (cmn.s - 4 * fem::pow2(pimass)) / 4;
  return_value = 4.f / 9.f * sppb2p / pi2 * cmn.wtot;
  /// C
  return return_value;
}

struct prbbar_save {
  float pi2;
  float sppb3p;

  prbbar_save() : pi2(fem::float0), sppb3p(fem::float0) {}
};

/// C
/// C****************************************
/// C for pion+rho-->Bbar B * C      real*4 function prbbar(srt)
float prbbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(prbbar);
  /// COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  ///
  /// SAVE
  float& pi2 = sve.pi2;
  float& sppb3p = sve.sppb3p;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  sppb3p = xppbar(cmn, srt) * factr2(3) * cmn.ene / cmn.fsum;
  const float pimass = 0.140f;
  const float arho = 0.77f;
  pi2 = (s - fem::pow2((pimass + arho))) * (s - fem::pow2((pimass - arho))) /
        4 / s;
  return_value = 4.f / 27.f * sppb3p / pi2 * cmn.wtot;
  /// C
  return return_value;
}

struct rrbbar_save {
  float pi2;
  float sppb4p;

  rrbbar_save() : pi2(fem::float0), sppb4p(fem::float0) {}
};

/// C
/// C****************************************
/// C for rho+rho-->Bbar B * C      real*4 function rrbbar(srt)
float rrbbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rrbbar);
  /// COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  ///
  /// SAVE
  float& pi2 = sve.pi2;
  float& sppb4p = sve.sppb4p;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  sppb4p = xppbar(cmn, srt) * factr2(4) * fem::pow2(cmn.ene) / cmn.fsum;
  const float arho = 0.77f;
  pi2 = (cmn.s - 4 * fem::pow2(arho)) / 4;
  return_value = 4.f / 81.f * (sppb4p / 2) / pi2 * cmn.wtot;
  /// C
  return return_value;
}

struct pobbar_save {
  float pi2;
  float sppb4p;

  pobbar_save() : pi2(fem::float0), sppb4p(fem::float0) {}
};

/// C
/// C****************************************
/// C for pi+omega-->Bbar B * C      real*4 function pobbar(srt)
float pobbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pobbar);
  /// COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  ///
  /// SAVE
  float& pi2 = sve.pi2;
  float& sppb4p = sve.sppb4p;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  sppb4p = xppbar(cmn, srt) * factr2(4) * fem::pow2(cmn.ene) / cmn.fsum;
  const float pimass = 0.140f;
  const float aomega = 0.782f;
  pi2 = (s - fem::pow2((pimass + aomega))) *
        (s - fem::pow2((pimass - aomega))) / 4 / s;
  return_value = 4.f / 9.f * (sppb4p / 2) / pi2 * cmn.wtot;
  /// C
  return return_value;
}

struct robbar_save {
  float pi2;
  float sppb5p;

  robbar_save() : pi2(fem::float0), sppb5p(fem::float0) {}
};

/// C
/// C****************************************
/// C for rho+omega-->Bbar B * C      real*4 function robbar(srt)
float robbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(robbar);
  /// COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  float& s = cmn.s;
  ///
  /// SAVE
  float& pi2 = sve.pi2;
  float& sppb5p = sve.sppb5p;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  sppb5p = xppbar(cmn, srt) * factr2(5) * fem::pow3(cmn.ene) / cmn.fsum;
  const float arho = 0.77f;
  const float aomega = 0.782f;
  pi2 = (s - fem::pow2((arho + aomega))) * (s - fem::pow2((arho - aomega))) /
        4 / s;
  return_value = 4.f / 27.f * sppb5p / pi2 * cmn.wtot;
  /// C
  return return_value;
}

struct oobbar_save {
  float pi2;
  float sppb6p;

  oobbar_save() : pi2(fem::float0), sppb6p(fem::float0) {}
};

/// C
/// C****************************************
/// C for omega+omega-->Bbar B * C      real*4 function oobbar(srt)
float oobbar(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(oobbar);
  /// COMMON ppb1
  arr_cref<float> factr2(cmn.factr2, dimension(6));
  ///
  /// SAVE
  float& pi2 = sve.pi2;
  float& sppb6p = sve.sppb6p;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  sppb6p = xppbar(cmn, srt) * factr2(6) * fem::pow4(cmn.ene) / cmn.fsum;
  const float aomega = 0.782f;
  pi2 = (cmn.s - 4 * fem::pow2(aomega)) / 4;
  return_value = 4.f / 9.f * sppb6p / pi2 * cmn.wtot;
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for rho rho -> pi pi, assumed a constant cross section (in mb)
float rtop(float const& /* srt */) {
  float return_value = fem::float0;
  /// C****************************************
  return_value = 5.f;
  return return_value;
}

struct ptor_save {
  float s2;

  ptor_save() : s2(fem::float0) {}
};

/// C
/// C****************************************
/// C for pi pi -> rho rho, determined from detailed balance
float ptor(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptor);
  /// SAVE
  float& s2 = sve.s2;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  s2 = fem::pow2(srt);
  const float arho = 0.77f;
  const float pimass = 0.140f;
  return_value =
      9 * (s2 - 4 * fem::pow2(arho)) / (s2 - 4 * fem::pow2(pimass)) * rtop(srt);
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for pi pi <-> rho rho cross sections
void spprr(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  /// COMMON ppmm
  float& pprr = cmn.pprr;
  ///
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  pprr = 0.f;
  const float arho = 0.77f;
  if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
    /// C     for now, rho mass taken to be the central value in these two
    /// processes
    if (srt > (2 * arho)) {
      pprr = ptor(cmn, srt);
    }
  } else if ((lb1 >= 25 && lb1 <= 27) && (lb2 >= 25 && lb2 <= 27)) {
    pprr = rtop(srt);
  }
  /// C
}

/// C****************************************
/// C for eta eta -> pi pi, assumed a constant cross section (in mb)
float etop(float const& /* srt */) {
  float return_value = fem::float0;
  /// C****************************************
  /// C
  /// C     eta equilibration:
  /// C     most important channel is found to be pi pi <-> pi eta, then
  /// C     rho pi <-> rho eta.
  return_value = 5.f;
  return return_value;
}

struct ptoe_save {
  float s2;

  ptoe_save() : s2(fem::float0) {}
};

/// C
/// C****************************************
/// C for pi pi -> eta eta, determined from detailed balance, spin-isospin
/// averaged
float ptoe(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ptoe);
  /// SAVE
  float& s2 = sve.s2;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  s2 = fem::pow2(srt);
  const float etam = 0.5475f;
  const float pimass = 0.140f;
  return_value = 1.f / 9.f * (s2 - 4 * fem::pow2(etam)) /
                 (s2 - 4 * fem::pow2(pimass)) * etop(srt);
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for pi pi <-> eta eta cross sections
void sppee(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  /// COMMON ppmm
  float& ppee = cmn.ppee;
  ///
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  ppee = 0.f;
  const float etam = 0.5475f;
  if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
    if (srt > (2 * etam)) {
      ppee = ptoe(cmn, srt);
    }
  } else if (lb1 == 0 && lb2 == 0) {
    ppee = etop(srt);
  }
  /// C
}

/// C****************************************
/// C for pi eta -> pi pi, assumed a constant cross section (in mb)
float petopp(float const& /* srt */) {
  float return_value = fem::float0;
  /// C****************************************
  /// C
  /// C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct pptope_save {
  float pf2;
  float pi2;
  float s2;

  pptope_save() : pf2(fem::float0), pi2(fem::float0), s2(fem::float0) {}
};

/// C
/// C****************************************
/// C for pi pi -> pi eta, determined from detailed balance, spin-isospin
/// averaged
float pptope(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pptope);
  /// SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s2 = sve.s2;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  s2 = fem::pow2(srt);
  const float pimass = 0.140f;
  const float etam = 0.5475f;
  pf2 = (s2 - fem::pow2((pimass + etam))) * (s2 - fem::pow2((pimass - etam))) /
        2 / fem::sqrt(s2);
  pi2 = (s2 - 4 * fem::pow2(pimass)) * s2 / 2 / fem::sqrt(s2);
  return_value = 1.f / 3.f * pf2 / pi2 * petopp(srt);
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for pi pi <-> pi eta cross sections
void spppe(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  /// COMMON ppmm
  float& pppe = cmn.pppe;
  ///
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  pppe = 0.f;
  const float etam = 0.5475f;
  const float pimass = 0.140f;
  if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
    if (srt > (etam + pimass)) {
      pppe = pptope(cmn, srt);
    }
  } else if ((lb1 >= 3 && lb1 <= 5) && lb2 == 0) {
    pppe = petopp(srt);
  } else if ((lb2 >= 3 && lb2 <= 5) && lb1 == 0) {
    pppe = petopp(srt);
  }
  /// C
}

/// C****************************************
/// C for rho eta -> rho pi, assumed a constant cross section (in mb)
float retorp(float const& /* srt */) {
  float return_value = fem::float0;
  /// C****************************************
  /// C
  /// C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct rptore_save {
  float pf2;
  float pi2;
  float s2;

  rptore_save() : pf2(fem::float0), pi2(fem::float0), s2(fem::float0) {}
};

/// C
/// C****************************************
/// C for rho pi->rho eta, determined from detailed balance, spin-isospin
/// averaged
float rptore(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rptore);
  /// SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s2 = sve.s2;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  s2 = fem::pow2(srt);
  const float arho = 0.77f;
  const float etam = 0.5475f;
  pf2 = (s2 - fem::pow2((arho + etam))) * (s2 - fem::pow2((arho - etam))) / 2 /
        fem::sqrt(s2);
  const float pimass = 0.140f;
  pi2 = (s2 - fem::pow2((arho + pimass))) * (s2 - fem::pow2((arho - pimass))) /
        2 / fem::sqrt(s2);
  return_value = 1.f / 3.f * pf2 / pi2 * retorp(srt);
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for rho pi <-> rho eta cross sections
void srpre(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  /// COMMON ppmm
  float& rpre = cmn.rpre;
  ///
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  rpre = 0.f;
  const float etam = 0.5475f;
  const float arho = 0.77f;
  const float pimass = 0.140f;
  if (lb1 >= 25 && lb1 <= 27 && lb2 >= 3 && lb2 <= 5) {
    if (srt > (etam + arho)) {
      rpre = rptore(cmn, srt);
    }
  } else if (lb2 >= 25 && lb2 <= 27 && lb1 >= 3 && lb1 <= 5) {
    if (srt > (etam + arho)) {
      rpre = rptore(cmn, srt);
    }
  } else if (lb1 >= 25 && lb1 <= 27 && lb2 == 0) {
    if (srt > (pimass + arho)) {
      rpre = retorp(srt);
    }
  } else if (lb2 >= 25 && lb2 <= 27 && lb1 == 0) {
    if (srt > (pimass + arho)) {
      rpre = retorp(srt);
    }
  }
  /// C
}

/// C****************************************
/// C for omega eta -> omega pi, assumed a constant cross section (in mb)
float xoe2op(float const& /* srt */) {
  float return_value = fem::float0;
  /// C****************************************
  /// C
  /// C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct xop2oe_save {
  float pf2;
  float pi2;
  float s2;

  xop2oe_save() : pf2(fem::float0), pi2(fem::float0), s2(fem::float0) {}
};

/// C
/// C****************************************
/// C for omega pi -> omega eta,
/// C     determined from detailed balance, spin-isospin averaged
float xop2oe(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(xop2oe);
  /// SAVE
  float& pf2 = sve.pf2;
  float& pi2 = sve.pi2;
  float& s2 = sve.s2;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  s2 = fem::pow2(srt);
  const float aomega = 0.782f;
  const float etam = 0.5475f;
  pf2 = (s2 - fem::pow2((aomega + etam))) * (s2 - fem::pow2((aomega - etam))) /
        2 / fem::sqrt(s2);
  const float pimass = 0.140f;
  pi2 = (s2 - fem::pow2((aomega + pimass))) *
        (s2 - fem::pow2((aomega - pimass))) / 2 / fem::sqrt(s2);
  return_value = 1.f / 3.f * pf2 / pi2 * xoe2op(srt);
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for omega pi <-> omega eta cross sections
void sopoe(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  /// COMMON ppmm
  float& xopoe = cmn.xopoe;
  ///
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  xopoe = 0.f;
  const float aomega = 0.782f;
  const float etam = 0.5475f;
  if ((lb1 == 28 && lb2 >= 3 && lb2 <= 5) ||
      (lb2 == 28 && lb1 >= 3 && lb1 <= 5)) {
    if (srt > (aomega + etam)) {
      xopoe = xop2oe(cmn, srt);
    }
  } else if ((lb1 == 28 && lb2 == 0) || (lb1 == 0 && lb2 == 28)) {
    if (srt > (aomega + etam)) {
      xopoe = xoe2op(srt);
    }
  }
  /// C
}

/// C****************************************
/// C for rho rho -> eta eta, assumed a constant cross section (in mb)
float rrtoee(float const& /* srt */) {
  float return_value = fem::float0;
  /// C****************************************
  /// C
  /// C     eta equilibration:
  return_value = 5.f;
  return return_value;
}

struct eetorr_save {
  float s2;

  eetorr_save() : s2(fem::float0) {}
};

/// C
/// C****************************************
/// C for eta eta -> rho rho
/// C     determined from detailed balance, spin-isospin averaged
float eetorr(common& cmn, float const& srt) {
  float return_value = fem::float0;
  FEM_CMN_SVE(eetorr);
  /// SAVE
  float& s2 = sve.s2;
  ///
  /// C****************************************
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  s2 = fem::pow2(srt);
  const float arho = 0.77f;
  const float etam = 0.5475f;
  return_value = 81.f * (s2 - 4 * fem::pow2(arho)) /
                 (s2 - 4 * fem::pow2(etam)) * rrtoee(srt);
  /// C
  return return_value;
}

/// C
/// C****************************************
/// C for rho rho <-> eta eta cross sections
void srree(common& cmn, int const& lb1, int const& lb2, float const& srt) {
  /// COMMON ppmm
  float& rree = cmn.rree;
  ///
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// C
  rree = 0.f;
  const float etam = 0.5475f;
  const float arho = 0.77f;
  if (lb1 >= 25 && lb1 <= 27 && lb2 >= 25 && lb2 <= 27) {
    if (srt > (2 * etam)) {
      rree = rrtoee(srt);
    }
  } else if (lb1 == 0 && lb2 == 0) {
    if (srt > (2 * arho)) {
      rree = eetorr(cmn, srt);
    }
  }
  /// C
}

struct ksreso_save {
  float dm;
  double e10;
  double e20;
  int i;
  double p1;
  double p2;
  double p3;
  double scheck;

  ksreso_save()
      : dm(fem::float0),
        e10(fem::double0),
        e20(fem::double0),
        i(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        scheck(fem::double0) {}
};

/// C
/// C---------------------------------------------------------------------------
/// C PURPOSE : CALCULATE THE MASS AND MOMENTUM OF K* RESONANCE
/// C           AFTER PION + KAON COLLISION
/// Cclin only here the K* mass may be different from aks=0.895
void ksreso(common& cmn, int const& i1, int const& i2) {
  FEM_CMN_SVE(ksreso);
  common_write write(cmn);
  /// COMMON bb
  const int maxstr = 150001;
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& dm = sve.dm;
  double& e10 = sve.e10;
  double& e20 = sve.e20;
  int& i = sve.i;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& scheck = sve.scheck;
  ///
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// C 1. DETERMINE THE MOMENTUM COMPONENT OF THE K* IN THE CMS OF PI-K FRAME
  /// C    WE LET I1 TO BE THE K* AND ABSORB I2
  /// C
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// C        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
  /// C        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
  e10 = fem::dsqrt(
      fem::pow2(fem::dble(e(i1))) + fem::pow2(fem::dble(p(1, i1))) +
      fem::pow2(fem::dble(p(2, i1))) + fem::pow2(fem::dble(p(3, i1))));
  e20 = fem::dsqrt(
      fem::pow2(fem::dble(e(i2))) + fem::pow2(fem::dble(p(1, i2))) +
      fem::pow2(fem::dble(p(2, i2))) + fem::pow2(fem::dble(p(3, i2))));
  p1 = fem::dble(p(1, i1)) + fem::dble(p(1, i2));
  p2 = fem::dble(p(2, i1)) + fem::dble(p(2, i2));
  p3 = fem::dble(p(3, i1)) + fem::dble(p(3, i2));
  /// C
  if (lb(i2) == 21 || lb(i2) == 23) {
    e(i1) = 0.f;
    i = i2;
  } else {
    e(i2) = 0.f;
    i = i1;
  }
  if (lb(i) == 23) {
    lb(i) = 30;
  } else if (lb(i) == 21) {
    lb(i) = -30;
  }
  p(1, i) = p(1, i1) + p(1, i2);
  p(2, i) = p(2, i1) + p(2, i2);
  p(3, i) = p(3, i1) + p(3, i2);
  /// C 2. DETERMINE THE MASS OF K* BY USING THE REACTION KINEMATICS
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck =
      fem::pow2((e10 + e20)) - fem::pow2(p1) - fem::pow2(p2) - fem::pow2(p3);
  if (scheck < 0) {
    write(99, star), "scheck49: ", scheck;
    write(99, star), "scheck49", scheck, e10, e20, p(1, i), p(2, i), p(3, i);
    write(99, star), "scheck49-1", e(i1), p(1, i1), p(2, i1), p(3, i1);
    write(99, star), "scheck49-2", e(i2), p(1, i2), p(2, i2), p(3, i2);
  }
  dm = fem::sqrt(fem::sngl(scheck));
  /// C        DM=SQRT((E10+E20)**2-P(1,I)**2-P(2,I)**2-P(3,I)**2)
  /// C
  e(i) = dm;
}

struct aknpsg_save {
  float sigma1;

  aknpsg_save() : sigma1(fem::float0) {}
};

/// C
/// C GQ Li parametrization (without resonance)
float aknpsg(common& cmn, float const& pkaon) {
  float return_value = fem::float0;
  FEM_CMN_SVE(aknpsg);
  /// SAVE
  float& sigma1 = sve.sigma1;
  ///
  /// Ccross section in mb for K- + N reactions.
  /// C       sigma1: x section for K- + p/n -> sigma0 + PI0
  if (pkaon <= 0.345f) {
    sigma1 = 0.624f * fem::pow(pkaon, (-1.83f));
  } else {
    sigma1 = 0.7f * fem::pow(pkaon, (-2.09f));
  }
  return_value = sigma1;
  return return_value;
}

struct pertur_save {
  float acap;
  float akal;
  float akap;
  float alas;
  float ames;
  float aomp;
  float app;
  float asap;
  float brpp;
  float c1;
  float cmat;
  float ct1;
  float dfr;
  float ds;
  float dsr;
  float e1cm;
  float e2cm;
  float ec;
  float em1;
  float em2;
  float empp1;
  float empp2;
  int ic;
  int icsbel;
  int idn;
  int idp;
  int lb1;
  int lb2;
  int lbpp1;
  int lbpp2;
  float p1beta;
  float pff;
  float pii;
  float pkaon;
  float ppt11;
  float ppt12;
  float ppt13;
  float ppt21;
  float ppt22;
  float ppt23;
  float pr;
  float pr2;
  float prob1;
  float prob2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float sig;
  float sigca;
  float sigcal;
  float sigcas;
  float sigeta;
  float sigom;
  float sigomm;
  float sigpe;
  float sigpi;
  float srrt;
  float st1;
  float t1;
  float transf;
  float x1;
  float x2;
  float xpt;
  float xrand;
  float y1;
  float y2;
  float ypt;
  float z1;
  float z2;
  float zpt;

  pertur_save()
      : acap(fem::float0),
        akal(fem::float0),
        akap(fem::float0),
        alas(fem::float0),
        ames(fem::float0),
        aomp(fem::float0),
        app(fem::float0),
        asap(fem::float0),
        brpp(fem::float0),
        c1(fem::float0),
        cmat(fem::float0),
        ct1(fem::float0),
        dfr(fem::float0),
        ds(fem::float0),
        dsr(fem::float0),
        e1cm(fem::float0),
        e2cm(fem::float0),
        ec(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        empp1(fem::float0),
        empp2(fem::float0),
        ic(fem::int0),
        icsbel(fem::int0),
        idn(fem::int0),
        idp(fem::int0),
        lb1(fem::int0),
        lb2(fem::int0),
        lbpp1(fem::int0),
        lbpp2(fem::int0),
        p1beta(fem::float0),
        pff(fem::float0),
        pii(fem::float0),
        pkaon(fem::float0),
        ppt11(fem::float0),
        ppt12(fem::float0),
        ppt13(fem::float0),
        ppt21(fem::float0),
        ppt22(fem::float0),
        ppt23(fem::float0),
        pr(fem::float0),
        pr2(fem::float0),
        prob1(fem::float0),
        prob2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        sig(fem::float0),
        sigca(fem::float0),
        sigcal(fem::float0),
        sigcas(fem::float0),
        sigeta(fem::float0),
        sigom(fem::float0),
        sigomm(fem::float0),
        sigpe(fem::float0),
        sigpi(fem::float0),
        srrt(fem::float0),
        st1(fem::float0),
        t1(fem::float0),
        transf(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xpt(fem::float0),
        xrand(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        ypt(fem::float0),
        z1(fem::float0),
        z2(fem::float0),
        zpt(fem::float0) {}
};

/// C
/// C--------------------------------------------------------
/// C************************************
/// C                                                                         *
void pertur(common& cmn, float& px, float& py, float& pz, float const& srt,
            int const& irun, int const& i1, int const& i2, int const& /* nt */,
            int const& /* kp */, int& icont) {
  FEM_CMN_SVE(pertur);
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  arr_ref<float> proper(cmn.proper, dimension(maxstr));
  int& nnn = cmn.nnn;
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  arr_ref<float, 2> propi(cmn.propi, dimension(maxstr, maxr));
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  float& dt = cmn.dt;
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  float& acap = sve.acap;
  float& akal = sve.akal;
  float& akap = sve.akap;
  float& alas = sve.alas;
  float& ames = sve.ames;
  float& aomp = sve.aomp;
  float& app = sve.app;
  float& asap = sve.asap;
  float& brpp = sve.brpp;
  float& c1 = sve.c1;
  float& cmat = sve.cmat;
  float& ct1 = sve.ct1;
  float& dfr = sve.dfr;
  float& ds = sve.ds;
  float& dsr = sve.dsr;
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& ec = sve.ec;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& empp1 = sve.empp1;
  float& empp2 = sve.empp2;
  int& ic = sve.ic;
  int& icsbel = sve.icsbel;
  int& idn = sve.idn;
  int& idp = sve.idp;
  int& lb1 = sve.lb1;
  int& lb2 = sve.lb2;
  int& lbpp1 = sve.lbpp1;
  int& lbpp2 = sve.lbpp2;
  float& p1beta = sve.p1beta;
  float& pff = sve.pff;
  float& pii = sve.pii;
  float& pkaon = sve.pkaon;
  float& ppt11 = sve.ppt11;
  float& ppt12 = sve.ppt12;
  float& ppt13 = sve.ppt13;
  float& ppt21 = sve.ppt21;
  float& ppt22 = sve.ppt22;
  float& ppt23 = sve.ppt23;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& px0 = sve.px0;
  float& py0 = sve.py0;
  float& pz0 = sve.pz0;
  float& s1 = sve.s1;
  float& sig = sve.sig;
  float& sigca = sve.sigca;
  float& sigcal = sve.sigcal;
  float& sigcas = sve.sigcas;
  float& sigeta = sve.sigeta;
  float& sigom = sve.sigom;
  float& sigomm = sve.sigomm;
  float& sigpe = sve.sigpe;
  float& sigpi = sve.sigpi;
  float& srrt = sve.srrt;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  float& transf = sve.transf;
  float& x1 = sve.x1;
  float& xpt = sve.xpt;
  float& xrand = sve.xrand;
  float& y1 = sve.y1;
  float& ypt = sve.ypt;
  float& z1 = sve.z1;
  float& zpt = sve.zpt;
  const float acas = 1.3213f;
  const float amn = 0.939457f;
  const float aeta = 0.548f;
  const float aome = 1.6724f;
  const float asa = 1.1974f;
  const float aka = 0.498f;
  const float ala = 1.1157f;
  const float pi = 3.1415926f;
  /// C * C       PURPOSE:   TO PRODUCE CASCADE AND OMEGA PERTURBATIVELY * C sp
  /// 01/03/01 C                   40 cascade- C                  -40
  /// cascade-(bar) C                   41 cascade0 C                  -41
  /// cascade0(bar) C                   45 Omega baryon C                  -45
  /// Omega baryon(bar) C                   44 Di-Omega
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /HH/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /PE/
  /// Cc      SAVE /RR/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /input1/
  /// C     perturbative method is disabled:
  /// C      common /imulst/ iperts
  /// C
  /// Cc      SAVE /RNDF77/
  /// C
  px0 = px;
  py0 = py;
  pz0 = pz;
  lb1 = lb(i1);
  em1 = e(i1);
  x1 = r(1, i1);
  y1 = r(2, i1);
  z1 = r(3, i1);
  sve.prob1 = proper(i1);
  /// C
  lb2 = lb(i2);
  em2 = e(i2);
  sve.x2 = r(1, i2);
  sve.y2 = r(2, i2);
  sve.z2 = r(3, i2);
  sve.prob2 = proper(i2);
  /// C
  /// C                 !! flag for real 2-body process (1/0=no/yes)
  icont = 1;
  /// C                !! flag for elastic scatt only (-1=no)
  icsbel = -1;
  /// C
  /// C K-/K*0bar + La/Si --> cascade + pi
  /// C K+/K*0 + La/Si (bar) --> cascade-bar + pi
  if ((lb1 == 21 || lb1 == 23 || fem::iabs(lb1) == 30) &&
      (fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17)) {
    goto statement_60;
  }
  if ((lb2 == 21 || lb2 == 23 || fem::iabs(lb2) == 30) &&
      (fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17)) {
    goto statement_60;
  }
  /// C K-/K*0bar + cascade --> omega + pi
  /// C K+/K*0 + cascade-bar --> omega-bar + pi
  if ((lb1 == 21 || lb1 == 23 || fem::iabs(lb1) == 30) &&
      (fem::iabs(lb2) == 40 || fem::iabs(lb2) == 41)) {
    goto statement_70;
  }
  if ((lb2 == 21 || lb2 == 23 || fem::iabs(lb2) == 30) &&
      (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41)) {
    goto statement_70;
  }
  /// C
  /// C annhilation of cascade,cascade-bar, omega,omega-bar
  /// C
  /// C K- + La/Si <-- cascade + pi(eta,rho,omega)
  /// C K+ + La/Si(bar) <-- cascade-bar + pi(eta,rho,omega)
  if ((((lb1 >= 3 && lb1 <= 5) || lb1 == 0) &&
       (fem::iabs(lb2) == 40 || fem::iabs(lb2) == 41)) ||
      (((lb2 >= 3 && lb2 <= 5) || lb2 == 0) &&
       (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41))) {
    goto statement_90;
  }
  /// C K- + cascade <-- omega + pi
  /// C K+ + cascade-bar <-- omega-bar + pi
  /// C         if( (lb1.eq.0.and.iabs(lb2).eq.45)
  /// C    &    .OR. (lb2.eq.0.and.iabs(lb1).eq.45) ) go to 110
  if (((lb1 >= 3 && lb1 <= 5) && fem::iabs(lb2) == 45) ||
      ((lb2 >= 3 && lb2 <= 5) && fem::iabs(lb1) == 45)) {
    goto statement_110;
  }
/// C
/// C----------------------------------------------------
/// C  for process:  K-bar + L(S) --> Ca + pi
/// C
statement_60:
  if (fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) {
    asap = e(i1);
    akap = e(i2);
    idp = i1;
  } else {
    asap = e(i2);
    akap = e(i1);
    idp = i2;
  }
  app = 0.138f;
  if (srt < (acas + app)) {
    return;
  }
  srrt = srt - (acas + app) + (amn + akap);
  pkaon = fem::sqrt(
      fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(akap))) / 2.f /
                 amn)) -
      fem::pow2(akap));
  sigca = 1.5f * (aknpsg(cmn, pkaon) + aknpsg(cmn, pkaon));
  /// Clin pii & pff should be each divided by (4*srt**2),
  /// C     but these two factors cancel out in the ratio pii/pff:
  pii = fem::sqrt((fem::pow2(srt) - fem::pow2((amn + akap))) *
                  (fem::pow2(srt) - fem::pow2((amn - akap))));
  pff = fem::sqrt((fem::pow2(srt) - fem::pow2((asap + app))) *
                  (fem::pow2(srt) - fem::pow2((asap - app))));
  cmat = sigca * pii / pff;
  sigpi = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((acas + app))) *
                    (fem::pow2(srt) - fem::pow2((acas - app)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((asap + akap))) *
                    (fem::pow2(srt) - fem::pow2((asap - akap))));
  /// C
  sigeta = 0.f;
  if (srt > (acas + aeta)) {
    srrt = srt - (acas + aeta) + (amn + akap);
    pkaon = fem::sqrt(
        fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(akap))) /
                   2.f / amn)) -
        fem::pow2(akap));
    sigca = 1.5f * (aknpsg(cmn, pkaon) + aknpsg(cmn, pkaon));
    cmat = sigca * pii / pff;
    sigeta = cmat *
             fem::sqrt((fem::pow2(srt) - fem::pow2((acas + aeta))) *
                       (fem::pow2(srt) - fem::pow2((acas - aeta)))) /
             fem::sqrt((fem::pow2(srt) - fem::pow2((asap + akap))) *
                       (fem::pow2(srt) - fem::pow2((asap - akap))));
  }
  /// C
  sigca = sigpi + sigeta;
  sigpe = 0.f;
  /// Clin-2/25/03 disable the perturb option:
  /// C        if(iperts .eq. 1) sigpe = 40.   !! perturbative xsecn
  sig = fem::amax1(sigpe, sigca);
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  brpp = sigca / sig;
  /// C
  /// C else particle production
  if ((lb1 >= 14 && lb1 <= 17) || (lb2 >= 14 && lb2 <= 17)) {
    /// C   !! cascade- or cascde0
    lbpp1 = 40 + fem::fint(2 * ranart(nseed));
  } else {
    /// C elseif(lb1 .eq. -14 .or. lb2 .eq. -14)
    /// C     !! cascade-bar- or cascde0 -bar
    lbpp1 = -40 - fem::fint(2 * ranart(nseed));
  }
  empp1 = acas;
  if (ranart(nseed) < sigpi / sigca) {
    /// C    !! pion
    lbpp2 = 3 + fem::fint(3 * ranart(nseed));
    empp2 = 0.138f;
  } else {
    /// C    !! eta
    lbpp2 = 0;
    empp2 = aeta;
  }
  /// C* check real process of cascade(bar) and pion formation
  if (ranart(nseed) < brpp) {
    /// C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    /// C  !! cascade formed with prob Gam
    proper(i1) = brpp;
    lb(i2) = lbpp2;
    e(i2) = empp2;
    /// C         !! pion/eta formed with prob 1.
    proper(i2) = 1.f;
  }
  /// C else only cascade(bar) formed perturbatively
  goto statement_700;
/// C
/// C----------------------------------------------------
/// C  for process:  Cas(bar) + K_bar(K) --> Om(bar) + pi  !! eta
/// C
statement_70:
  if (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41) {
    acap = e(i1);
    akap = e(i2);
    idp = i1;
  } else {
    acap = e(i2);
    akap = e(i1);
    idp = i2;
  }
  app = 0.138f;
  /// C         ames = aeta
  /// C  !! only pion
  ames = 0.138f;
  if (srt < (aome + ames)) {
    return;
  }
  srrt = srt - (aome + ames) + (amn + akap);
  pkaon = fem::sqrt(
      fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(akap))) / 2.f /
                 amn)) -
      fem::pow2(akap));
  /// C use K(bar) + Ca --> Om + eta  xsecn same as  K(bar) + N --> Si + Pi
  /// C  as Omega have no resonances
  /// C** using same matrix elements as K-bar + N -> Si + pi
  sigomm = 1.5f * (aknpsg(cmn, pkaon) + aknpsg(cmn, pkaon));
  cmat = sigomm *
         fem::sqrt((fem::pow2(srt) - fem::pow2((amn + akap))) *
                   (fem::pow2(srt) - fem::pow2((amn - akap)))) /
         fem::sqrt((fem::pow2(srt) - fem::pow2((asa + app))) *
                   (fem::pow2(srt) - fem::pow2((asa - app))));
  sigom = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((aome + ames))) *
                    (fem::pow2(srt) - fem::pow2((aome - ames)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((acap + akap))) *
                    (fem::pow2(srt) - fem::pow2((acap - akap))));
  sigpe = 0.f;
  /// Clin-2/25/03 disable the perturb option:
  /// C         if(iperts .eq. 1) sigpe = 40.   !! perturbative xsecn
  sig = fem::amax1(sigpe, sigom);
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  if (ic == -1) {
    return;
  }
  brpp = sigom / sig;
  /// C
  /// C else particle production
  if ((lb1 >= 40 && lb1 <= 41) || (lb2 >= 40 && lb2 <= 41)) {
    /// C    !! omega
    lbpp1 = 45;
  } else {
    /// C elseif(lb1 .eq. -40 .or. lb2 .eq. -40)
    /// C    !! omega-bar
    lbpp1 = -45;
  }
  empp1 = aome;
  /// C           lbpp2 = 0    !! eta
  /// C    !! pion
  lbpp2 = 3 + fem::fint(3 * ranart(nseed));
  empp2 = ames;
  /// C
  /// C* check real process of omega(bar) and pion formation
  xrand = ranart(nseed);
  if (xrand < (proper(idp) * brpp)) {
    /// C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    /// C  !! P_Om = P_Cas*Gam
    proper(i1) = proper(idp) * brpp;
    lb(i2) = lbpp2;
    e(i2) = empp2;
    /// C   !! pion formed with prob 1.
    proper(i2) = 1.f;
  } else if (xrand < brpp) {
    /// C else omega(bar) formed perturbatively and cascade destroyed
    e(idp) = 0.f;
  }
  goto statement_700;
/// C
/// C-----------------------------------------------------------
/// C  for process:  Ca + pi/eta --> K-bar + L(S)
/// C
statement_90:
  if (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41) {
    acap = e(i1);
    app = e(i2);
    idp = i1;
    idn = i2;
  } else {
    acap = e(i2);
    app = e(i1);
    idp = i2;
    idn = i1;
  }
  /// C            akal = (aka+aks)/2.  !! average of K and K* taken
  /// C  !! using K only
  akal = aka;
  /// C
  alas = ala;
  if (srt <= (alas + aka)) {
    return;
  }
  srrt = srt - (acap + app) + (amn + aka);
  pkaon = fem::sqrt(
      fem::pow2(
          ((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(aka))) / 2.f / amn)) -
      fem::pow2(aka));
  /// C** using same matrix elements as K-bar + N -> La/Si + pi
  sigca = 1.5f * (aknpsg(cmn, pkaon) + aknpsg(cmn, pkaon));
  cmat = sigca *
         fem::sqrt((fem::pow2(srt) - fem::pow2((amn + aka))) *
                   (fem::pow2(srt) - fem::pow2((amn - aka)))) /
         fem::sqrt((fem::pow2(srt) - fem::pow2((alas + 0.138f))) *
                   (fem::pow2(srt) - fem::pow2((alas - 0.138f))));
  sigca = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((acap + app))) *
                    (fem::pow2(srt) - fem::pow2((acap - app)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((alas + aka))) *
                    (fem::pow2(srt) - fem::pow2((alas - aka))));
  /// C    !! pi
  dfr = 1.f / 3.f;
  /// C       !! eta
  if (lb(idn) == 0) {
    dfr = 1.f;
  }
  sigcal = sigca * dfr * (fem::pow2(srt) - fem::pow2((alas + aka))) *
           (fem::pow2(srt) - fem::pow2((alas - aka))) /
           (fem::pow2(srt) - fem::pow2((acap + app))) /
           (fem::pow2(srt) - fem::pow2((acap - app)));
  /// C
  alas = asa;
  if (srt <= (alas + aka)) {
    sigcas = 0.f;
  } else {
    srrt = srt - (acap + app) + (amn + aka);
    pkaon = fem::sqrt(
        fem::pow2(((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(aka))) / 2.f /
                   amn)) -
        fem::pow2(aka));
    /// C use K(bar) + La/Si --> Ca + Pi  xsecn same as  K(bar) + N --> Si + Pi
    /// C** using same matrix elements as K-bar + N -> La/Si + pi
    sigca = 1.5f * (aknpsg(cmn, pkaon) + aknpsg(cmn, pkaon));
    cmat = sigca *
           fem::sqrt((fem::pow2(srt) - fem::pow2((amn + aka))) *
                     (fem::pow2(srt) - fem::pow2((amn - aka)))) /
           fem::sqrt((fem::pow2(srt) - fem::pow2((alas + 0.138f))) *
                     (fem::pow2(srt) - fem::pow2((alas - 0.138f))));
    sigca = cmat *
            fem::sqrt((fem::pow2(srt) - fem::pow2((acap + app))) *
                      (fem::pow2(srt) - fem::pow2((acap - app)))) /
            fem::sqrt((fem::pow2(srt) - fem::pow2((alas + aka))) *
                      (fem::pow2(srt) - fem::pow2((alas - aka))));
    /// C    !! pi
    dfr = 1.f;
    /// C    !! eta
    if (lb(idn) == 0) {
      dfr = 3.f;
    }
    sigcas = sigca * dfr * (fem::pow2(srt) - fem::pow2((alas + aka))) *
             (fem::pow2(srt) - fem::pow2((alas - aka))) /
             (fem::pow2(srt) - fem::pow2((acap + app))) /
             (fem::pow2(srt) - fem::pow2((acap - app)));
  }
  /// C
  sig = sigcal + sigcas;
  brpp = 1.f;
  ds = fem::sqrt(sig / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  /// C
  /// Clin-2/25/03: checking elastic scatt after failure of inelastic scatt
  /// gives C     conditional probability (in general incorrect), tell Pal to
  /// correct:
  if (ic == -1) {
    /// C check for elastic scatt, no particle annhilation
    /// C  !! elastic cross section of 20 mb
    ds = fem::sqrt(20.0f / 31.4f);
    dsr = ds + 0.1f;
    distce(cmn, i1, i2, dsr, ds, dt, ec, srt, icsbel, px, py, pz);
    if (icsbel == -1) {
      return;
    }
    empp1 = em1;
    empp2 = em2;
    goto statement_700;
  }
  /// C
  /// C else pert. produced cascade(bar) is annhilated OR real process
  /// C
  /// C DECIDE LAMBDA OR SIGMA PRODUCTION
  /// C
  if (sigcal / sig > ranart(nseed)) {
    if (lb1 == 40 || lb1 == 41 || lb2 == 40 || lb2 == 41) {
      lbpp1 = 21;
      lbpp2 = 14;
    } else {
      lbpp1 = 23;
      lbpp2 = -14;
    }
    alas = ala;
  } else {
    if (lb1 == 40 || lb1 == 41 || lb2 == 40 || lb2 == 41) {
      lbpp1 = 21;
      lbpp2 = 15 + fem::fint(3 * ranart(nseed));
    } else {
      lbpp1 = 23;
      lbpp2 = -15 - fem::fint(3 * ranart(nseed));
    }
    alas = asa;
  }
  empp1 = aka;
  empp2 = alas;
  /// C
  /// C check for real process for L/S(bar) and K(bar) formation
  if (ranart(nseed) < proper(idp)) {
    /// C real process
    /// C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    /// C   !! K(bar) formed with prob 1.
    proper(i1) = 1.f;
    lb(i2) = lbpp2;
    e(i2) = empp2;
    /// C   !! L/S(bar) formed with prob 1.
    proper(i2) = 1.f;
    goto statement_700;
  } else {
    /// C else only cascade(bar) annhilation & go out
    e(idp) = 0.f;
  }
  return;
/// C
/// C----------------------------------------------------
/// C  for process:  Om(bar) + pi --> Cas(bar) + K_bar(K)
/// C
statement_110:
  if (lb1 == 45 || lb1 == -45) {
    aomp = e(i1);
    app = e(i2);
    idp = i1;
    idn = i2;
  } else {
    aomp = e(i2);
    app = e(i1);
    idp = i2;
    idn = i1;
  }
  /// C            akal = (aka+aks)/2.  !! average of K and K* taken
  /// C  !! using K only
  akal = aka;
  if (srt <= (acas + aka)) {
    return;
  }
  srrt = srt - (aome + app) + (amn + aka);
  pkaon = fem::sqrt(
      fem::pow2(
          ((fem::pow2(srrt) - (fem::pow2(amn) + fem::pow2(aka))) / 2.f / amn)) -
      fem::pow2(aka));
  /// C use K(bar) + Ca --> Om + eta  xsecn same as  K(bar) + N --> Si + Pi
  /// C** using same matrix elements as K-bar + N -> La/Si + pi
  sigca = 1.5f * (aknpsg(cmn, pkaon) + aknpsg(cmn, pkaon));
  cmat = sigca *
         fem::sqrt((fem::pow2(srt) - fem::pow2((amn + aka))) *
                   (fem::pow2(srt) - fem::pow2((amn - aka)))) /
         fem::sqrt((fem::pow2(srt) - fem::pow2((asa + 0.138f))) *
                   (fem::pow2(srt) - fem::pow2((asa - 0.138f))));
  sigom = cmat *
          fem::sqrt((fem::pow2(srt) - fem::pow2((aomp + app))) *
                    (fem::pow2(srt) - fem::pow2((aomp - app)))) /
          fem::sqrt((fem::pow2(srt) - fem::pow2((acas + aka))) *
                    (fem::pow2(srt) - fem::pow2((acas - aka))));
  /// C            dfr = 2.    !! eta
  /// C    !! pion
  dfr = 2.f / 3.f;
  sigom = sigom * dfr * (fem::pow2(srt) - fem::pow2((acas + aka))) *
          (fem::pow2(srt) - fem::pow2((acas - aka))) /
          (fem::pow2(srt) - fem::pow2((aomp + app))) /
          (fem::pow2(srt) - fem::pow2((aomp - app)));
  /// C
  brpp = 1.f;
  ds = fem::sqrt(sigom / 31.4f);
  dsr = ds + 0.1f;
  ec = fem::pow2((em1 + em2 + 0.02f));
  distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px, py, pz);
  /// C
  /// Clin-2/25/03: checking elastic scatt after failure of inelastic scatt
  /// gives C     conditional probability (in general incorrect), tell Pal to
  /// correct:
  if (ic == -1) {
    /// C check for elastic scatt, no particle annhilation
    /// C  !! elastic cross section of 20 mb
    ds = fem::sqrt(20.0f / 31.4f);
    dsr = ds + 0.1f;
    distce(cmn, i1, i2, dsr, ds, dt, ec, srt, icsbel, px, py, pz);
    if (icsbel == -1) {
      return;
    }
    empp1 = em1;
    empp2 = em2;
    goto statement_700;
  }
  /// C
  /// C else pert. produced omega(bar) annhilated  OR real process
  /// C annhilate only pert. omega, rest from hijing go out WITHOUT annhil.
  if (lb1 == 45 || lb2 == 45) {
    /// C  !! Ca
    lbpp1 = 40 + fem::fint(2 * ranart(nseed));
    /// C   !! K-
    lbpp2 = 21;
  } else {
    /// C elseif(lb1 .eq. -45 .or. lb2 .eq. -45)
    /// C    !! Ca-bar
    lbpp1 = -40 - fem::fint(2 * ranart(nseed));
    /// C      !! K+
    lbpp2 = 23;
  }
  empp1 = acas;
  empp2 = aka;
  /// C
  /// C check for real process for Cas(bar) and K(bar) formation
  if (ranart(nseed) < proper(idp)) {
    /// C       !! real process flag
    icont = 0;
    lb(i1) = lbpp1;
    e(i1) = empp1;
    /// C   !! P_Cas(bar) = P_Om(bar)
    proper(i1) = proper(idp);
    lb(i2) = lbpp2;
    e(i2) = empp2;
    /// C   !! K(bar) formed with prob 1.
    proper(i2) = 1.f;
    /// C
  } else {
    /// C else Cascade(bar)  produced and Omega(bar) annhilated
    e(idp) = 0.f;
  }
  /// C   !! for produced particles
  goto statement_700;
/// C
/// C-----------------------------------------------------------
statement_700:
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(empp1) - fem::pow2(empp2))) -
        4.0f * fem::pow2((empp1 * empp2));
  if (pr2 <= 0.f) {
    pr2 = 0.00000001f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  /// C using isotropic
  c1 = 1.0f - 2.0f * ranart(nseed);
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
  /// C ROTATE IT
  rotate(cmn, px0, py0, pz0, px, py, pz);
  if (icont == 0) {
    return;
  }
  /// C
  /// C LORENTZ-TRANSFORMATION INTO CMS FRAME
  e1cm = fem::sqrt(fem::pow2(empp1) + fem::pow2(px) + fem::pow2(py) +
                   fem::pow2(pz));
  p1beta = px * betax + py * betay + pz * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
  ppt11 = betax * transf + px;
  ppt12 = betay * transf + py;
  ppt13 = betaz * transf + pz;
  /// C
  /// Cc** for elastic scattering update the momentum of pertb particles
  if (icsbel != -1) {
    /// C            if(EMpp1 .gt. 0.9)then
    p(1, i1) = ppt11;
    p(2, i1) = ppt12;
    p(3, i1) = ppt13;
    /// C            else
    e2cm = fem::sqrt(fem::pow2(empp2) + fem::pow2(px) + fem::pow2(py) +
                     fem::pow2(pz));
    transf = gamma * (-gamma * p1beta / (gamma + 1) + e2cm);
    ppt21 = betax * transf - px;
    ppt22 = betay * transf - py;
    ppt23 = betaz * transf - pz;
    p(1, i2) = ppt21;
    p(2, i2) = ppt22;
    p(3, i2) = ppt23;
    /// C            endif
    return;
  }
  /// Clin-5/2008:
  /// C2008        X01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Y01 = 1.0 - 2.0 * RANART(NSEED)
  /// C            Z01 = 1.0 - 2.0 * RANART(NSEED)
  /// C        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2008
  /// C                Xpt=X1+0.5*x01
  /// C                Ypt=Y1+0.5*y01
  /// C                Zpt=Z1+0.5*z01
  xpt = x1;
  ypt = y1;
  zpt = z1;
  /// C
  /// C          if(lbpp1 .eq. 45)then
  /// C           write(*,*)'II lb1,lb2,lbpp1,empp1,proper(idp),brpp'
  /// C           write(*,*)lb1,lb2,lbpp1,empp1,proper(idp),brpp
  /// C          endif
  /// C
  nnn++;
  propi(nnn, irun) = proper(idp) * brpp;
  lpion(nnn, irun) = lbpp1;
  epion(nnn, irun) = empp1;
  rpion(1, nnn, irun) = xpt;
  rpion(2, nnn, irun) = ypt;
  rpion(3, nnn, irun) = zpt;
  ppion(1, nnn, irun) = ppt11;
  ppion(2, nnn, irun) = ppt12;
  ppion(3, nnn, irun) = ppt13;
  /// Clin-5/2008:
  dppion(nnn, irun) = dpertp(i1) * dpertp(i2);
}

struct crhb_save {
  float c1;
  float ct1;
  float em1;
  float em2;
  int ntag;
  float pr;
  float pr2;
  float px0;
  float py0;
  float pz0;
  float s1;
  float st1;
  float t1;

  crhb_save()
      : c1(fem::float0),
        ct1(fem::float0),
        em1(fem::float0),
        em2(fem::float0),
        ntag(fem::int0),
        pr(fem::float0),
        pr2(fem::float0),
        px0(fem::float0),
        py0(fem::float0),
        pz0(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C*********************************
/// C  sp 12/08/00                                                         *
void crhb(common& cmn, float& px, float& py, float& pz, float const& srt,
          int const& i1, int const& i2, int& iblock) {
  FEM_CMN_SVE(crhb);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& em1 = sve.em1;
  float& em2 = sve.em2;
  float& pr = sve.pr;
  float& pr2 = sve.pr2;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     PURPOSE:                                                         *
  /// C        DEALING WITH hyperon+N(D,N*)->hyp+N(D,N*) elastic PROCESS     *
  /// C     NOTE   :                                                         *
  /// C
  /// C     QUANTITIES:                                                 *
  /// C           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
  /// C           SRT      - SQRT OF S                                       *
  /// C           IBLOCK   - THE INFORMATION BACK                            *
  /// C                     144-> hyp+N(D,N*)->hyp+N(D,N*)
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /RNDF77/
  /// C
  sve.px0 = px;
  sve.py0 = py;
  sve.pz0 = pz;
  /// C-----------------------------------------------------------------------
  iblock = 144;
  sve.ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  /// C-----------------------------------------------------------------------
  /// C CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
  /// C ENERGY CONSERVATION
  pr2 = fem::pow2((fem::pow2(srt) - fem::pow2(em1) - fem::pow2(em2))) -
        4.0f * fem::pow2((em1 * em2));
  if (pr2 <= 0.f) {
    pr2 = 1.e-09f;
  }
  pr = fem::sqrt(pr2) / (2.f * srt);
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  pz = pr * c1;
  px = pr * s1 * ct1;
  py = pr * s1 * st1;
}

struct lambar_save {
  float emb;
  float eml;
  float plab;
  float plab2;
  float pthr;

  lambar_save()
      : emb(fem::float0),
        eml(fem::float0),
        plab(fem::float0),
        plab2(fem::float0),
        pthr(fem::float0) {}
};

/// C***************************************
/// C sp 04/05/01
/// C Purpose: lambda-baryon elastic xsection as a functon of their cms energy
void lambar(common& cmn, int const& i1, int const& i2, float const& srt,
            float& siglab) {
  FEM_CMN_SVE(lambar);
  /// COMMON cc
  const int maxstr = 150001;
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  ///
  /// SAVE
  float& emb = sve.emb;
  float& eml = sve.eml;
  float& plab = sve.plab;
  float& plab2 = sve.plab2;
  float& pthr = sve.pthr;
  ///
  /// C  srt    = DSQRT(s) in GeV * C  siglab = lambda-nuclar elastic cross
  /// section in mb C         = 12 + 0.43/p_lab**3.3 (mb)
  /// C
  /// C (2) Calculate p(lab) from srt [GeV], since the formular in the
  /// C reference applies only to the case of a p_bar on a proton at rest
  /// C Formula used: srt**2=2.*pmass*(pmass+sqrt(pmass**2+plab**2))
  /// C****************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// C
  siglab = 1.e-06f;
  if (fem::iabs(lb(i1)) >= 14 && fem::iabs(lb(i1)) <= 17) {
    eml = e(i1);
    emb = e(i2);
  } else {
    eml = e(i2);
    emb = e(i1);
  }
  pthr = fem::pow2(srt) - fem::pow2(eml) - fem::pow2(emb);
  if (pthr > 0.f) {
    plab2 = fem::pow2((pthr / 2.f / emb)) - fem::pow2(eml);
    if (plab2 > 0) {
      plab = fem::sqrt(plab2);
      siglab = 12.f + 0.43f / (fem::pow(plab, 3.3f));
      if (siglab > 200.f) {
        siglab = 200.f;
      }
    }
  }
}

struct distc0_save {
  float bbb;
  float ddd;
  float drbeta;
  float drcm;
  float dxcm;
  float dycm;
  float dzcm;
  float dzz;
  float e1;
  float e2;
  float p1beta;
  float prcm;
  float relvel;
  float transf;

  distc0_save()
      : bbb(fem::float0),
        ddd(fem::float0),
        drbeta(fem::float0),
        drcm(fem::float0),
        dxcm(fem::float0),
        dycm(fem::float0),
        dzcm(fem::float0),
        dzz(fem::float0),
        e1(fem::float0),
        e2(fem::float0),
        p1beta(fem::float0),
        prcm(fem::float0),
        relvel(fem::float0),
        transf(fem::float0) {}
};

/// C------------------------------------------------------------------
/// Clin-7/26/03 improve speed
/// C**************************************
void distc0(common& cmn, float const& drmax, float const& /* deltr0 */,
            float const& dt, int& ifirst, float const& px1cm,
            float const& py1cm, float const& pz1cm, float const& x1,
            float const& y1, float const& z1, float const& px1,
            float const& py1, float const& pz1, float const& em1,
            float const& x2, float const& y2, float const& z2, float const& px2,
            float const& py2, float const& pz2, float const& em2) {
  FEM_CMN_SVE(distc0);
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  ///
  /// SAVE
  float& bbb = sve.bbb;
  float& ddd = sve.ddd;
  float& drbeta = sve.drbeta;
  float& drcm = sve.drcm;
  float& dxcm = sve.dxcm;
  float& dycm = sve.dycm;
  float& dzcm = sve.dzcm;
  float& dzz = sve.dzz;
  float& e1 = sve.e1;
  float& e2 = sve.e2;
  float& p1beta = sve.p1beta;
  float& prcm = sve.prcm;
  float& relvel = sve.relvel;
  float& transf = sve.transf;
  ///
  /// C PURPOSE : CHECK IF THE COLLISION BETWEEN TWO PARTICLES CAN HAPPEN
  /// C           BY CHECKING
  /// C                      (2) IF PARTICLE WILL PASS EACH OTHER WITHIN
  /// C           TWO HARD CORE RADIUS.
  /// C                      (3) IF PARTICLES WILL GET CLOSER.
  /// C VARIABLES :
  /// C           Ifirst=1 COLLISION may HAPPENED
  /// C           Ifirst=-1 COLLISION CAN NOT HAPPEN
  /// C****************************************
  /// Cc      SAVE /BG/
  ifirst = -1;
  e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                 fem::pow2(pz1));
  /// CNOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
  e2 = fem::sqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                 fem::pow2(pz2));
  /// CNOW THERE IS ENOUGH ENERGY AVAILABLE !
  /// CLORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
  /// C BETAX, BETAY, BETAZ AND GAMMA HAVE BEEN GIVEN IN THE SUBROUTINE CMS
  /// CTRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
  p1beta = px1 * betax + py1 * betay + pz1 * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1) - e1);
  prcm = fem::sqrt(fem::pow2(px1cm) + fem::pow2(py1cm) + fem::pow2(pz1cm));
  if (prcm <= 0.00001f) {
    return;
  }
  /// CTRANSFORMATION OF SPATIAL DISTANCE
  drbeta = betax * (x1 - x2) + betay * (y1 - y2) + betaz * (z1 - z2);
  transf = gamma * gamma * drbeta / (gamma + 1);
  dxcm = betax * transf + x1 - x2;
  dycm = betay * transf + y1 - y2;
  dzcm = betaz * transf + z1 - z2;
  /// CDETERMINING IF THIS IS THE POINT OF CLOSEST APPROACH
  drcm = fem::sqrt(fem::pow2(dxcm) + fem::pow2(dycm) + fem::pow2(dzcm));
  dzz = (px1cm * dxcm + py1cm * dycm + pz1cm * dzcm) / prcm;
  if ((fem::pow2(drcm) - fem::pow2(dzz)) <= 0.f) {
    bbb = 0.f;
  } else {
    bbb = fem::sqrt(fem::pow2(drcm) - fem::pow2(dzz));
  }
  /// CWILL PARTICLE PASS EACH OTHER WITHIN 2 * HARD CORE RADIUS ?
  if (bbb > drmax) {
    return;
  }
  relvel = prcm * (1.0f / e1 + 1.0f / e2);
  ddd = relvel * dt * 0.5f;
  /// CWILL PARTICLES GET CLOSER ?
  if (fem::abs(ddd) < fem::abs(dzz)) {
    return;
  }
  ifirst = 1;
}

/// C
/// C     Cross section of Deuteron+Pi elastic (in mb):
float fdpiel(float const& s) {
  float return_value = fem::float0;
  const float srt0 = 2.012f;
  if (s <= fem::pow2(srt0)) {
    return_value = 0.f;
  } else {
    return_value = 63.f * fem::exp(-fem::pow2((s - 4.67f)) / 0.15f) +
                   15.f * fem::exp(-fem::pow2((s - 6.25f)) / 0.3f);
  }
  return return_value;
}

struct sdmbb_save {
  float fs;
  float pfinal;
  float pinitial;
  float s;
  float snew;
  float threshold;
  float xnnfactor;

  sdmbb_save()
      : fs(fem::float0),
        pfinal(fem::float0),
        pinitial(fem::float0),
        s(fem::float0),
        snew(fem::float0),
        threshold(fem::float0),
        xnnfactor(fem::float0) {}
};

/// C
/// C     Deuteron+Meson->B+B cross section (in mb)
void sdmbb(common& cmn, float const& srt, float& sdm, int const& ianti) {
  FEM_CMN_SVE(sdmbb);
  /// COMMON leadng
  int& lb1 = cmn.lb1;
  float& em1 = cmn.em1;
  /// COMMON dpi
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  /// COMMON dpifsl
  int& lbnn1 = cmn.lbnn1;
  int& lbnn2 = cmn.lbnn2;
  int& lbnd1 = cmn.lbnd1;
  int& lbnd2 = cmn.lbnd2;
  int& lbns1 = cmn.lbns1;
  int& lbns2 = cmn.lbns2;
  int& lbnp1 = cmn.lbnp1;
  int& lbnp2 = cmn.lbnp2;
  int& lbdd1 = cmn.lbdd1;
  int& lbdd2 = cmn.lbdd2;
  int& lbds1 = cmn.lbds1;
  int& lbds2 = cmn.lbds2;
  int& lbdp1 = cmn.lbdp1;
  int& lbdp2 = cmn.lbdp2;
  int& lbss1 = cmn.lbss1;
  int& lbss2 = cmn.lbss2;
  int& lbsp1 = cmn.lbsp1;
  int& lbsp2 = cmn.lbsp2;
  int& lbpp1 = cmn.lbpp1;
  int& lbpp2 = cmn.lbpp2;
  /// COMMON dpifsm
  float& xmnn1 = cmn.xmnn1;
  float& xmnn2 = cmn.xmnn2;
  float& xmnd1 = cmn.xmnd1;
  float& xmnd2 = cmn.xmnd2;
  float& xmns1 = cmn.xmns1;
  float& xmns2 = cmn.xmns2;
  float& xmnp1 = cmn.xmnp1;
  float& xmnp2 = cmn.xmnp2;
  float& xmdd1 = cmn.xmdd1;
  float& xmdd2 = cmn.xmdd2;
  float& xmds1 = cmn.xmds1;
  float& xmds2 = cmn.xmds2;
  float& xmdp1 = cmn.xmdp1;
  float& xmdp2 = cmn.xmdp2;
  float& xmss1 = cmn.xmss1;
  float& xmss2 = cmn.xmss2;
  float& xmsp1 = cmn.xmsp1;
  float& xmsp2 = cmn.xmsp2;
  float& xmpp1 = cmn.xmpp1;
  float& xmpp2 = cmn.xmpp2;
  /// COMMON dpisig
  float& sdmel = cmn.sdmel;
  float& sdmnn = cmn.sdmnn;
  float& sdmnd = cmn.sdmnd;
  float& sdmns = cmn.sdmns;
  float& sdmnp = cmn.sdmnp;
  float& sdmdd = cmn.sdmdd;
  float& sdmds = cmn.sdmds;
  float& sdmdp = cmn.sdmdp;
  float& sdmss = cmn.sdmss;
  float& sdmsp = cmn.sdmsp;
  float& sdmpp = cmn.sdmpp;
  /// COMMON para8
  int& idxsec = cmn.idxsec;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& fs = sve.fs;
  float& pfinal = sve.pfinal;
  float& pinitial = sve.pinitial;
  float& s = sve.s;
  float& snew = sve.snew;
  float& threshold = sve.threshold;
  float& xnnfactor = sve.xnnfactor;
  ///
  /// C
  sdm = 0.f;
  sdmel = 0.f;
  sdmnn = 0.f;
  sdmnd = 0.f;
  sdmns = 0.f;
  sdmnp = 0.f;
  sdmdd = 0.f;
  sdmds = 0.f;
  sdmdp = 0.f;
  sdmss = 0.f;
  sdmsp = 0.f;
  sdmpp = 0.f;
  /// Ctest off check Xsec using fixed mass for resonances:
  /// C      if(lb1.ge.25.and.lb1.le.27) then
  /// C         em1=0.776
  /// C      elseif(lb1.eq.28) then
  /// C         em1=0.783
  /// C      elseif(lb1.eq.0) then
  /// C         em1=0.548
  /// C      endif
  /// C      if(lb2.ge.25.and.lb2.le.27) then
  /// C         em2=0.776
  /// C      elseif(lb2.eq.28) then
  /// C         em2=0.783
  /// C      elseif(lb2.eq.0) then
  /// C         em2=0.548
  /// C      endif
  /// C
  if (srt <= (em1 + em2)) {
    return;
  }
  s = fem::pow2(srt);
  pinitial =
      fem::sqrt((s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)))) /
      2.f / srt;
  fs = fnndpi(s);
  /// C     Determine isospin and spin factors for the ratio between
  /// C     Deuteron+Meson->BB and BB->Deuteron+Meson cross sections:
  if (idxsec == 1 || idxsec == 2) {
    /// C     Assume B+B -> d+Meson has the same cross sections as N+N -> d+pi,
    /// C     then determine d+Meson -> B+B cross sections:
    if ((lb1 >= 3 && lb1 <= 5) || (lb2 >= 3 && lb2 <= 5)) {
      xnnfactor = 8.f / 9.f;
    } else if ((lb1 >= 25 && lb1 <= 27) || (lb2 >= 25 && lb2 <= 27)) {
      xnnfactor = 8.f / 27.f;
    } else if (lb1 == 28 || lb2 == 28) {
      xnnfactor = 8.f / 9.f;
    } else if (lb1 == 0 || lb2 == 0) {
      xnnfactor = 8.f / 3.f;
    }
  } else {
    /// C     Assume d+Meson -> B+B has the same cross sections as d+pi -> N+N:
  }
  /// Clin-9/2008 For elastic collisions:
  const float srt0 = 2.012f;
  if (idxsec == 1 || idxsec == 3) {
    /// C     1/3: assume the same |matrix element|**2/s (after averaging over
    /// initial C     spins and isospins) for d+Meson elastic at the same
    /// sqrt(s);
    sdmel = fdpiel(s);
  } else if (idxsec == 2 || idxsec == 4) {
    /// C     2/4: assume the same |matrix element|**2/s (after averaging over
    /// initial C     spins and isospins) for d+Meson elastic at the same
    /// sqrt(s)-threshold:
    threshold = em1 + em2;
    snew = fem::pow2((srt - threshold + srt0));
    sdmel = fdpiel(snew);
  }
  /// C
  /// C     NN: DETERMINE THE CHARGE STATES OF PARTICLESIN THE FINAL STATE
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  if (((lb1 == 5 || lb2 == 5 || lb1 == 27 || lb2 == 27) && ianti == 0) ||
      ((lb1 == 3 || lb2 == 3 || lb1 == 25 || lb2 == 25) && ianti == 1)) {
    /// C     (1) FOR Deuteron+(pi+,rho+) -> P+P or DeuteronBar+(pi-,rho-)->
    /// PBar+PBar:
    lbnn1 = 1;
    lbnn2 = 1;
    xmnn1 = amp;
    xmnn2 = amp;
  } else if (lb1 == 3 || lb2 == 3 || lb1 == 26 || lb2 == 26 || lb1 == 28 ||
             lb2 == 28 || lb1 == 0 || lb2 == 0) {
    /// C     (2) FOR Deuteron+(pi0,rho0,omega,eta) -> N+P
    /// C     or DeuteronBar+(pi0,rho0,omega,eta) ->NBar+PBar:
    lbnn1 = 2;
    lbnn2 = 1;
    xmnn1 = amn;
    xmnn2 = amp;
  } else {
    /// C     (3) FOR Deuteron+(pi-,rho-) -> N+N or DeuteronBar+(pi+,rho+)->
    /// NBar+NBar:
    lbnn1 = 2;
    lbnn2 = 2;
    xmnn1 = amn;
    xmnn2 = amn;
  }
  if (srt > (xmnn1 + xmnn2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmnn1 + xmnn2))) *
                       (s - fem::pow2((xmnn1 - xmnn2)))) /
             2.f / srt;
    if (idxsec == 1) {
      /// C     1: assume the same |matrix element|**2/s (after averaging over
      /// initial C     spins and isospins) for B+B -> deuteron+meson at the
      /// same sqrt(s);
      sdmnn = fs * pfinal / pinitial * 3.f / 16.f * xnnfactor;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmnn1 + xmnn2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        /// C     2: assume the same |matrix element|**2/s for B+B ->
        /// deuteron+meson C     at the same sqrt(s)-threshold:
        sdmnn = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * xnnfactor;
      } else if (idxsec == 4) {
        /// C     4: assume the same |matrix element|**2/s for B+B <-
        /// deuteron+meson C     at the same sqrt(s)-threshold:
        sdmnn = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      /// C     3: assume the same |matrix element|**2/s for B+B <-
      /// deuteron+meson C     at the same sqrt(s):
      sdmnn = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     ND: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbnd1 = 1 + fem::fint(2 * ranart(nseed));
  lbnd2 = 6 + fem::fint(4 * ranart(nseed));
  if (lbnd1 == 1) {
    xmnd1 = amp;
  } else if (lbnd1 == 2) {
    xmnd1 = amn;
  }
  const float am0 = 1.232f;
  xmnd2 = am0;
  if (srt > (xmnd1 + xmnd2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmnd1 + xmnd2))) *
                       (s - fem::pow2((xmnd1 - xmnd2)))) /
             2.f / srt;
    if (idxsec == 1) {
      /// C     The spin- and isospin-averaged factor is 8-times larger for ND:
      sdmnd = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmnd1 + xmnd2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmnd =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
      } else if (idxsec == 4) {
        sdmnd = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmnd = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     NS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbns1 = 1 + fem::fint(2 * ranart(nseed));
  lbns2 = 10 + fem::fint(2 * ranart(nseed));
  if (lbns1 == 1) {
    xmns1 = amp;
  } else if (lbns1 == 2) {
    xmns1 = amn;
  }
  const float am1440 = 1.44f;
  xmns2 = am1440;
  if (srt > (xmns1 + xmns2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmns1 + xmns2))) *
                       (s - fem::pow2((xmns1 - xmns2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmns = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmns1 + xmns2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmns =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
      } else if (idxsec == 4) {
        sdmns = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmns = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     NP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbnp1 = 1 + fem::fint(2 * ranart(nseed));
  lbnp2 = 12 + fem::fint(2 * ranart(nseed));
  if (lbnp1 == 1) {
    xmnp1 = amp;
  } else if (lbnp1 == 2) {
    xmnp1 = amn;
  }
  const float am1535 = 1.535f;
  xmnp2 = am1535;
  if (srt > (xmnp1 + xmnp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmnp1 + xmnp2))) *
                       (s - fem::pow2((xmnp1 - xmnp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmnp = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmnp1 + xmnp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmnp =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
      } else if (idxsec == 4) {
        sdmnp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmnp = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     DD: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbdd1 = 6 + fem::fint(4 * ranart(nseed));
  lbdd2 = 6 + fem::fint(4 * ranart(nseed));
  xmdd1 = am0;
  xmdd2 = am0;
  if (srt > (xmdd1 + xmdd2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmdd1 + xmdd2))) *
                       (s - fem::pow2((xmdd1 - xmdd2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmdd = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 16.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmdd1 + xmdd2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmdd =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 16.f);
      } else if (idxsec == 4) {
        sdmdd = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmdd = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     DS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbds1 = 6 + fem::fint(4 * ranart(nseed));
  lbds2 = 10 + fem::fint(2 * ranart(nseed));
  xmds1 = am0;
  xmds2 = am1440;
  if (srt > (xmds1 + xmds2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmds1 + xmds2))) *
                       (s - fem::pow2((xmds1 - xmds2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmds = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmds1 + xmds2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmds =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
      } else if (idxsec == 4) {
        sdmds = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmds = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     DP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbdp1 = 6 + fem::fint(4 * ranart(nseed));
  lbdp2 = 12 + fem::fint(2 * ranart(nseed));
  xmdp1 = am0;
  xmdp2 = am1535;
  if (srt > (xmdp1 + xmdp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmdp1 + xmdp2))) *
                       (s - fem::pow2((xmdp1 - xmdp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmdp = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmdp1 + xmdp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmdp =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 8.f);
      } else if (idxsec == 4) {
        sdmdp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmdp = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     SS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbss1 = 10 + fem::fint(2 * ranart(nseed));
  lbss2 = 10 + fem::fint(2 * ranart(nseed));
  xmss1 = am1440;
  xmss2 = am1440;
  if (srt > (xmss1 + xmss2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmss1 + xmss2))) *
                       (s - fem::pow2((xmss1 - xmss2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmss = fs * pfinal / pinitial * 3.f / 16.f * xnnfactor;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmss1 + xmss2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmss = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * xnnfactor;
      } else if (idxsec == 4) {
        sdmss = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmns = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     SP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbsp1 = 10 + fem::fint(2 * ranart(nseed));
  lbsp2 = 12 + fem::fint(2 * ranart(nseed));
  xmsp1 = am1440;
  xmsp2 = am1535;
  if (srt > (xmsp1 + xmsp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmsp1 + xmsp2))) *
                       (s - fem::pow2((xmsp1 - xmsp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmsp = fs * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmsp1 + xmsp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmsp =
            fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * (xnnfactor * 2.f);
      } else if (idxsec == 4) {
        sdmsp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmsp = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  /// C     PP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
  lbpp1 = 12 + fem::fint(2 * ranart(nseed));
  lbpp2 = 12 + fem::fint(2 * ranart(nseed));
  xmpp1 = am1535;
  xmpp2 = am1535;
  if (srt > (xmpp1 + xmpp2)) {
    pfinal = fem::sqrt((s - fem::pow2((xmpp1 + xmpp2))) *
                       (s - fem::pow2((xmpp1 - xmpp2)))) /
             2.f / srt;
    if (idxsec == 1) {
      sdmpp = fs * pfinal / pinitial * 3.f / 16.f * xnnfactor;
    } else if (idxsec == 2 || idxsec == 4) {
      threshold = fem::amax1(xmpp1 + xmpp2, em1 + em2);
      snew = fem::pow2((srt - threshold + srt0));
      if (idxsec == 2) {
        sdmpp = fnndpi(snew) * pfinal / pinitial * 3.f / 16.f * xnnfactor;
      } else if (idxsec == 4) {
        sdmpp = fnndpi(snew) * pfinal / pinitial / 6.f;
      }
    } else if (idxsec == 3) {
      sdmpp = fs * pfinal / pinitial / 6.f;
    }
  }
  /// C
  sdm = sdmel + sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp + sdmss +
        sdmsp + sdmpp;
  if (ianti == 1) {
    lbnn1 = -lbnn1;
    lbnn2 = -lbnn2;
    lbnd1 = -lbnd1;
    lbnd2 = -lbnd2;
    lbns1 = -lbns1;
    lbns2 = -lbns2;
    lbnp1 = -lbnp1;
    lbnp2 = -lbnp2;
    lbdd1 = -lbdd1;
    lbdd2 = -lbdd2;
    lbds1 = -lbds1;
    lbds2 = -lbds2;
    lbdp1 = -lbdp1;
    lbdp2 = -lbdp2;
    lbss1 = -lbss1;
    lbss2 = -lbss2;
    lbsp1 = -lbsp1;
    lbsp2 = -lbsp2;
    lbpp1 = -lbpp1;
    lbpp2 = -lbpp2;
  }
  /// Ctest off
  /// C      write(98,100) srt,sdmnn,sdmnd,sdmns,sdmnp,sdmdd,sdmds,sdmdp,
  /// C     1     sdmss,sdmsp,sdmpp,sdm
  /// C 100  format(f5.2,11(1x,f5.1))
  /// C
}

struct dmangle_save {
  float c1;
  float ct1;
  float s1;
  float st1;
  float t1;

  dmangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C
/// C     Generate angular distribution of BB from d+meson in the CMS frame:
void dmangle(common& cmn, float& pxn, float& pyn, float& pzn, int const& nt,
             int const& ianti, float const& pfinal, int const& lbm) {
  FEM_CMN_SVE(dmangle);
  common_write write(cmn);
  /// COMMON leadng
  int& lb1 = cmn.lb1;
  /// COMMON dpi
  int& lb2 = cmn.lb2;
  /// COMMON arevt
  int& iaevt = cmn.iaevt;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzn = pfinal * c1;
  pxn = pfinal * s1 * ct1;
  pyn = pfinal * s1 * st1;
  /// Clin-5/2008 track the number of regularly-destructed deuterons:
  if (ianti == 0) {
    write(91, star), " d+", lbm, " ->BB (regular d destrn) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  } else {
    write(91, star), " d+", lbm, " ->BB (regular dbar destrn) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  }
  /// C
}

struct dmelangle_save {
  float c1;
  float ct1;
  float s1;
  float st1;
  float t1;

  dmelangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C
/// C     Angular distribution of d+meson elastic collisions in the CMS frame:
void dmelangle(common& cmn, float& pxn, float& pyn, float& pzn,
               float const& pfinal) {
  FEM_CMN_SVE(dmelangle);
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzn = pfinal * c1;
  pxn = pfinal * s1 * ct1;
  pyn = pfinal * s1 * st1;
}

struct crdmbb_save {
  float e1cm;
  float e2cm;
  float edcm;
  int ideut;
  int idm;
  int lbb1;
  int lbb2;
  int lbm;
  float p1beta;
  float p2beta;
  float pdbeta;
  float pfinal;
  float pt1d;
  float pt1i1;
  float pt1i2;
  float pt2d;
  float pt2i1;
  float pt2i2;
  float pt3d;
  float pt3i1;
  float pt3i2;
  float pxn;
  float pyn;
  float pzn;
  float s;
  float scheck;
  float transf;
  float x1;
  float xmb1;
  float xmb2;

  crdmbb_save()
      : e1cm(fem::float0),
        e2cm(fem::float0),
        edcm(fem::float0),
        ideut(fem::int0),
        idm(fem::int0),
        lbb1(fem::int0),
        lbb2(fem::int0),
        lbm(fem::int0),
        p1beta(fem::float0),
        p2beta(fem::float0),
        pdbeta(fem::float0),
        pfinal(fem::float0),
        pt1d(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2d(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3d(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        pxn(fem::float0),
        pyn(fem::float0),
        pzn(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        transf(fem::float0),
        x1(fem::float0),
        xmb1(fem::float0),
        xmb2(fem::float0) {}
};

/// C
/// Clin-9/2008 Deuteron+Meson ->B+B and elastic collisions
void crdmbb(common& cmn, float const& px, float const& py, float const& pz,
            float const& srt, int const& i1, int const& i2, int& iblock,
            int& ntag, float const& sig, int const& nt, int const& ianti) {
  FEM_CMN_SVE(crdmbb);
  common_write write(cmn);
  /// COMMON aa
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  /// COMMON bb
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  /// COMMON cc
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  /// COMMON arevt
  int& iaevt = cmn.iaevt;
  /// COMMON leadng
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  /// COMMON dpi
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  /// COMMON para8
  int& idpert = cmn.idpert;
  /// COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  /// COMMON dpisig
  float& sdmnn = cmn.sdmnn;
  float& sdmnd = cmn.sdmnd;
  float& sdmns = cmn.sdmns;
  float& sdmnp = cmn.sdmnp;
  float& sdmdd = cmn.sdmdd;
  float& sdmds = cmn.sdmds;
  float& sdmdp = cmn.sdmdp;
  float& sdmss = cmn.sdmss;
  float& sdmsp = cmn.sdmsp;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& edcm = sve.edcm;
  int& ideut = sve.ideut;
  int& idm = sve.idm;
  int& lbb1 = sve.lbb1;
  int& lbb2 = sve.lbb2;
  int& lbm = sve.lbm;
  float& p1beta = sve.p1beta;
  float& p2beta = sve.p2beta;
  float& pdbeta = sve.pdbeta;
  float& pfinal = sve.pfinal;
  float& pt1d = sve.pt1d;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2d = sve.pt2d;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3d = sve.pt3d;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxn = sve.pxn;
  float& pyn = sve.pyn;
  float& pzn = sve.pzn;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& transf = sve.transf;
  float& x1 = sve.x1;
  float& xmb1 = sve.xmb1;
  float& xmb2 = sve.xmb2;
  ///
  /// C-----------------------------------------------------------------------
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  s = fem::pow2(srt);
  if (sig <= 0) {
    return;
  }
  /// C
  if (fem::iabs(lb1) == 42) {
    ideut = i1;
    lbm = lb2;
    idm = i2;
  } else {
    ideut = i2;
    lbm = lb1;
    idm = i1;
  }
  /// Cccc  Elastic collision or destruction of perturbatively-produced
  /// deuterons:
  if ((idpert == 1 || idpert == 2) && dpertp(ideut) != 1.f) {
    /// C     choose reaction channels:
    x1 = ranart(nseed);
    if (x1 <= cmn.sdmel / sig) {
      /// C     Elastic collisions:
      if (ianti == 0) {
        write(91, star), "  d+", lbm, " (pert d M elastic) @nt=", nt,
            " @prob=", dpertp(ideut);
      } else {
        write(91, star), "  d+", lbm, " (pert dbar M elastic) @nt=", nt,
            " @prob=", dpertp(ideut);
      }
      /// C
      /// Clin-9/2012: check argument in sqrt():
      scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
      if (scheck < 0) {
        write(99, star), "scheck51: ", scheck;
        scheck = 0.f;
      }
      pfinal = fem::sqrt(scheck) / 2.f / srt;
      /// C            pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
      /// C
      dmelangle(cmn, pxn, pyn, pzn, pfinal);
      rotate(cmn, px, py, pz, pxn, pyn, pzn);
      edcm = fem::sqrt(fem::pow2(e(ideut)) + fem::pow2(pxn) + fem::pow2(pyn) +
                       fem::pow2(pzn));
      pdbeta = pxn * betax + pyn * betay + pzn * betaz;
      transf = gamma * (gamma * pdbeta / (gamma + 1.f) + edcm);
      pt1d = betax * transf + pxn;
      pt2d = betay * transf + pyn;
      pt3d = betaz * transf + pzn;
      p(1, ideut) = pt1d;
      p(2, ideut) = pt2d;
      p(3, ideut) = pt3d;
      iblock = 504;
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      id(i1) = 2;
      id(i2) = 2;
      /// C     Change the position of the perturbative deuteron to that of
      /// C     the meson to avoid consecutive collisions between them:
      r(1, ideut) = r(1, idm);
      r(2, ideut) = r(2, idm);
      r(3, ideut) = r(3, idm);
    } else {
      /// C     Destruction of deuterons:
      if (ianti == 0) {
        write(91, star), "  d+", lbm, " ->BB (pert d destrn) @nt=", nt,
            " @prob=", dpertp(ideut);
      } else {
        write(91, star), "  d+", lbm, " ->BB (pert dbar destrn) @nt=", nt,
            " @prob=", dpertp(ideut);
      }
      e(ideut) = 0.f;
      iblock = 502;
    }
    return;
  }
  /// C
  /// Cccc  Destruction of regularly-produced deuterons:
  iblock = 502;
  /// C     choose final state and assign masses here:
  x1 = ranart(nseed);
  if (x1 <= sdmnn / sig) {
    lbb1 = cmn.lbnn1;
    lbb2 = cmn.lbnn2;
    xmb1 = cmn.xmnn1;
    xmb2 = cmn.xmnn2;
  } else if (x1 <= (sdmnn + sdmnd) / sig) {
    lbb1 = cmn.lbnd1;
    lbb2 = cmn.lbnd2;
    xmb1 = cmn.xmnd1;
    xmb2 = cmn.xmnd2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns) / sig) {
    lbb1 = cmn.lbns1;
    lbb2 = cmn.lbns2;
    xmb1 = cmn.xmns1;
    xmb2 = cmn.xmns2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp) / sig) {
    lbb1 = cmn.lbnp1;
    lbb2 = cmn.lbnp2;
    xmb1 = cmn.xmnp1;
    xmb2 = cmn.xmnp2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd) / sig) {
    lbb1 = cmn.lbdd1;
    lbb2 = cmn.lbdd2;
    xmb1 = cmn.xmdd1;
    xmb2 = cmn.xmdd2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds) / sig) {
    lbb1 = cmn.lbds1;
    lbb2 = cmn.lbds2;
    xmb1 = cmn.xmds1;
    xmb2 = cmn.xmds2;
  } else if (x1 <=
             (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp) / sig) {
    lbb1 = cmn.lbdp1;
    lbb2 = cmn.lbdp2;
    xmb1 = cmn.xmdp1;
    xmb2 = cmn.xmdp2;
  } else if (x1 <=
             (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp + sdmss) /
                 sig) {
    lbb1 = cmn.lbss1;
    lbb2 = cmn.lbss2;
    xmb1 = cmn.xmss1;
    xmb2 = cmn.xmss2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp +
                    sdmss + sdmsp) /
                       sig) {
    lbb1 = cmn.lbsp1;
    lbb2 = cmn.lbsp2;
    xmb1 = cmn.xmsp1;
    xmb2 = cmn.xmsp2;
  } else if (x1 <= (sdmnn + sdmnd + sdmns + sdmnp + sdmdd + sdmds + sdmdp +
                    sdmss + sdmsp + cmn.sdmpp) /
                       sig) {
    lbb1 = cmn.lbpp1;
    lbb2 = cmn.lbpp2;
    xmb1 = cmn.xmpp1;
    xmb2 = cmn.xmpp2;
  } else {
    /// C     Elastic collision:
    lbb1 = lb1;
    lbb2 = lb2;
    xmb1 = em1;
    xmb2 = em2;
    iblock = 504;
  }
  lb(i1) = lbb1;
  e(i1) = xmb1;
  lb(i2) = lbb2;
  e(i2) = xmb2;
  lb1 = lb(i1);
  lb2 = lb(i2);
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((xmb1 + xmb2))) * (s - fem::pow2((xmb1 - xmb2)));
  if (scheck < 0) {
    write(99, star), "scheck52: ", scheck;
    scheck = 0.f;
  }
  pfinal = fem::sqrt(scheck) / 2.f / srt;
  /// C      pfinal=sqrt((s-(xmb1+xmb2)**2)*(s-(xmb1-xmb2)**2))/2./srt
  /// C
  if (iblock == 502) {
    dmangle(cmn, pxn, pyn, pzn, nt, ianti, pfinal, lbm);
  } else if (iblock == 504) {
    if (ianti == 0) {
      write(91, star), " d+", lbm, " (regular d M elastic) @evt#", iaevt,
          " @nt=", nt, " lb1,2=", lb1, lb2;
    } else {
      write(91, star), " d+", lbm, " (regular dbar M elastic) @evt#", iaevt,
          " @nt=", nt, " lb1,2=", lb1, lb2;
    }
    dmelangle(cmn, pxn, pyn, pzn, pfinal);
  } else {
    write(6, star), "Wrong iblock number in crdmbb()";
    FEM_STOP(0);
  }
  /// C     ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  /// C     (This is not needed for isotropic distributions)
  rotate(cmn, px, py, pz, pxn, pyn, pzn);
  /// C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
  /// STATE C     FROM THE NUCLEUS-NUCLEUS CMS. FRAME INTO LAB FRAME: C     For
  /// the 1st baryon:
  e1cm = fem::sqrt(fem::pow2(e(i1)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p1beta = pxn * betax + pyn * betay + pzn * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1.f) + e1cm);
  pt1i1 = betax * transf + pxn;
  pt2i1 = betay * transf + pyn;
  pt3i1 = betaz * transf + pzn;
  /// C
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  /// C     For the 2nd baryon:
  e2cm = fem::sqrt(fem::pow2(e(i2)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p2beta = -pxn * betax - pyn * betay - pzn * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf - pxn;
  pt2i2 = betay * transf - pyn;
  pt3i2 = betaz * transf - pzn;
  /// C
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  /// C
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  em2 = e(i2);
  id(i1) = 2;
  id(i2) = 2;
}

/// C
/// C     Cross section of Deuteron+N elastic (in mb):
float fdbel(float const& s) {
  float return_value = fem::float0;
  const float srt0 = 2.012f;
  if (s <= fem::pow2(srt0)) {
    return_value = 0.f;
  } else {
    return_value = 2500.f * fem::exp(-fem::pow2((s - 7.93f)) / 0.003f) +
                   300.f * fem::exp(-fem::pow2((s - 7.93f)) / 0.1f) + 10.f;
  }
  return return_value;
}

struct sdbelastic_save {
  float s;
  float sdbel;
  float snew;
  float threshold;

  sdbelastic_save()
      : s(fem::float0),
        sdbel(fem::float0),
        snew(fem::float0),
        threshold(fem::float0) {}
};

/// C
/// Clin-9/2008 Deuteron+Baryon elastic cross section (in mb)
void sdbelastic(common& cmn, float const& srt, float& sdb) {
  FEM_CMN_SVE(sdbelastic);
  /// COMMON leadng
  float& em1 = cmn.em1;
  /// COMMON dpi
  float& em2 = cmn.em2;
  /// COMMON para8
  int& idxsec = cmn.idxsec;
  ///
  /// SAVE
  float& s = sve.s;
  float& sdbel = sve.sdbel;
  float& snew = sve.snew;
  float& threshold = sve.threshold;
  ///
  /// C
  sdb = 0.f;
  sdbel = 0.f;
  if (srt <= (em1 + em2)) {
    return;
  }
  s = fem::pow2(srt);
  /// C     For elastic collisions:
  const float srt0 = 2.012f;
  if (idxsec == 1 || idxsec == 3) {
    /// C     1/3: assume the same |matrix element|**2/s (after averaging over
    /// initial C     spins and isospins) for d+Baryon elastic at the same
    /// sqrt(s);
    sdbel = fdbel(s);
  } else if (idxsec == 2 || idxsec == 4) {
    /// C     2/4: assume the same |matrix element|**2/s (after averaging over
    /// initial C     spins and isospins) for d+Baryon elastic at the same
    /// sqrt(s)-threshold:
    threshold = em1 + em2;
    snew = fem::pow2((srt - threshold + srt0));
    sdbel = fdbel(snew);
  }
  sdb = sdbel;
}

struct dbelangle_save {
  float c1;
  float ct1;
  float s1;
  float st1;
  float t1;

  dbelangle_save()
      : c1(fem::float0),
        ct1(fem::float0),
        s1(fem::float0),
        st1(fem::float0),
        t1(fem::float0) {}
};

/// C
/// C     Angular distribution of d+baryon elastic collisions in the CMS frame:
void dbelangle(common& cmn, float& pxn, float& pyn, float& pzn,
               float const& pfinal) {
  FEM_CMN_SVE(dbelangle);
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  /// SAVE
  float& c1 = sve.c1;
  float& ct1 = sve.ct1;
  float& s1 = sve.s1;
  float& st1 = sve.st1;
  float& t1 = sve.t1;
  ///
  /// C     take isotropic distribution for now:
  c1 = 1.0f - 2.0f * ranart(nseed);
  const float pi = 3.1415926f;
  t1 = 2.0f * pi * ranart(nseed);
  s1 = fem::sqrt(1.0f - fem::pow2(c1));
  ct1 = fem::cos(t1);
  st1 = fem::sin(t1);
  /// C THE MOMENTUM IN THE CMS IN THE FINAL STATE
  pzn = pfinal * c1;
  pxn = pfinal * s1 * ct1;
  pyn = pfinal * s1 * st1;
}

struct crdbel_save {
  float e1cm;
  float e2cm;
  float edcm;
  int idb;
  int ideut;
  int lbb;
  float p1beta;
  float p2beta;
  float pdbeta;
  float pfinal;
  float pt1d;
  float pt1i1;
  float pt1i2;
  float pt2d;
  float pt2i1;
  float pt2i2;
  float pt3d;
  float pt3i1;
  float pt3i2;
  float pxn;
  float pyn;
  float pzn;
  float s;
  float scheck;
  float transf;

  crdbel_save()
      : e1cm(fem::float0),
        e2cm(fem::float0),
        edcm(fem::float0),
        idb(fem::int0),
        ideut(fem::int0),
        lbb(fem::int0),
        p1beta(fem::float0),
        p2beta(fem::float0),
        pdbeta(fem::float0),
        pfinal(fem::float0),
        pt1d(fem::float0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2d(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3d(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        pxn(fem::float0),
        pyn(fem::float0),
        pzn(fem::float0),
        s(fem::float0),
        scheck(fem::float0),
        transf(fem::float0) {}
};

/// Clin-9/2008 Deuteron+Baryon elastic collisions
void crdbel(common& cmn, float const& px, float const& py, float const& pz,
            float const& srt, int const& i1, int const& i2, int& iblock,
            int& ntag, float const& sig, int const& nt, int const& ianti) {
  FEM_CMN_SVE(crdbel);
  common_write write(cmn);
  /// COMMON aa
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  /// COMMON bb
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  /// COMMON bg
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  /// COMMON cc
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  /// COMMON ee
  arr_ref<int> id(cmn.id, dimension(maxstr));
  /// COMMON arevt
  int& iaevt = cmn.iaevt;
  /// COMMON leadng
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  /// COMMON dpi
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  /// COMMON para8
  int& idpert = cmn.idpert;
  /// COMMON dpert
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  ///
  /// SAVE
  float& e1cm = sve.e1cm;
  float& e2cm = sve.e2cm;
  float& edcm = sve.edcm;
  int& idb = sve.idb;
  int& ideut = sve.ideut;
  int& lbb = sve.lbb;
  float& p1beta = sve.p1beta;
  float& p2beta = sve.p2beta;
  float& pdbeta = sve.pdbeta;
  float& pfinal = sve.pfinal;
  float& pt1d = sve.pt1d;
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2d = sve.pt2d;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3d = sve.pt3d;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& pxn = sve.pxn;
  float& pyn = sve.pyn;
  float& pzn = sve.pzn;
  float& s = sve.s;
  float& scheck = sve.scheck;
  float& transf = sve.transf;
  ///
  /// C-----------------------------------------------------------------------
  iblock = 0;
  ntag = 0;
  em1 = e(i1);
  em2 = e(i2);
  s = fem::pow2(srt);
  if (sig <= 0) {
    return;
  }
  iblock = 503;
  /// C
  if (fem::iabs(lb1) == 42) {
    ideut = i1;
    lbb = lb2;
    idb = i2;
  } else {
    ideut = i2;
    lbb = lb1;
    idb = i1;
  }
  /// Cccc  Elastic collision of perturbatively-produced deuterons:
  if ((idpert == 1 || idpert == 2) && dpertp(ideut) != 1.f) {
    if (ianti == 0) {
      write(91, star), "  d+", lbb, " (pert d B elastic) @nt=", nt,
          " @prob=", dpertp(ideut), p(1, idb), p(2, idb), p(1, ideut),
          p(2, ideut);
    } else {
      write(91, star), "  d+", lbb, " (pert dbar Bbar elastic) @nt=", nt,
          " @prob=", dpertp(ideut), p(1, idb), p(2, idb), p(1, ideut),
          p(2, ideut);
    }
    /// C
    /// Clin-9/2012: check argument in sqrt():
    scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
    if (scheck < 0) {
      write(99, star), "scheck53: ", scheck;
      scheck = 0.f;
    }
    pfinal = fem::sqrt(scheck) / 2.f / srt;
    /// C         pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
    /// C
    dbelangle(cmn, pxn, pyn, pzn, pfinal);
    rotate(cmn, px, py, pz, pxn, pyn, pzn);
    edcm = fem::sqrt(fem::pow2(e(ideut)) + fem::pow2(pxn) + fem::pow2(pyn) +
                     fem::pow2(pzn));
    pdbeta = pxn * betax + pyn * betay + pzn * betaz;
    transf = gamma * (gamma * pdbeta / (gamma + 1.f) + edcm);
    pt1d = betax * transf + pxn;
    pt2d = betay * transf + pyn;
    pt3d = betaz * transf + pzn;
    p(1, ideut) = pt1d;
    p(2, ideut) = pt2d;
    p(3, ideut) = pt3d;
    px1 = p(1, i1);
    py1 = p(2, i1);
    pz1 = p(3, i1);
    id(i1) = 2;
    id(i2) = 2;
    /// C     Change the position of the perturbative deuteron to that of
    /// C     the baryon to avoid consecutive collisions between them:
    r(1, ideut) = r(1, idb);
    r(2, ideut) = r(2, idb);
    r(3, ideut) = r(3, idb);
    return;
  }
  /// C
  /// C     Elastic collision of regularly-produced deuterons:
  if (ianti == 0) {
    write(91, star), " d+", lbb, " (regular d B elastic) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  } else {
    write(91, star), " d+", lbb, " (regular dbar Bbar elastic) @evt#", iaevt,
        " @nt=", nt, " lb1,2=", lb1, lb2;
  }
  /// Clin-9/2012: check argument in sqrt():
  scheck = (s - fem::pow2((em1 + em2))) * (s - fem::pow2((em1 - em2)));
  if (scheck < 0) {
    write(99, star), "scheck54: ", scheck;
    scheck = 0.f;
  }
  pfinal = fem::sqrt(scheck) / 2.f / srt;
  /// C      pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
  /// C
  dbelangle(cmn, pxn, pyn, pzn, pfinal);
  /// C     ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
  /// C     (This is not needed for isotropic distributions)
  rotate(cmn, px, py, pz, pxn, pyn, pzn);
  /// C     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL
  /// STATE C     FROM THE NUCLEUS-NUCLEUS CMS. FRAME INTO LAB FRAME: C     For
  /// the 1st baryon:
  e1cm = fem::sqrt(fem::pow2(e(i1)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p1beta = pxn * betax + pyn * betay + pzn * betaz;
  transf = gamma * (gamma * p1beta / (gamma + 1.f) + e1cm);
  pt1i1 = betax * transf + pxn;
  pt2i1 = betay * transf + pyn;
  pt3i1 = betaz * transf + pzn;
  /// C
  p(1, i1) = pt1i1;
  p(2, i1) = pt2i1;
  p(3, i1) = pt3i1;
  /// C     For the 2nd baryon:
  e2cm = fem::sqrt(fem::pow2(e(i2)) + fem::pow2(pxn) + fem::pow2(pyn) +
                   fem::pow2(pzn));
  p2beta = -pxn * betax - pyn * betay - pzn * betaz;
  transf = gamma * (gamma * p2beta / (gamma + 1.f) + e2cm);
  pt1i2 = betax * transf - pxn;
  pt2i2 = betay * transf - pyn;
  pt3i2 = betaz * transf - pzn;
  /// C
  p(1, i2) = pt1i2;
  p(2, i2) = pt2i2;
  p(3, i2) = pt3i2;
  /// C
  px1 = p(1, i1);
  py1 = p(2, i1);
  pz1 = p(3, i1);
  em1 = e(i1);
  em2 = e(i2);
  id(i1) = 2;
  id(i2) = 2;
}

struct rlu_save {
  fem::variant_bindings ludatr_bindings;
};

/// C
/// C*********************************************************************
/// C
float rlu(common& cmn, int const& /* idum */) {
  float return_value = fem::float0;
  FEM_CMN_SVE(rlu);
  common_variant ludatr(cmn.common_ludatr, sve.ludatr_bindings);
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> mrlu(dimension(6));
      mbr<int> mrlu1;
      mbr<int> mrlu2;
      mbr<int> mrlu3;
      mbr<int> mrlu4;
      mbr<int> mrlu5;
      mbr<int> mrlu6;
      mbr<float> rrlu(dimension(100));
      mbr<float> rrlu98;
      mbr<float> rrlu99;
      mbr<float> rrlu00;
      ludatr.allocate(),
          equivalence(mrlu, mrlu1, mrlu2, mrlu3, mrlu4, mrlu5, mrlu6)
              .align<2>()
              .with<1>(arr_index(1))
              .align<3>()
              .with<1>(arr_index(2))
              .align<4>()
              .with<1>(arr_index(3))
              .align<5>()
              .with<1>(arr_index(4))
              .align<6>()
              .with<1>(arr_index(5))
              .align<7>()
              .with<1>(arr_index(6)),
          equivalence(rrlu, rrlu98, rrlu99, rrlu00)
              .align<2>()
              .with<1>(arr_index(98))
              .align<3>()
              .with<1>(arr_index(99))
              .align<4>()
              .with<1>(arr_index(100));
    }
  }
  /* arr_ref<int> mrlu( */ ludatr.bind<int>() /* , dimension(6)) */;
  int& mrlu1 = ludatr.bind<int>();
  int& mrlu2 = ludatr.bind<int>();
  int& mrlu3 = ludatr.bind<int>();
  int& mrlu4 = ludatr.bind<int>();
  int& mrlu5 = ludatr.bind<int>();
  /* int& mrlu6 */ ludatr.bind<int>();
  arr_ref<float> rrlu(ludatr.bind<float>(), dimension(100));
  float& rrlu98 = ludatr.bind<float>();
  float& rrlu99 = ludatr.bind<float>();
  float& rrlu00 = ludatr.bind<float>();
  int ij = fem::int0;
  int kl = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int k = fem::int0;
  int l = fem::int0;
  int ii = fem::int0;
  float s = fem::float0;
  float t = fem::float0;
  int jj = fem::int0;
  int m = fem::int0;
  float twom24 = fem::float0;
  int i24 = fem::int0;
  float runi = fem::float0;
  /// C
  /// C...Purpose: to generate random numbers uniformly distributed between
  /// C...0 and 1, excluding the endpoints.
  /// C
  /// C...Initialize generation from given seed.
  if (mrlu2 == 0) {
    ij = fem::mod(mrlu1 / 30082, 31329);
    kl = fem::mod(mrlu1, 30082);
    i = fem::mod(ij / 177, 177) + 2;
    j = fem::mod(ij, 177) + 2;
    k = fem::mod(kl / 169, 178) + 1;
    l = fem::mod(kl, 169);
    FEM_DO_SAFE(ii, 1, 97) {
      s = 0.f;
      t = 0.5f;
      FEM_DO_SAFE(jj, 1, 24) {
        m = fem::mod(fem::mod(i * j, 179) * k, 179);
        i = j;
        j = k;
        k = m;
        l = fem::mod(53 * l + 1, 169);
        if (fem::mod(l * m, 64) >= 32) {
          s += t;
        }
        t = 0.5f * t;
      }
      rrlu(ii) = s;
    }
    twom24 = 1.f;
    FEM_DO_SAFE(i24, 1, 24) { twom24 = 0.5f * twom24; }
    rrlu98 = 362436.f * twom24;
    rrlu99 = 7654321.f * twom24;
    rrlu00 = 16777213.f * twom24;
    mrlu2 = 1;
    mrlu3 = 0;
    mrlu4 = 97;
    mrlu5 = 33;
  }
/// C
/// C...Generate next random number.
statement_130:
  runi = rrlu(mrlu4) - rrlu(mrlu5);
  if (runi < 0.f) {
    runi += 1.f;
  }
  rrlu(mrlu4) = runi;
  mrlu4 = mrlu4 - 1;
  if (mrlu4 == 0) {
    mrlu4 = 97;
  }
  mrlu5 = mrlu5 - 1;
  if (mrlu5 == 0) {
    mrlu5 = 97;
  }
  rrlu98 = rrlu98 - rrlu99;
  if (rrlu98 < 0.f) {
    rrlu98 += rrlu00;
  }
  runi = runi - rrlu98;
  if (runi < 0.f) {
    runi += 1.f;
  }
  if (runi <= 0 || runi >= 1.f) {
    goto statement_130;
  }
  /// C
  /// C...Update counters. Random number to output.
  mrlu3++;
  if (mrlu3 == 1000000000) {
    mrlu2++;
    mrlu3 = 0;
  }
  return_value = runi;
  /// C
  return return_value;
}

/// C
/// C*********************************************************************
/// C
float ulmass(common& cmn, int const& kf) {
  float return_value = fem::float0;
  /// COMMON ludat1
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  /// COMMON ludat2
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_ref<float> parf(cmn.parf, dimension(2000));
  ///
  /// C
  /// C...Purpose: to give the mass of a particle/parton.
  /// C
  /// C...Reset variables. Compressed code.
  return_value = 0.f;
  int kfa = fem::iabs(kf);
  int kc = lucomp(cmn, kf);
  if (kc == 0) {
    return return_value;
  }
  parf(106) = pmas(6, 1);
  parf(107) = pmas(7, 1);
  parf(108) = pmas(8, 1);
  /// C
  /// C...Guarantee use of constituent masses for internal checks.
  int kfla = fem::int0;
  int kflb = fem::int0;
  int kflc = fem::int0;
  int kfls = fem::int0;
  int kflr = fem::int0;
  float pma = fem::float0;
  float pmb = fem::float0;
  float pmc = fem::float0;
  float pmspl = fem::float0;
  int kmul = fem::int0;
  if ((mstj(93) == 1 || mstj(93) == 2) && kfa <= 10) {
    return_value = parf(100 + kfa);
    if (mstj(93) == 2) {
      return_value = fem::max(0.f, return_value - parf(121));
    }
    /// C
    /// C...Masses that can be read directly off table.
  } else if (kfa <= 100 || kc <= 80 || kc > 100) {
    return_value = pmas(kc, 1);
    /// C
    /// C...Find constituent partons and their masses.
  } else {
    kfla = fem::mod(kfa / 1000, 10);
    kflb = fem::mod(kfa / 100, 10);
    kflc = fem::mod(kfa / 10, 10);
    kfls = fem::mod(kfa, 10);
    kflr = fem::mod(kfa / 10000, 10);
    pma = parf(100 + kfla);
    pmb = parf(100 + kflb);
    pmc = parf(100 + kflc);
    /// C
    /// C...Construct masses for various meson, diquark and baryon cases.
    if (kfla == 0 && kflr == 0 && kfls <= 3) {
      if (kfls == 1) {
        pmspl = -3.f / (pmb * pmc);
      }
      if (kfls >= 3) {
        pmspl = 1.f / (pmb * pmc);
      }
      return_value =
          parf(111) + pmb + pmc + parf(113) * fem::pow2(parf(101)) * pmspl;
    } else if (kfla == 0) {
      kmul = 2;
      if (kfls == 1) {
        kmul = 3;
      }
      if (kflr == 2) {
        kmul = 4;
      }
      if (kfls == 5) {
        kmul = 5;
      }
      return_value = parf(113 + kmul) + pmb + pmc;
    } else if (kflc == 0) {
      if (kfls == 1) {
        pmspl = -3.f / (pma * pmb);
      }
      if (kfls == 3) {
        pmspl = 1.f / (pma * pmb);
      }
      return_value = 2.f * parf(112) / 3.f + pma + pmb +
                     parf(114) * fem::pow2(parf(101)) * pmspl;
      if (mstj(93) == 1) {
        return_value = pma + pmb;
      }
      if (mstj(93) == 2) {
        return_value =
            fem::max(0.f, return_value - parf(122) - 2.f * parf(112) / 3.f);
      }
    } else {
      if (kfls == 2 && kfla == kflb) {
        pmspl = 1.f / (pma * pmb) - 2.f / (pma * pmc) - 2.f / (pmb * pmc);
      } else if (kfls == 2 && kflb >= kflc) {
        pmspl = -2.f / (pma * pmb) - 2.f / (pma * pmc) + 1.f / (pmb * pmc);
      } else if (kfls == 2) {
        pmspl = -3.f / (pmb * pmc);
      } else {
        pmspl = 1.f / (pma * pmb) + 1.f / (pma * pmc) + 1.f / (pmb * pmc);
      }
      return_value = parf(112) + pma + pmb + pmc +
                     parf(114) * fem::pow2(parf(101)) * pmspl;
    }
  }
  /// C
  /// C...Optional mass broadening according to truncated Breit-Wigner
  /// C...(either in m or in m^2).
  float pm0 = fem::float0;
  float pmlow = fem::float0;
  float pmupp = fem::float0;
  if (mstj(24) >= 1 && pmas(kc, 2) > 1e-4f) {
    if (mstj(24) == 1 || (mstj(24) == 2 && kfa > 100)) {
      return_value += 0.5f * pmas(kc, 2) *
                      fem::tan((2.f * rlu(cmn, 0) - 1.f) *
                               fem::atan(2.f * pmas(kc, 3) / pmas(kc, 2)));
    } else {
      pm0 = return_value;
      pmlow = fem::atan(
          (fem::pow2(fem::max(0.f, pm0 - pmas(kc, 3))) - fem::pow2(pm0)) /
          (pm0 * pmas(kc, 2)));
      pmupp = fem::atan(fem::pow2((pm0 + pmas(kc, 3))) - fem::pow2(pm0)) /
              (pm0 * pmas(kc, 2));
      return_value = fem::sqrt(fem::max(
          0.f, fem::pow2(pm0) +
                   pm0 * pmas(kc, 2) *
                       fem::tan(pmlow + (pmupp - pmlow) * rlu(cmn, 0))));
    }
  }
  mstj(93) = 0;
  /// C
  return return_value;
}

/// C
/// C*********************************************************************
/// C
void luname(common& cmn, int const& kf, str_ref chau) {
  /// COMMON ludat1
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  /// COMMON ludat4
  str_arr_cref<1> chaf(cmn.chaf, dimension(500));
  ///
  /// C
  /// C...Purpose: to give the particle/parton name as a character string.
  /// C
  /// C...Initial values. Charge. Subdivide code.
  chau = " ";
  int kfa = fem::iabs(kf);
  int kc = lucomp(cmn, kf);
  if (kc == 0) {
    return;
  }
  int kq = luchge(cmn, kf);
  int kfla = fem::mod(kfa / 1000, 10);
  int kflb = fem::mod(kfa / 100, 10);
  int kflc = fem::mod(kfa / 10, 10);
  int kfls = fem::mod(kfa, 10);
  int kflr = fem::mod(kfa / 10000, 10);
  /// C
  /// C...Read out root name and spin for simple particle.
  int len = fem::int0;
  int lem = fem::int0;
  if (kfa <= 100 || (kfa > 100 && kc > 100)) {
    chau = chaf(kc);
    len = 0;
    FEM_DO_SAFE(lem, 1, 8) {
      if (chau(lem, lem) != " ") {
        len = lem;
      }
    }
    /// C
    /// C...Construct root name for diquark. Add on spin.
  } else if (kflc == 0) {
    chau(1, 2) = chaf(kfla)(1, 1) + chaf(kflb)(1, 1);
    if (kfls == 1) {
      chau(3, 4) = "_0";
    }
    if (kfls == 3) {
      chau(3, 4) = "_1";
    }
    len = 4;
    /// C
    /// C...Construct root name for heavy meson. Add on spin and heavy flavour.
  } else if (kfla == 0) {
    if (kflb == 5) {
      chau(1, 1) = "B";
    }
    if (kflb == 6) {
      chau(1, 1) = "T";
    }
    if (kflb == 7) {
      chau(1, 1) = "L";
    }
    if (kflb == 8) {
      chau(1, 1) = "H";
    }
    len = 1;
    if (kflr == 0 && kfls == 1) {
    } else if (kflr == 0 && kfls == 3) {
      chau(2, 2) = "*";
      len = 2;
    } else if (kflr == 1 && kfls == 3) {
      chau(2, 3) = "_1";
      len = 3;
    } else if (kflr == 1 && kfls == 1) {
      chau(2, 4) = "*_0";
      len = 4;
    } else if (kflr == 2) {
      chau(2, 4) = "*_1";
      len = 4;
    } else if (kfls == 5) {
      chau(2, 4) = "*_2";
      len = 4;
    }
    if (kflc >= 3 && kflr == 0 && kfls <= 3) {
      chau(len + 1, len + 2) = "_" + chaf(kflc)(1, 1);
      len += 2;
    } else if (kflc >= 3) {
      chau(len + 1, len + 1) = chaf(kflc)(1, 1);
      len++;
    }
    /// C
    /// C...Construct root name and spin for heavy baryon.
  } else {
    if (kflb <= 2 && kflc <= 2) {
      chau = "Sigma ";
      if (kflc > kflb) {
        chau = "Lambda";
      }
      if (kfls == 4) {
        chau = "Sigma*";
      }
      len = 5;
      if (chau(6, 6) != " ") {
        len = 6;
      }
    } else if (kflb <= 2 || kflc <= 2) {
      chau = "Xi ";
      if (kfla > kflb && kflb > kflc) {
        chau = "Xi'";
      }
      if (kfls == 4) {
        chau = "Xi*";
      }
      len = 2;
      if (chau(3, 3) != " ") {
        len = 3;
      }
    } else {
      chau = "Omega ";
      if (kfla > kflb && kflb > kflc) {
        chau = "Omega'";
      }
      if (kfls == 4) {
        chau = "Omega*";
      }
      len = 5;
      if (chau(6, 6) != " ") {
        len = 6;
      }
    }
    /// C
    /// C...Add on heavy flavour content for heavy baryon.
    chau(len + 1, len + 2) = "_" + chaf(kfla)(1, 1);
    len += 2;
    if (kflb >= kflc && kflc >= 4) {
      chau(len + 1, len + 2) = chaf(kflb)(1, 1) + chaf(kflc)(1, 1);
      len += 2;
    } else if (kflb >= kflc && kflb >= 4) {
      chau(len + 1, len + 1) = chaf(kflb)(1, 1);
      len++;
    } else if (kflc > kflb && kflb >= 4) {
      chau(len + 1, len + 2) = chaf(kflc)(1, 1) + chaf(kflb)(1, 1);
      len += 2;
    } else if (kflc > kflb && kflc >= 4) {
      chau(len + 1, len + 1) = chaf(kflc)(1, 1);
      len++;
    }
  }
  /// C
  /// C...Add on bar sign for antiparticle (where necessary).
  if (kf > 0 || len == 0) {
  } else if (kfa > 10 && kfa <= 40 && kq != 0) {
  } else if (kfa == 89 || (kfa >= 91 && kfa <= 99)) {
  } else if (kfa > 100 && kfla == 0 && kq != 0) {
  } else if (mstu(15) <= 1) {
    chau(len + 1, len + 1) = "~";
    len++;
  } else {
    chau(len + 1, len + 3) = "bar";
    len += 3;
  }
  /// C
  /// C...Add on charge where applicable (conventional cases skipped).
  if (kq == 6) {
    chau(len + 1, len + 2) = "++";
  }
  if (kq == -6) {
    chau(len + 1, len + 2) = "--";
  }
  if (kq == 3) {
    chau(len + 1, len + 1) = "+";
  }
  if (kq == -3) {
    chau(len + 1, len + 1) = "-";
  }
  if (kq == 0 && (kfa <= 22 || len == 0)) {
  } else if (kq == 0 && (kfa >= 81 && kfa <= 100)) {
  } else if (kfa > 100 && kfla == 0 && kflb == kflc && kflb != 1) {
  } else if (kq == 0) {
    chau(len + 1, len + 1) = "0";
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
float ulangl(common& cmn, float const& x, float const& y) {
  float return_value = fem::float0;
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  ///
  /// C
  /// C...Purpose: to reconstruct an angle from given x and y coordinates.
  /// C
  return_value = 0.f;
  float r = fem::sqrt(fem::pow2(x) + fem::pow2(y));
  if (r < 1e-20f) {
    return return_value;
  }
  if (fem::abs(x) / r < 0.8f) {
    return_value = fem::sign(fem::acos(x / r), y);
  } else {
    return_value = fem::asin(y / r);
    if (x < 0.f && return_value >= 0.f) {
      return_value = paru(1) - return_value;
    } else if (x < 0.f) {
      return_value = -paru(1) - return_value;
    }
  }
  /// C
  return return_value;
}

/// C
/// C*********************************************************************
/// C
float plu(common& cmn, int const& i, int const& j) {
  float return_value = fem::float0;
  /// COMMON lujets
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_cref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  /// COMMON ludat1
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  ///
  /// C
  /// C...Purpose: to provide various real-valued event related data.
  /// C
  /// C...Set default value. For I = 0 sum of momenta or charges,
  /// C...or invariant mass of system.
  return_value = 0.f;
  int i1 = fem::int0;
  int j1 = fem::int0;
  arr_1d<4, float> psum(fem::fill0);
  float pmr = fem::float0;
  float pr = fem::float0;
  if (i < 0 || i > mstu(4) || j <= 0) {
  } else if (i == 0 && j <= 4) {
    FEM_DO_SAFE(i1, 1, n) {
      if (k(i1, 1) > 0 && k(i1, 1) <= 10) {
        return_value += p(i1, j);
      }
    }
  } else if (i == 0 && j == 5) {
    FEM_DO_SAFE(j1, 1, 4) {
      psum(j1) = 0.f;
      FEM_DO_SAFE(i1, 1, n) {
        if (k(i1, 1) > 0 && k(i1, 1) <= 10) {
          psum(j1) += p(i1, j1);
        }
      }
    }
    return_value =
        fem::sqrt(fem::max(0.f, fem::pow2(psum(4)) - fem::pow2(psum(1)) -
                                    fem::pow2(psum(2)) - fem::pow2(psum(3))));
  } else if (i == 0 && j == 6) {
    FEM_DO_SAFE(i1, 1, n) {
      if (k(i1, 1) > 0 && k(i1, 1) <= 10) {
        return_value += luchge(cmn, k(i1, 2)) / 3.f;
      }
    }
  } else if (i == 0) {
    /// C
    /// C...Direct readout of P matrix.
  } else if (j <= 5) {
    return_value = p(i, j);
    /// C
    /// C...Charge, total momentum, transverse momentum, transverse mass.
  } else if (j <= 12) {
    if (j == 6) {
      return_value = luchge(cmn, k(i, 2)) / 3.f;
    }
    if (j == 7 || j == 8) {
      return_value =
          fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) + fem::pow2(p(i, 3));
    }
    if (j == 9 || j == 10) {
      return_value = fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
    }
    if (j == 11 || j == 12) {
      return_value =
          fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
    }
    if (j == 8 || j == 10 || j == 12) {
      return_value = fem::sqrt(return_value);
    }
    /// C
    /// C...Theta and phi angle in radians or degrees.
  } else if (j <= 16) {
    if (j <= 14) {
      return_value = ulangl(cmn, p(i, 3),
                            fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2))));
    }
    if (j >= 15) {
      return_value = ulangl(cmn, p(i, 1), p(i, 2));
    }
    if (j == 14 || j == 16) {
      return_value = return_value * 180.f / paru(1);
    }
    /// C
    /// C...True rapidity, rapidity with pion mass, pseudorapidity.
  } else if (j <= 19) {
    pmr = 0.f;
    if (j == 17) {
      pmr = p(i, 5);
    }
    if (j == 18) {
      pmr = ulmass(cmn, 211);
    }
    pr = fem::max(1e-20f,
                  fem::pow2(pmr) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)));
    return_value =
        fem::sign(fem::log(fem::min(
                      (fem::sqrt(pr + fem::pow2(p(i, 3))) + fem::abs(p(i, 3))) /
                          fem::sqrt(pr),
                      1e20f)),
                  p(i, 3));
    /// C
    /// C...Energy and momentum fractions (only to be used in CM frame).
  } else if (j <= 25) {
    if (j == 20) {
      return_value = 2.f *
                     fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                               fem::pow2(p(i, 3))) /
                     paru(21);
    }
    if (j == 21) {
      return_value = 2.f * p(i, 3) / paru(21);
    }
    if (j == 22) {
      return_value =
          2.f * fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2))) / paru(21);
    }
    if (j == 23) {
      return_value = 2.f * p(i, 4) / paru(21);
    }
    if (j == 24) {
      return_value = (p(i, 4) + p(i, 3)) / paru(21);
    }
    if (j == 25) {
      return_value = (p(i, 4) - p(i, 3)) / paru(21);
    }
  }
  /// C
  return return_value;
}

struct lulist_save {
  arr<fem::str<4> > chdl;
  arr<fem::str<3> > chmo;

  lulist_save()
      : chdl(dimension(7), fem::fill0), chmo(dimension(12), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void lulist(common& cmn, int const& mlist) {
  FEM_CMN_SVE(lulist);
  common_write write(cmn);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_cref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_cref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<float> parf(cmn.parf, dimension(2000));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_cref<float> brat(cmn.brat, dimension(2000));
  arr_cref<int, 2> kfdp(cmn.kfdp, dimension(2000, 5));
  ///
  str_arr_ref<1> chdl(sve.chdl, dimension(7));
  str_arr_ref<1> chmo(sve.chmo, dimension(12));
  if (is_called_first_time) {
    {
      static const char* values[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chmo;
    }
    {
      static const char* values[] = {"(())", " ",  "()",  "!!",
                                     "<>",   "==", "(==)"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chdl;
    }
  }
  int lmx = fem::int0;
  int istr = fem::int0;
  int imax = fem::int0;
  int i = fem::int0;
  fem::str<16> chap = fem::char0;
  int len = fem::int0;
  int lem = fem::int0;
  int mdl = fem::int0;
  int ldl = fem::int0;
  fem::str<16> chac = fem::char0;
  int kc = fem::int0;
  int kcc = fem::int0;
  int j1 = fem::int0;
  int j2 = fem::int0;
  int j = fem::int0;
  int isep = fem::int0;
  arr_1d<6, float> ps(fem::fill0);
  int kf = fem::int0;
  fem::str<16> chan = fem::char0;
  int kfls = fem::int0;
  int kfla = fem::int0;
  int kflb = fem::int0;
  int kmul = fem::int0;
  int kflr = fem::int0;
  int kflc = fem::int0;
  int kflsp = fem::int0;
  int mstj24 = fem::int0;
  int kfmax = fem::int0;
  float pm = fem::float0;
  int idc = fem::int0;
  arr_1d<5, fem::str<16> > chad(fem::fill0);
  static const char* format_2700 = "(4x,i6,4x,a16,6x,i6,4x,a16)";
  /// C
  /// C...Purpose: to give program heading, or list an event, or particle
  /// C...data, or current parameter values.
  /// C
  /// C...Initialization printout: version number and date of last change.
  /// C      IF(MLIST.EQ.0.OR.MSTU(12).EQ.1) THEN
  /// C        WRITE(MSTU(11),1000) MSTU(181),MSTU(182),MSTU(185),
  /// C     &  CHMO(MSTU(184)),MSTU(183)
  /// C        MSTU(12)=0
  /// C        IF(MLIST.EQ.0) RETURN
  /// C      ENDIF
  /// C
  /// C...List event data, including additional lines after N.
  if (mlist >= 1 && mlist <= 3) {
    if (mlist == 1) {
      write(
          mstu(11),
          "(/,/,/,28x,'Event listing (summary)',/,/,4x,'I  particle/jet KS',5x,"
          "'KF orig    p_x      p_y      p_z       E        m',/)");
    }
    if (mlist == 2) {
      write(mstu(11),
            "(/,/,/,28x,'Event listing (standard)',/,/,4x,'I  particle/jet',"
            "'  K(I,1)   K(I,2) K(I,3)     K(I,4)      K(I,5)       P(I,1)',"
            "'       P(I,2)       P(I,3)       P(I,4)       P(I,5)',/)");
    }
    if (mlist == 3) {
      write(mstu(11),
            "(/,/,/,28x,'Event listing (with vertices)',/,/,4x,'I  particle/j',"
            "'et  K(I,1)   K(I,2) K(I,3)     K(I,4)      K(I,5)       P(I,1)',"
            "'       P(I,2)       P(I,3)       P(I,4)       P(I,5)',/,73x,"
            "'V(I,1)       V(I,2)       V(I,3)       V(I,4)       V(I,5)',/)");
    }
    lmx = 12;
    if (mlist >= 2) {
      lmx = 16;
    }
    istr = 0;
    imax = n;
    if (mstu(2) > 0) {
      imax = mstu(2);
    }
    FEM_DO_SAFE(i, fem::max(1, mstu(1)),
                fem::max(imax, n + fem::max(0, mstu(3)))) {
      if ((i > imax && i <= n) || k(i, 1) < 0) {
        goto statement_120;
      }
      /// C
      /// C...Get particle name, pad it and check it is not too long.
      luname(cmn, k(i, 2), chap);
      len = 0;
      FEM_DO_SAFE(lem, 1, 16) {
        if (chap(lem, lem) != " ") {
          len = lem;
        }
      }
      mdl = (k(i, 1) + 19) / 10;
      ldl = 0;
      if (mdl == 2 || mdl >= 8) {
        chac = chap;
        if (len > lmx) {
          chac(lmx, lmx) = "?";
        }
      } else {
        ldl = 1;
        if (mdl == 1 || mdl == 7) {
          ldl = 2;
        }
        if (len == 0) {
          chac = chdl(mdl)(1, 2 * ldl) + str_cref(" ");
        } else {
          chac = chdl(mdl)(1, ldl) + chap(1, fem::min(len, lmx - 2 * ldl)) +
                 chdl(mdl)(ldl + 1, 2 * ldl) + str_cref(" ");
          if (len + 2 * ldl > lmx) {
            chac(lmx, lmx) = "?";
          }
        }
      }
      /// C
      /// C...Add information on string connection.
      if (k(i, 1) == 1 || k(i, 1) == 2 || k(i, 1) == 11 || k(i, 1) == 12) {
        kc = lucomp(cmn, k(i, 2));
        kcc = 0;
        if (kc != 0) {
          kcc = kchg(kc, 2);
        }
        if (kcc != 0 && istr == 0) {
          istr = 1;
          if (len + 2 * ldl + 3 <= lmx) {
            chac(lmx - 1, lmx - 1) = "A";
          }
        } else if (kcc != 0 && (k(i, 1) == 2 || k(i, 1) == 12)) {
          if (len + 2 * ldl + 3 <= lmx) {
            chac(lmx - 1, lmx - 1) = "I";
          }
        } else if (kcc != 0) {
          istr = 0;
          if (len + 2 * ldl + 3 <= lmx) {
            chac(lmx - 1, lmx - 1) = "V";
          }
        }
      }
      /// C
      /// C...Write data for particle/jet.
      if (mlist == 1 && fem::abs(p(i, 4)) < 9999.f) {
        {
          write_loop wloop(cmn, mstu(11),
                           "(1x,i4,2x,a12,1x,i2,1x,i6,1x,i4,5f9.3)");
          wloop, i, chac(1, 12);
          FEM_DO_SAFE(j1, 1, 3) { wloop, k(i, j1); }
          FEM_DO_SAFE(j2, 1, 5) { wloop, p(i, j2); }
        }
      } else if (mlist == 1 && fem::abs(p(i, 4)) < 99999.f) {
        {
          write_loop wloop(cmn, mstu(11),
                           "(1x,i4,2x,a12,1x,i2,1x,i6,1x,i4,5f9.2)");
          wloop, i, chac(1, 12);
          FEM_DO_SAFE(j1, 1, 3) { wloop, k(i, j1); }
          FEM_DO_SAFE(j2, 1, 5) { wloop, p(i, j2); }
        }
      } else if (mlist == 1) {
        {
          write_loop wloop(cmn, mstu(11),
                           "(1x,i4,2x,a12,1x,i2,1x,i6,1x,i4,5f9.1)");
          wloop, i, chac(1, 12);
          FEM_DO_SAFE(j1, 1, 3) { wloop, k(i, j1); }
          FEM_DO_SAFE(j2, 1, 5) { wloop, p(i, j2); }
        }
      } else if (mstu(5) == 10000 &&
                 (k(i, 1) == 3 || k(i, 1) == 13 || k(i, 1) == 14)) {
        {
          write_loop wloop(
              cmn, mstu(11),
              "(1x,i4,2x,a16,1x,i3,1x,i8,2x,i4,2(3x,i1,2i4),5f13.5)");
          wloop, i, chac;
          FEM_DO_SAFE(j1, 1, 3) { wloop, k(i, j1); }
          wloop, k(i, 4) / 100000000, fem::mod(k(i, 4) / 10000, 10000),
              fem::mod(k(i, 4), 10000), k(i, 5) / 100000000,
              fem::mod(k(i, 5) / 10000, 10000), fem::mod(k(i, 5), 10000);
          FEM_DO_SAFE(j2, 1, 5) { wloop, p(i, j2); }
        }
      } else {
        {
          write_loop wloop(cmn, mstu(11),
                           "(1x,i4,2x,a16,1x,i3,1x,i8,2x,i4,2(3x,i9),5f13.5)");
          wloop, i, chac;
          FEM_DO_SAFE(j1, 1, 5) { wloop, k(i, j1); }
          FEM_DO_SAFE(j2, 1, 5) { wloop, p(i, j2); }
        }
      }
      if (mlist == 3) {
        {
          write_loop wloop(cmn, mstu(11), "(66x,5(1x,f12.3))");
          FEM_DO_SAFE(j, 1, 5) { wloop, v(i, j); }
        }
      }
      /// C
      /// C...Insert extra separator lines specified by user.
      if (mstu(70) >= 1) {
        isep = 0;
        FEM_DO_SAFE(j, 1, fem::min(10, mstu(70))) {
          if (i == mstu(70 + j)) {
            isep = 1;
          }
        }
        if (isep == 1 && mlist == 1) {
          write(mstu(11), "(1x,78('='))");
        }
        if (isep == 1 && mlist >= 2) {
          write(mstu(11), "(1x,130('='))");
        }
      }
    statement_120:;
    }
    /// C
    /// C...Sum of charges and momenta.
    FEM_DO_SAFE(j, 1, 6) { ps(j) = plu(cmn, 0, j); }
    if (mlist == 1 && fem::abs(ps(4)) < 9999.f) {
      {
        write_loop wloop(cmn, mstu(11), "(19x,'sum:',f6.2,5x,5f9.3)");
        wloop, ps(6);
        FEM_DO_SAFE(j, 1, 5) { wloop, ps(j); }
      }
    } else if (mlist == 1 && fem::abs(ps(4)) < 99999.f) {
      {
        write_loop wloop(cmn, mstu(11), "(19x,'sum:',f6.2,5x,5f9.2)");
        wloop, ps(6);
        FEM_DO_SAFE(j, 1, 5) { wloop, ps(j); }
      }
    } else if (mlist == 1) {
      {
        write_loop wloop(cmn, mstu(11), "(19x,'sum:',f6.2,5x,5f9.1)");
        wloop, ps(6);
        FEM_DO_SAFE(j, 1, 5) { wloop, ps(j); }
      }
    } else {
      {
        write_loop wloop(
            cmn, mstu(11),
            "(19x,'sum charge:',f6.2,3x,'sum momentum and inv. mass:',5f13.5)");
        wloop, ps(6);
        FEM_DO_SAFE(j, 1, 5) { wloop, ps(j); }
      }
    }
    /// C
    /// C...Give simple list of KF codes defined in program.
  } else if (mlist == 11) {
    write(mstu(11), "(/,/,/,20x,'List of KF codes in program',/)");
    FEM_DO_SAFE(kf, 1, 40) {
      luname(cmn, kf, chap);
      luname(cmn, -kf, chan);
      if (chap != " " && chan == " ") {
        write(mstu(11), format_2700), kf, chap;
      }
      if (chan != " ") {
        write(mstu(11), format_2700), kf, chap, -kf, chan;
      }
    }
    FEM_DOSTEP(kfls, 1, 3, 2) {
      FEM_DO_SAFE(kfla, 1, 8) {
        FEM_DO_SAFE(kflb, 1, kfla - (3 - kfls) / 2) {
          kf = 1000 * kfla + 100 * kflb + kfls;
          luname(cmn, kf, chap);
          luname(cmn, -kf, chan);
          write(mstu(11), format_2700), kf, chap, -kf, chan;
        }
      }
    }
    FEM_DO_SAFE(kmul, 0, 5) {
      kfls = 3;
      if (kmul == 0 || kmul == 3) {
        kfls = 1;
      }
      if (kmul == 5) {
        kfls = 5;
      }
      kflr = 0;
      if (kmul == 2 || kmul == 3) {
        kflr = 1;
      }
      if (kmul == 4) {
        kflr = 2;
      }
      FEM_DO_SAFE(kflb, 1, 8) {
        FEM_DO_SAFE(kflc, 1, kflb - 1) {
          kf = 10000 * kflr + 100 * kflb + 10 * kflc + kfls;
          luname(cmn, kf, chap);
          luname(cmn, -kf, chan);
          write(mstu(11), format_2700), kf, chap, -kf, chan;
        }
        kf = 10000 * kflr + 110 * kflb + kfls;
        luname(cmn, kf, chap);
        write(mstu(11), format_2700), kf, chap;
      }
    }
    kf = 130;
    luname(cmn, kf, chap);
    write(mstu(11), format_2700), kf, chap;
    kf = 310;
    luname(cmn, kf, chap);
    write(mstu(11), format_2700), kf, chap;
    FEM_DO_SAFE(kflsp, 1, 3) {
      kfls = 2 + 2 * (kflsp / 3);
      FEM_DO_SAFE(kfla, 1, 8) {
        FEM_DO_SAFE(kflb, 1, kfla) {
          FEM_DO_SAFE(kflc, 1, kflb) {
            if (kflsp == 1 && (kfla == kflb || kflb == kflc)) {
              goto statement_180;
            }
            if (kflsp == 2 && kfla == kflc) {
              goto statement_180;
            }
            if (kflsp == 1) {
              kf = 1000 * kfla + 100 * kflc + 10 * kflb + kfls;
            }
            if (kflsp >= 2) {
              kf = 1000 * kfla + 100 * kflb + 10 * kflc + kfls;
            }
            luname(cmn, kf, chap);
            luname(cmn, -kf, chan);
            write(mstu(11), format_2700), kf, chap, -kf, chan;
          statement_180:;
          }
        }
      }
    }
    /// C
    /// C...List parton/particle data table. Check whether to be listed.
  } else if (mlist == 12) {
    write(
        mstu(11),
        "(/,/,/,30x,'Particle/parton data table',/,/,5x,'KF',5x,'KC',4x,"
        "'particle',8x,'antiparticle',6x,'chg  col  anti',8x,'mass',7x,'width',"
        "7x,'w-cut',5x,'lifetime',1x,'decay',/,11x,'IDC',1x,'on/"
        "off',1x,'ME',3x,"
        "'Br.rat.',4x,'decay products')");
    mstj24 = mstj(24);
    mstj(24) = 0;
    kfmax = 20883;
    if (mstu(2) != 0) {
      kfmax = mstu(2);
    }
    FEM_DO_SAFE(kf, fem::max(1, mstu(1)), kfmax) {
      kc = lucomp(cmn, kf);
      if (kc == 0) {
        goto statement_220;
      }
      if (mstu(14) == 0 && kf > 100 && kc <= 100) {
        goto statement_220;
      }
      if (mstu(14) > 0 && kf > 100 &&
          fem::max(fem::mod(kf / 1000, 10), fem::mod(kf / 100, 10)) >
              mstu(14)) {
        goto statement_220;
      }
      /// C
      /// C...Find particle name and mass. Print information.
      luname(cmn, kf, chap);
      if (kf <= 100 && chap == " " && mdcy(kc, 2) == 0) {
        goto statement_220;
      }
      luname(cmn, -kf, chan);
      pm = ulmass(cmn, kf);
      write(
          mstu(11),
          "(/,1x,i6,3x,i4,4x,a16,a16,3i5,1x,f12.5,2(1x,f11.5),2x,f12.5,3x,i2)"),
          kf, kc, chap, chan, kchg(kc, 1), kchg(kc, 2), kchg(kc, 3), pm,
          pmas(kc, 2), pmas(kc, 3), pmas(kc, 4), mdcy(kc, 1);
      /// C
      /// C...Particle decay: channel number, branching ration, matrix element,
      /// C...decay products.
      if (kf > 100 && kc <= 100) {
        goto statement_220;
      }
      FEM_DO_SAFE(idc, mdcy(kc, 2), mdcy(kc, 2) + mdcy(kc, 3) - 1) {
        FEM_DO_SAFE(j, 1, 5) { luname(cmn, kfdp(idc, j), chad(j)); }
        {
          write_loop wloop(cmn, mstu(11),
                           "(10x,i4,2x,i3,2x,i3,2x,f8.5,4x,5a16)");
          wloop, idc, mdme(idc, 1), mdme(idc, 2), brat(idc);
          FEM_DO_SAFE(j, 1, 5) { wloop, chad(j); }
        }
      }
    statement_220:;
    }
    mstj(24) = mstj24;
    /// C
    /// C...List parameter value table.
  } else if (mlist == 13) {
    write(mstu(11),
          "(/,/,/,20x,'Parameter value table',/,/,4x,'I',3x,'MSTU(I)',8x,"
          "'PARU(I)',3x,'MSTJ(I)',8x,'PARJ(I)',8x,'PARF(I)')");
    FEM_DO_SAFE(i, 1, 200) {
      write(mstu(11), "(1x,i4,1x,i9,1x,f14.5,1x,i9,1x,f14.5,1x,f14.5)"), i,
          mstu(i), paru(i), mstj(i), parj(i), parf(i);
    }
  }
  /// C
  /// C...Format statements for output on unit MSTU(11) (by default 6).
  /// Clin 1000 FORMAT(////20X,'The Lund Monte Carlo - JETSET version
  /// ',I1,'.',I1/ Clin     &20X,'**  Last date of change:  ',I2,1X,A3,1X,I4,'
  /// **'/)
  /// C
}

/// C
/// C*********************************************************************
/// C
void luerrm(common& cmn, int const& merr, str_cref chmess) {
  common_write write(cmn);
  /// COMMON ludat1
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  ///
  static const char* format_1100 =
      "(/,5x,'Error type',i2,' has occured after',i6,' LUEXEC calls:',/,5x,a)";
  /// C
  /// C...Purpose: to inform user of errors in program execution.
  /// C
  write(6, star), "merr,chmess=", merr, chmess;
  /// C
  /// C...Write first few warnings, then be silent.
  if (merr <= 10) {
    mstu(27)++;
    mstu(28) = merr;
    if (mstu(25) == 1 && mstu(27) <= mstu(26)) {
      write(
          mstu(11),
          "(/,5x,'Advisory warning type',i2,' given after',i6,' LUEXEC calls:',"
          "/,5x,a)"),
          merr, mstu(31), chmess;
    }
    /// C
    /// C...Write first few errors, then be silent or stop program.
  } else if (merr <= 20) {
    mstu(23)++;
    mstu(24) = merr - 10;
    if (mstu(21) >= 1 && mstu(23) <= mstu(22)) {
      write(mstu(11), format_1100), merr - 10, mstu(31), chmess;
    }
    if (mstu(21) >= 2 && mstu(23) > mstu(22)) {
      write(mstu(11), format_1100), merr - 10, mstu(31), chmess;
      write(mstu(11),
            "(5x,'Execution will be stopped after listing of last ','event!')");
      if (merr != 17) {
        lulist(cmn, 2);
      }
      FEM_STOP(0);
    }
    /// C
    /// C...Stop program in case of irreparable error.
  } else {
    write(mstu(11),
          "(/,5x,'Fatal error type',i2,' has occured after',i6,' LUEXEC "
          "calls:',/,"
          "5x,a,/,5x,'Execution will now be stopped!')"),
        merr - 20, mstu(31), chmess;
    FEM_STOP(0);
  }
  /// C
  /// C...Formats for output.
  /// C
}

/// C
/// C*********************************************************************
/// C
void lukfdi(common& cmn, int const& kfl1, int const& kfl2, int& kfl3, int& kf) {
  arr_cref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<float> parf(cmn.parf, dimension(2000));
  ///
  int kf1a = fem::int0;
  int kf2a = fem::int0;
  int ktab1 = fem::int0;
  int kfl1a = fem::int0;
  int kfl1b = fem::int0;
  int kfl1s = fem::int0;
  int ktab2 = fem::int0;
  int kfl2a = fem::int0;
  int kfl2b = fem::int0;
  int kfl2s = fem::int0;
  float par2 = fem::float0;
  float par3 = fem::float0;
  float par4 = fem::float0;
  float par3m = fem::float0;
  float par4m = fem::float0;
  float pardm = fem::float0;
  float pars0 = fem::float0;
  float pars1 = fem::float0;
  float pars2 = fem::float0;
  float parsm = fem::float0;
  int mbary = fem::int0;
  int kfda = fem::int0;
  int kflda = fem::int0;
  int kfldb = fem::int0;
  int kflds = fem::int0;
  float wtdq = fem::float0;
  int kfs = fem::int0;
  int kfla = fem::int0;
  int kflb = fem::int0;
  int kfl1d = fem::int0;
  int kfl1e = fem::int0;
  int kfl3a = fem::int0;
  int kmul = fem::int0;
  float rmul = fem::float0;
  int kfls = fem::int0;
  float rmix = fem::float0;
  int imix = fem::int0;
  int kflc = fem::int0;
  int kbary = fem::int0;
  float wt = fem::float0;
  int kfld = fem::int0;
  int kflf = fem::int0;
  int kfle = fem::int0;
  int kfll = fem::int0;
  int kt3l = fem::int0;
  int kt3u = fem::int0;
  float rfl = fem::float0;
  int kts = fem::int0;
  int kt3 = fem::int0;
  int ktabs = fem::int0;
  int ktab3 = fem::int0;
  int kfl3b = fem::int0;
  int kc = fem::int0;
  /// C
  /// C...Purpose: to generate a new flavour pair and combine off a hadron.
  /// C
  /// C...Default flavour values. Input consistency checks.
  kf1a = fem::iabs(kfl1);
  kf2a = fem::iabs(kfl2);
  kfl3 = 0;
  kf = 0;
  if (kf1a == 0) {
    return;
  }
  if (kf2a != 0) {
    if (kf1a <= 10 && kf2a <= 10 && kfl1 * kfl2 > 0) {
      return;
    }
    if (kf1a > 10 && kf2a > 10) {
      return;
    }
    if ((kf1a > 10 || kf2a > 10) && kfl1 * kfl2 < 0) {
      return;
    }
  }
  /// C
  /// C...Check if tabulated flavour probabilities are to be used.
  if (mstj(15) == 1) {
    ktab1 = -1;
    if (kf1a >= 1 && kf1a <= 6) {
      ktab1 = kf1a;
    }
    kfl1a = fem::mod(kf1a / 1000, 10);
    kfl1b = fem::mod(kf1a / 100, 10);
    kfl1s = fem::mod(kf1a, 10);
    if (kfl1a >= 1 && kfl1a <= 4 && kfl1b >= 1 && kfl1b <= 4) {
      ktab1 = 6 + kfl1a * (kfl1a - 2) + 2 * kfl1b + (kfl1s - 1) / 2;
    }
    if (kfl1a >= 1 && kfl1a <= 4 && kfl1a == kfl1b) {
      ktab1 = ktab1 - 1;
    }
    if (kf1a >= 1 && kf1a <= 6) {
      kfl1a = kf1a;
    }
    ktab2 = 0;
    if (kf2a != 0) {
      ktab2 = -1;
      if (kf2a >= 1 && kf2a <= 6) {
        ktab2 = kf2a;
      }
      kfl2a = fem::mod(kf2a / 1000, 10);
      kfl2b = fem::mod(kf2a / 100, 10);
      kfl2s = fem::mod(kf2a, 10);
      if (kfl2a >= 1 && kfl2a <= 4 && kfl2b >= 1 && kfl2b <= 4) {
        ktab2 = 6 + kfl2a * (kfl2a - 2) + 2 * kfl2b + (kfl2s - 1) / 2;
      }
      if (kfl2a >= 1 && kfl2a <= 4 && kfl2a == kfl2b) {
        ktab2 = ktab2 - 1;
      }
    }
    if (ktab1 >= 0 && ktab2 >= 0) {
      goto statement_140;
    }
  }
/// C
/// C...Parameters and breaking diquark parameter combinations.
statement_100:
  par2 = parj(2);
  par3 = parj(3);
  par4 = 3.f * parj(4);
  if (mstj(12) >= 2) {
    par3m = fem::sqrt(parj(3));
    par4m = 1.f / (3.f * fem::sqrt(parj(4)));
    pardm = parj(7) / (parj(7) + par3m * parj(6));
    pars0 = parj(5) * (2.f + (1.f + par2 * par3m * parj(7)) * (1.f + par4m));
    pars1 =
        parj(7) * pars0 / (2.f * par3m) +
        parj(5) * (parj(6) * (1.f + par4m) + par2 * par3m * parj(6) * parj(7));
    pars2 = parj(5) * 2.f * parj(6) * parj(7) *
            (par2 * parj(7) + (1.f + par4m) / par3m);
    parsm = fem::max(pars0, pars1, pars2);
    par4 = par4 * (1.f + parsm) / (1.f + parsm / (3.f * par4m));
  }
  /// C
  /// C...Choice of whether to generate meson or baryon.
  mbary = 0;
  kfda = 0;
  if (kf1a <= 10) {
    if (kf2a == 0 && mstj(12) >= 1 && (1.f + parj(1)) * rlu(cmn, 0) > 1.f) {
      mbary = 1;
    }
    if (kf2a > 10) {
      mbary = 2;
    }
    if (kf2a > 10 && kf2a <= 10000) {
      kfda = kf2a;
    }
  } else {
    mbary = 2;
    if (kf1a <= 10000) {
      kfda = kf1a;
    }
  }
  /// C
  /// C...Possibility of process diquark -> meson + new diquark.
  if (kfda != 0 && mstj(12) >= 2) {
    kflda = fem::mod(kfda / 1000, 10);
    kfldb = fem::mod(kfda / 100, 10);
    kflds = fem::mod(kfda, 10);
    wtdq = pars0;
    if (fem::max(kflda, kfldb) == 3) {
      wtdq = pars1;
    }
    if (fem::min(kflda, kfldb) == 3) {
      wtdq = pars2;
    }
    if (kflds == 1) {
      wtdq = wtdq / (3.f * par4m);
    }
    if ((1.f + wtdq) * rlu(cmn, 0) > 1.f) {
      mbary = -1;
    }
    if (mbary == -1 && kf2a != 0) {
      return;
    }
  }
  /// C
  /// C...Flavour for meson, possibly with new flavour.
  if (mbary <= 0) {
    kfs = fem::isign(1, kfl1);
    if (mbary == 0) {
      if (kf2a == 0) {
        kfl3 = fem::isign(1 + fem::fint((2.f + par2) * rlu(cmn, 0)), -kfl1);
      }
      kfla = fem::max(kf1a, kf2a + fem::iabs(kfl3));
      kflb = fem::min(kf1a, kf2a + fem::iabs(kfl3));
      if (kfla != kf1a) {
        kfs = -kfs;
      }
      /// C
      /// C...Splitting of diquark into meson plus new diquark.
    } else {
      kfl1a = fem::mod(kf1a / 1000, 10);
      kfl1b = fem::mod(kf1a / 100, 10);
    statement_110:
      kfl1d = kfl1a + fem::fint(rlu(cmn, 0) + 0.5f) * (kfl1b - kfl1a);
      kfl1e = kfl1a + kfl1b - kfl1d;
      if ((kfl1d == 3 && rlu(cmn, 0) > pardm) ||
          (kfl1e == 3 && rlu(cmn, 0) < pardm)) {
        kfl1d = kfl1a + kfl1b - kfl1d;
        kfl1e = kfl1a + kfl1b - kfl1e;
      }
      kfl3a = 1 + fem::fint((2.f + par2 * par3m * parj(7)) * rlu(cmn, 0));
      if ((kfl1e != kfl3a &&
           rlu(cmn, 0) > (1.f + par4m) / fem::max(2.f, 1.f + par4m)) ||
          (kfl1e == kfl3a && rlu(cmn, 0) > 2.f / fem::max(2.f, 1.f + par4m))) {
        goto statement_110;
      }
      kflds = 3;
      if (kfl1e != kfl3a) {
        kflds = 2 * fem::fint(rlu(cmn, 0) + 1.f / (1.f + par4m)) + 1;
      }
      kfl3 = fem::isign(10000 + 1000 * fem::max(kfl1e, kfl3a) +
                            100 * fem::min(kfl1e, kfl3a) + kflds,
                        -kfl1);
      kfla = fem::max(kfl1d, kfl3a);
      kflb = fem::min(kfl1d, kfl3a);
      if (kfla != kfl1d) {
        kfs = -kfs;
      }
    }
    /// C
    /// C...Form meson, with spin and flavour mixing for diagonal states.
    if (kfla <= 2) {
      kmul = fem::fint(parj(11) + rlu(cmn, 0));
    }
    if (kfla == 3) {
      kmul = fem::fint(parj(12) + rlu(cmn, 0));
    }
    if (kfla >= 4) {
      kmul = fem::fint(parj(13) + rlu(cmn, 0));
    }
    if (kmul == 0 && parj(14) > 0.f) {
      if (rlu(cmn, 0) < parj(14)) {
        kmul = 2;
      }
    } else if (kmul == 1 && parj(15) + parj(16) + parj(17) > 0.f) {
      rmul = rlu(cmn, 0);
      if (rmul < parj(15)) {
        kmul = 3;
      }
      if (kmul == 1 && rmul < parj(15) + parj(16)) {
        kmul = 4;
      }
      if (kmul == 1 && rmul < parj(15) + parj(16) + parj(17)) {
        kmul = 5;
      }
    }
    kfls = 3;
    if (kmul == 0 || kmul == 3) {
      kfls = 1;
    }
    if (kmul == 5) {
      kfls = 5;
    }
    if (kfla != kflb) {
      kf = (100 * kfla + 10 * kflb + kfls) * kfs * fem::pow((-1), kfla);
    } else {
      rmix = rlu(cmn, 0);
      imix = 2 * kfla + 10 * kmul;
      if (kfla <= 3) {
        kf = 110 * (1 + fem::fint(rmix + parf(imix - 1)) +
                    fem::fint(rmix + parf(imix))) +
             kfls;
      }
      if (kfla >= 4) {
        kf = 110 * kfla + kfls;
      }
    }
    if (kmul == 2 || kmul == 3) {
      kf += fem::isign(10000, kf);
    }
    if (kmul == 4) {
      kf += fem::isign(20000, kf);
    }
    /// C
    /// C...Generate diquark flavour.
  } else {
  statement_120:
    if (kf1a <= 10 && kf2a == 0) {
      kfla = kf1a;
    statement_130:
      kflb = 1 + fem::fint((2.f + par2 * par3) * rlu(cmn, 0));
      kflc = 1 + fem::fint((2.f + par2 * par3) * rlu(cmn, 0));
      kflds = 1;
      if (kflb >= kflc) {
        kflds = 3;
      }
      if (kflds == 1 && par4 * rlu(cmn, 0) > 1.f) {
        goto statement_130;
      }
      if (kflds == 3 && par4 < rlu(cmn, 0)) {
        goto statement_130;
      }
      kfl3 = fem::isign(
          1000 * fem::max(kflb, kflc) + 100 * fem::min(kflb, kflc) + kflds,
          kfl1);
      /// C
      /// C...Take diquark flavour from input.
    } else if (kf1a <= 10) {
      kfla = kf1a;
      kflb = fem::mod(kf2a / 1000, 10);
      kflc = fem::mod(kf2a / 100, 10);
      kflds = fem::mod(kf2a, 10);
      /// C
      /// C...Generate (or take from input) quark to go with diquark.
    } else {
      if (kf2a == 0) {
        kfl3 = fem::isign(1 + fem::fint((2.f + par2) * rlu(cmn, 0)), kfl1);
      }
      kfla = kf2a + fem::iabs(kfl3);
      kflb = fem::mod(kf1a / 1000, 10);
      kflc = fem::mod(kf1a / 100, 10);
      kflds = fem::mod(kf1a, 10);
    }
    /// C
    /// C...SU(6) factors for formation of baryon. Try again if fails.
    kbary = kflds;
    if (kflds == 3 && kflb != kflc) {
      kbary = 5;
    }
    if (kfla != kflb && kfla != kflc) {
      kbary++;
    }
    wt = parf(60 + kbary) + parj(18) * parf(70 + kbary);
    if (mbary == 1 && mstj(12) >= 2) {
      wtdq = pars0;
      if (fem::max(kflb, kflc) == 3) {
        wtdq = pars1;
      }
      if (fem::min(kflb, kflc) == 3) {
        wtdq = pars2;
      }
      if (kflds == 1) {
        wtdq = wtdq / (3.f * par4m);
      }
      if (kflds == 1) {
        wt = wt * (1.f + wtdq) / (1.f + parsm / (3.f * par4m));
      }
      if (kflds == 3) {
        wt = wt * (1.f + wtdq) / (1.f + parsm);
      }
    }
    if (kf2a == 0 && wt < rlu(cmn, 0)) {
      goto statement_120;
    }
    /// C
    /// C...Form baryon. Distinguish Lambda- and Sigmalike baryons.
    kfld = fem::max(kfla, kflb, kflc);
    kflf = fem::min(kfla, kflb, kflc);
    kfle = kfla + kflb + kflc - kfld - kflf;
    kfls = 2;
    if ((parf(60 + kbary) + parj(18) * parf(70 + kbary)) * rlu(cmn, 0) >
        parf(60 + kbary)) {
      kfls = 4;
    }
    kfll = 0;
    if (kfls == 2 && kfld > kfle && kfle > kflf) {
      if (kflds == 1 && kfla == kfld) {
        kfll = 1;
      }
      if (kflds == 1 && kfla != kfld) {
        kfll = fem::fint(0.25f + rlu(cmn, 0));
      }
      if (kflds == 3 && kfla != kfld) {
        kfll = fem::fint(0.75f + rlu(cmn, 0));
      }
    }
    if (kfll == 0) {
      kf = fem::isign(1000 * kfld + 100 * kfle + 10 * kflf + kfls, kfl1);
    }
    if (kfll == 1) {
      kf = fem::isign(1000 * kfld + 100 * kflf + 10 * kfle + kfls, kfl1);
    }
  }
  return;
/// C
/// C...Use tabulated probabilities to select new flavour and hadron.
statement_140:
  if (ktab2 == 0 && mstj(12) <= 0) {
    kt3l = 1;
    kt3u = 6;
  } else if (ktab2 == 0 && ktab1 >= 7 && mstj(12) <= 1) {
    kt3l = 1;
    kt3u = 6;
  } else if (ktab2 == 0) {
    kt3l = 1;
    kt3u = 22;
  } else {
    kt3l = ktab2;
    kt3u = ktab2;
  }
  rfl = 0.f;
  FEM_DO_SAFE(kts, 0, 2) {
    FEM_DO_SAFE(kt3, kt3l, kt3u) {
      rfl += parf(120 + 80 * ktab1 + 25 * kts + kt3);
    }
  }
  rfl = rlu(cmn, 0) * rfl;
  FEM_DO_SAFE(kts, 0, 2) {
    ktabs = kts;
    FEM_DO_SAFE(kt3, kt3l, kt3u) {
      ktab3 = kt3;
      rfl = rfl - parf(120 + 80 * ktab1 + 25 * kts + kt3);
      if (rfl <= 0.f) {
        goto statement_170;
      }
    }
  }
statement_170:
  /// C
  /// C...Reconstruct flavour of produced quark/diquark.
  if (ktab3 <= 6) {
    kfl3a = ktab3;
    kfl3b = 0;
    kfl3 = fem::isign(kfl3a, kfl1 * (2 * ktab1 - 13));
  } else {
    kfl3a = 1;
    if (ktab3 >= 8) {
      kfl3a = 2;
    }
    if (ktab3 >= 11) {
      kfl3a = 3;
    }
    if (ktab3 >= 16) {
      kfl3a = 4;
    }
    kfl3b = (ktab3 - 6 - kfl3a * (kfl3a - 2)) / 2;
    kfl3 = 1000 * kfl3a + 100 * kfl3b + 1;
    if (kfl3a == kfl3b || ktab3 != 6 + kfl3a * (kfl3a - 2) + 2 * kfl3b) {
      kfl3 += 2;
    }
    kfl3 = fem::isign(kfl3, kfl1 * (13 - 2 * ktab1));
  }
  /// C
  /// C...Reconstruct meson code.
  if (kfl3a == kfl1a && kfl3b == kfl1b && (kfl3a <= 3 || kfl3b != 0)) {
    rfl = rlu(cmn, 0) * (parf(143 + 80 * ktab1 + 25 * ktabs) +
                         parf(144 + 80 * ktab1 + 25 * ktabs) +
                         parf(145 + 80 * ktab1 + 25 * ktabs));
    kf = 110 + 2 * ktabs + 1;
    if (rfl > parf(143 + 80 * ktab1 + 25 * ktabs)) {
      kf = 220 + 2 * ktabs + 1;
    }
    if (rfl > parf(143 + 80 * ktab1 + 25 * ktabs) +
                  parf(144 + 80 * ktab1 + 25 * ktabs)) {
      kf = 330 + 2 * ktabs + 1;
    }
  } else if (ktab1 <= 6 && ktab3 <= 6) {
    kfla = fem::max(ktab1, ktab3);
    kflb = fem::min(ktab1, ktab3);
    kfs = fem::isign(1, kfl1);
    if (kfla != kf1a) {
      kfs = -kfs;
    }
    kf = (100 * kfla + 10 * kflb + 2 * ktabs + 1) * kfs * fem::pow((-1), kfla);
  } else if (ktab1 >= 7 && ktab3 >= 7) {
    kfs = fem::isign(1, kfl1);
    if (kfl1a == kfl3a) {
      kfla = fem::max(kfl1b, kfl3b);
      kflb = fem::min(kfl1b, kfl3b);
      if (kfla != kfl1b) {
        kfs = -kfs;
      }
    } else if (kfl1a == kfl3b) {
      kfla = kfl3a;
      kflb = kfl1b;
      kfs = -kfs;
    } else if (kfl1b == kfl3a) {
      kfla = kfl1a;
      kflb = kfl3b;
    } else if (kfl1b == kfl3b) {
      kfla = fem::max(kfl1a, kfl3a);
      kflb = fem::min(kfl1a, kfl3a);
      if (kfla != kfl1a) {
        kfs = -kfs;
      }
    } else {
      luerrm(cmn, 2, "(LUKFDI:) no matching flavours for qq -> qq");
      goto statement_100;
    }
    kf = (100 * kfla + 10 * kflb + 2 * ktabs + 1) * kfs * fem::pow((-1), kfla);
    /// C
    /// C...Reconstruct baryon code.
  } else {
    if (ktab1 >= 7) {
      kfla = kfl3a;
      kflb = kfl1a;
      kflc = kfl1b;
    } else {
      kfla = kfl1a;
      kflb = kfl3a;
      kflc = kfl3b;
    }
    kfld = fem::max(kfla, kflb, kflc);
    kflf = fem::min(kfla, kflb, kflc);
    kfle = kfla + kflb + kflc - kfld - kflf;
    if (ktabs == 0) {
      kf = fem::isign(1000 * kfld + 100 * kflf + 10 * kfle + 2, kfl1);
    }
    if (ktabs >= 1) {
      kf = fem::isign(1000 * kfld + 100 * kfle + 10 * kflf + 2 * ktabs, kfl1);
    }
  }
  /// C
  /// C...Check that constructed flavour code is an allowed one.
  if (kfl2 != 0) {
    kfl3 = 0;
  }
  kc = lucomp(cmn, kf);
  if (kc == 0) {
    luerrm(
        cmn, 2,
        "(LUKFDI:) user-defined flavour probabilities " + str_cref("failed"));
    goto statement_100;
  }
  /// C
}

struct ludecy_save {
  arr<float> wtcor;

  ludecy_save() : wtcor(dimension(10), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void ludecy(common& cmn, int const& ip) {
  FEM_CMN_SVE(ludecy);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_cref<float> brat(cmn.brat, dimension(2000));
  arr_cref<int, 2> kfdp(cmn.kfdp, dimension(2000, 5));
  int& nsav = cmn.nsav;
  ///
  arr_ref<float> wtcor(sve.wtcor, dimension(10));
  if (is_called_first_time) {
    static const float values[] = {2.f,    5.f,    15.f,   60.f,  250.f,
                                   1500.f, 1.2e4f, 1.2e5f, 150.f, 16.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), wtcor;
  }
  float a = fem::float0;
  float b = fem::float0;
  float c = fem::float0;
  int i = fem::int0;
  int j = fem::int0;
  float ha = fem::float0;
  float hrq = fem::float0;
  int ntry = fem::int0;
  int kfa = fem::int0;
  int kfs = fem::int0;
  int kc = fem::int0;
  arr_1d<4, float> vdcy(fem::fill0);
  int mout = fem::int0;
  int kca = fem::int0;
  int mdmdcy = fem::int0;
  int kfsp = fem::int0;
  int kfsn = fem::int0;
  int nope = fem::int0;
  float brsu = fem::float0;
  int idl = fem::int0;
  float rbr = fem::float0;
  int idc = fem::int0;
  int mmat = fem::int0;
  int np = fem::int0;
  int nq = fem::int0;
  int mbst = fem::int0;
  arr_2d<10, 5, float> pv(fem::fill0);
  float ps = fem::float0;
  float psq = fem::float0;
  int mrem = fem::int0;
  int jtmax = fem::int0;
  int jt = fem::int0;
  int kp = fem::int0;
  int kpa = fem::int0;
  int kcp = fem::int0;
  int kfp = fem::int0;
  int kdump = fem::int0;
  int kfpa = fem::int0;
  int kqp = fem::int0;
  arr_1d<4, int> kflo(fem::fill0);
  int kfi = fem::int0;
  int kfldmp = fem::int0;
  float psp = fem::float0;
  float cnde = fem::float0;
  float gauss = fem::float0;
  int nd = fem::int0;
  arr_1d<4, int> kfl1(fem::fill0);
  int kfl2 = fem::int0;
  int jt2 = fem::int0;
  int jt3 = fem::int0;
  float pqt = fem::float0;
  float psmc = fem::float0;
  float hr1 = fem::float0;
  float hr2 = fem::float0;
  float hlq = fem::float0;
  float huq = fem::float0;
  float hw = fem::float0;
  float hqw = fem::float0;
  float hlw = fem::float0;
  float huw = fem::float0;
  float hg = fem::float0;
  float hatl = fem::float0;
  float hm = fem::float0;
  float hmv1 = fem::float0;
  float hmv2 = fem::float0;
  float hsav1 = fem::float0;
  float hsav2 = fem::float0;
  float hmv = fem::float0;
  float hm1 = fem::float0;
  float hatm = fem::float0;
  float hwt1 = fem::float0;
  float hwt2 = fem::float0;
  float hwt3 = fem::float0;
  float hatu = fem::float0;
  float hmp1 = fem::float0;
  float hreg = fem::float0;
  float hacc = fem::float0;
  int nm = fem::int0;
  int msgn = fem::int0;
  int im = fem::int0;
  int kfam = fem::int0;
  int il = fem::int0;
  float wtmax = fem::float0;
  float pmax = fem::float0;
  float pmin = fem::float0;
  float pmes = fem::float0;
  float pmrho2 = fem::float0;
  float pgrho2 = fem::float0;
  float pmst = fem::float0;
  float wt = fem::float0;
  arr_1d<10, float> rord(fem::fill0);
  int il1 = fem::int0;
  float rsav = fem::float0;
  int il2 = fem::int0;
  float pa = fem::float0;
  arr_1d<3, float> ue(fem::fill0);
  float phi = fem::float0;
  arr_1d<3, float> be(fem::fill0);
  float ga = fem::float0;
  float bep = fem::float0;
  float four12 = fem::float0;
  float four13 = fem::float0;
  float four23 = fem::float0;
  float hx1 = fem::float0;
  float hx2 = fem::float0;
  float hx3 = fem::float0;
  int is = fem::int0;
  float pm2 = fem::float0;
  float pm3 = fem::float0;
  int kftemp = fem::int0;
  float pm4 = fem::float0;
  float hb = fem::float0;
  float hc = fem::float0;
  float hd = fem::float0;
  float he = fem::float0;
  float hf = fem::float0;
  float hh = fem::float0;
  float pcor = fem::float0;
  float pmr = fem::float0;
  float pm1 = fem::float0;
  int kfldum = fem::int0;
  int kf1 = fem::int0;
  int kf2 = fem::int0;
  float psm = fem::float0;
  int jcon = fem::int0;
  /// C
  /// C...Purpose: to handle the decay of unstable particles.
  /// Clin-2/18/03 for resonance decay in hadron cascade:
  /// C
  /// C...Functions: momentum in two-particle decays, four-product and
  /// C...matrix element times phase space in weak decays.
  pawt(a, b, c) = fem::sqrt((fem::pow2(a) - fem::pow2((b + c))) *
                            (fem::pow2(a) - fem::pow2((b - c)))) /
                  (2.f * a);
  four(i, j) = p(i, 4) * p(j, 4) - p(i, 1) * p(j, 1) - p(i, 2) * p(j, 2) -
               p(i, 3) * p(j, 3);
  hmeps(ha) = (fem::pow2((1.f - hrq - ha)) + 3.f * ha * (1.f + hrq - ha)) *
              fem::sqrt(fem::pow2((1.f - hrq - ha)) - 4.f * hrq * ha);
  /// C
  /// C...Initial values.
  ntry = 0;
  nsav = n;
  kfa = fem::iabs(k(ip, 2));
  kfs = fem::isign(1, k(ip, 2));
  kc = lucomp(cmn, kfa);
  mstj(92) = 0;
  /// C
  /// C...Choose lifetime and determine decay vertex.
  if (k(ip, 1) == 5) {
    v(ip, 5) = 0.f;
  } else if (k(ip, 1) != 4) {
    v(ip, 5) = -pmas(kc, 4) * fem::log(rlu(cmn, 0));
  }
  FEM_DO_SAFE(j, 1, 4) { vdcy(j) = v(ip, j) + v(ip, 5) * p(ip, j) / p(ip, 5); }
  /// C
  /// C...Determine whether decay allowed or not.
  mout = 0;
  if (mstj(22) == 2) {
    if (pmas(kc, 4) > parj(71)) {
      mout = 1;
    }
  } else if (mstj(22) == 3) {
    if (fem::pow2(vdcy(1)) + fem::pow2(vdcy(2)) + fem::pow2(vdcy(3)) >
        fem::pow2(parj(72))) {
      mout = 1;
    }
  } else if (mstj(22) == 4) {
    if (fem::pow2(vdcy(1)) + fem::pow2(vdcy(2)) > fem::pow2(parj(73))) {
      mout = 1;
    }
    if (fem::abs(vdcy(3)) > parj(74)) {
      mout = 1;
    }
  }
  if (mout == 1 && k(ip, 1) != 5) {
    k(ip, 1) = 4;
    return;
  }
  /// C
  /// C...Check existence of decay channels. Particle/antiparticle rules.
  kca = kc;
  if (mdcy(kc, 2) > 0) {
    mdmdcy = mdme(mdcy(kc, 2), 2);
    if (mdmdcy > 80 && mdmdcy <= 90) {
      kca = mdmdcy;
    }
  }
  if (mdcy(kca, 2) <= 0 || mdcy(kca, 3) <= 0) {
    luerrm(cmn, 9, "(LUDECY:) no decay channel defined");
    return;
  }
  if (fem::mod(kfa / 1000, 10) == 0 && (kca == 85 || kca == 87)) {
    kfs = -kfs;
  }
  if (kchg(kc, 3) == 0) {
    kfsp = 1;
    kfsn = 0;
    if (rlu(cmn, 0) > 0.5f) {
      kfs = -kfs;
    }
  } else if (kfs > 0) {
    kfsp = 1;
    kfsn = 0;
  } else {
    kfsp = 0;
    kfsn = 1;
  }
  /// C
  /// C...Sum branching ratios of allowed decay channels.
  /// Clin  110 NOPE=0
  nope = 0;
  brsu = 0.f;
  FEM_DO_SAFE(idl, mdcy(kca, 2), mdcy(kca, 2) + mdcy(kca, 3) - 1) {
    if (mdme(idl, 1) != 1 && kfsp * mdme(idl, 1) != 2 &&
        kfsn * mdme(idl, 1) != 3) {
      goto statement_120;
    }
    if (mdme(idl, 2) > 100) {
      goto statement_120;
    }
    nope++;
    brsu += brat(idl);
  statement_120:;
  }
  if (nope == 0) {
    luerrm(cmn, 2, "(LUDECY:) all decay channels closed by user");
    return;
  }
/// C
/// C...Select decay channel among allowed ones.
statement_130:
  rbr = brsu * rlu(cmn, 0);
  idl = mdcy(kca, 2) - 1;
statement_140:
  idl++;
  if (mdme(idl, 1) != 1 && kfsp * mdme(idl, 1) != 2 &&
      kfsn * mdme(idl, 1) != 3) {
    if (idl < mdcy(kca, 2) + mdcy(kca, 3) - 1) {
      goto statement_140;
    }
  } else if (mdme(idl, 2) > 100) {
    if (idl < mdcy(kca, 2) + mdcy(kca, 3) - 1) {
      goto statement_140;
    }
  } else {
    idc = idl;
    rbr = rbr - brat(idl);
    if (idl < mdcy(kca, 2) + mdcy(kca, 3) - 1 && rbr > 0.f) {
      goto statement_140;
    }
  }
  /// C
  /// C...Start readout of decay channel: matrix element, reset counters.
  mmat = mdme(idc, 2);
statement_150:
  ntry++;
  if (ntry > 1000) {
    luerrm(cmn, 14, "(LUDECY:) caught in infinite loop");
    if (mstu(21) >= 1) {
      return;
    }
  }
  i = n;
  np = 0;
  nq = 0;
  mbst = 0;
  if (mmat >= 11 && mmat != 46 && p(ip, 4) > 20.f * p(ip, 5)) {
    mbst = 1;
  }
  FEM_DO_SAFE(j, 1, 4) {
    pv(1, j) = 0.f;
    if (mbst == 0) {
      pv(1, j) = p(ip, j);
    }
  }
  if (mbst == 1) {
    pv(1, 4) = p(ip, 5);
  }
  pv(1, 5) = p(ip, 5);
  ps = 0.f;
  psq = 0.f;
  mrem = 0;
  /// C
  /// C...Read out decay products. Convert to standard flavour code.
  jtmax = 5;
  if (mdme(idc + 1, 2) == 101) {
    jtmax = 10;
  }
  FEM_DO_SAFE(jt, 1, jtmax) {
    if (jt <= 5) {
      kp = kfdp(idc, jt);
    }
    if (jt >= 6) {
      kp = kfdp(idc + 1, jt - 5);
    }
    if (kp == 0) {
      goto statement_170;
    }
    kpa = fem::iabs(kp);
    kcp = lucomp(cmn, kpa);
    if (kchg(kcp, 3) == 0 && kpa != 81 && kpa != 82) {
      kfp = kp;
    } else if (kpa != 81 && kpa != 82) {
      kfp = kfs * kp;
    } else if (kpa == 81 && fem::mod(kfa / 1000, 10) == 0) {
      kfp = -kfs * fem::mod(kfa / 10, 10);
    } else if (kpa == 81 && fem::mod(kfa / 100, 10) >= fem::mod(kfa / 10, 10)) {
      kfp = kfs * (100 * fem::mod(kfa / 10, 100) + 3);
    } else if (kpa == 81) {
      kfp = kfs *
            (1000 * fem::mod(kfa / 10, 10) + 100 * fem::mod(kfa / 100, 10) + 1);
    } else if (kp == 82) {
      lukfdi(cmn, -kfs * fem::fint(1.f + (2.f + parj(2)) * rlu(cmn, 0)), 0, kfp,
             kdump);
      if (kfp == 0) {
        goto statement_150;
      }
      mstj(93) = 1;
      if (pv(1, 5) < parj(32) + 2.f * ulmass(cmn, kfp)) {
        goto statement_150;
      }
    } else if (kp == -82) {
      kfp = -kfp;
      if (fem::iabs(kfp) > 10) {
        kfp += fem::isign(10000, kfp);
      }
    }
    if (kpa == 81 || kpa == 82) {
      kcp = lucomp(cmn, kfp);
    }
    /// C
    /// C...Add decay product to event record or to quark flavour list.
    kfpa = fem::iabs(kfp);
    kqp = kchg(kcp, 2);
    if (mmat >= 11 && mmat <= 30 && kqp != 0) {
      nq++;
      kflo(nq) = kfp;
      mstj(93) = 2;
      psq += ulmass(cmn, kflo(nq));
    } else if (mmat >= 42 && mmat <= 43 && np == 3 && fem::mod(nq, 2) == 1) {
      nq = nq - 1;
      ps = ps - p(i, 5);
      k(i, 1) = 1;
      kfi = k(i, 2);
      lukfdi(cmn, kfp, kfi, kfldmp, k(i, 2));
      if (k(i, 2) == 0) {
        goto statement_150;
      }
      mstj(93) = 1;
      p(i, 5) = ulmass(cmn, k(i, 2));
      ps += p(i, 5);
    } else {
      i++;
      np++;
      if (mmat != 33 && kqp != 0) {
        nq++;
      }
      if (mmat == 33 && kqp != 0 && kqp != 2) {
        nq++;
      }
      k(i, 1) = 1 + fem::mod(nq, 2);
      if (mmat == 4 && jt <= 2 && kfp == 21) {
        k(i, 1) = 2;
      }
      if (mmat == 4 && jt == 3) {
        k(i, 1) = 1;
      }
      k(i, 2) = kfp;
      k(i, 3) = ip;
      k(i, 4) = 0;
      k(i, 5) = 0;
      p(i, 5) = ulmass(cmn, kfp);
      if (mmat == 45 && kfpa == 89) {
        p(i, 5) = parj(32);
      }
      ps += p(i, 5);
    }
  statement_170:;
  }
/// C
/// C...Choose decay multiplicity in phase space model.
statement_180:
  if (mmat >= 11 && mmat <= 30) {
    psp = ps;
    cnde =
        parj(61) * fem::log(fem::max((pv(1, 5) - ps - psq) / parj(62), 1.1f));
    if (mmat == 12) {
      cnde += parj(63);
    }
  statement_190:
    ntry++;
    if (ntry > 1000) {
      luerrm(cmn, 14, "(LUDECY:) caught in infinite loop");
      if (mstu(21) >= 1) {
        return;
      }
    }
    if (mmat <= 20) {
      gauss = fem::sqrt(-2.f * cnde * fem::log(fem::max(1e-10f, rlu(cmn, 0)))) *
              fem::sin(paru(2) * rlu(cmn, 0));
      nd = fem::fint(0.5f + 0.5f * np + 0.25f * nq + cnde + gauss);
      if (nd < np + nq / 2 || nd < 2 || nd > 10) {
        goto statement_190;
      }
      if (mmat == 13 && nd == 2) {
        goto statement_190;
      }
      if (mmat == 14 && nd <= 3) {
        goto statement_190;
      }
      if (mmat == 15 && nd <= 4) {
        goto statement_190;
      }
    } else {
      nd = mmat - 20;
    }
    /// C
    /// C...Form hadrons from flavour content.
    FEM_DO_SAFE(jt, 1, 4) { kfl1(jt) = kflo(jt); }
    if (nd == np + nq / 2) {
      goto statement_220;
    }
    FEM_DO_SAFE(i, n + np + 1, n + nd - nq / 2) {
      jt = 1 + fem::fint((nq - 1) * rlu(cmn, 0));
      lukfdi(cmn, kfl1(jt), 0, kfl2, k(i, 2));
      if (k(i, 2) == 0) {
        goto statement_190;
      }
      kfl1(jt) = -kfl2;
    }
  statement_220:
    jt = 2;
    jt2 = 3;
    jt3 = 4;
    if (nq == 4 && rlu(cmn, 0) < parj(66)) {
      jt = 4;
    }
    if (jt == 4 &&
        fem::isign(1, kfl1(1) * (10 - fem::iabs(kfl1(1)))) *
                fem::isign(1, kfl1(jt) * (10 - fem::iabs(kfl1(jt)))) >
            0) {
      jt = 3;
    }
    if (jt == 3) {
      jt2 = 2;
    }
    if (jt == 4) {
      jt3 = 2;
    }
    lukfdi(cmn, kfl1(1), kfl1(jt), kfldmp, k(n + nd - nq / 2 + 1, 2));
    if (k(n + nd - nq / 2 + 1, 2) == 0) {
      goto statement_190;
    }
    if (nq == 4) {
      lukfdi(cmn, kfl1(jt2), kfl1(jt3), kfldmp, k(n + nd, 2));
    }
    if (nq == 4 && k(n + nd, 2) == 0) {
      goto statement_190;
    }
    /// C
    /// C...Check that sum of decay product masses not too large.
    ps = psp;
    FEM_DO_SAFE(i, n + np + 1, n + nd) {
      k(i, 1) = 1;
      k(i, 3) = ip;
      k(i, 4) = 0;
      k(i, 5) = 0;
      p(i, 5) = ulmass(cmn, k(i, 2));
      ps += p(i, 5);
    }
    if (ps + parj(64) > pv(1, 5)) {
      goto statement_190;
    }
    /// C
    /// C...Rescale energy to subtract off spectator quark mass.
  } else if ((mmat == 31 || mmat == 33 || mmat == 44 || mmat == 45) &&
             np >= 3) {
    ps = ps - p(n + np, 5);
    pqt = (p(n + np, 5) + parj(65)) / pv(1, 5);
    FEM_DO_SAFE(j, 1, 5) {
      p(n + np, j) = pqt * pv(1, j);
      pv(1, j) = (1.f - pqt) * pv(1, j);
    }
    if (ps + parj(64) > pv(1, 5)) {
      goto statement_150;
    }
    nd = np - 1;
    mrem = 1;
    /// C
    /// C...Phase space factors imposed in W decay.
  } else if (mmat == 46) {
    mstj(93) = 1;
    psmc = ulmass(cmn, k(n + 1, 2));
    mstj(93) = 1;
    psmc += ulmass(cmn, k(n + 2, 2));
    if (fem::max(ps, psmc) + parj(32) > pv(1, 5)) {
      goto statement_130;
    }
    hr1 = fem::pow2((p(n + 1, 5) / pv(1, 5)));
    hr2 = fem::pow2((p(n + 2, 5) / pv(1, 5)));
    if ((1.f - hr1 - hr2) * (2.f + hr1 + hr2) *
            fem::sqrt(fem::pow2((1.f - hr1 - hr2)) - 4.f * hr1 * hr2) <
        2.f * rlu(cmn, 0)) {
      goto statement_130;
    }
    nd = np;
    /// C
    /// C...Fully specified final state: check mass broadening effects.
  } else {
    if (np >= 2 && ps + parj(64) > pv(1, 5)) {
      goto statement_150;
    }
    nd = np;
  }
  /// C
  /// C...Select W mass in decay Q -> W + q, without W propagator.
  if (mmat == 45 && mstj(25) <= 0) {
    hlq = fem::pow2((parj(32) / pv(1, 5)));
    huq = fem::pow2((1.f - (p(n + 2, 5) + parj(64)) / pv(1, 5)));
    hrq = fem::pow2((p(n + 2, 5) / pv(1, 5)));
  statement_250:
    hw = hlq + rlu(cmn, 0) * (huq - hlq);
    if (hmeps(hw) < rlu(cmn, 0)) {
      goto statement_250;
    }
    p(n + 1, 5) = pv(1, 5) * fem::sqrt(hw);
    /// C
    /// C...Ditto, including W propagator. Divide mass range into three regions.
  } else if (mmat == 45) {
    hqw = fem::pow2((pv(1, 5) / pmas(24, 1)));
    hlw = fem::pow2((parj(32) / pmas(24, 1)));
    huw = fem::pow2(((pv(1, 5) - p(n + 2, 5) - parj(64)) / pmas(24, 1)));
    hrq = fem::pow2((p(n + 2, 5) / pv(1, 5)));
    hg = pmas(24, 2) / pmas(24, 1);
    hatl = fem::atan((hlw - 1.f) / hg);
    hm = fem::min(1.f, huw - 0.001f);
    hmv1 = hmeps(hm / hqw) / (fem::pow2((hm - 1.f)) + fem::pow2(hg));
  statement_260:
    hm = hm - hg;
    hmv2 = hmeps(hm / hqw) / (fem::pow2((hm - 1.f)) + fem::pow2(hg));
    hsav1 = hmeps(hm / hqw);
    hsav2 = 1.f / (fem::pow2((hm - 1.f)) + fem::pow2(hg));
    if (hmv2 > hmv1 && hm - hg > hlw) {
      hmv1 = hmv2;
      goto statement_260;
    }
    hmv = fem::min(2.f * hmv1, hmeps(hm / hqw) / fem::pow2(hg));
    hm1 = 1.f - fem::sqrt(1.f / hmv - fem::pow2(hg));
    if (hm1 > hlw && hm1 < hm) {
      hm = hm1;
    } else if (hmv2 <= hmv1) {
      hm = fem::max(hlw, hm - fem::min(0.1f, 1.f - hm));
    }
    hatm = fem::atan((hm - 1.f) / hg);
    hwt1 = (hatm - hatl) / hg;
    hwt2 = hmv * (fem::min(1.f, huw) - hm);
    hwt3 = 0.f;
    if (huw > 1.f) {
      hatu = fem::atan((huw - 1.f) / hg);
      hmp1 = hmeps(1.f / hqw);
      hwt3 = hmp1 * hatu / hg;
    }
  /// C
  /// C...Select mass region and W mass there. Accept according to weight.
  statement_270:
    hreg = rlu(cmn, 0) * (hwt1 + hwt2 + hwt3);
    if (hreg <= hwt1) {
      hw = 1.f + hg * fem::tan(hatl + rlu(cmn, 0) * (hatm - hatl));
      hacc = hmeps(hw / hqw);
    } else if (hreg <= hwt1 + hwt2) {
      hw = hm + rlu(cmn, 0) * (fem::min(1.f, huw) - hm);
      hacc = hmeps(hw / hqw) / (fem::pow2((hw - 1.f)) + fem::pow2(hg)) / hmv;
    } else {
      hw = 1.f + hg * fem::tan(rlu(cmn, 0) * hatu);
      hacc = hmeps(hw / hqw) / hmp1;
    }
    if (hacc < rlu(cmn, 0)) {
      goto statement_270;
    }
    p(n + 1, 5) = pmas(24, 1) * fem::sqrt(hw);
  }
  /// C
  /// C...Determine position of grandmother, number of sisters, Q -> W sign.
  nm = 0;
  msgn = 0;
  if (mmat == 3 || mmat == 46) {
    im = k(ip, 3);
    if (im < 0 || im >= ip) {
      im = 0;
    }
    if (im != 0) {
      kfam = fem::iabs(k(im, 2));
    }
    if (im != 0 && mmat == 3) {
      FEM_DO_SAFE(il, fem::max(ip - 2, im + 1), fem::min(ip + 2, n)) {
        if (k(il, 3) == im) {
          nm++;
        }
      }
      if (nm != 2 || kfam <= 100 || fem::mod(kfam, 10) != 1 ||
          fem::mod(kfam / 1000, 10) != 0) {
        nm = 0;
      }
    } else if (im != 0 && mmat == 46) {
      msgn = fem::isign(1, k(im, 2) * k(ip, 2));
      if (kfam > 100 && fem::mod(kfam / 1000, 10) == 0) {
        msgn = msgn * fem::pow((-1), fem::mod(kfam / 100, 10));
      }
    }
  }
  /// C
  /// C...Kinematics of one-particle decays.
  if (nd == 1) {
    FEM_DO_SAFE(j, 1, 4) { p(n + 1, j) = p(ip, j); }
    goto statement_510;
  }
  /// C
  /// C...Calculate maximum weight ND-particle decay.
  pv(nd, 5) = p(n + nd, 5);
  if (nd >= 3) {
    wtmax = 1.f / wtcor(nd - 2);
    pmax = pv(1, 5) - ps + p(n + nd, 5);
    pmin = 0.f;
    FEM_DOSTEP(il, nd - 1, 1, -1) {
      pmax += p(n + il, 5);
      pmin += p(n + il + 1, 5);
      wtmax = wtmax * pawt(pmax, pmin, p(n + il, 5));
    }
  }
/// C
/// C...Find virtual gamma mass in Dalitz decay.
statement_310:
  if (nd == 2) {
  } else if (mmat == 2) {
    pmes = 4.f * fem::pow2(pmas(11, 1));
    pmrho2 = fem::pow2(pmas(131, 1));
    pgrho2 = fem::pow2(pmas(131, 2));
  statement_320:
    pmst = pmes * fem::pow((fem::pow2(p(ip, 5)) / pmes), rlu(cmn, 0));
    wt = (1 + 0.5f * pmes / pmst) *
         fem::sqrt(fem::max(0.f, 1.f - pmes / pmst)) *
         fem::pow3((1.f - pmst / fem::pow2(p(ip, 5)))) *
         (1.f + pgrho2 / pmrho2) /
         (fem::pow2((1.f - pmst / pmrho2)) + pgrho2 / pmrho2);
    if (wt < rlu(cmn, 0)) {
      goto statement_320;
    }
    pv(2, 5) = fem::max(2.00001f * pmas(11, 1), fem::sqrt(pmst));
    /// C
    /// C...M-generator gives weight. If rejected, try again.
  } else {
  statement_330:
    rord(1) = 1.f;
    FEM_DO_SAFE(il1, 2, nd - 1) {
      rsav = rlu(cmn, 0);
      FEM_DOSTEP(il2, il1 - 1, 1, -1) {
        if (rsav <= rord(il2)) {
          goto statement_350;
        }
        rord(il2 + 1) = rord(il2);
      }
    statement_350:
      rord(il2 + 1) = rsav;
    }
    rord(nd) = 0.f;
    wt = 1.f;
    FEM_DOSTEP(il, nd - 1, 1, -1) {
      pv(il, 5) = pv(il + 1, 5) + p(n + il, 5) +
                  (rord(il) - rord(il + 1)) * (pv(1, 5) - ps);
      wt = wt * pawt(pv(il, 5), pv(il + 1, 5), p(n + il, 5));
    }
    if (wt < rlu(cmn, 0) * wtmax) {
      goto statement_330;
    }
  }
/// C
/// C...Perform two-particle decays in respective CM frame.
statement_370:
  FEM_DO_SAFE(il, 1, nd - 1) {
    pa = pawt(pv(il, 5), pv(il + 1, 5), p(n + il, 5));
    ue(3) = 2.f * rlu(cmn, 0) - 1.f;
    phi = paru(2) * rlu(cmn, 0);
    ue(1) = fem::sqrt(1.f - fem::pow2(ue(3))) * fem::cos(phi);
    ue(2) = fem::sqrt(1.f - fem::pow2(ue(3))) * fem::sin(phi);
    FEM_DO_SAFE(j, 1, 3) {
      p(n + il, j) = pa * ue(j);
      pv(il + 1, j) = -pa * ue(j);
    }
    p(n + il, 4) = fem::sqrt(fem::pow2(pa) + fem::pow2(p(n + il, 5)));
    pv(il + 1, 4) = fem::sqrt(fem::pow2(pa) + fem::pow2(pv(il + 1, 5)));
  }
  /// C
  /// C...Lorentz transform decay products to lab frame.
  FEM_DO_SAFE(j, 1, 4) { p(n + nd, j) = pv(nd, j); }
  FEM_DOSTEP(il, nd - 1, 1, -1) {
    FEM_DO_SAFE(j, 1, 3) { be(j) = pv(il, j) / pv(il, 4); }
    ga = pv(il, 4) / pv(il, 5);
    FEM_DO_SAFE(i, n + il, n + nd) {
      bep = be(1) * p(i, 1) + be(2) * p(i, 2) + be(3) * p(i, 3);
      FEM_DO_SAFE(j, 1, 3) {
        p(i, j) += ga * (ga * bep / (1.f + ga) + p(i, 4)) * be(j);
      }
      p(i, 4) = ga * (p(i, 4) + bep);
    }
  }
  /// C
  /// C...Matrix elements for omega and phi decays.
  if (mmat == 1) {
    wt = fem::pow2((p(n + 1, 5) * p(n + 2, 5) * p(n + 3, 5))) -
         fem::pow2((p(n + 1, 5) * four(n + 2, n + 3))) -
         fem::pow2((p(n + 2, 5) * four(n + 1, n + 3))) -
         fem::pow2((p(n + 3, 5) * four(n + 1, n + 2))) +
         2.f * four(n + 1, n + 2) * four(n + 1, n + 3) * four(n + 2, n + 3);
    if (fem::max(wt * wtcor(9) / fem::pow(p(ip, 5), 6), 0.001f) < rlu(cmn, 0)) {
      goto statement_310;
    }
    /// C
    /// C...Matrix elements for pi0 or eta Dalitz decay to gamma e+ e-.
  } else if (mmat == 2) {
    four12 = four(n + 1, n + 2);
    four13 = four(n + 1, n + 3);
    four23 = 0.5f * pmst - 0.25f * pmes;
    wt = (pmst - 0.5f * pmes) * (fem::pow2(four12) + fem::pow2(four13)) +
         pmes * (four12 * four13 + fem::pow2(four12) + fem::pow2(four13));
    if (wt <
        rlu(cmn, 0) * 0.25f * pmst * fem::pow2((fem::pow2(p(ip, 5)) - pmst))) {
      goto statement_370;
    }
    /// C
    /// C...Matrix element for S0 -> S1 + V1 -> S1 + S2 + S3 (S scalar,
    /// C...V vector), of form cos**2(theta02) in V1 rest frame.
  } else if (mmat == 3 && nm == 2) {
    if (fem::pow2((fem::pow2(p(ip, 5)) * four(im, n + 1) -
                   four(ip, im) * four(ip, n + 1))) <=
        rlu(cmn, 0) *
            (fem::pow2(four(ip, im)) - fem::pow2((p(ip, 5) * p(im, 5)))) *
            (fem::pow2(four(ip, n + 1)) -
             fem::pow2((p(ip, 5) * p(n + 1, 5))))) {
      goto statement_370;
    }
    /// C
    /// C...Matrix element for "onium" -> g + g + g or gamma + g + g.
  } else if (mmat == 4) {
    hx1 = 2.f * four(ip, n + 1) / fem::pow2(p(ip, 5));
    hx2 = 2.f * four(ip, n + 2) / fem::pow2(p(ip, 5));
    hx3 = 2.f * four(ip, n + 3) / fem::pow2(p(ip, 5));
    wt = fem::pow2(((1.f - hx1) / (hx2 * hx3))) +
         fem::pow2(((1.f - hx2) / (hx1 * hx3))) +
         fem::pow2(((1.f - hx3) / (hx1 * hx2)));
    if (wt < 2.f * rlu(cmn, 0)) {
      goto statement_310;
    }
    if (k(ip + 1, 2) == 22 &&
        (1.f - hx1) * fem::pow2(p(ip, 5)) < 4.f * fem::pow2(parj(32))) {
      goto statement_310;
    }
    /// C
    /// C...Effective matrix element for nu spectrum in tau -> nu + hadrons.
  } else if (mmat == 41) {
    hx1 = 2.f * four(ip, n + 1) / fem::pow2(p(ip, 5));
    if (8.f * hx1 * (3.f - 2.f * hx1) / 9.f < rlu(cmn, 0)) {
      goto statement_310;
    }
    /// C
    /// C...Matrix elements for weak decays (only semileptonic for c and b)
  } else if (mmat >= 42 && mmat <= 44 && nd == 3) {
    if (mbst == 0) {
      wt = four(ip, n + 1) * four(n + 2, n + 3);
    }
    if (mbst == 1) {
      wt = p(ip, 5) * p(n + 1, 4) * four(n + 2, n + 3);
    }
    if (wt < rlu(cmn, 0) * p(ip, 5) * fem::pow3(pv(1, 5)) / wtcor(10)) {
      goto statement_310;
    }
  } else if (mmat >= 42 && mmat <= 44) {
    FEM_DO_SAFE(j, 1, 4) {
      p(n + np + 1, j) = 0.f;
      FEM_DO_SAFE(is, n + 3, n + np) { p(n + np + 1, j) += p(is, j); }
    }
    if (mbst == 0) {
      wt = four(ip, n + 1) * four(n + 2, n + np + 1);
    }
    if (mbst == 1) {
      wt = p(ip, 5) * p(n + 1, 4) * four(n + 2, n + np + 1);
    }
    if (wt < rlu(cmn, 0) * p(ip, 5) * fem::pow3(pv(1, 5)) / wtcor(10)) {
      goto statement_310;
    }
    /// C
    /// C...Angular distribution in W decay.
  } else if (mmat == 46 && msgn != 0) {
    if (msgn > 0) {
      wt = four(im, n + 1) * four(n + 2, ip + 1);
    }
    if (msgn < 0) {
      wt = four(im, n + 2) * four(n + 1, ip + 1);
    }
    if (wt < rlu(cmn, 0) * fem::pow4(p(im, 5)) / wtcor(10)) {
      goto statement_370;
    }
  }
  /// C
  /// C...Scale back energy and reattach spectator.
  if (mrem == 1) {
    FEM_DO_SAFE(j, 1, 5) { pv(1, j) = pv(1, j) / (1.f - pqt); }
    nd++;
    mrem = 0;
  }
  /// C
  /// C...Low invariant mass for system with spectator quark gives particle,
  /// C...not two jets. Readjust momenta accordingly.
  if ((mmat == 31 || mmat == 45) && nd == 3) {
    mstj(93) = 1;
    pm2 = ulmass(cmn, k(n + 2, 2));
    mstj(93) = 1;
    pm3 = ulmass(cmn, k(n + 3, 2));
    if (fem::pow2(p(n + 2, 5)) + fem::pow2(p(n + 3, 5)) +
            2.f * four(n + 2, n + 3) >=
        fem::pow2((parj(32) + pm2 + pm3))) {
      goto statement_510;
    }
    k(n + 2, 1) = 1;
    kftemp = k(n + 2, 2);
    lukfdi(cmn, kftemp, k(n + 3, 2), kfldmp, k(n + 2, 2));
    if (k(n + 2, 2) == 0) {
      goto statement_150;
    }
    p(n + 2, 5) = ulmass(cmn, k(n + 2, 2));
    ps = p(n + 1, 5) + p(n + 2, 5);
    pv(2, 5) = p(n + 2, 5);
    mmat = 0;
    nd = 2;
    goto statement_370;
  } else if (mmat == 44) {
    mstj(93) = 1;
    pm3 = ulmass(cmn, k(n + 3, 2));
    mstj(93) = 1;
    pm4 = ulmass(cmn, k(n + 4, 2));
    if (fem::pow2(p(n + 3, 5)) + fem::pow2(p(n + 4, 5)) +
            2.f * four(n + 3, n + 4) >=
        fem::pow2((parj(32) + pm3 + pm4))) {
      goto statement_480;
    }
    k(n + 3, 1) = 1;
    kftemp = k(n + 3, 2);
    lukfdi(cmn, kftemp, k(n + 4, 2), kfldmp, k(n + 3, 2));
    if (k(n + 3, 2) == 0) {
      goto statement_150;
    }
    p(n + 3, 5) = ulmass(cmn, k(n + 3, 2));
    FEM_DO_SAFE(j, 1, 3) { p(n + 3, j) += p(n + 4, j); }
    p(n + 3, 4) = fem::sqrt(fem::pow2(p(n + 3, 1)) + fem::pow2(p(n + 3, 2)) +
                            fem::pow2(p(n + 3, 3)) + fem::pow2(p(n + 3, 5)));
    ha = fem::pow2(p(n + 1, 4)) - fem::pow2(p(n + 2, 4));
    hb = ha - (fem::pow2(p(n + 1, 5)) - fem::pow2(p(n + 2, 5)));
    hc = fem::pow2((p(n + 1, 1) - p(n + 2, 1))) +
         fem::pow2((p(n + 1, 2) - p(n + 2, 2))) +
         fem::pow2((p(n + 1, 3) - p(n + 2, 3)));
    hd = fem::pow2((pv(1, 4) - p(n + 3, 4)));
    he = fem::pow2(ha) -
         2.f * hd * (fem::pow2(p(n + 1, 4)) + fem::pow2(p(n + 2, 4))) +
         fem::pow2(hd);
    hf = hd * hc - fem::pow2(hb);
    hg = hd * hc - ha * hb;
    hh = (fem::sqrt(fem::pow2(hg) + he * hf) - hg) / (2.f * hf);
    FEM_DO_SAFE(j, 1, 3) {
      pcor = hh * (p(n + 1, j) - p(n + 2, j));
      p(n + 1, j) += pcor;
      p(n + 2, j) = p(n + 2, j) - pcor;
    }
    p(n + 1, 4) = fem::sqrt(fem::pow2(p(n + 1, 1)) + fem::pow2(p(n + 1, 2)) +
                            fem::pow2(p(n + 1, 3)) + fem::pow2(p(n + 1, 5)));
    p(n + 2, 4) = fem::sqrt(fem::pow2(p(n + 2, 1)) + fem::pow2(p(n + 2, 2)) +
                            fem::pow2(p(n + 2, 3)) + fem::pow2(p(n + 2, 5)));
    nd = nd - 1;
  }
/// C
/// C...Check invariant mass of W jets. May give one particle or start over.
statement_480:
  if (mmat >= 42 && mmat <= 44 && fem::iabs(k(n + 1, 2)) < 10) {
    pmr = fem::sqrt(fem::max(0.f, fem::pow2(p(n + 1, 5)) +
                                      fem::pow2(p(n + 2, 5)) +
                                      2.f * four(n + 1, n + 2)));
    mstj(93) = 1;
    pm1 = ulmass(cmn, k(n + 1, 2));
    mstj(93) = 1;
    pm2 = ulmass(cmn, k(n + 2, 2));
    if (pmr > parj(32) + pm1 + pm2) {
      goto statement_490;
    }
    kfldum = fem::fint(1.5f + rlu(cmn, 0));
    lukfdi(cmn, k(n + 1, 2), -fem::isign(kfldum, k(n + 1, 2)), kfldmp, kf1);
    lukfdi(cmn, k(n + 2, 2), -fem::isign(kfldum, k(n + 2, 2)), kfldmp, kf2);
    if (kf1 == 0 || kf2 == 0) {
      goto statement_150;
    }
    psm = ulmass(cmn, kf1) + ulmass(cmn, kf2);
    if (mmat == 42 && pmr > parj(64) + psm) {
      goto statement_490;
    }
    if (mmat >= 43 && pmr > 0.2f * parj(32) + psm) {
      goto statement_490;
    }
    if (nd == 4 || kfa == 15) {
      goto statement_150;
    }
    k(n + 1, 1) = 1;
    kftemp = k(n + 1, 2);
    lukfdi(cmn, kftemp, k(n + 2, 2), kfldmp, k(n + 1, 2));
    if (k(n + 1, 2) == 0) {
      goto statement_150;
    }
    p(n + 1, 5) = ulmass(cmn, k(n + 1, 2));
    k(n + 2, 2) = k(n + 3, 2);
    p(n + 2, 5) = p(n + 3, 5);
    ps = p(n + 1, 5) + p(n + 2, 5);
    pv(2, 5) = p(n + 3, 5);
    mmat = 0;
    nd = 2;
    goto statement_370;
  }
/// C
/// C...Phase space decay of partons from W decay.
statement_490:
  if (mmat == 42 && fem::iabs(k(n + 1, 2)) < 10) {
    kflo(1) = k(n + 1, 2);
    kflo(2) = k(n + 2, 2);
    k(n + 1, 1) = k(n + 3, 1);
    k(n + 1, 2) = k(n + 3, 2);
    FEM_DO_SAFE(j, 1, 5) {
      pv(1, j) = p(n + 1, j) + p(n + 2, j);
      p(n + 1, j) = p(n + 3, j);
    }
    pv(1, 5) = pmr;
    n++;
    np = 0;
    nq = 2;
    ps = 0.f;
    mstj(93) = 2;
    psq = ulmass(cmn, kflo(1));
    mstj(93) = 2;
    psq += ulmass(cmn, kflo(2));
    mmat = 11;
    goto statement_180;
  }
/// C
/// C...Boost back for rapidly moving particle.
statement_510:
  n += nd;
  if (mbst == 1) {
    FEM_DO_SAFE(j, 1, 3) { be(j) = p(ip, j) / p(ip, 4); }
    ga = p(ip, 4) / p(ip, 5);
    FEM_DO_SAFE(i, nsav + 1, n) {
      bep = be(1) * p(i, 1) + be(2) * p(i, 2) + be(3) * p(i, 3);
      FEM_DO_SAFE(j, 1, 3) {
        p(i, j) += ga * (ga * bep / (1.f + ga) + p(i, 4)) * be(j);
      }
      p(i, 4) = ga * (p(i, 4) + bep);
    }
  }
  /// C
  /// C...Fill in position of decay vertex.
  FEM_DO_SAFE(i, nsav + 1, n) {
    FEM_DO_SAFE(j, 1, 4) { v(i, j) = vdcy(j); }
    v(i, 5) = 0.f;
  }
  /// C
  /// C...Set up for parton shower evolution from jets.
  if (mstj(23) >= 1 && mmat == 4 && k(nsav + 1, 2) == 21) {
    k(nsav + 1, 1) = 3;
    k(nsav + 2, 1) = 3;
    k(nsav + 3, 1) = 3;
    k(nsav + 1, 4) = mstu(5) * (nsav + 2);
    k(nsav + 1, 5) = mstu(5) * (nsav + 3);
    k(nsav + 2, 4) = mstu(5) * (nsav + 3);
    k(nsav + 2, 5) = mstu(5) * (nsav + 1);
    k(nsav + 3, 4) = mstu(5) * (nsav + 1);
    k(nsav + 3, 5) = mstu(5) * (nsav + 2);
    mstj(92) = -(nsav + 1);
  } else if (mstj(23) >= 1 && mmat == 4) {
    k(nsav + 2, 1) = 3;
    k(nsav + 3, 1) = 3;
    k(nsav + 2, 4) = mstu(5) * (nsav + 3);
    k(nsav + 2, 5) = mstu(5) * (nsav + 3);
    k(nsav + 3, 4) = mstu(5) * (nsav + 2);
    k(nsav + 3, 5) = mstu(5) * (nsav + 2);
    mstj(92) = nsav + 2;
  } else if (mstj(23) >= 1 && (mmat == 32 || mmat == 44 || mmat == 46) &&
             fem::iabs(k(nsav + 1, 2)) <= 10 &&
             fem::iabs(k(nsav + 2, 2)) <= 10) {
    k(nsav + 1, 1) = 3;
    k(nsav + 2, 1) = 3;
    k(nsav + 1, 4) = mstu(5) * (nsav + 2);
    k(nsav + 1, 5) = mstu(5) * (nsav + 2);
    k(nsav + 2, 4) = mstu(5) * (nsav + 1);
    k(nsav + 2, 5) = mstu(5) * (nsav + 1);
    mstj(92) = nsav + 1;
  } else if (mstj(23) >= 1 && mmat == 33 && fem::iabs(k(nsav + 2, 2)) == 21) {
    k(nsav + 1, 1) = 3;
    k(nsav + 2, 1) = 3;
    k(nsav + 3, 1) = 3;
    kcp = lucomp(cmn, k(nsav + 1, 2));
    kqp = kchg(kcp, 2) * fem::isign(1, k(nsav + 1, 2));
    jcon = 4;
    if (kqp < 0) {
      jcon = 5;
    }
    k(nsav + 1, jcon) = mstu(5) * (nsav + 2);
    k(nsav + 2, 9 - jcon) = mstu(5) * (nsav + 1);
    k(nsav + 2, jcon) = mstu(5) * (nsav + 3);
    k(nsav + 3, 9 - jcon) = mstu(5) * (nsav + 2);
    mstj(92) = nsav + 1;
  } else if (mstj(23) >= 1 && mmat == 33) {
    k(nsav + 1, 1) = 3;
    k(nsav + 3, 1) = 3;
    k(nsav + 1, 4) = mstu(5) * (nsav + 3);
    k(nsav + 1, 5) = mstu(5) * (nsav + 3);
    k(nsav + 3, 4) = mstu(5) * (nsav + 1);
    k(nsav + 3, 5) = mstu(5) * (nsav + 1);
    mstj(92) = nsav + 1;
  }
  /// C
  /// C...Mark decayed particle.
  if (k(ip, 1) == 5) {
    k(ip, 1) = 15;
  }
  if (k(ip, 1) <= 10) {
    k(ip, 1) = 11;
  }
  k(ip, 4) = nsav + 1;
  k(ip, 5) = n;
  /// C
}

struct resdec_save {
  float dpdecp;
  float enet;
  float esave;
  int idau;
  int ip;
  int irun;
  int kdaut;
  int kf;
  int ksave;
  int lbdaut;
  int ndaut;
  float pxsave;
  float pysave;
  float pzsave;
  float tau0;
  float taudcy;
  float xmsave;

  resdec_save()
      : dpdecp(fem::float0),
        enet(fem::float0),
        esave(fem::float0),
        idau(fem::int0),
        ip(fem::int0),
        irun(fem::int0),
        kdaut(fem::int0),
        kf(fem::int0),
        ksave(fem::int0),
        lbdaut(fem::int0),
        ndaut(fem::int0),
        pxsave(fem::float0),
        pysave(fem::float0),
        pzsave(fem::float0),
        tau0(fem::float0),
        taudcy(fem::float0),
        xmsave(fem::float0) {}
};

/// C
/// C=======================================================================
/// C     2/18/03 use PYTHIA to decay eta,rho,omega,k*,phi and Delta
/// C     4/2012 added pi0 decay flag:
/// C       ipion=0: resonance or pi0 in lb(i1); >0: pi0 in lpion(ipion).
void resdec(common& cmn, int const& i1, int const& nt, int& nnn,
            float const& wid, int const& idecay, int const& ipion) {
  FEM_CMN_SVE(resdec);
  common_write write(cmn);
  int& ntmax = cmn.ntmax;
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  const int maxstr = 150001;
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  const int maxr = 1;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  int& nsav = cmn.nsav;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  int& nseed = cmn.nseed;
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  int& ipi0dcy = cmn.ipi0dcy;
  ///
  float& dpdecp = sve.dpdecp;
  float& enet = sve.enet;
  float& esave = sve.esave;
  int& idau = sve.idau;
  int& ip = sve.ip;
  int& irun = sve.irun;
  int& kdaut = sve.kdaut;
  int& kf = sve.kf;
  int& ksave = sve.ksave;
  int& lbdaut = sve.lbdaut;
  int& ndaut = sve.ndaut;
  float& pxsave = sve.pxsave;
  float& pysave = sve.pysave;
  float& pzsave = sve.pzsave;
  float& tau0 = sve.tau0;
  float& taudcy = sve.taudcy;
  float& xmsave = sve.xmsave;
  const float apich = 0.140f;
  const float api0 = 0.135f;
  const float addm = 0.02f;
  const float ak0 = 0.498f;
  const float an = 0.940f;
  const float hbarc = 0.19733f;
  /// C
  /// Cc      SAVE /INPUT2/
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /LUDAT1/
  /// Cc      SAVE /LUDAT2/
  /// Cc      SAVE /LUDAT3/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /resdcy/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /tdecay/
  /// Cc      SAVE /RNDF77/
  irun = idecay;
  /// Clin-4/2012 for option of pi0 decay:
  if (nt == ntmax && ipi0dcy == 1 && ((lb1 == 4 && ipion == 0) || ipion >= 1)) {
    kf = 111;
    /// C        if(lb1.eq.0.or.lb1.eq.25.or.lb1.eq.26.or.lb1.eq.27
  } else if (lb1 == 0 || lb1 == 25 || lb1 == 26 || lb1 == 27 || lb1 == 28 ||
             lb1 == 29 || fem::iabs(lb1) == 30 || lb1 == 24 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) ||
             fem::iabs(lb1) == 16) {
    kf = invflv(cmn, lb1);
  } else {
    return;
  }
  /// C
  ip = 1;
  /// C     label as undecayed and the only particle in the record:
  n = 1;
  k(ip, 1) = 1;
  k(ip, 3) = 0;
  k(ip, 4) = 0;
  k(ip, 5) = 0;
  /// C
  k(ip, 2) = kf;
  /// Clin-4/2012 for option of pi0 decay:
  if (ipion == 0) {
    /// C
    p(ip, 1) = px1;
    p(ip, 2) = py1;
    p(ip, 3) = pz1;
    /// C        em1a=em1
    /// C     eta or omega in ART may be below or too close to (pi+pi-pi0) mass,
    /// C     causing LUDECY error,thus increase their mass ADDM above this
    /// thresh, C     noting that rho (m=0.281) too close to 2pi thrshold fails
    /// to decay:
    if ((lb1 == 0 || lb1 == 28) && em1 < (2 * apich + api0 + addm)) {
      em1 = 2 * apich + api0 + addm;
      /// C     rho
    } else if (lb1 >= 25 && lb1 <= 27 && em1 < (2 * apich + addm)) {
      em1 = 2 * apich + addm;
      /// C     K*
    } else if (fem::iabs(lb1) == 30 && em1 < (apich + ak0 + addm)) {
      em1 = apich + ak0 + addm;
      /// C     Delta created in ART may be below (n+pich) mass, causing LUDECY
      /// error:
    } else if (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9 &&
               em1 < (apich + an + addm)) {
      em1 = apich + an + addm;
    }
    /// C        if(em1.ge.(em1a+0.01)) write (6,*)
    /// C     1       'Mass increase in resdec():',nt,em1-em1a,lb1
    e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                   fem::pow2(pz1));
    p(ip, 4) = e1;
    p(ip, 5) = em1;
    /// Clin-5/2008:
    dpdecp = dpertp(i1);
    /// Clin-4/2012 for option of pi0 decay:
  } else if (nt == ntmax && ipi0dcy == 1 && ipion >= 1) {
    p(ip, 1) = ppion(1, ipion, irun);
    p(ip, 2) = ppion(2, ipion, irun);
    p(ip, 3) = ppion(3, ipion, irun);
    p(ip, 5) = epion(ipion, irun);
    p(ip, 4) = fem::sqrt(fem::pow2(p(ip, 5)) + fem::pow2(p(ip, 1)) +
                         fem::pow2(p(ip, 2)) + fem::pow2(p(ip, 3)));
    dpdecp = dppion(ipion, irun);
    /// Ctest off
    /// C           write(99,*) P(IP,4), P(IP,5), dpdecp, ipion, wid
  } else {
    write(6, star), "stopped in resdec() a";
    FEM_STOP(0);
  }
  /// C
  ludecy(cmn, ip);
  /// C     add decay time to daughter's formation time at the last timestep:
  if (nt == ntmax) {
    tau0 = hbarc / wid;
    taudcy = tau0 * (-1.f) * fem::alog(1.f - ranart(nseed));
    ndaut = n - nsav;
    if (ndaut <= 1) {
      write(10, star), "note: ndaut(<1)=", ndaut;
      lulist(cmn, 2);
      FEM_STOP(0);
    }
    /// C     lorentz boost:
    /// Clin-4/2012 for option of pi0 decay:
    if (ipion == 0) {
      taudcy = taudcy * e1 / em1;
      tfnl += taudcy;
      xfnl += px1 / e1 * taudcy;
      yfnl += py1 / e1 * taudcy;
      zfnl += pz1 / e1 * taudcy;
    } else if (ipion >= 1) {
      taudcy = taudcy * p(ip, 4) / p(ip, 5);
      tfnl = tfdpi(ipion, irun) + taudcy;
      xfnl = rpion(1, ipion, irun) + p(ip, 1) / p(ip, 4) * taudcy;
      yfnl = rpion(2, ipion, irun) + p(ip, 2) / p(ip, 4) * taudcy;
      zfnl = rpion(3, ipion, irun) + p(ip, 3) / p(ip, 4) * taudcy;
    } else {
      write(6, star), "stopped in resdec() b", ipion, wid, p(ip, 4);
      FEM_STOP(0);
    }
    /// C     at the last timestep, assign rho, K0S or eta (decay daughter)
    /// C     to lb(i1) only (not to lpion) in order to decay them again:
    /// Clin-4/2012 for option of pi0 decay:
    /// C           if(n.ge.(nsav+2)) then
    if (n >= (nsav + 2) && ipion == 0) {
      FEM_DO_SAFE(idau, nsav + 2, n) {
        kdaut = k(idau, 2);
        if (kdaut == 221 || kdaut == 113 || kdaut == 213 || kdaut == -213 ||
            kdaut == 310) {
          /// C     switch idau and i1(nsav+1):
          ksave = kdaut;
          pxsave = p(idau, 1);
          pysave = p(idau, 2);
          pzsave = p(idau, 3);
          esave = p(idau, 4);
          xmsave = p(idau, 5);
          k(idau, 2) = k(nsav + 1, 2);
          p(idau, 1) = p(nsav + 1, 1);
          p(idau, 2) = p(nsav + 1, 2);
          p(idau, 3) = p(nsav + 1, 3);
          p(idau, 4) = p(nsav + 1, 4);
          p(idau, 5) = p(nsav + 1, 5);
          k(nsav + 1, 2) = ksave;
          p(nsav + 1, 1) = pxsave;
          p(nsav + 1, 2) = pysave;
          p(nsav + 1, 3) = pzsave;
          p(nsav + 1, 4) = esave;
          p(nsav + 1, 5) = xmsave;
          /// C     note: phi decay may produce rho, K0s or eta, N*(1535) decay
          /// may produce C     eta, but only one daughter may be rho, K0s or
          /// eta:
          goto statement_111;
        }
      }
    }
  statement_111:
    /// C
    enet = 0.f;
    FEM_DO_SAFE(idau, nsav + 1, n) { enet += p(idau, 4); }
    /// C           if(abs(enet-e1).gt.0.02)
    /// C     1          write(93,*) 'resdec(): nt=',nt,enet-e1,lb1
  }
  /// C
  FEM_DO_SAFE(idau, nsav + 1, n) {
    kdaut = k(idau, 2);
    lbdaut = iarflv(cmn, kdaut);
    /// C     K0S and K0L are named K+/K- during hadron cascade, and only
    /// C     at the last timestep they keep their real LB # before output;
    /// C     K0/K0bar (from K* decay) converted to K0S and K0L at the last
    /// timestep:
    if (nt == ntmax &&
        (kdaut == 130 || kdaut == 310 || fem::iabs(kdaut) == 311)) {
      if (kdaut == 130) {
        lbdaut = 22;
      } else if (kdaut == 310) {
        lbdaut = 24;
      } else if (fem::iabs(kdaut) == 311) {
        if (ranart(nseed) < 0.5f) {
          lbdaut = 22;
        } else {
          lbdaut = 24;
        }
      }
    }
    /// C
    if (idau == (nsav + 1)) {
      /// Clin-4/2012 for option of pi0 decay:
      if (ipion == 0) {
        lb(i1) = lbdaut;
        e(i1) = p(idau, 5);
        cmn.px1n = p(idau, 1);
        cmn.py1n = p(idau, 2);
        cmn.pz1n = p(idau, 3);
        /// Clin-5/2008:
        cmn.dp1n = dpdecp;
      } else if (ipion >= 1) {
        lpion(ipion, irun) = lbdaut;
        epion(ipion, irun) = p(idau, 5);
        ppion(1, ipion, irun) = p(idau, 1);
        ppion(2, ipion, irun) = p(idau, 2);
        ppion(3, ipion, irun) = p(idau, 3);
        rpion(1, ipion, irun) = xfnl;
        rpion(2, ipion, irun) = yfnl;
        rpion(3, ipion, irun) = zfnl;
        tfdpi(ipion, irun) = tfnl;
        dppion(ipion, irun) = dpdecp;
      }
      /// C
    } else {
      nnn++;
      lpion(nnn, irun) = lbdaut;
      epion(nnn, irun) = p(idau, 5);
      ppion(1, nnn, irun) = p(idau, 1);
      ppion(2, nnn, irun) = p(idau, 2);
      ppion(3, nnn, irun) = p(idau, 3);
      rpion(1, nnn, irun) = xfnl;
      rpion(2, nnn, irun) = yfnl;
      rpion(3, nnn, irun) = zfnl;
      tfdpi(nnn, irun) = tfnl;
      /// Clin-5/2008:
      dppion(nnn, irun) = dpdecp;
    }
  }
}

/// C
/// C=======================================================================
void inidcy(common& cmn) {
  /// COMMON lujets
  int& n = static_cast<common_lujets&>(cmn).n;
  ///
  /// C
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /resdcy/
  n = 1;
  cmn.nsav = n;
}

struct relcol_save {
  static const int maxstr = 150001;
  static const int maxr = 1;

  float am1;
  float am2;
  float bmass;
  float brel;
  float brsgm;
  float brsig;
  float cutoff;
  float deltar;
  float deltr0;
  float deltre;
  arr<float> dptemp;
  float dr0max;
  float drmax;
  float ds;
  float dse;
  float dshn;
  float dshnr;
  float dskk;
  float dskk0;
  float dskn;
  float dsknr;
  float dspert;
  float dspp;
  float dsppb;
  float dsppbr;
  float dsppr;
  float dsr;
  float dsrpert;
  float e1cm;
  float e2;
  float e2cm;
  float ec;
  float ec0;
  float ece;
  float eini;
  float em1i;
  float em2i;
  float emm1;
  float emm2;
  float er1;
  float er2;
  float ert;
  arr<float> et;
  arr<float, 2> ftpisv;
  arr<float> fttemp;
  float gfactr;
  int i;
  int i0;
  int i1;
  int i2;
  int ia;
  int ianti;
  int ib;
  int iblock;
  int ic;
  int icase;
  int ichann;
  int icheck;
  int icontp;
  int ictrl;
  int id1;
  int id2;
  int idecay;
  int ie;
  int ifirst;
  int ig;
  int ikk;
  int ikkg;
  int ikkl;
  int ikmp;
  int il;
  int ilb1;
  int ilb2;
  int im;
  int in;
  int inewka;
  int ipdflag;
  int ipert1;
  int ipion;
  int ipp;
  int ipx1;
  int ipx2;
  int ipy1;
  int ipy2;
  int ipz1;
  int ipz2;
  int irun;
  int is;
  int iss;
  int ix1;
  int ix2;
  int iy1;
  int iy2;
  int iz1;
  int iz2;
  int j;
  int j1;
  int j10;
  int j2;
  int kp;
  int lb1i;
  int lb2i;
  int lbm;
  int lbp1;
  int lbp2;
  int lomgar;
  int lpdr;
  int lrhor;
  arr<int> lt;
  int mass;
  arr<int> massrn;
  int msum;
  int n;
  int n0;
  int nchrg;
  int nnnini;
  int nodelt;
  int ntag;
  float p1beta;
  float pcx;
  float pcy;
  float pcz;
  float pdecay;
  float pfinal;
  float pk0;
  float pkaon;
  float pnstar;
  float ppel;
  float ppin;
  float ppink;
  float ppsig;
  arr<float> prot;
  arr<float, 2> pt;
  float pt1i1;
  float pt1i2;
  float pt2i1;
  float pt2i2;
  float pt3i1;
  float pt3i2;
  float px1cm;
  float px1i;
  float px2;
  float px2i;
  float pxini;
  float py1cm;
  float py1i;
  float py2;
  float py2i;
  float pyini;
  float pz1cm;
  float pz1i;
  float pz2;
  float pz2i;
  float pzini;
  float pzrt;
  float resona;
  float rhomp;
  float rppmax;
  float rsqare;
  arr<float, 2> rt;
  float sdb;
  float sdm;
  float sdprod;
  float sig;
  float sigela;
  float sigk;
  float sigkp;
  float siglab;
  float sigma0;
  float signn;
  float signn0;
  float sigp;
  float sigphi;
  float sigr0;
  float sigsgm;
  float spika;
  float spipi;
  float spprho;
  float srt;
  float sumsrt;
  float t0;
  float transf;
  float wid;
  float x1;
  float x2;
  float xdecay;
  float xdirct;
  float xelstc;
  float xeta;
  float xinel;
  float xkaon;
  float xkaon0;
  float xky1;
  float xky10;
  float xky11;
  float xky12;
  float xky13;
  float xky14;
  float xky15;
  float xky16;
  float xky17;
  float xky2;
  float xky3;
  float xky4;
  float xky5;
  float xky6;
  float xky7;
  float xky8;
  float xky9;
  float xmax;
  float xmaxn;
  float xmaxn1;
  float xmm;
  float xnelas;
  float xnpid;
  float xnpin;
  float xnpin1;
  float xphi;
  float xphin;
  float xreab;
  float xres;
  float xsk1;
  float xsk2;
  float xsk3;
  float xsk4;
  float xsk5;
  float xsk6;
  float xsk7;
  float xx;
  float xx0;
  float y1;
  float y2;
  float yy;
  float z1;
  float z2;
  arr<float> zet;

  relcol_save()
      : am1(fem::float0),
        am2(fem::float0),
        bmass(fem::float0),
        brel(fem::float0),
        brsgm(fem::float0),
        brsig(fem::float0),
        cutoff(fem::float0),
        deltar(fem::float0),
        deltr0(fem::float0),
        deltre(fem::float0),
        dptemp(dimension(maxstr), fem::fill0),
        dr0max(fem::float0),
        drmax(fem::float0),
        ds(fem::float0),
        dse(fem::float0),
        dshn(fem::float0),
        dshnr(fem::float0),
        dskk(fem::float0),
        dskk0(fem::float0),
        dskn(fem::float0),
        dsknr(fem::float0),
        dspert(fem::float0),
        dspp(fem::float0),
        dsppb(fem::float0),
        dsppbr(fem::float0),
        dsppr(fem::float0),
        dsr(fem::float0),
        dsrpert(fem::float0),
        e1cm(fem::float0),
        e2(fem::float0),
        e2cm(fem::float0),
        ec(fem::float0),
        ec0(fem::float0),
        ece(fem::float0),
        eini(fem::float0),
        em1i(fem::float0),
        em2i(fem::float0),
        emm1(fem::float0),
        emm2(fem::float0),
        er1(fem::float0),
        er2(fem::float0),
        ert(fem::float0),
        et(dimension(maxstr), fem::fill0),
        ftpisv(dimension(maxstr, maxr), fem::fill0),
        fttemp(dimension(maxstr), fem::fill0),
        gfactr(fem::float0),
        i(fem::int0),
        i0(fem::int0),
        i1(fem::int0),
        i2(fem::int0),
        ia(fem::int0),
        ianti(fem::int0),
        ib(fem::int0),
        iblock(fem::int0),
        ic(fem::int0),
        icase(fem::int0),
        ichann(fem::int0),
        icheck(fem::int0),
        icontp(fem::int0),
        ictrl(fem::int0),
        id1(fem::int0),
        id2(fem::int0),
        idecay(fem::int0),
        ie(fem::int0),
        ifirst(fem::int0),
        ig(fem::int0),
        ikk(fem::int0),
        ikkg(fem::int0),
        ikkl(fem::int0),
        ikmp(fem::int0),
        il(fem::int0),
        ilb1(fem::int0),
        ilb2(fem::int0),
        im(fem::int0),
        in(fem::int0),
        inewka(fem::int0),
        ipdflag(fem::int0),
        ipert1(fem::int0),
        ipion(fem::int0),
        ipp(fem::int0),
        ipx1(fem::int0),
        ipx2(fem::int0),
        ipy1(fem::int0),
        ipy2(fem::int0),
        ipz1(fem::int0),
        ipz2(fem::int0),
        irun(fem::int0),
        is(fem::int0),
        iss(fem::int0),
        ix1(fem::int0),
        ix2(fem::int0),
        iy1(fem::int0),
        iy2(fem::int0),
        iz1(fem::int0),
        iz2(fem::int0),
        j(fem::int0),
        j1(fem::int0),
        j10(fem::int0),
        j2(fem::int0),
        kp(fem::int0),
        lb1i(fem::int0),
        lb2i(fem::int0),
        lbm(fem::int0),
        lbp1(fem::int0),
        lbp2(fem::int0),
        lomgar(fem::int0),
        lpdr(fem::int0),
        lrhor(fem::int0),
        lt(dimension(maxstr), fem::fill0),
        mass(fem::int0),
        massrn(dim1(0, maxr), fem::fill0),
        msum(fem::int0),
        n(fem::int0),
        n0(fem::int0),
        nchrg(fem::int0),
        nnnini(fem::int0),
        nodelt(fem::int0),
        ntag(fem::int0),
        p1beta(fem::float0),
        pcx(fem::float0),
        pcy(fem::float0),
        pcz(fem::float0),
        pdecay(fem::float0),
        pfinal(fem::float0),
        pk0(fem::float0),
        pkaon(fem::float0),
        pnstar(fem::float0),
        ppel(fem::float0),
        ppin(fem::float0),
        ppink(fem::float0),
        ppsig(fem::float0),
        prot(dimension(maxstr), fem::fill0),
        pt(dimension(3, maxstr), fem::fill0),
        pt1i1(fem::float0),
        pt1i2(fem::float0),
        pt2i1(fem::float0),
        pt2i2(fem::float0),
        pt3i1(fem::float0),
        pt3i2(fem::float0),
        px1cm(fem::float0),
        px1i(fem::float0),
        px2(fem::float0),
        px2i(fem::float0),
        pxini(fem::float0),
        py1cm(fem::float0),
        py1i(fem::float0),
        py2(fem::float0),
        py2i(fem::float0),
        pyini(fem::float0),
        pz1cm(fem::float0),
        pz1i(fem::float0),
        pz2(fem::float0),
        pz2i(fem::float0),
        pzini(fem::float0),
        pzrt(fem::float0),
        resona(fem::float0),
        rhomp(fem::float0),
        rppmax(fem::float0),
        rsqare(fem::float0),
        rt(dimension(3, maxstr), fem::fill0),
        sdb(fem::float0),
        sdm(fem::float0),
        sdprod(fem::float0),
        sig(fem::float0),
        sigela(fem::float0),
        sigk(fem::float0),
        sigkp(fem::float0),
        siglab(fem::float0),
        sigma0(fem::float0),
        signn(fem::float0),
        signn0(fem::float0),
        sigp(fem::float0),
        sigphi(fem::float0),
        sigr0(fem::float0),
        sigsgm(fem::float0),
        spika(fem::float0),
        spipi(fem::float0),
        spprho(fem::float0),
        srt(fem::float0),
        sumsrt(fem::float0),
        t0(fem::float0),
        transf(fem::float0),
        wid(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xdecay(fem::float0),
        xdirct(fem::float0),
        xelstc(fem::float0),
        xeta(fem::float0),
        xinel(fem::float0),
        xkaon(fem::float0),
        xkaon0(fem::float0),
        xky1(fem::float0),
        xky10(fem::float0),
        xky11(fem::float0),
        xky12(fem::float0),
        xky13(fem::float0),
        xky14(fem::float0),
        xky15(fem::float0),
        xky16(fem::float0),
        xky17(fem::float0),
        xky2(fem::float0),
        xky3(fem::float0),
        xky4(fem::float0),
        xky5(fem::float0),
        xky6(fem::float0),
        xky7(fem::float0),
        xky8(fem::float0),
        xky9(fem::float0),
        xmax(fem::float0),
        xmaxn(fem::float0),
        xmaxn1(fem::float0),
        xmm(fem::float0),
        xnelas(fem::float0),
        xnpid(fem::float0),
        xnpin(fem::float0),
        xnpin1(fem::float0),
        xphi(fem::float0),
        xphin(fem::float0),
        xreab(fem::float0),
        xres(fem::float0),
        xsk1(fem::float0),
        xsk2(fem::float0),
        xsk3(fem::float0),
        xsk4(fem::float0),
        xsk5(fem::float0),
        xsk6(fem::float0),
        xsk7(fem::float0),
        xx(fem::float0),
        xx0(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        yy(fem::float0),
        z1(fem::float0),
        z2(fem::float0),
        zet(dim1(-45, 45), fem::fill0) {}
};

const int relcol_save::maxstr;
const int relcol_save::maxr;

/// C*********************************
/// C                                                                      *
void relcol(common& cmn, int& lcoll, int& lbloc, int& lcnne, int& ldd, int& lpp,
            int& lppk, int& lpn, int& lpd, int& lrho, int& lomega, int& lkn,
            int& lnnk, int& lddk, int& lndk, int& lcnnd, int& lcndn, int& ldirt,
            int& ldecay, int& lres, int& ldou, int& lddrho, int& lnnrho,
            int& lnnom, int const& nt, int const& ntmax, float& sp,
            float& akaon, float& sk) {
  FEM_CMN_SVE(relcol);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  arr_ref<float> proper(cmn.proper, dimension(maxstr));
  float& dx = cmn.dx;
  float& dy = cmn.dy;
  float& dz = cmn.dz;
  float& dpx = cmn.dpx;
  float& dpy = cmn.dpy;
  float& dpz = cmn.dpz;
  int& nnn = cmn.nnn;
  const int maxr = 1;
  arr_ref<int> massr(cmn.massr, dim1(0, maxr));
  float& betax = cmn.betax;
  float& betay = cmn.betay;
  float& betaz = cmn.betaz;
  float& gamma = cmn.gamma;
  int& num = cmn.num;
  arr_ref<float, 3> rpion(cmn.rpion, dimension(3, maxstr, maxr));
  arr_ref<float, 3> ppion(cmn.ppion, dimension(3, maxstr, maxr));
  arr_ref<float, 2> epion(cmn.epion, dimension(maxstr, maxr));
  arr_ref<int, 2> lpion(cmn.lpion, dimension(maxstr, maxr));
  arr_ref<float, 2> propi(cmn.propi, dimension(maxstr, maxr));
  arr_ref<float> tkaon(cmn.tkaon, dimension(7));
  arr_ref<float, 2> ekaon(cmn.ekaon, dim1(7).dim2(0, 2000));
  int& iseed = cmn.iseed;
  float& dt = cmn.dt;
  int& lb1 = cmn.lb1;
  float& px1 = static_cast<common_leadng&>(cmn).px1;
  float& py1 = static_cast<common_leadng&>(cmn).py1;
  float& pz1 = static_cast<common_leadng&>(cmn).pz1;
  float& em1 = cmn.em1;
  float& e1 = cmn.e1;
  float& xfnl = cmn.xfnl;
  float& yfnl = cmn.yfnl;
  float& zfnl = cmn.zfnl;
  float& tfnl = cmn.tfnl;
  float& px1n = cmn.px1n;
  float& py1n = cmn.py1n;
  float& pz1n = cmn.pz1n;
  float& dp1n = cmn.dp1n;
  arr_ref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  arr_ref<float, 2> tfdpi(cmn.tfdpi, dimension(maxstr, maxr));
  arr_ref<float> tft(cmn.tft, dimension(maxstr));
  arr_cref<float> thresh(cmn.thresh, dimension(15));
  float& ppinnb = cmn.ppinnb;
  int& iksdcy = cmn.iksdcy;
  int& nseed = cmn.nseed;
  arr_ref<float> ftsv(cmn.ftsv, dimension(maxstr));
  float& em2 = cmn.em2;
  int& lb2 = cmn.lb2;
  int& ipi0dcy = cmn.ipi0dcy;
  int& idpert = cmn.idpert;
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dppion(cmn.dppion, dimension(maxstr, maxr));
  ///
  float& am1 = sve.am1;
  float& am2 = sve.am2;
  float& bmass = sve.bmass;
  float& brel = sve.brel;
  float& brsgm = sve.brsgm;
  float& brsig = sve.brsig;
  float& cutoff = sve.cutoff;
  float& deltar = sve.deltar;
  float& deltr0 = sve.deltr0;
  float& deltre = sve.deltre;
  arr_ref<float> dptemp(sve.dptemp, dimension(maxstr));
  float& dr0max = sve.dr0max;
  float& drmax = sve.drmax;
  float& ds = sve.ds;
  float& dse = sve.dse;
  float& dshn = sve.dshn;
  float& dshnr = sve.dshnr;
  float& dskk = sve.dskk;
  float& dskk0 = sve.dskk0;
  float& dskn = sve.dskn;
  float& dsknr = sve.dsknr;
  float& dspert = sve.dspert;
  float& dspp = sve.dspp;
  float& dsppb = sve.dsppb;
  float& dsppbr = sve.dsppbr;
  float& dsppr = sve.dsppr;
  float& dsr = sve.dsr;
  float& dsrpert = sve.dsrpert;
  float& e1cm = sve.e1cm;
  float& e2 = sve.e2;
  float& e2cm = sve.e2cm;
  float& ec = sve.ec;
  float& ec0 = sve.ec0;
  float& ece = sve.ece;
  float& emm1 = sve.emm1;
  float& emm2 = sve.emm2;
  float& er1 = sve.er1;
  float& er2 = sve.er2;
  float& ert = sve.ert;
  arr_ref<float> et(sve.et, dimension(maxstr));
  arr_ref<float, 2> ftpisv(sve.ftpisv, dimension(maxstr, maxr));
  arr_ref<float> fttemp(sve.fttemp, dimension(maxstr));
  float& gfactr = sve.gfactr;
  int& i = sve.i;
  int& i0 = sve.i0;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ia = sve.ia;
  int& ianti = sve.ianti;
  int& ib = sve.ib;
  int& iblock = sve.iblock;
  int& ic = sve.ic;
  int& icase = sve.icase;
  int& ichann = sve.ichann;
  int& icheck = sve.icheck;
  int& icontp = sve.icontp;
  int& ictrl = sve.ictrl;
  int& id1 = sve.id1;
  int& idecay = sve.idecay;
  int& ie = sve.ie;
  int& ifirst = sve.ifirst;
  int& ig = sve.ig;
  int& ikkg = sve.ikkg;
  int& ikkl = sve.ikkl;
  int& ikmp = sve.ikmp;
  int& il = sve.il;
  int& ilb1 = sve.ilb1;
  int& ilb2 = sve.ilb2;
  int& im = sve.im;
  int& in = sve.in;
  int& inewka = sve.inewka;
  int& ipdflag = sve.ipdflag;
  int& ipert1 = sve.ipert1;
  int& ipion = sve.ipion;
  int& ipp = sve.ipp;
  int& irun = sve.irun;
  int& is = sve.is;
  int& iss = sve.iss;
  int& j = sve.j;
  int& j1 = sve.j1;
  int& j10 = sve.j10;
  int& j2 = sve.j2;
  int& kp = sve.kp;
  int& lbm = sve.lbm;
  int& lbp1 = sve.lbp1;
  int& lbp2 = sve.lbp2;
  int& lomgar = sve.lomgar;
  int& lpdr = sve.lpdr;
  int& lrhor = sve.lrhor;
  arr_ref<int> lt(sve.lt, dimension(maxstr));
  int& mass = sve.mass;
  arr_ref<int> massrn(sve.massrn, dim1(0, maxr));
  int& msum = sve.msum;
  int& n = sve.n;
  int& n0 = sve.n0;
  int& nchrg = sve.nchrg;
  int& ntag = sve.ntag;
  float& p1beta = sve.p1beta;
  float& pcx = sve.pcx;
  float& pcy = sve.pcy;
  float& pcz = sve.pcz;
  float& pdecay = sve.pdecay;
  float& pfinal = sve.pfinal;
  float& pk0 = sve.pk0;
  float& pkaon = sve.pkaon;
  float& pnstar = sve.pnstar;
  float& ppel = sve.ppel;
  float& ppin = sve.ppin;
  float& ppink = sve.ppink;
  float& ppsig = sve.ppsig;
  arr_ref<float> prot(sve.prot, dimension(maxstr));
  arr_ref<float, 2> pt(sve.pt, dimension(3, maxstr));
  float& pt1i1 = sve.pt1i1;
  float& pt1i2 = sve.pt1i2;
  float& pt2i1 = sve.pt2i1;
  float& pt2i2 = sve.pt2i2;
  float& pt3i1 = sve.pt3i1;
  float& pt3i2 = sve.pt3i2;
  float& px1cm = sve.px1cm;
  float& px2 = sve.px2;
  float& py1cm = sve.py1cm;
  float& py2 = sve.py2;
  float& pz1cm = sve.pz1cm;
  float& pz2 = sve.pz2;
  float& pzrt = sve.pzrt;
  float& resona = sve.resona;
  float& rppmax = sve.rppmax;
  float& rsqare = sve.rsqare;
  arr_ref<float, 2> rt(sve.rt, dimension(3, maxstr));
  float& sdb = sve.sdb;
  float& sdm = sve.sdm;
  float& sdprod = sve.sdprod;
  float& sig = sve.sig;
  float& sigela = sve.sigela;
  float& sigk = sve.sigk;
  float& sigkp = sve.sigkp;
  float& siglab = sve.siglab;
  float& sigma0 = sve.sigma0;
  float& signn = sve.signn;
  float& signn0 = sve.signn0;
  float& sigp = sve.sigp;
  float& sigphi = sve.sigphi;
  float& sigr0 = sve.sigr0;
  float& sigsgm = sve.sigsgm;
  float& spika = sve.spika;
  float& spipi = sve.spipi;
  float& spprho = sve.spprho;
  float& srt = sve.srt;
  float& t0 = sve.t0;
  float& transf = sve.transf;
  float& wid = sve.wid;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xdecay = sve.xdecay;
  float& xdirct = sve.xdirct;
  float& xelstc = sve.xelstc;
  float& xeta = sve.xeta;
  float& xinel = sve.xinel;
  float& xkaon = sve.xkaon;
  float& xkaon0 = sve.xkaon0;
  float& xky1 = sve.xky1;
  float& xky10 = sve.xky10;
  float& xky11 = sve.xky11;
  float& xky12 = sve.xky12;
  float& xky13 = sve.xky13;
  float& xky14 = sve.xky14;
  float& xky15 = sve.xky15;
  float& xky16 = sve.xky16;
  float& xky17 = sve.xky17;
  float& xky2 = sve.xky2;
  float& xky3 = sve.xky3;
  float& xky4 = sve.xky4;
  float& xky5 = sve.xky5;
  float& xky6 = sve.xky6;
  float& xky7 = sve.xky7;
  float& xky8 = sve.xky8;
  float& xky9 = sve.xky9;
  float& xmax = sve.xmax;
  float& xmaxn = sve.xmaxn;
  float& xmaxn1 = sve.xmaxn1;
  float& xmm = sve.xmm;
  float& xnelas = sve.xnelas;
  float& xnpid = sve.xnpid;
  float& xnpin = sve.xnpin;
  float& xnpin1 = sve.xnpin1;
  float& xphi = sve.xphi;
  float& xphin = sve.xphin;
  float& xreab = sve.xreab;
  float& xres = sve.xres;
  float& xsk1 = sve.xsk1;
  float& xsk2 = sve.xsk2;
  float& xsk3 = sve.xsk3;
  float& xsk4 = sve.xsk4;
  float& xsk5 = sve.xsk5;
  float& xsk6 = sve.xsk6;
  float& xx = sve.xx;
  float& xx0 = sve.xx0;
  float& y1 = sve.y1;
  float& y2 = sve.y2;
  float& yy = sve.yy;
  float& z1 = sve.z1;
  float& z2 = sve.z2;
  arr_ref<float> zet(sve.zet, dim1(-45, 45));
  if (is_called_first_time) {
    static const float values[] = {
        1.f,  0.f,  0.f, 0.f,  0.f,  1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, -1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, 0.f,  -1.f, 0.f, 1.f,  0.f, -1.f, 0.f, -1.f, 0.f,
        -2.f, -1.f, 0.f, 1.f,  0.f,  0.f, 0.f,  0.f, -1.f, 0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, -1.f, 0.f,  1.f, 2.f,  0.f, 1.f,  0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, 0.f,  0.f,  0.f, -1.f, 0.f, 1.f,  0.f, -1.f, 0.f,
        1.f,  0.f,  0.f, 1.f,  0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  -1.f, 0.f, 0.f,  0.f,  0.f, -1.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), zet;
  }
  const float esbin = 0.04f;
  const float aka = 0.498f;
  const float pi = 3.1415926f;
  const float srhoks = 5.f;
  const float rrkk = 0.6f;
  const float aks = 0.895f;
  const float prkk = 0.3f;
  /// C                                                                      *
  /// C       PURPOSE:    CHECK CONDITIONS AND CALCULATE THE KINEMATICS      *
  /// C                   FOR BINARY COLLISIONS AMONG PARTICLES              *
  /// C                                 - RELATIVISTIC FORMULA USED          *
  /// C                                                                      *
  /// C       REFERENCES: HAGEDORN, RELATIVISTIC KINEMATICS (1963)           *
  /// C                                                                      *
  /// C       VARIABLES:                                                     *
  /// C         MASSPR  - NUMBER OF NUCLEONS IN PROJECTILE   (INTEGER,INPUT) *
  /// C         MASSTA  - NUMBER OF NUCLEONS IN TARGET       (INTEGER,INPUT) *
  /// C         NUM     - NUMBER OF TESTPARTICLES PER NUCLEON(INTEGER,INPUT) *
  /// C         ISEED   - SEED FOR RANDOM NUMBER GENERATOR   (INTEGER,INPUT) *
  /// C         IAVOID  - (= 1 => AVOID FIRST CLLISIONS WITHIN THE SAME      *
  /// C                   NUCLEUS, ELSE ALL COLLISIONS)      (INTEGER,INPUT) *
  /// C         DELTAR  - MAXIMUM SPATIAL DISTANCE FOR WHICH A COLLISION     *
  /// C                   STILL CAN OCCUR                       (REAL,INPUT) *
  /// C         DT      - TIME STEP SIZE                        (REAL,INPUT) *
  /// C         LCOLL   - NUMBER OF COLLISIONS              (INTEGER,OUTPUT) *
  /// C         LBLOC   - NUMBER OF PULI-BLOCKED COLLISIONS (INTEGER,OUTPUT) *
  /// C         LCNNE   - NUMBER OF ELASTIC COLLISION       (INTEGER,OUTPUT) *
  /// C         LCNND   - NUMBER OF N+N->N+DELTA REACTION   (INTEGER,OUTPUT) *
  /// C         LCNDN   - NUMBER OF N+DELTA->N+N REACTION   (INTEGER,OUTPUT) *
  /// C         LDD     - NUMBER OF RESONANCE+RESONANCE COLLISIONS
  /// C         LPP     - NUMBER OF PION+PION elastic COLIISIONS
  /// C         lppk    - number of pion(RHO,OMEGA)+pion(RHO,OMEGA)
  /// C                   -->K+K- collisions
  /// C         LPN     - NUMBER OF PION+N-->KAON+X
  /// C         lpd     - number of pion+n-->delta+pion
  /// C         lrho    - number of pion+n-->Delta+rho
  /// C         lomega  - number of pion+n-->Delta+omega
  /// C         LKN     - NUMBER OF KAON RESCATTERINGS
  /// C         LNNK    - NUMBER OF bb-->kAON PROCESS
  /// C         LDDK    - NUMBER OF DD-->KAON PROCESS
  /// C         LNDK    - NUMBER OF ND-->KAON PROCESS
  /// C         LB(I) IS USED TO LABEL PARTICLE'S CHARGE STATE
  /// C         LB(I)   =
  /// Cbali2/7/99
  /// C                 -45 Omega baryon(bar)
  /// C                 -41 cascade0(bar)
  /// C                 -40 cascade-(bar)
  /// Clin-11/07/00:
  /// C                 -30 K*-
  /// C                 -17 sigma+(bar)
  /// C                 -16 sigma0(bar)
  /// C                 -15 sigma-(bar)
  /// C                 -14 LAMBDA(bar)
  /// Clin-8/29/00
  /// C                 -13 anti-N*(+1)(1535),s_11
  /// C                 -12 anti-N*0(1535),s_11
  /// C                 -11 anti-N*(+1)(1440),p_11
  /// C                 -10 anti-N*0(1440), p_11
  /// C                  -9 anti-DELTA+2
  /// C                  -8 anti-DELTA+1
  /// C                  -7 anti-DELTA0
  /// C                  -6 anti-DELTA-1
  /// C
  /// C                  -2 antineutron
  /// C                  -1 antiproton
  /// Cbali2/7/99end
  /// C                   0 eta
  /// C                   1 PROTON
  /// C                   2 NUETRON
  /// C                   3 PION-
  /// C                   4 PION0
  /// C                   5 PION+
  /// C                   6 DELTA-1
  /// C                   7 DELTA0
  /// C                   8 DELTA+1
  /// C                   9 DELTA+2
  /// C                   10 N*0(1440), p_11
  /// C                   11 N*(+1)(1440),p_11
  /// C                  12 N*0(1535),s_11
  /// C                  13 N*(+1)(1535),s_11
  /// C                  14 LAMBDA
  /// C                   15 sigma-
  /// C                   16 sigma0
  /// C                   17 sigma+
  /// C                   21 kaon-
  /// Clin-2/23/03        22 Kaon0Long (converted at the last timestep)
  /// C                   23 KAON+
  /// C                   24 Kaon0short (converted at the last timestep then
  /// decay) C                   25 rho- C                   26 rho0 C 27 rho+ C
  /// 28 omega meson C                   29 phi C                   30 K*+ C
  /// sp01/03/01 C                   31 eta-prime C                   40
  /// cascade- C                   41 cascade0 C                   45 Omega
  /// baryon C sp01/03/01 end
  /// C
  /// C                   ++  ------- SEE NOTE BOOK
  /// C         NSTAR=1 INCLUDING N* RESORANCE
  /// C         ELSE DELTA RESORANCE ONLY
  /// C         NDIRCT=1 INCLUDING DIRECT PROCESS,ELSE NOT
  /// C         DIR - PERCENTAGE OF DIRECT PION PRODUCTION PROCESS
  /// C*********************************
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /HH/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /NN/
  /// Cc      SAVE /RR/
  /// Cc      SAVE /ss/
  /// Cc      SAVE /BG/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /PA/
  /// Cc      SAVE /PB/
  /// Cc      SAVE /PC/
  /// Cc      SAVE /PD/
  /// Cc      SAVE /PE/
  /// Cc      SAVE /KKK/
  /// Cc      SAVE /KAON/
  /// Cc      SAVE /TABLE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /leadng/
  /// Cc      SAVE /tdecay/
  /// Cc      SAVE /lastt/
  /// C
  /// Cc      SAVE /ppbmas/
  /// Cc      SAVE /ppb1/
  /// Cc      SAVE /ppmm/
  /// Cc      SAVE /hbt/
  /// Cc      SAVE /resdcy/
  /// Cc      SAVE /RNDF77/
  /// Clin-5/2008:
  /// C
  /// Clin-2/19/03 initialize n and nsav for resonance decay at each timestep
  /// C     in order to prevent integer overflow:
  inidcy(cmn);
  /// C
  /// C OFF skip ART collisions to reproduce HJ:
  /// Cc       if(nt.ne.ntmax) return
  /// C
  /// Clin-11/07/00 rrkk is assumed to be 0.6mb(default) for mm->KKbar
  /// C     with m=rho or omega, estimated from Ko's paper:
  /// C      rrkk=0.6
  /// C prkk: cross section of pi (rho or omega) -> K* Kbar (AND) K*bar K:
  /// C      prkk=0.3
  /// C     cross section in mb for (rho or omega) K* -> pi K:
  /// C      srhoks=5.
  /// Clin-11/07/00-end
  /// C      ESBIN=0.04
  resona = 5.f;
  /// C-----------------------------------------------------------------------
  /// C     INITIALIZATION OF COUNTING VARIABLES
  sve.nodelt = 0;
  sve.sumsrt = 0.f;
  lcoll = 0;
  lbloc = 0;
  lcnne = 0;
  ldd = 0;
  lpp = 0;
  lpd = 0;
  lpdr = 0;
  lrho = 0;
  lrhor = 0;
  lomega = 0;
  lomgar = 0;
  lpn = 0;
  lkn = 0;
  lnnk = 0;
  lddk = 0;
  lndk = 0;
  lppk = 0;
  lcnnd = 0;
  lcndn = 0;
  ldirt = 0;
  ldecay = 0;
  lres = 0;
  ldou = 0;
  lddrho = 0;
  lnnrho = 0;
  lnnom = 0;
  msum = 0;
  massrn(0) = 0;
  /// C COM: MSUM IS USED TO COUNT THE TOTAL NO. OF PARTICLES
  /// C      IN PREVIOUS IRUN-1 RUNS
  /// C KAON COUNTERS
  FEM_DO_SAFE(il, 1, 5) {
    tkaon(il) = 0;
    FEM_DO_SAFE(is, 1, 2000) { ekaon(il, is) = 0; }
  }
  /// C sp 12/19/00
  FEM_DO_SAFE(i, 1, num) {
    FEM_DO_SAFE(j, 1, maxstr) { propi(j, i) = 1.f; }
  }
  /// C
  FEM_DO_SAFE(i, 1, maxstr) {
    fttemp(i) = 0.f;
    FEM_DO_SAFE(irun, 1, maxr) { ftpisv(i, irun) = 0.f; }
  }
  /// C
  /// C sp 12/19/00 end
  sp = 0;
  /// C antikaon counters
  akaon = 0;
  sk = 0;
  /// C-----------------------------------------------------------------------
  /// C     LOOP OVER ALL PARALLEL RUNS
  /// Cbz11/17/98
  /// C      MASS=MASSPR+MASSTA
  mass = 0;
  /// Cbz11/17/98end
  FEM_DO_SAFE(irun, 1, num) {
    nnn = 0;
    msum += massr(irun - 1);
    /// C     LOOP OVER ALL PSEUDOPARTICLES 1 IN THE SAME RUN
    j10 = 2;
    if (nt == ntmax) {
      j10 = 1;
    }
    /// C
    /// Ctest off skips the check of energy conservation after each timestep:
    /// C         enetot=0.
    /// C         do ip=1,MASSR(IRUN)
    /// C            if(e(ip).ne.0.or.lb(ip).eq.10022) enetot=enetot
    /// C     1           +sqrt(p(1,ip)**2+p(2,ip)**2+p(3,ip)**2+e(ip)**2)
    /// C         enddo
    /// C         write(91,*) 'A:',nt,enetot,massr(irun),bimp
    /// C
    FEM_DO_SAFE(j1, j10, massr(irun)) {
      i1 = j1 + msum;
      /// C E(I)=0 are for pions having been absorbed or photons which do not
      /// enter here: Clin-4/2012 option of pi0 decays: C IF(E(I1).EQ.0.)GO TO
      /// 800
      if (e(i1) == 0.f) {
        goto statement_798;
      }
      /// C     To include anti-(Delta,N*1440 and N*1535):
      /// C          IF ((LB(I1) .LT. -13 .OR. LB(I1) .GT. 28)
      /// C     1         .and.iabs(LB(I1)) .ne. 30 ) GOTO 800
      /// Clin-4/2012 option of pi0 decays:
      /// C            IF (LB(I1) .LT. -45 .OR. LB(I1) .GT. 45) GOTO 800
      if (lb(i1) < -45 || lb(i1) > 45) {
        goto statement_798;
      }
      x1 = r(1, i1);
      y1 = r(2, i1);
      z1 = r(3, i1);
      px1 = p(1, i1);
      py1 = p(2, i1);
      pz1 = p(3, i1);
      em1 = e(i1);
      am1 = em1;
      e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                     fem::pow2(pz1));
      id1 = id(i1);
      lb1 = lb(i1);
      /// C
      /// C     generate k0short and k0long from K+ and K- at the last timestep:
      if (nt == ntmax && (lb1 == 21 || lb1 == 23)) {
        pk0 = ranart(nseed);
        if (pk0 < 0.25f) {
          lb(i1) = 22;
        } else if (pk0 < 0.50f) {
          lb(i1) = 24;
        }
        lb1 = lb(i1);
      }
      /// C
      /// Clin-8/07/02 these particles don't decay strongly, so skip decay
      /// routines: C            IF( (lb1.ge.-2.and.lb1.le.5) .OR. lb1.eq.31
      /// .OR. C     &           (iabs(lb1).ge.14.and.iabs(lb1).le.24) .OR. C &
      /// (iabs(lb1).ge.40.and.iabs(lb1).le.45) .or. C     & lb1.eq.31)GO TO 1
      /// C     only decay K0short when iksdcy=1:
      if (lb1 == 0 || lb1 == 25 || lb1 == 26 || lb1 == 27 || lb1 == 28 ||
          lb1 == 29 || fem::iabs(lb1) == 30 ||
          (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13) ||
          (iksdcy == 1 && lb1 == 24) || fem::iabs(lb1) == 16 ||
          (ipi0dcy == 1 && nt == ntmax && lb1 == 4)) {
        /// Clin-4/2012-above for option of pi0 decay:
        /// C     &           .or.iabs(lb1).eq.16) then
      } else {
        goto statement_1;
      }
      /// C IF I1 IS A RESONANCE, CHECK WHETHER IT DECAYS DURING THIS TIME STEP
      if (lb1 >= 25 && lb1 <= 27) {
        wid = 0.151f;
      } else if (lb1 == 28) {
        wid = 0.00841f;
      } else if (lb1 == 29) {
        wid = 0.00443f;
      } else if (fem::iabs(lb1) == 30) {
        wid = 0.051f;
      } else if (lb1 == 0) {
        wid = 1.18e-6f;
        /// C     to give K0short ct0=2.676cm:
      } else if (iksdcy == 1 && lb1 == 24) {
        wid = 7.36e-15f;
        /// Clin-4/29/03 add Sigma0 decay to Lambda, ct0=2.22E-11m:
      } else if (fem::iabs(lb1) == 16) {
        wid = 8.87e-6f;
        /// Csp-07/25/01 test a1 resonance:
        /// Cc          ELSEIF(LB1.EQ.32) then
        /// Cc             WID=0.40
      } else if (lb1 == 32) {
        wida1(cmn, em1, sve.rhomp, wid, iseed);
      } else if (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) {
        wid = width(cmn, em1);
      } else if ((fem::iabs(lb1) == 10) || (fem::iabs(lb1) == 11)) {
        wid = w1440(cmn, em1);
      } else if ((fem::iabs(lb1) == 12) || (fem::iabs(lb1) == 13)) {
        wid = w1535(cmn, em1);
        /// Clin-4/2012 for option of pi0 decay:
      } else if (ipi0dcy == 1 && nt == ntmax && lb1 == 4) {
        wid = 7.85e-9f;
      }
      /// C
      /// C if it is the last time step, FORCE all resonance to strong-decay
      /// C and go out of the loop
      if (nt == ntmax) {
        pdecay = 1.1f;
        /// Clin-5b/2008 forbid phi decay at the end of hadronic cascade:
        if (cmn.iphidcy == 0 && fem::iabs(lb1) == 29) {
          pdecay = 0.f;
        }
        /// Ctest off clin-9/2012 forbid long-time decays (eta,omega,K*,Sigma0)
        /// C     at the end of hadronic cascade to analyze freezeout time:
        /// C             if(LB1.eq.0.or.LB1.eq.28.or.iabs(LB1).eq.30
        /// C     1            .or.iabs(LB1).eq.16) pdecay=0.
      } else {
        t0 = 0.19733f / wid;
        gfactr = e1 / em1;
        t0 = t0 * gfactr;
        if (t0 > 0.f) {
          pdecay = 1.f - fem::exp(-dt / t0);
        } else {
          pdecay = 0.f;
        }
      }
      xdecay = ranart(nseed);
      /// C
      /// Cc dilepton production from rho0, omega, phi decay
      /// Cc        if(lb1.eq.26 .or. lb1.eq.28 .or. lb1.eq.29)
      /// Cc     &   call dec_ceres(nt,ntmax,irun,i1)
      /// Cc
      if (xdecay < pdecay) {
        /// Clin-10/25/02 get rid of argument usage mismatch in rhocay():
        idecay = irun;
        tfnl = nt * dt;
        /// Clin-10/28/03 keep formation time of hadrons unformed at nt=ntmax-1:
        if (nt == ntmax && ftsv(i1) > ((ntmax - 1) * dt)) {
          tfnl = ftsv(i1);
        }
        xfnl = x1;
        yfnl = y1;
        zfnl = z1;
        /// C use PYTHIA to perform decays of eta,rho,omega,phi,K*,(K0s) and
        /// Delta:
        if (lb1 == 0 || lb1 == 25 || lb1 == 26 || lb1 == 27 || lb1 == 28 ||
            lb1 == 29 || fem::iabs(lb1) == 30 ||
            (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) ||
            (iksdcy == 1 && lb1 == 24) || fem::iabs(lb1) == 16 ||
            (ipi0dcy == 1 && nt == ntmax && lb1 == 4)) {
          /// Clin-4/2012 Above for option of pi0 decay:
          /// C     &           .or.iabs(lb1).eq.16) then
          /// C     previous rho decay performed in rhodecay():
          /// C                nnn=nnn+1
          /// C                call rhodecay(idecay,i1,nnn,iseed)
          /// C
          /// Ctest off record decays of phi,K*,Lambda(1520) resonances:
          /// C                if(lb1.eq.29.or.iabs(lb1).eq.30)
          /// C     1               write(18,112) 'decay',lb1,px1,py1,pz1,am1,nt
          /// C
          /// Clin-4/2012 option of pi0 decays:
          /// C                call resdec(i1,nt,nnn,wid,idecay)
          resdec(cmn, i1, nt, nnn, wid, idecay, 0);
          p(1, i1) = px1n;
          p(2, i1) = py1n;
          p(3, i1) = pz1n;
          /// Clin-5/2008:
          dpertp(i1) = dp1n;
          /// C     add decay time to freezeout positions & time at the last
          /// timestep:
          if (nt == ntmax) {
            r(1, i1) = xfnl;
            r(2, i1) = yfnl;
            r(3, i1) = zfnl;
            tfdcy(i1) = tfnl;
          }
          /// C
          /// C decay number for baryon resonance or L/S decay
          if (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 9) {
            ldecay++;
          }
          /// C
          /// C for a1 decay
          /// C             elseif(lb1.eq.32)then
          /// C                NNN=NNN+1
          /// C                call a1decay(idecay,i1,nnn,iseed,rhomp)
          /// C
          /// C FOR N*(1440)
        } else if (fem::iabs(lb1) == 10 || fem::iabs(lb1) == 11) {
          nnn++;
          ldecay++;
          pnstar = 1.f;
          if (e(i1) > 1.22f) {
            pnstar = 0.6f;
          }
          if (ranart(nseed) <= pnstar) {
            /// C (1) DECAY TO SINGLE PION+NUCLEON
            decay(cmn, idecay, i1, nnn, iseed, wid, nt);
          } else {
            /// C (2) DECAY TO TWO PIONS + NUCLEON
            decay2(cmn, idecay, i1, nnn, iseed, wid, nt);
            nnn++;
          }
          /// C for N*(1535) decay
        } else if (fem::iabs(lb1) == 12 || fem::iabs(lb1) == 13) {
          nnn++;
          decay(cmn, idecay, i1, nnn, iseed, wid, nt);
          ldecay++;
        }
        /// C
        /// CCOM: AT HIGH ENERGIES WE USE VERY SHORT TIME STEPS,
        /// C     IN ORDER TO TAKE INTO ACCOUNT THE FINITE FORMATIOM TIME, WE
        /// C     DO NOT ALLOW PARTICLES FROM THE DECAY OF RESONANCE TO INTERACT
        /// C     WITH OTHERS IN THE SAME TIME STEP. CHANGE 9000 TO REVERSE THIS
        /// C     ASSUMPTION. EFFECTS OF THIS ASSUMPTION CAN BE STUDIED BY
        /// CHANGING C     THE STATEMENT OF 9000. See notebook for discussions
        /// on effects of C     changing statement 9000.
        /// C
        /// C     kaons from K* decay are converted to k0short (and k0long),
        /// C     phi decay may produce rho, K0S or eta, N*(1535) decay may
        /// produce eta, C     and these decay daughters need to decay again if
        /// at the last timestep: C     (note: these daughters have been
        /// assigned to lb(i1) only, not to lpion) C
        /// if(nt.eq.ntmax.and.(lb1.eq.29.or.iabs(lb1).eq.30 C     1
        /// .iabs(lb1).eq.12.or.iabs(lb1).eq.13)) then
        if (nt == ntmax) {
          if (lb(i1) == 25 || lb(i1) == 26 || lb(i1) == 27) {
            wid = 0.151f;
          } else if (lb(i1) == 0) {
            wid = 1.18e-6f;
          } else if (lb(i1) == 24 && iksdcy == 1) {
            /// Clin-4/2012 corrected K0s decay width:
            /// C                   wid=7.36e-17
            wid = 7.36e-15f;
            /// Clin-4/2012 option of pi0 decays:
          } else if (ipi0dcy == 1 && lb(i1) == 4) {
            wid = 7.85e-9f;
          } else {
            goto statement_9000;
          }
          lb1 = lb(i1);
          px1 = p(1, i1);
          py1 = p(2, i1);
          pz1 = p(3, i1);
          em1 = e(i1);
          e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                         fem::pow2(pz1));
          /// Clin-4/2012 option of pi0 decays:
          /// C                call resdec(i1,nt,nnn,wid,idecay)
          resdec(cmn, i1, nt, nnn, wid, idecay, 0);
          p(1, i1) = px1n;
          p(2, i1) = py1n;
          p(3, i1) = pz1n;
          r(1, i1) = xfnl;
          r(2, i1) = yfnl;
          r(3, i1) = zfnl;
          tfdcy(i1) = tfnl;
          /// Clin-5/2008:
          dpertp(i1) = dp1n;
        }
        /// C
        /// C     Decay daughter of the above decay in lb(i1) may be a pi0:
        if (nt == ntmax && ipi0dcy == 1 && lb(i1) == 4) {
          wid = 7.85e-9f;
          lb1 = lb(i1);
          px1 = p(1, i1);
          py1 = p(2, i1);
          pz1 = p(3, i1);
          em1 = e(i1);
          e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                         fem::pow2(pz1));
          resdec(cmn, i1, nt, nnn, wid, idecay, 0);
          p(1, i1) = px1n;
          p(2, i1) = py1n;
          p(3, i1) = pz1n;
          r(1, i1) = xfnl;
          r(2, i1) = yfnl;
          r(3, i1) = zfnl;
          tfdcy(i1) = tfnl;
          dpertp(i1) = dp1n;
        }
      /// C
      /// C negelecting the Pauli blocking at high energies
      /// Clin-4/2012 option of pi0 decays:
      /// C 9000        go to 800
      statement_9000:
        goto statement_798;
        /// C
      }
    /// C LOOP OVER ALL PSEUDOPARTICLES 2 IN THE SAME RUN
    /// C SAVE ALL THE COORDINATES FOR POSSIBLE CHANGE IN THE FOLLOWING
    /// COLLISION Clin-4/2012 option of pi0 decays: C 1        if(nt.eq.ntmax)go
    /// to 800
    statement_1:
      if (nt == ntmax) {
        goto statement_798;
      }
      /// C
      x1 = r(1, i1);
      y1 = r(2, i1);
      z1 = r(3, i1);
      /// C
      FEM_DO_SAFE(j2, 1, j1 - 1) {
        i2 = j2 + msum;
        /// C IF I2 IS A MESON BEING ABSORBED, THEN GO OUT OF THE LOOP
        if (e(i2) == 0.f) {
          goto statement_600;
        }
        /// Clin-5/2008 in case the first particle is already destroyed:
        if (e(i1) == 0.f) {
          goto statement_800;
        }
        /// Clin-4/2012 option of pi0 decays:
        if (lb(i2) < -45 || lb(i2) > 45) {
          goto statement_600;
        }
        /// Clin-7/26/03 improve speed
        x2 = r(1, i2);
        y2 = r(2, i2);
        z2 = r(3, i2);
        dr0max = 5.f;
        /// Clin-9/2008 deuteron+nucleon elastic cross sections could reach
        /// ~2810mb:
        ilb1 = fem::iabs(lb(i1));
        ilb2 = fem::iabs(lb(i2));
        if (ilb1 == 42 || ilb2 == 42) {
          if ((ilb1 >= 1 && ilb1 <= 2) || (ilb1 >= 6 && ilb1 <= 13) ||
              (ilb2 >= 1 && ilb2 <= 2) || (ilb2 >= 6 && ilb2 <= 13)) {
            if ((lb(i1) * lb(i2)) > 0) {
              dr0max = 10.f;
            }
          }
        }
        /// C
        if ((fem::pow2((x1 - x2)) + fem::pow2((y1 - y2)) +
             fem::pow2((z1 - z2))) > fem::pow2(dr0max)) {
          goto statement_600;
        }
        if (id(i1) * id(i2) == cmn.iavoid) {
          goto statement_400;
        }
        id1 = id(i1);
        sve.id2 = id(i2);
        /// C
        sve.ix1 = fem::nint(x1 / dx);
        sve.iy1 = fem::nint(y1 / dy);
        sve.iz1 = fem::nint(z1 / dz);
        px1 = p(1, i1);
        py1 = p(2, i1);
        pz1 = p(3, i1);
        em1 = e(i1);
        am1 = em1;
        lb1 = lb(i1);
        e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                       fem::pow2(pz1));
        sve.ipx1 = fem::nint(px1 / dpx);
        sve.ipy1 = fem::nint(py1 / dpy);
        sve.ipz1 = fem::nint(pz1 / dpz);
        lb2 = lb(i2);
        px2 = p(1, i2);
        py2 = p(2, i2);
        pz2 = p(3, i2);
        em2 = e(i2);
        am2 = em2;
        sve.lb1i = lb(i1);
        sve.lb2i = lb(i2);
        sve.px1i = p(1, i1);
        sve.py1i = p(2, i1);
        sve.pz1i = p(3, i1);
        sve.em1i = e(i1);
        sve.px2i = p(1, i2);
        sve.py2i = p(2, i2);
        sve.pz2i = p(3, i2);
        sve.em2i = e(i2);
        /// Clin-2/26/03 ctest off check energy conservation after each binary
        /// search:
        sve.eini = fem::sqrt(fem::pow2(e(i1)) + fem::pow2(p(1, i1)) +
                             fem::pow2(p(2, i1)) + fem::pow2(p(3, i1))) +
                   fem::sqrt(fem::pow2(e(i2)) + fem::pow2(p(1, i2)) +
                             fem::pow2(p(2, i2)) + fem::pow2(p(3, i2)));
        sve.pxini = p(1, i1) + p(1, i2);
        sve.pyini = p(2, i1) + p(2, i2);
        sve.pzini = p(3, i1) + p(3, i2);
        sve.nnnini = nnn;
        /// C
        /// Clin-4/30/03 initialize value:
        iblock = 0;
        /// C
        /// C TO SAVE COMPUTING TIME we do the following
        /// C (1) make a ROUGH estimate to see whether particle i2 will collide
        /// with C particle I1, and (2) skip the particle pairs for which
        /// collisions are C not modeled in the code. C FOR MESON-BARYON AND
        /// MESON-MESON COLLISIONS, we use a maximum C interaction distance
        /// DELTR0=2.6 C for ppbar production from meson (pi rho omega)
        /// interactions:
        /// C
        deltr0 = 3.f;
        if ((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
            (fem::iabs(lb1) >= 30 && fem::iabs(lb1) <= 45)) {
          deltr0 = 5.0f;
        }
        if ((fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17) ||
            (fem::iabs(lb2) >= 30 && fem::iabs(lb2) <= 45)) {
          deltr0 = 5.0f;
        }
        /// C
        if (lb1 == 28 && lb2 == 28) {
          deltr0 = 4.84f;
        }
        /// Clin-10/08/00 to include pi pi -> rho rho:
        if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
          e2 = fem::sqrt(fem::pow2(em2) + fem::pow2(px2) + fem::pow2(py2) +
                         fem::pow2(pz2));
          spipi = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
                  fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
          if (spipi >= (4 * fem::pow2(0.77f))) {
            deltr0 = 3.5f;
          }
        }
        /// C
        /// C khyperon
        if (lb1 == 23 && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_3699;
        }
        if (lb2 == 23 && (lb1 >= 14 && lb1 <= 17)) {
          goto statement_3699;
        }
        /// C
        /// C K(K*) + Kbar(K*bar) scattering including
        /// C     K(K*) + Kbar(K*bar) --> phi + pi(rho,omega) and pi
        /// pi(rho,omega)
        if (lb1 == 21 && lb2 == 23) {
          goto statement_3699;
        }
        if (lb2 == 21 && lb1 == 23) {
          goto statement_3699;
        }
        if (lb1 == 30 && lb2 == 21) {
          goto statement_3699;
        }
        if (lb2 == 30 && lb1 == 21) {
          goto statement_3699;
        }
        if (lb1 == -30 && lb2 == 23) {
          goto statement_3699;
        }
        if (lb2 == -30 && lb1 == 23) {
          goto statement_3699;
        }
        if (lb1 == -30 && lb2 == 30) {
          goto statement_3699;
        }
        if (lb2 == -30 && lb1 == 30) {
          goto statement_3699;
        }
        /// C
        /// Clin-12/15/00
        /// C     kaon+rho(omega,eta) collisions:
        if (lb1 == 21 || lb1 == 23) {
          if (lb2 == 0 || (lb2 >= 25 && lb2 <= 28)) {
            goto statement_3699;
          }
        } else if (lb2 == 21 || lb2 == 23) {
          if (lb1 == 0 || (lb1 >= 25 && lb1 <= 28)) {
            goto statement_3699;
          }
        }
        /// C
        /// Clin-8/14/02 K* (pi, rho, omega, eta) collisions:
        if (fem::iabs(lb1) == 30 &&
            (lb2 == 0 || (lb2 >= 25 && lb2 <= 28) || (lb2 >= 3 && lb2 <= 5))) {
          goto statement_3699;
        } else if (fem::iabs(lb2) == 30 &&
                   (lb1 == 0 || (lb1 >= 25 && lb1 <= 28) ||
                    (lb1 >= 3 && lb1 <= 5))) {
          goto statement_3699;
          /// Clin-8/14/02-end
          /// C K*/K*-bar + baryon/antibaryon collisions:
        } else if (fem::iabs(lb1) == 30 &&
                   (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
                    (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_3699;
        }
        if (fem::iabs(lb2) == 30 &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_3699;
        }
        /// C K^+ baryons and antibaryons:
        /// C** K+ + B-bar  --> La(Si)-bar + pi
        /// C K^- and antibaryons, note K^- and baryons are included in newka():
        /// C note that we fail to satisfy charge conjugation for these cross
        /// sections:
        if ((lb1 == 23 || lb1 == 21) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
             (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_3699;
        } else if ((lb2 == 23 || lb2 == 21) &&
                   (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
                    (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_3699;
        }
        /// C
        /// C For anti-nucleons annihilations:
        /// C Assumptions:
        /// C (1) for collisions involving a p_bar or n_bar,
        /// C we allow only collisions between a p_bar and a baryon or a baryon
        /// C resonance (as well as a n_bar and a baryon or a baryon resonance),
        /// C we skip all other reactions involving a p_bar or n_bar,
        /// C such as collisions between p_bar (n_bar) and mesons,
        /// C and collisions between two p_bar's (n_bar's).
        /// C (2) we introduce a new parameter rppmax: the maximum interaction
        /// C distance to make the quick collision check,rppmax=3.57 fm
        /// C corresponding to a cutoff of annihilation xsection= 400mb which is
        /// C also used consistently in the actual annihilation xsection to be
        /// C used in the following as given in the subroutine xppbar(srt)
        rppmax = 3.57f;
        /// C anti-baryon on baryons
        if ((lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)) &&
            (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13))) {
          deltr0 = rppmax;
          goto statement_2699;
        } else if ((lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6)) &&
                   (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 13))) {
          deltr0 = rppmax;
          goto statement_2699;
        }
        /// C
        /// C*  ((anti) lambda, cascade, omega  should not be rejected)
        if ((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
            (fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17)) {
          goto statement_3699;
        }
        /// C
        /// Clin-9/2008 maximum sigma~2810mb for deuteron+nucleon elastic
        /// collisions:
        if (fem::iabs(lb1) == 42 || fem::iabs(lb2) == 42) {
          ilb1 = fem::iabs(lb1);
          ilb2 = fem::iabs(lb2);
          if ((ilb1 >= 1 && ilb1 <= 2) || (ilb1 >= 6 && ilb1 <= 13) ||
              (ilb2 >= 1 && ilb2 <= 2) || (ilb2 >= 6 && ilb2 <= 13)) {
            if ((lb1 * lb2) > 0) {
              deltr0 = 9.5f;
            }
          }
        }
        /// C
        if ((fem::iabs(lb1) >= 40 && fem::iabs(lb1) <= 45) ||
            (fem::iabs(lb2) >= 40 && fem::iabs(lb2) <= 45)) {
          goto statement_3699;
        }
        /// C
        /// C* phi channel --> elastic + inelastic scatt.
        if ((lb1 == 29 && ((lb2 >= 1 && lb2 <= 13) ||
                           (lb2 >= 21 && lb2 <= 28) || fem::iabs(lb2) == 30)) ||
            (lb2 == 29 && ((lb1 >= 1 && lb1 <= 13) ||
                           (lb1 >= 21 && lb1 <= 28) || fem::iabs(lb1) == 30))) {
          deltr0 = 3.0f;
          goto statement_3699;
        }
        /// C
        /// C  La/Si, Cas, Om (bar)-meson elastic colln
        /// C pion vs. La & Ca (bar) coll. are treated in resp. subroutines
        /// C
        /// C SKIP all other K* RESCATTERINGS
        if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
          goto statement_400;
        }
        /// C SKIP KAON(+) RESCATTERINGS WITH particles other than pions and
        /// baryons
        if (lb1 == 23 && (lb2 < 1 || lb2 > 17)) {
          goto statement_400;
        }
        if (lb2 == 23 && (lb1 < 1 || lb1 > 17)) {
          goto statement_400;
        }
        /// C
        /// C anti-baryon proccess: B-bar+M, N-bar+R-bar, N-bar+N-bar,
        /// R-bar+R-bar C  R = (D,N*)
        if (((lb1 <= -1 && lb1 >= -13) && (lb2 == 0 || (lb2 >= 3 && lb2 <= 5) ||
                                           (lb2 >= 25 && lb2 <= 28))) ||
            ((lb2 <= -1 && lb2 >= -13) && (lb1 == 0 || (lb1 >= 3 && lb1 <= 5) ||
                                           (lb1 >= 25 && lb1 <= 28)))) {
        } else if (((lb1 == -1 || lb1 == -2) && (lb2 < -5 && lb2 >= -13)) ||
                   ((lb2 == -1 || lb2 == -2) && (lb1 < -5 && lb1 >= -13))) {
        } else if ((lb1 == -1 || lb1 == -2) && (lb2 == -1 || lb2 == -2)) {
        } else if ((lb1 < -5 && lb1 >= -13) && (lb2 < -5 && lb2 >= -13)) {
          /// C        elseif((lb1.lt.0).or.(lb2.lt.0)) then
          /// C         go to 400
        }
      /// C
      statement_2699:
        /// C for baryon-baryon collisions
        if (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 17)) {
          if (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 17)) {
            deltr0 = 2.f;
          }
        }
      /// C
      statement_3699:
        rsqare =
            fem::pow2((x1 - x2)) + fem::pow2((y1 - y2)) + fem::pow2((z1 - z2));
        if (rsqare > fem::pow2(deltr0)) {
          goto statement_400;
        }
        /// CNOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
        /// C KEEP ALL COORDINATES FOR POSSIBLE PHASE SPACE CHANGE
        sve.ix2 = fem::nint(x2 / dx);
        sve.iy2 = fem::nint(y2 / dy);
        sve.iz2 = fem::nint(z2 / dz);
        sve.ipx2 = fem::nint(px2 / dpx);
        sve.ipy2 = fem::nint(py2 / dpy);
        sve.ipz2 = fem::nint(pz2 / dpz);
        /// C FIND MOMENTA OF PARTICLES IN THE CMS OF THE TWO COLLIDING
        /// PARTICLES C AND THE CMS ENERGY SRT
        cms(cmn, i1, i2, pcx, pcy, pcz, srt);
        /// C
        /// Clin-7/26/03 improve speed
        drmax = dr0max;
        distc0(cmn, drmax, deltr0, dt, ifirst, pcx, pcy, pcz, x1, y1, z1, px1,
               py1, pz1, em1, x2, y2, z2, px2, py2, pz2, em2);
        if (ifirst == -1) {
          goto statement_400;
        }
        /// C
        iss = fem::nint(srt / esbin);
        /// Clin-4/2008 use last bin if ISS is out of EKAON's upper bound of
        /// 2000:
        if (iss > 2000) {
          iss = 2000;
        }
        /// CSort collisions
        /// C
        /// Clin-8/2008 Deuteron+Meson->B+B;
        /// C     meson=(pi,rho,omega,eta), B=(n,p,Delta,N*1440,N*1535):
        if (fem::iabs(lb1) == 42 || fem::iabs(lb2) == 42) {
          ilb1 = fem::iabs(lb1);
          ilb2 = fem::iabs(lb2);
          if (lb1 == 0 || (lb1 >= 3 && lb1 <= 5) || (lb1 >= 25 && lb1 <= 28) ||
              lb2 == 0 || (lb2 >= 3 && lb2 <= 5) || (lb2 >= 25 && lb2 <= 28)) {
            goto statement_505;
            /// Clin-9/2008 Deuteron+Baryon or antiDeuteron+antiBaryon elastic
            /// collisions:
          } else if (((ilb1 >= 1 && ilb1 <= 2) || (ilb1 >= 6 && ilb1 <= 13) ||
                      (ilb2 >= 1 && ilb2 <= 2) || (ilb2 >= 6 && ilb2 <= 13)) &&
                     (lb1 * lb2) > 0) {
            goto statement_506;
          } else {
            goto statement_400;
          }
        }
        /// C
        /// C K+ + (N,N*,D)-bar --> L/S-bar + pi
        if (((lb1 == 23 || lb1 == 30) &&
             (lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6))) ||
            ((lb2 == 23 || lb2 == 30) &&
             (lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)))) {
          bmass = 0.938f;
          if (srt <= (bmass + aka)) {
            pkaon = 0.f;
          } else {
            pkaon = fem::sqrt(fem::pow2(((fem::pow2(srt) -
                                          (fem::pow2(aka) + fem::pow2(bmass))) /
                                         2.f / bmass)) -
                              fem::pow2(aka));
          }
          /// Clin-10/31/02 cross sections are isospin-averaged, same as those
          /// in newka C     for K- + (N,N*,D) --> L/S + pi:
          sigela = 0.5f * (akpel(cmn, pkaon) + aknel(cmn, pkaon));
          sigsgm = 1.5f * akpsgm(cmn, pkaon) + aknsgm(cmn, pkaon);
          sig = sigela + sigsgm + akplam(cmn, pkaon);
          if (sig > 1.e-7f) {
            /// C     ! K+ + N-bar reactions
            icase = 3;
            brel = sigela / sig;
            brsgm = sigsgm / sig;
            brsig = sig;
            nchrg = 1;
            goto statement_3555;
          }
          goto statement_400;
        }
        /// C
        /// C  meson + hyperon-bar -> K+ + N-bar
        if (((lb1 >= -17 && lb1 <= -14) && (lb2 >= 3 && lb2 <= 5)) ||
            ((lb2 >= -17 && lb2 <= -14) && (lb1 >= 3 && lb1 <= 5))) {
          nchrg = -100;
          /// C
          /// C*       first classify the reactions due to total charge.
          if ((lb1 == -15 && (lb2 == 5 || lb2 == 27)) ||
              (lb2 == -15 && (lb1 == 5 || lb1 == 27))) {
            nchrg = -2;
            /// C     ! D-(bar)
            bmass = 1.232f;
            goto statement_110;
          }
          if ((lb1 == -15 &&
               (lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28)) ||
              (lb2 == -15 &&
               (lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28)) ||
              ((lb1 == -14 || lb1 == -16) && (lb2 == 5 || lb2 == 27)) ||
              ((lb2 == -14 || lb2 == -16) && (lb1 == 5 || lb1 == 27))) {
            nchrg = -1;
            /// C     ! n-bar
            bmass = 0.938f;
            goto statement_110;
          }
          if ((lb1 == -15 && (lb2 == 3 || lb2 == 25)) ||
              (lb2 == -15 && (lb1 == 3 || lb1 == 25)) ||
              (lb1 == -17 && (lb2 == 5 || lb2 == 27)) ||
              (lb2 == -17 && (lb1 == 5 || lb1 == 27)) ||
              ((lb1 == -14 || lb1 == -16) &&
               (lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28)) ||
              ((lb2 == -14 || lb2 == -16) &&
               (lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28))) {
            nchrg = 0;
            /// C     ! p-bar
            bmass = 0.938f;
            goto statement_110;
          }
          if ((lb1 == -17 &&
               (lb2 == 0 || lb2 == 4 || lb2 == 26 || lb2 == 28)) ||
              (lb2 == -17 &&
               (lb1 == 0 || lb1 == 4 || lb1 == 26 || lb1 == 28)) ||
              ((lb1 == -14 || lb1 == -16) && (lb2 == 3 || lb2 == 25)) ||
              ((lb2 == -14 || lb2 == -16) && (lb1 == 3 || lb1 == 25))) {
            nchrg = 1;
            /// C     ! D++(bar)
            bmass = 1.232f;
          }
        /// C
        /// C 110     if(nchrg.ne.-100.and.srt.ge.(aka+bmass))then !! for
        /// elastic
        statement_110:
          sig = 0.f;
          /// C !! for elastic
          if (nchrg != -100 && srt >= (aka + bmass)) {
            /// Cc110        if(nchrg.eq.-100.or.srt.lt.(aka+bmass)) go to 400
            /// C             ! PI + La(Si)-bar => K+ + N-bar reactions
            icase = 4;
            /// Cc pkaon=sqrt(((srt**2-(aka**2+bmass**2))/2./bmass)**2-aka**2)
            pkaon =
                fem::sqrt(fem::pow2(((fem::pow2(srt) -
                                      (fem::pow2(aka) + fem::pow2(0.938f))) /
                                     2.f / 0.938f)) -
                          fem::pow2(aka));
            /// C ! lambda-bar + Pi
            if (lb1 == -14 || lb2 == -14) {
              if (nchrg >= 0) {
                sigma0 = akplam(cmn, pkaon);
              }
              if (nchrg < 0) {
                sigma0 = aknlam(cmn, pkaon);
              }
              /// C                ! sigma-bar + pi
            } else {
              /// C !K-p or K-D++
              if (nchrg >= 0) {
                sigma0 = akpsgm(cmn, pkaon);
              }
              /// C !K-n or K-D-
              if (nchrg < 0) {
                sigma0 = aknsgm(cmn, pkaon);
              }
              sigma0 = 1.5f * akpsgm(cmn, pkaon) + aknsgm(cmn, pkaon);
            }
            sig = (fem::pow2(srt) - fem::pow2((aka + bmass))) *
                  (fem::pow2(srt) - fem::pow2((aka - bmass))) /
                  (fem::pow2(srt) - fem::pow2((em1 + em2))) /
                  (fem::pow2(srt) - fem::pow2((em1 - em2))) * sigma0;
            /// C ! K0barD++, K-D-
            if (nchrg == -2 || nchrg == 2) {
              sig = 2.f * sig;
            }
            /// C*     the factor 2 comes from spin of delta, which is 3/2
            /// C*     detailed balance. copy from Page 423 of N.P. A614 1997
            if (lb1 == -14 || lb2 == -14) {
              sig = 4.0f / 3.0f * sig;
            } else if (nchrg == -2 || nchrg == 2) {
              sig = 8.0f / 9.0f * sig;
            } else {
              sig = 4.0f / 9.0f * sig;
            }
            /// Cc        brel=0.
            /// Cc        brsgm=0.
            /// Cc        brsig = sig
            /// Cc          if(sig.lt.1.e-7) go to 400
            /// C-
          }
          /// C                ! PI + La(Si)-bar => elastic included
          icase = 4;
          sigela = 10.f;
          sig += sigela;
          brel = sigela / sig;
          brsgm = 0.f;
          brsig = sig;
          /// C-
          goto statement_3555;
        }
        /// C
        /// C* MULTISTRANGE PARTICLE (Cas,Omega -bar) PRODUCTION -
        /// (NON)PERTURBATIVE
        /// C
        /// C K-/K*0bar + La/Si --> cascade + pi/eta
        if (((lb1 == 21 || lb1 == -30) && (lb2 >= 14 && lb2 <= 17)) ||
            ((lb2 == 21 || lb2 == -30) && (lb1 >= 14 && lb1 <= 17))) {
          kp = 0;
          goto statement_3455;
        }
        /// C K+/K*0 + La/Si(bar) --> cascade-bar + pi/eta
        if (((lb1 == 23 || lb1 == 30) && (lb2 <= -14 && lb2 >= -17)) ||
            ((lb2 == 23 || lb2 == 30) && (lb1 <= -14 && lb1 >= -17))) {
          kp = 1;
          goto statement_3455;
        }
        /// C K-/K*0bar + cascade --> omega + pi
        if (((lb1 == 21 || lb1 == -30) && (lb2 == 40 || lb2 == 41)) ||
            ((lb2 == 21 || lb2 == -30) && (lb1 == 40 || lb1 == 41))) {
          kp = 0;
          goto statement_3455;
        }
        /// C K+/K*0 + cascade-bar --> omega-bar + pi
        if (((lb1 == 23 || lb1 == 30) && (lb2 == -40 || lb2 == -41)) ||
            ((lb2 == 23 || lb2 == 30) && (lb1 == -40 || lb1 == -41))) {
          kp = 1;
          goto statement_3455;
        }
        /// C Omega + Omega --> Di-Omega + photon(eta)
        /// Cc        if( lb1.eq.45.and.lb2.eq.45 ) go to 3455
        /// C
        /// C annhilation of cascade(bar), omega(bar)
        kp = 3;
        /// C K- + L/S <-- cascade(bar) + pi/eta
        if ((((lb1 >= 3 && lb1 <= 5) || lb1 == 0) &&
             (fem::iabs(lb2) == 40 || fem::iabs(lb2) == 41)) ||
            (((lb2 >= 3 && lb2 <= 5) || lb2 == 0) &&
             (fem::iabs(lb1) == 40 || fem::iabs(lb1) == 41))) {
          goto statement_3455;
        }
        /// C K- + cascade(bar) <-- omega(bar) + pi
        /// C         if(  (lb1.eq.0.and.iabs(lb2).eq.45)
        /// C    &       .OR. (lb2.eq.0.and.iabs(lb1).eq.45) )go to 3455
        if (((lb1 >= 3 && lb1 <= 5) && fem::iabs(lb2) == 45) ||
            ((lb2 >= 3 && lb2 <= 5) && fem::iabs(lb1) == 45)) {
          goto statement_3455;
        }
        /// C
        /// C**  MULTISTRANGE PARTICLE PRODUCTION  (END)
        /// C
        /// C* K+ + La(Si) --> Meson + B
        if (lb1 == 23 && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_5699;
        }
        if (lb2 == 23 && (lb1 >= 14 && lb1 <= 17)) {
          goto statement_5699;
        }
        /// C* K- + La(Si)-bar --> Meson + B-bar
        if (lb1 == 21 && (lb2 >= -17 && lb2 <= -14)) {
          goto statement_5699;
        }
        if (lb2 == 21 && (lb1 >= -17 && lb1 <= -14)) {
          goto statement_5699;
        }
        /// C
        /// C La/Si-bar + B --> pi + K+
        if ((((lb1 == 1 || lb1 == 2) || (lb1 >= 6 && lb1 <= 13)) &&
             (lb2 >= -17 && lb2 <= -14)) ||
            (((lb2 == 1 || lb2 == 2) || (lb2 >= 6 && lb2 <= 13)) &&
             (lb1 >= -17 && lb1 <= -14))) {
          goto statement_5999;
        }
        /// C La/Si + B-bar --> pi + K-
        if ((((lb1 == -1 || lb1 == -2) || (lb1 <= -6 && lb1 >= -13)) &&
             (lb2 >= 14 && lb2 <= 17)) ||
            (((lb2 == -1 || lb2 == -2) || (lb2 <= -6 && lb2 >= -13)) &&
             (lb1 >= 14 && lb1 <= 17))) {
          goto statement_5999;
        }
        /// C
        /// C K(K*) + Kbar(K*bar) --> phi + pi(rho,omega), M + M
        /// (M=pi,rho,omega,eta)
        if (lb1 == 21 && lb2 == 23) {
          goto statement_8699;
        }
        if (lb2 == 21 && lb1 == 23) {
          goto statement_8699;
        }
        if (lb1 == 30 && lb2 == 21) {
          goto statement_8699;
        }
        if (lb2 == 30 && lb1 == 21) {
          goto statement_8699;
        }
        if (lb1 == -30 && lb2 == 23) {
          goto statement_8699;
        }
        if (lb2 == -30 && lb1 == 23) {
          goto statement_8699;
        }
        if (lb1 == -30 && lb2 == 30) {
          goto statement_8699;
        }
        if (lb2 == -30 && lb1 == 30) {
          goto statement_8699;
        }
        /// C* (K,K*)-bar + rho(omega) --> phi +(K,K*)-bar, piK and elastic
        if (((lb1 == 23 || lb1 == 21 || fem::iabs(lb1) == 30) &&
             (lb2 >= 25 && lb2 <= 28)) ||
            ((lb2 == 23 || lb2 == 21 || fem::iabs(lb2) == 30) &&
             (lb1 >= 25 && lb1 <= 28))) {
          goto statement_8799;
        }
        /// C
        /// C* K*(-bar) + pi --> phi + (K,K*)-bar
        if ((fem::iabs(lb1) == 30 && (lb2 >= 3 && lb2 <= 5)) ||
            (fem::iabs(lb2) == 30 && (lb1 >= 3 && lb1 <= 5))) {
          goto statement_8799;
        }
        /// C
        /// C* phi + N --> pi+N(D),  rho+N(D),  K+ +La
        /// C* phi + D --> pi+N(D),  rho+N(D)
        if ((lb1 == 29 && (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 9))) ||
            (lb2 == 29 && (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 9)))) {
          goto statement_7222;
        }
        /// C
        /// C* phi + (pi,rho,ome,K,K*-bar) --> K+K, K+K*, K*+K*,
        /// (pi,rho,omega)+(K,K*-bar)
        if ((lb1 == 29 && ((lb2 >= 3 && lb2 <= 5) || (lb2 >= 21 && lb2 <= 28) ||
                           fem::iabs(lb2) == 30)) ||
            (lb2 == 29 && ((lb1 >= 3 && lb1 <= 5) || (lb1 >= 21 && lb1 <= 28) ||
                           fem::iabs(lb1) == 30))) {
          goto statement_7444;
        }
        /// C
        /// C La/Si, Cas, Om (bar)-(rho,omega,phi) elastic colln
        /// C pion vs. La, Ca, Omega-(bar) elastic coll. treated in resp.
        /// subroutines
        if (((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
             fem::iabs(lb1) >= 40) &&
            ((lb2 >= 25 && lb2 <= 29) || lb2 == 0)) {
          goto statement_888;
        }
        if (((fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17) ||
             fem::iabs(lb2) >= 40) &&
            ((lb1 >= 25 && lb1 <= 29) || lb1 == 0)) {
          goto statement_888;
        }
        /// C
        /// C K+/K* (N,R)  OR   K-/K*- (N,R)-bar  elastic scatt
        if (((lb1 == 23 || lb1 == 30) &&
             (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13))) ||
            ((lb2 == 23 || lb2 == 30) &&
             (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 13)))) {
          goto statement_888;
        }
        if (((lb1 == 21 || lb1 == -30) &&
             (lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6))) ||
            ((lb2 == 21 || lb2 == -30) &&
             (lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)))) {
          goto statement_888;
        }
        /// C
        /// C L/S-baryon elastic collision
        if (((lb1 >= 14 && lb1 <= 17) && (lb2 >= 6 && lb2 <= 13)) ||
            ((lb2 >= 14 && lb2 <= 17) && (lb1 >= 6 && lb1 <= 13))) {
          goto statement_7799;
        }
        if (((lb1 <= -14 && lb1 >= -17) && (lb2 <= -6 && lb2 >= -13)) ||
            ((lb2 <= -14 && lb2 >= -17) && (lb1 <= -6 && lb1 >= -13))) {
          goto statement_7799;
        }
        /// C
        /// C skip other collns with perturbative particles or hyperon-bar
        if (fem::iabs(lb1) >= 40 || fem::iabs(lb2) >= 40 ||
            (lb1 <= -14 && lb1 >= -17) || (lb2 <= -14 && lb2 >= -17)) {
          goto statement_400;
        }
        /// C
        /// C anti-baryon on baryon resonaces
        if ((lb1 == -1 || lb1 == -2 || (lb1 >= -13 && lb1 <= -6)) &&
            (lb2 == 1 || lb2 == 2 || (lb2 >= 6 && lb2 <= 13))) {
          goto statement_2799;
        } else if ((lb2 == -1 || lb2 == -2 || (lb2 >= -13 && lb2 <= -6)) &&
                   (lb1 == 1 || lb1 == 2 || (lb1 >= 6 && lb1 <= 13))) {
          goto statement_2799;
        }
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in newka():
        inewka = irun;
        /// C        call newka(icase,irun,iseed,dt,nt,
        /// Clin-5/01/03 set iblock value in art1f.f, necessary for resonance
        /// studies: C        call newka(icase,inewka,iseed,dt,nt, C     &
        /// ictrl,i1,i2,srt,pcx,pcy,pcz)
        newka(cmn, icase, inewka, iseed, dt, nt, ictrl, i1, i2, srt, pcx, pcy,
              pcz, iblock);
        /// C
        /// Clin-10/25/02-end
        if (ictrl == 1) {
          goto statement_400;
        }
        /// C
        /// C SEPARATE NUCLEON+NUCLEON( BARYON RESONANCE+ BARYON RESONANCE
        /// ELASTIC C COLLISION), BARYON RESONANCE+NUCLEON AND BARYON-PION C
        /// COLLISIONS INTO THREE PARTS TO CHECK IF THEY ARE GOING TO SCATTER, C
        /// WE only allow L/S to COLLIDE elastically with a nucleon and meson
        if ((fem::iabs(lb1) >= 14 && fem::iabs(lb1) <= 17) ||
            (fem::iabs(lb2) >= 14 && fem::iabs(lb2) <= 17)) {
          goto statement_400;
        }
        /// C IF PION+PION COLLISIONS GO TO 777
        /// C if pion+eta, eta+eta to create kaons go to 777
        if ((lb1 >= 3 && lb1 <= 5) && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_777;
        }
        if (lb1 == 0 && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_777;
        }
        if (lb2 == 0 && (lb1 >= 3 && lb1 <= 5)) {
          goto statement_777;
        }
        if (lb1 == 0 && lb2 == 0) {
          goto statement_777;
        }
        /// C we assume that rho and omega behave the same way as pions in
        /// C kaon production
        /// C (1) rho(omega)+rho(omega)
        if ((lb1 >= 25 && lb1 <= 28) && (lb2 >= 25 && lb2 <= 28)) {
          goto statement_777;
        }
        /// C (2) rho(omega)+pion
        if ((lb1 >= 25 && lb1 <= 28) && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_777;
        }
        if ((lb2 >= 25 && lb2 <= 28) && (lb1 >= 3 && lb1 <= 5)) {
          goto statement_777;
        }
        /// C (3) rho(omega)+eta
        if ((lb1 >= 25 && lb1 <= 28) && lb2 == 0) {
          goto statement_777;
        }
        if ((lb2 >= 25 && lb2 <= 28) && lb1 == 0) {
          goto statement_777;
        }
        /// C
        /// C if kaon+pion collisions go to 889
        if ((lb1 == 23 || lb1 == 21) && (lb2 >= 3 && lb2 <= 5)) {
          goto statement_889;
        }
        if ((lb2 == 23 || lb2 == 21) && (lb1 >= 3 && lb1 <= 5)) {
          goto statement_889;
        }
        /// C
        /// Clin-2/06/03 skip all other (K K* Kbar K*bar) channels:
        /// C SKIP all other K and K* RESCATTERINGS
        if (fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
          goto statement_400;
        }
        if (lb1 == 21 || lb2 == 21) {
          goto statement_400;
        }
        if (lb1 == 23 || lb2 == 23) {
          goto statement_400;
        }
        /// C
        /// C IF PION+baryon COLLISION GO TO 3
        if ((lb1 >= 3 && lb1 <= 5) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
             (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_3;
        }
        if ((lb2 >= 3 && lb2 <= 5) &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_3;
        }
        /// C
        /// C IF rho(omega)+NUCLEON (baryon resonance) COLLISION GO TO 33
        if ((lb1 >= 25 && lb1 <= 28) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
             (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_33;
        }
        if ((lb2 >= 25 && lb2 <= 28) &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
             (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_33;
        }
        /// C
        /// C IF ETA+NUCLEON (baryon resonance) COLLISIONS GO TO 547
        if (lb1 == 0 && (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2 ||
                         (fem::iabs(lb2) >= 6 && fem::iabs(lb2) <= 13))) {
          goto statement_547;
        }
        if (lb2 == 0 && (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2 ||
                         (fem::iabs(lb1) >= 6 && fem::iabs(lb1) <= 13))) {
          goto statement_547;
        }
        /// C
        /// C IF NUCLEON+BARYON RESONANCE COLLISION GO TO 44
        if ((lb1 == 1 || lb1 == 2) && (lb2 > 5 && lb2 <= 13)) {
          goto statement_44;
        }
        if ((lb2 == 1 || lb2 == 2) && (lb1 > 5 && lb1 <= 13)) {
          goto statement_44;
        }
        if ((lb1 == -1 || lb1 == -2) && (lb2 < -5 && lb2 >= -13)) {
          goto statement_44;
        }
        if ((lb2 == -1 || lb2 == -2) && (lb1 < -5 && lb1 >= -13)) {
          goto statement_44;
        }
        /// C
        /// C IF NUCLEON+NUCLEON COLLISION GO TO 4
        if ((lb1 == 1 || lb1 == 2) && (lb2 == 1 || lb2 == 2)) {
          goto statement_4;
        }
        if ((lb1 == -1 || lb1 == -2) && (lb2 == -1 || lb2 == -2)) {
          goto statement_4;
        }
        /// C
        /// C IF BARYON RESONANCE+BARYON RESONANCE COLLISION GO TO 444
        if ((lb1 > 5 && lb1 <= 13) && (lb2 > 5 && lb2 <= 13)) {
          goto statement_444;
        }
        if ((lb1 < -5 && lb1 >= -13) && (lb2 < -5 && lb2 >= -13)) {
          goto statement_444;
        }
        /// C
        /// C if L/S+L/S or L/s+nucleon go to 400
        /// C otherwise, develop a model for their collisions
        if ((lb1 < 3) && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_400;
        }
        if ((lb2 < 3) && (lb1 >= 14 && lb1 <= 17)) {
          goto statement_400;
        }
        if ((lb1 >= 14 && lb1 <= 17) && (lb2 >= 14 && lb2 <= 17)) {
          goto statement_400;
        }
        /// C
        /// C otherwise, go out of the loop
        goto statement_400;
      /// C
      statement_547:
        if (lb1 * lb2 == 0) {
          /// C (1) FOR ETA+NUCLEON SYSTEM, we allow both elastic collision,
          /// C     i.e. N*(1535) formation and kaon production
          /// C     the total kaon production cross section is
          /// C     ASSUMED to be THE SAME AS PION+NUCLEON COLLISIONS
          /// C (2) for eta+baryon resonance we only allow kaon production
          ece = fem::pow2((em1 + em2 + 0.02f));
          xkaon0 = 0.f;
          if (srt >= 1.63f && srt <= 1.7f) {
            xkaon0 = pnlka(cmn, srt);
          }
          if (srt > 1.7f) {
            xkaon0 = pnlka(cmn, srt) + pnska(cmn, srt);
          }
          /// Cbz3/7/99 neutralk
          xkaon0 = 2.0f * xkaon0;
          /// Cbz3/7/99 neutralk end
          /// C
          /// C Here we negelect eta+n inelastic collisions other than the
          /// C kaon production, therefore the total inelastic cross section
          /// C xkaon equals to the xkaon0 (kaon production cross section)
          xkaon = xkaon0;
          /// C note here the xkaon is in unit of fm**2
          xeta = xn1535(cmn, i1, i2, 0);
          if ((fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13) ||
              (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
            xeta = 0.f;
          }
          if ((xeta + xkaon) <= 1.e-06f) {
            goto statement_400;
          }
          dse = fem::sqrt((xeta + xkaon) / pi);
          deltre = dse + 0.1f;
          px1cm = pcx;
          py1cm = pcy;
          pz1cm = pcz;
          /// C CHECK IF N*(1535) resonance CAN BE FORMED
          distce(cmn, i1, i2, deltre, dse, dt, ece, srt, ic, pcx, pcy, pcz);
          if (ic == -1) {
            goto statement_400;
          }
          ekaon(4, iss)++;
          if (xkaon0 / (xkaon + xeta) > ranart(nseed)) {
            /// C kaon production, USE CREN TO CALCULATE THE MOMENTUM OF L/S K+
            cren(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
            /// C kaon production
            if (iblock == 7) {
              lpn++;
            } else if (iblock == -7) {
            }
            /// C
            em1 = e(i1);
            em2 = e(i2);
            goto statement_440;
          }
          /// C N*(1535) FORMATION
          resona = 1.f;
          goto statement_98;
        }
      /// CIF PION+NUCLEON (baryon resonance) COLLISION THEN
      statement_3:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C the total kaon production cross section for pion+baryon
        /// (resonance) is C assumed to be the same as in pion+nucleon
        xkaon0 = 0.f;
        if (srt >= 1.63f && srt <= 1.7f) {
          xkaon0 = pnlka(cmn, srt);
        }
        if (srt > 1.7f) {
          xkaon0 = pnlka(cmn, srt) + pnska(cmn, srt);
        }
        xkaon0 = 2.0f * xkaon0;
        /// C
        /// C sp11/21/01  phi production: pi +N(D) -> phi + N(D)
        xphi = 0.f;
        if ((((lb1 >= 1 && lb1 <= 2) || (lb1 >= 6 && lb1 <= 9)) ||
             ((lb2 >= 1 && lb2 <= 2) || (lb2 >= 6 && lb2 <= 9))) &&
            srt > 1.958f) {
          pibphi(cmn, srt, lb1, lb2, em1, em2, xphi, xphin);
        }
        /// C !! in fm^2 above
        /// C
        /// C if a pion collide with a baryon resonance,
        /// C we only allow kaon production AND the reabsorption
        /// C processes: Delta+pion-->N+pion, N*+pion-->N+pion
        /// C Later put in pion+baryon resonance elastic
        /// C cross through forming higher resonances implicitly.
        /// C          If(em1.gt.1.or.em2.gt.1.)go to 31
        if ((fem::iabs(lb(i1)) >= 6 && fem::iabs(lb(i1)) <= 13) ||
            (fem::iabs(lb(i2)) >= 6 && fem::iabs(lb(i2)) <= 13)) {
          goto statement_31;
        }
        /// C For pion+nucleon collisions:
        /// C using the experimental pion+nucleon inelastic cross section, we
        /// assume it C is exhausted by the Delta+pion, Delta+rho and
        /// Delta+omega production C and kaon production. In the following we
        /// first check whether C inelastic pion+n collision can happen or not,
        /// then determine in C crpn whether it is through pion production or
        /// through kaon production C note that the xkaon0 is the kaon
        /// production cross section C Note in particular that: C xkaon in the
        /// following is the total pion+nucleon inelastic cross section C note
        /// here the xkaon is in unit of fm**2, xnpi is also in unit of fm**2 C
        /// FOR PION+NUCLEON SYSTEM, THE MINIMUM S IS 1.2056 the minimum srt for
        /// C elastic scattering, and it is 1.60 for pion production, 1.63 for
        /// LAMBDA+kaon C production and 1.7 FOR SIGMA+KAON C (EC = PION
        /// MASS+NUCLEON MASS+20MEV)**2
        ec = fem::pow2((em1 + em2 + 0.02f));
        xkaon = 0.f;
        if (srt > 1.23f) {
          xkaon = (pionpp(cmn, srt) + pipp1(cmn, srt)) / 2.f;
        }
        /// C pion+nucleon elastic cross section is divided into two parts:
        /// C (1) forming D(1232)+N*(1440) +N*(1535)
        /// C (2) cross sections forming higher resonances are calculated as
        /// C     the difference between the total elastic and (1), this part is
        /// C     treated as direct process since we do not explicitLY include
        /// C     higher resonances.
        /// C the following is the resonance formation cross sections.
        /// C1. PION(+)+PROTON-->DELTA++,PION(-)+NEUTRON-->DELTA(-)
        if ((lb1 * lb2 == 5 || ((lb1 * lb2 == 6) && (lb1 == 3 || lb2 == 3))) ||
            (lb1 * lb2 == -3 ||
             ((lb1 * lb2 == -10) && (lb1 == 5 || lb2 == 5)))) {
          xmax = 190.f;
          xmaxn = 0;
          xmaxn1 = 0;
          xdirct = dirct1(cmn, srt);
          goto statement_678;
        }
        /// C2. PION(-)+PROTON-->DELTA0,PION(+)+NEUTRON-->DELTA+
        /// C   or N*(+)(1440) or N*(+)(1535)
        /// C note the factor 2/3 is from the isospin consideration and
        /// C the factor 0.6 or 0.5 is the branching ratio for the resonance to
        /// decay C into pion+nucleon
        if ((lb1 * lb2 == 3 || ((lb1 * lb2 == 10) && (lb1 == 5 || lb2 == 5))) ||
            (lb1 * lb2 == -5 ||
             ((lb1 * lb2 == -6) && (lb1 == 3 || lb2 == 3)))) {
          xmax = 27.f;
          xmaxn = 2.f / 3.f * 25.f * 0.6f;
          xmaxn1 = 2.f / 3.f * 40.f * 0.5f;
          xdirct = dirct2(cmn, srt);
          goto statement_678;
        }
        /// C3. PION0+PROTON-->DELTA+,PION0+NEUTRON-->DELTA0, or N*(0)(1440) or
        /// N*(0)(1535)
        if ((lb1 == 4 || lb2 == 4) &&
            (fem::iabs(lb1 * lb2) == 4 || fem::iabs(lb1 * lb2) == 8)) {
          xmax = 50.f;
          xmaxn = 1.f / 3.f * 25 * 0.6f;
          xmaxn1 = 1 / 3.f * 40.f * 0.5f;
          xdirct = dirct3(cmn, srt);
          goto statement_678;
        }
      statement_678:
        xnpin1 = 0;
        xnpin = 0;
        xnpid = xnpi(cmn, i1, i2, 1, xmax);
        if (xmaxn1 != 0) {
          xnpin1 = xnpi(cmn, i1, i2, 2, xmaxn1);
        }
        if (xmaxn != 0) {
          xnpin = xnpi(cmn, i1, i2, 0, xmaxn);
        }
        /// C the following
        xres = xnpid + xnpin + xnpin1;
        xnelas = xres + xdirct;
        icheck = 1;
        goto statement_34;
      /// C For pion + baryon resonance the reabsorption
      /// C cross section is calculated from the detailed balance
      /// C using reab(i1,i2,srt,ictrl), ictrl=1, 2 and 3
      /// C for pion, rho and omega + baryon resonance
      statement_31:
        ec = fem::pow2((em1 + em2 + 0.02f));
        xreab = reab(cmn, i1, i2, srt, 1);
        /// C
        /// Clin-12/02/00 to satisfy detailed balance, forbid N* absorptions:
        if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
            (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
          xreab = 0.f;
        }
        /// C
        xkaon = xkaon0 + xreab;
        /// C a constant of 10 mb IS USED FOR PION + N* RESONANCE,
        if ((fem::iabs(lb1) > 9 && fem::iabs(lb1) <= 13) ||
            (fem::iabs(lb2) > 9 && fem::iabs(lb2) <= 13)) {
          xnelas = 1.0f;
        } else {
          xnelas = dpion(cmn, em1, em2, lb1, lb2, srt);
        }
        icheck = 2;
      statement_34:
        if ((xnelas + xkaon + xphi) <= 0.000001f) {
          goto statement_400;
        }
        ds = fem::sqrt((xnelas + xkaon + xphi) / pi);
        /// Csp09/20/01
        /// C           totcr = xnelas+xkaon
        /// C           if(srt .gt. 3.5)totcr = max1(totcr,3.)
        /// C           DS=SQRT(totcr/PI)
        /// Csp09/20/01 end
        /// C
        deltar = ds + 0.1f;
        distce(cmn, i1, i2, deltar, ds, dt, ec, srt, ic, pcx, pcy, pcz);
        if (ic == -1) {
          goto statement_400;
        }
        ekaon(4, iss)++;
        /// C***
        /// C check what kind of collision has happened
        /// C (1) pion+baryon resonance
        /// C if direct elastic process
        if (icheck == 2) {
          /// C  !!sp11/21/01
          if (xnelas / (xnelas + xkaon + xphi) >= ranart(nseed)) {
            /// C               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2)
            crdir(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
            goto statement_440;
          } else {
            /// C for inelastic process, go to 96 to check
            /// C kaon production and pion reabsorption : pion+D(N*)-->pion+N
            goto statement_96;
          }
        }
        /// C(2) pion+n
        /// C CHECK IF inELASTIC COLLISION IS POSSIBLE FOR PION+N COLLISIONS
        /// Clin-8/17/00 typo corrected, many other occurences:
        /// C        IF(XKAON/(XKAON+Xnelas).GT.RANART(NSEED))GO TO 95
        if ((xkaon + xphi) / (xkaon + xphi + xnelas) > ranart(nseed)) {
          goto statement_95;
        }
        /// C
        /// C direct process
        if (xdirct / xnelas >= ranart(nseed)) {
          /// C               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2)
          crdir(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
          goto statement_440;
        }
        /// C now resonance formation or direct process (higher resonances)
        if ((lb1 * lb2 == 5 || ((lb1 * lb2 == 6) && (lb1 == 3 || lb2 == 3))) ||
            (lb1 * lb2 == -3 ||
             ((lb1 * lb2 == -10) && (lb1 == 5 || lb2 == 5)))) {
          /// C
          /// C ONLY DELTA RESONANCE IS POSSIBLE, go to 99
          goto statement_99;
        } else {
          /// C NOW BOTH DELTA AND N* RESORANCE ARE POSSIBLE
          /// C DETERMINE THE RESORANT STATE BY USING THE MONTRE CARLO METHOD
          xx = (xnpin + xnpin1) / xres;
          if (ranart(nseed) < xx) {
            /// C N* RESONANCE IS SELECTED
            /// C decide N*(1440) or N*(1535) formation
            xx0 = xnpin / (xnpin + xnpin1);
            if (ranart(nseed) < xx0) {
              resona = 0.f;
              /// C N*(1440) formation
              goto statement_97;
            } else {
              /// C N*(1535) formation
              resona = 1.f;
              goto statement_98;
            }
          } else {
            /// C DELTA RESONANCE IS SELECTED
            goto statement_99;
          }
        }
      statement_97:
        if (resona == 0.f) {
          /// CN*(1440) IS PRODUCED,WE DETERMINE THE CHARGE STATE OF THE
          /// PRODUCED N*
          i = i1;
          if (em1 < 0.6f) {
            i = i2;
          }
          /// C (0.1) n+pion(+)-->N*(+)
          if ((lb1 * lb2 == 10 && (lb1 == 5 || lb2 == 5)) ||
              (lb1 * lb2 == -6 && (lb1 == 3 || lb2 == 3))) {
            lb(i) = 11;
            goto statement_303;
          }
          /// C (0.2) p+pion(0)-->N*(+)
          /// C IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 4 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 11;
            goto statement_303;
          }
          /// C (0.3) n+pion(0)-->N*(0)
          /// C IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 8 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 10;
            goto statement_303;
          }
          /// C (0.4) p+pion(-)-->N*(0)
          /// C            IF(LB(I1)*LB(I2).EQ.3)THEN
          if ((lb(i1) * lb(i2) == 3) || (lb(i1) * lb(i2) == -5)) {
            lb(i) = 10;
          }
        statement_303:
          dreson(cmn, i1, i2);
          if (lb1 < 0 || lb2 < 0) {
            lb(i) = -lb(i);
          }
          lres++;
          goto statement_101;
          /// CCOM: GO TO 101 TO CHANGE THE PHASE SPACE DENSITY OF THE NUCLEON
        }
      statement_98:
        if (resona == 1.f) {
          /// CN*(1535) IS PRODUCED, WE DETERMINE THE CHARGE STATE OF THE
          /// PRODUCED N*
          i = i1;
          if (em1 < 0.6f) {
            i = i2;
          }
          /// C note: this condition applies to both eta and pion
          /// C (0.1) n+pion(+)-->N*(+)
          /// C            IF(LB1*LB2.EQ.10.AND.(LB1.EQ.2.OR.LB2.EQ.2))THEN
          if ((lb1 * lb2 == 10 && (lb1 == 5 || lb2 == 5)) ||
              (lb1 * lb2 == -6 && (lb1 == 3 || lb2 == 3))) {
            lb(i) = 13;
            goto statement_304;
          }
          /// C (0.2) p+pion(0)-->N*(+)
          /// C IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 4 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 13;
            goto statement_304;
          }
          /// C (0.3) n+pion(0)-->N*(0)
          /// C IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
          if (fem::iabs(lb(i1) * lb(i2)) == 8 && (lb(i1) == 4 || lb(i2) == 4)) {
            lb(i) = 12;
            goto statement_304;
          }
          /// C (0.4) p+pion(-)-->N*(0)
          /// C            IF(LB(I1)*LB(I2).EQ.3)THEN
          if ((lb(i1) * lb(i2) == 3) || (lb(i1) * lb(i2) == -5)) {
            lb(i) = 12;
            goto statement_304;
          }
          /// C (0.5) p+eta-->N*(+)(1535),n+eta-->N*(0)(1535)
          if (lb(i1) * lb(i2) == 0) {
            /// C            if((lb(i1).eq.1).or.(lb(i2).eq.1))then
            if (fem::iabs(lb(i1)) == 1 || fem::iabs(lb(i2)) == 1) {
              lb(i) = 13;
              goto statement_304;
            } else {
              lb(i) = 12;
            }
          }
        statement_304:
          dreson(cmn, i1, i2);
          if (lb1 < 0 || lb2 < 0) {
            lb(i) = -lb(i);
          }
          lres++;
          goto statement_101;
          /// CCOM: GO TO 101 TO CHANGE THE PHASE SPACE DENSITY OF THE NUCLEON
        }
      /// CDELTA IS PRODUCED,IN THE FOLLOWING WE DETERMINE THE
      /// CCHARGE STATE OF THE PRODUCED DELTA
      statement_99:
        lres++;
        i = i1;
        if (em1 <= 0.6f) {
          i = i2;
        }
        /// C (1) p+pion(+)-->DELTA(++)
        /// C        IF(LB(I1)*LB(I2).EQ.5)THEN
        if ((lb(i1) * lb(i2) == 5) || (lb(i1) * lb(i2) == -3)) {
          lb(i) = 9;
          goto statement_305;
        }
        /// C (2) p+pion(0)-->delta(+)
        /// C        IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))then
        if (fem::iabs(lb(i1) * lb(i2)) == 4 && (lb(i1) == 4 || lb(i2) == 4)) {
          lb(i) = 8;
          goto statement_305;
        }
        /// C (3) n+pion(+)-->delta(+)
        /// C IF(LB(I1)*LB(I2).EQ.10.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
        if ((lb(i1) * lb(i2) == 10 && (lb(i1) == 5 || lb(i2) == 5)) ||
            (lb(i1) * lb(i2) == -6 && (lb(i1) == 3 || lb(i2) == 3))) {
          lb(i) = 8;
          goto statement_305;
        }
        /// C (4) n+pion(0)-->delta(0)
        /// C        IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
        if (fem::iabs(lb(i1) * lb(i2)) == 8 && (lb(i1) == 4 || lb(i2) == 4)) {
          lb(i) = 7;
          goto statement_305;
        }
        /// C (5) p+pion(-)-->delta(0)
        /// C        IF(LB(I1)*LB(I2).EQ.3)THEN
        if ((lb(i1) * lb(i2) == 3) || (lb(i1) * lb(i2) == -5)) {
          lb(i) = 7;
          goto statement_305;
        }
        /// C (6) n+pion(-)-->delta(-)
        /// C        IF(LB(I1)*LB(I2).EQ.6.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
        if ((lb(i1) * lb(i2) == 6 && (lb(i1) == 3 || lb(i2) == 3)) ||
            (lb(i1) * lb(i2) == -10 && (lb(i1) == 5 || lb(i2) == 5))) {
          lb(i) = 6;
        }
      statement_305:
        dreson(cmn, i1, i2);
        if (lb1 < 0 || lb2 < 0) {
          lb(i) = -lb(i);
        }
        goto statement_101;
      /// C
      /// Csp-11/08/01 K*
      /// C FOR kaON+pion COLLISIONS, form K* (bar) or
      /// C La/Si-bar + N <-- pi + K+
      /// C La/Si + N-bar <-- pi + K-
      /// C phi + K <-- pi + K
      /// Clin (rho,omega) + K* <-- pi + K
      statement_889:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// C the cross section is from C.M. Ko, PRC 23, 2760 (1981).
        spika =
            60.f / (1.f + 4.f * fem::pow2((srt - 0.895f)) / fem::pow2((0.05f)));
        /// C
        /// Cc       if(lb(i1).eq.23.or.lb(i2).eq.23)then   !! block  K- +
        /// pi->La
        /// + B-bar
        /// C
        crkpla(cmn, px1cm, py1cm, pz1cm, ec, srt, spika, emm1, emm2, lbp1, lbp2,
               i1, i2, icase, srhoks);
        /// Cc
        /// C* only K* or K*bar formation
        /// C       else
        /// C      DSkn=SQRT(spika/PI/10.)
        /// C      dsknr=dskn+0.1
        /// C      CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
        /// C    1     PX1CM,PY1CM,PZ1CM)
        /// C        IF(IC.EQ.-1) GO TO 400
        /// C       icase = 1
        /// C      endif
        /// C
        if (icase == 0) {
          iblock = 0;
          goto statement_400;
        }
        /// C
        if (icase == 1) {
          ksreso(cmn, i1, i2);
          /// Clin-4/30/03 give non-zero iblock for resonance selections:
          iblock = 171;
          /// Ctest off for resonance (phi, K*) studies:
          /// C             if(iabs(lb(i1)).eq.30) then
          /// C             write(17,112)
          /// 'ks',lb(i1),p(1,i1),p(2,i1),p(3,i1),e(i1),nt C
          /// elseif(iabs(lb(i2)).eq.30) then C             write(17,112)
          /// 'ks',lb(i2),p(1,i2),p(2,i2),p(3,i2),e(i2),nt C             endif
          /// C
          lres++;
          goto statement_101;
        } else if (icase == 2) {
          iblock = 71;
          /// C
          /// C La/Si (bar) formation
          /// C
        } else if (fem::iabs(icase) == 5) {
          iblock = 88;
          /// C
        } else {
          /// C
          /// C phi formation
          iblock = 222;
        }
        lb(i1) = lbp1;
        lb(i2) = lbp2;
        e(i1) = emm1;
        e(i2) = emm2;
        em1 = e(i1);
        em2 = e(i2);
        ntag = 0;
        goto statement_440;
      /// C
      statement_33:
        em1 = e(i1);
        em2 = e(i2);
        /// C (1) if rho or omega collide with a nucleon we allow both elastic
        /// C     scattering and kaon production to happen if collision
        /// conditions C     are satisfied. C (2) if rho or omega collide with a
        /// baryon resonance we allow C     kaon production, pion reabsorption:
        /// rho(omega)+D(N*)-->pion+N C     and NO elastic scattering to happen
        xelstc = 0;
        if ((lb1 >= 25 && lb1 <= 28) &&
            (fem::iabs(lb2) == 1 || fem::iabs(lb2) == 2)) {
          xelstc = erhon(cmn, em1, em2, lb1, lb2, srt);
        }
        if ((lb2 >= 25 && lb2 <= 28) &&
            (fem::iabs(lb1) == 1 || fem::iabs(lb1) == 2)) {
          xelstc = erhon(cmn, em1, em2, lb1, lb2, srt);
        }
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// C the kaon production cross section is
        xkaon0 = 0;
        if (srt >= 1.63f && srt <= 1.7f) {
          xkaon0 = pnlka(cmn, srt);
        }
        if (srt > 1.7f) {
          xkaon0 = pnlka(cmn, srt) + pnska(cmn, srt);
        }
        if (xkaon0 < 0) {
          xkaon0 = 0;
        }
        /// C
        /// Cbz3/7/99 neutralk
        xkaon0 = 2.0f * xkaon0;
        /// Cbz3/7/99 neutralk end
        /// C
        /// C the total inelastic cross section for rho(omega)+N is
        xkaon = xkaon0;
        ichann = 0;
        /// C the total inelastic cross section for rho (omega)+D(N*) is
        /// C xkaon=xkaon0+reab(**)
        /// C
        /// C sp11/21/01  phi production: rho + N(D) -> phi + N(D)
        xphi = 0.f;
        if (((((lb1 >= 1 && lb1 <= 2) || (lb1 >= 6 && lb1 <= 9)) &&
              (lb2 >= 25 && lb2 <= 27)) ||
             (((lb2 >= 1 && lb2 <= 2) || (lb2 >= 6 && lb2 <= 9)) &&
              (lb1 >= 25 && lb1 <= 27))) &&
            srt > 1.958f) {
          pibphi(cmn, srt, lb1, lb2, em1, em2, xphi, xphin);
        }
        /// C !! in fm^2 above
        /// C
        if ((fem::iabs(lb1) >= 6 && lb2 >= 25) ||
            (lb1 >= 25 && fem::iabs(lb2) >= 6)) {
          ichann = 1;
          ictrl = 2;
          if (lb1 == 28 || lb2 == 28) {
            ictrl = 3;
          }
          xreab = reab(cmn, i1, i2, srt, ictrl);
          /// C
          /// Clin-12/02/00 to satisfy detailed balance, forbid N* absorptions:
          if ((fem::iabs(lb1) >= 10 && fem::iabs(lb1) <= 13) ||
              (fem::iabs(lb2) >= 10 && fem::iabs(lb2) <= 13)) {
            xreab = 0.f;
          }
          /// C
          if (xreab < 0) {
            xreab = 1.e-06f;
          }
          xkaon = xkaon0 + xreab;
          xelstc = 1.0f;
        }
        ds = fem::sqrt((xkaon + xphi + xelstc) / pi);
        /// C
        /// Csp09/20/01
        /// C           totcr = xelstc+xkaon
        /// C           if(srt .gt. 3.5)totcr = max1(totcr,3.)
        /// C           DS=SQRT(totcr/PI)
        /// Csp09/20/01 end
        /// C
        deltar = ds + 0.1f;
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C CHECK IF the collision can happen
        distce(cmn, i1, i2, deltar, ds, dt, ec, srt, ic, pcx, pcy, pcz);
        if (ic == -1) {
          goto statement_400;
        }
        ekaon(4, iss)++;
        /// C*
        /// C NOW rho(omega)+N or D(N*) COLLISION IS POSSIBLE
        /// C (1) check elastic collision
        if (xelstc / (xelstc + xkaon + xphi) > ranart(nseed)) {
          /// C       call crdir(px1CM,py1CM,pz1CM,srt,I1,i2)
          crdir(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
          goto statement_440;
        }
        /// C (2) check pion absorption or kaon production
        crrd(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, xkaon0, xkaon, xphi,
             xphin);
        /// C
        /// C kaon production
        /// Csp05/16/01
        if (iblock == 7) {
          lpn++;
        } else if (iblock == -7) {
        }
        /// Csp05/16/01 end
        /// C rho obsorption
        if (iblock == 81) {
          lrhor++;
        }
        /// C omega obsorption
        if (iblock == 82) {
          lomgar++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C for pion+n now using the subroutine crpn to change
      /// C the particle label and set the new momentum of L/S+K final state
      statement_95:
        /// C NOW PION+N INELASTIC COLLISION IS POSSIBLE
        /// C check pion production or kaon production
        crpn(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, xkaon0, xkaon, xphi,
             xphin);
        /// C
        /// C kaon production
        /// Csp05/16/01
        if (iblock == 7) {
          lpn++;
        } else if (iblock == -7) {
        }
        /// Csp05/16/01 end
        /// C pion production
        if (iblock == 77) {
          lpd++;
        }
        /// C rho production
        if (iblock == 78) {
          lrho++;
        }
        /// C omega production
        if (iblock == 79) {
          lomega++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C for pion+D(N*) now using the subroutine crpd to
      /// C (1) check kaon production or pion reabsorption
      /// C (2) change the particle label and set the new
      /// C     momentum of L/S+K final state
      statement_96:
        crpd(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, xkaon0, xkaon, xphi,
             xphin);
        /// C
        /// C kaon production
        /// Csp05/16/01
        if (iblock == 7) {
          lpn++;
        } else if (iblock == -7) {
        }
        /// Csp05/16/01 end
        /// C pion obserption
        if (iblock == 80) {
          lpdr++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C CALCULATE KAON PRODUCTION PROBABILITY FROM PION + N COLLISIONS
      /// C        IF(SRT.GT.1.615)THEN
      /// C        CALL PKAON(SRT,XXp,PK)
      /// C        TKAON(7)=TKAON(7)+PK
      /// C        EKAON(7,ISS)=EKAON(7,ISS)+1
      /// C        CALL KSPEC1(SRT,PK)
      /// C        call LK(3,srt,iseed,pk)
      /// C        ENDIF
      /// C negelecting the pauli blocking at high energies
      /// C
      statement_101:
        if (e(i2) == 0.f) {
          goto statement_600;
        }
        if (e(i1) == 0.f) {
          goto statement_800;
        }
      /// C IF NUCLEON+BARYON RESONANCE COLLISIONS
      statement_44:
        /// C CALCULATE THE TOTAL CROSS SECTION OF NUCLEON+ BARYON RESONANCE
        /// COLLISION C WE ASSUME THAT THE ELASTIC CROSS SECTION IS THE SAME AS
        /// NUCLEON+NUCLEON C COM: WE USE THE PARAMETERISATION BY CUGNON FOR LOW
        /// ENERGIES C      AND THE PARAMETERIZATIONS FROM CERN DATA BOOK FOR
        /// HIGHER C      ENERGIES. THE CUTOFF FOR THE TOTAL CROSS SECTION IS 55
        /// MB
        cutoff = em1 + em2 + 0.02f;
        if (srt <= cutoff) {
          goto statement_400;
        }
        if (srt > 2.245f) {
          signn = pp2(cmn, srt);
        } else {
          signn = 35.0f / (1.f + (srt - cutoff) * 100.0f) + 20.0f;
        }
        xnd(cmn, pcx, pcy, pcz, srt, i1, i2, xinel, sigk, xsk1, xsk2, xsk3,
            xsk4, xsk5);
        sig = signn + xinel;
        /// C For nucleon+baryon resonance collision, the minimum cms**2 energy
        /// is
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// C CHECK THE DISTENCE BETWEEN THE TWO PARTICLES
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C
        /// Clin-6/2008 Deuteron production:
        ianti = 0;
        if (lb(i1) < 0 && lb(i2) < 0) {
          ianti = 1;
        }
        sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
        sig += sdprod;
        /// Clin-6/2008 perturbative treatment of deuterons:
        ipdflag = 0;
        if (idpert == 1) {
          ipert1 = 1;
          sigr0 = sig;
          dspert = fem::sqrt(sigr0 / pi / 10.f);
          dsrpert = dspert + 0.1f;
          distce(cmn, i1, i2, dsrpert, dspert, dt, ec, srt, ic, px1cm, py1cm,
                 pz1cm);
          if (ic == -1) {
            goto statement_363;
          }
          signn0 = 0.f;
          crnd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, signn0,
               sigr0, sigk, xsk1, xsk2, xsk3, xsk4, xsk5, nt, ipert1);
          /// C     &  IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
          ipdflag = 1;
        statement_363:
          ipert1 = 0;
        }
        if (idpert == 2) {
          ipert1 = 1;
        }
        /// C
        ds = fem::sqrt(sig / (10.f * pi));
        deltar = ds + 0.1f;
        distce(cmn, i1, i2, deltar, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        /// C        IF(IC.EQ.-1)GO TO 400
        if (ic == -1) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        /// C
        ekaon(3, iss)++;
        /// C CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON + BARYON
        /// RESONANCE C COLLISIONS
        goto statement_361;
      /// C
      /// C CHECK WHAT KIND OF COLLISION HAS HAPPENED
      statement_361:
        crnd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, signn, sig,
             sigk, xsk1, xsk2, xsk3, xsk4, xsk5, nt, ipert1);
        /// C     &  IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
        if (iblock == 0 && ipdflag == 1) {
          iblock = 501;
        }
        if (iblock == 11) {
          lndk++;
          goto statement_400;
          /// C        elseIF(IBLOCK.EQ.-11) then
        } else if (iblock == -11 || iblock == 501) {
          goto statement_400;
        }
        if (iblock == 222) {
          /// C    !! sp12/17/01
          goto statement_400;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C IF NUCLEON+NUCLEON OR BARYON RESONANCE+BARYON RESONANCE COLLISIONS
      statement_4:
        /// C PREPARE THE EALSTIC CROSS SECTION FOR BARYON+BARYON COLLISIONS
        /// C COM: WE USE THE PARAMETERISATION BY CUGNON FOR SRT LEQ 2.0 GEV
        /// C      AND THE PARAMETERIZATIONS FROM CERN DATA BOOK FOR HIGHER
        /// C      ENERGIES. THE CUTOFF FOR THE TOTAL CROSS SECTION IS 55 MB
        /// C      WITH LOW-ENERGY-CUTOFF
        cutoff = em1 + em2 + 0.14f;
        /// C AT HIGH ENERGIES THE ISOSPIN DEPENDENCE IS NEGLIGIBLE
        /// C THE TOTAL CROSS SECTION IS TAKEN AS THAT OF THE PP
        /// C ABOVE E_KIN=800 MEV, WE USE THE ISOSPIN INDEPENDNET XSECTION
        if (srt > 2.245f) {
          sig = ppt(cmn, srt);
          signn = sig - pp1(cmn, srt);
        } else {
          /// C AT LOW ENERGIES THE ISOSPIN DEPENDENCE FOR NN COLLISION IS
          /// STRONG
          sig = xpp(cmn, srt);
          if (zet(lb(i1)) * zet(lb(i2)) <= 0) {
            sig = xnp(cmn, srt);
          }
          if (zet(lb(i1)) * zet(lb(i2)) > 0) {
            sig = xpp(cmn, srt);
          }
          if (zet(lb(i1)) == 0 && zet(lb(i2)) == 0) {
            sig = xpp(cmn, srt);
          }
          if ((lb(i1) == -1 && lb(i2) == -2) ||
              (lb(i2) == -1 && lb(i1) == -2)) {
            sig = xnp(cmn, srt);
          }
          /// C     WITH LOW-ENERGY-CUTOFF
          if (srt < 1.897f) {
            signn = sig;
          } else {
            signn = 35.0f / (1.f + (srt - 1.897f) * 100.0f) + 20.0f;
          }
        }
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// Clin-5/2008 Deuteron production cross sections were not included
        /// C     in the previous parameterized inelastic cross section of NN
        /// collisions C     (SIGinel=SIG-SIGNN), so they are added here:
        ianti = 0;
        if (lb(i1) < 0 && lb(i2) < 0) {
          ianti = 1;
        }
        sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
        sig += sdprod;
        /// C
        /// Clin-5/2008 perturbative treatment of deuterons:
        ipdflag = 0;
        if (idpert == 1) {
          /// C     For idpert=1: ipert1=1 means we will first treat deuteron
          /// perturbatively, C     then we set ipert1=0 to treat regular NN or
          /// NbarNbar collisions including C     the regular deuteron
          /// productions. C     ipdflag=1 means perturbative deuterons are
          /// produced here:
          ipert1 = 1;
          ec = fem::pow2(2.012f);
          /// C     Use the same cross section for NN/NNBAR collisions
          /// C     to trigger perturbative production
          sigr0 = sig;
          /// C     One can also trigger with X*sbbdm() so the weight will not
          /// be too small; C     but make sure to limit the maximum trigger
          /// Xsec: C sigr0=sdprod*25. C           if(sigr0.ge.100.) sigr0=100.
          dspert = fem::sqrt(sigr0 / pi / 10.f);
          dsrpert = dspert + 0.1f;
          distce(cmn, i1, i2, dsrpert, dspert, dt, ec, srt, ic, px1cm, py1cm,
                 pz1cm);
          if (ic == -1) {
            goto statement_365;
          }
          signn0 = 0.f;
          crnn(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag,
               signn0, sigr0, nt, ipert1);
          ipdflag = 1;
        statement_365:
          ipert1 = 0;
        }
        if (idpert == 2) {
          ipert1 = 1;
        }
        /// C
        /// Clin-5/2008 in case perturbative deuterons are produced for
        /// idpert=1: C        IF(SIGNN.LE.0)GO TO 400
        if (signn <= 0) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        /// C
        ec = 3.59709f;
        ds = fem::sqrt(sig / pi / 10.f);
        dsr = ds + 0.1f;
        if ((e(i1) >= 1.f) && (e(i2) >= 1.f)) {
          ec = 4.75f;
        }
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        /// Clin-5/2008 in case perturbative deuterons are produced above:
        /// C        IF(IC.EQ.-1) GO TO 400
        if (ic == -1) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        /// C
        /// C CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON+NUCLEON OR
        /// C RESONANCE+RESONANCE COLLISIONS
        goto statement_362;
      /// C
      /// C CHECK WHAT KIND OF COLLISION HAS HAPPENED
      statement_362:
        ekaon(1, iss)++;
        crnn(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, signn,
             sig, nt, ipert1);
        /// Clin-5/2008 give iblock # in case pert deuterons are produced for
        /// idpert=1:
        if (iblock == 0 && ipdflag == 1) {
          iblock = 501;
        }
        /// Clin-5/2008 add iblock # for deuteron formation:
        /// C IF(IBLOCK.EQ.4.OR.IBLOCK.Eq.9.or.iblock.ge.44.OR.IBLOCK.EQ.-9 C &
        /// .or.iblock.eq.222)THEN
        if (iblock == 4 || iblock == 9 || iblock >= 44 || iblock == -9 ||
            iblock == 222 || iblock == 501) {
          /// C
          /// C     !! sp12/17/01 above
          /// C momentum of the three particles in the final state have been
          /// calculated C in the crnn, go out of the loop
          lcoll++;
          if (iblock == 4) {
            ldirt++;
          } else if (iblock == 44) {
            lddrho++;
          } else if (iblock == 45) {
            lnnrho++;
          } else if (iblock == 46) {
            lnnom++;
          } else if (iblock == 222) {
          } else if (iblock == 9) {
            lnnk++;
          } else if (iblock == -9) {
          }
          goto statement_400;
        }
        /// C
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// Clin-8/2008 B+B->Deuteron+Meson over
      /// C
      /// Clin-8/2008 Deuteron+Meson->B+B collisions:
      statement_505:
        ianti = 0;
        if (lb(i1) < 0 || lb(i2) < 0) {
          ianti = 1;
        }
        sdmbb(cmn, srt, sdm, ianti);
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C     minimum srt**2, note a 2.012GeV lower cutoff is used in
        /// N+N->Deuteron+pi:
        ec = fem::pow2(2.012f);
        ds = fem::sqrt(sdm / 31.4f);
        dsr = ds + 0.1f;
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crdmbb(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, sdm, nt,
               ianti);
        lcoll++;
        goto statement_400;
      /// Clin-8/2008 Deuteron+Meson->B+B collisions over
      /// C
      /// Clin-9/2008 Deuteron+Baryon elastic collisions:
      statement_506:
        ianti = 0;
        if (lb(i1) < 0 || lb(i2) < 0) {
          ianti = 1;
        }
        sdbelastic(cmn, srt, sdb);
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C     minimum srt**2, note a 2.012GeV lower cutoff is used in
        /// N+N->Deuteron+pi:
        ec = fem::pow2(2.012f);
        ds = fem::sqrt(sdb / 31.4f);
        dsr = ds + 0.1f;
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crdbel(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, sdb, nt,
               ianti);
        lcoll++;
        goto statement_400;
      /// Clin-9/2008 Deuteron+Baryon elastic collisions over
      /// C
      /// C IF BARYON RESONANCE+BARYON RESONANCE COLLISIONS
      statement_444:
        /// C PREPARE THE EALSTIC CROSS SECTION FOR BARYON+BARYON COLLISIONS
        cutoff = em1 + em2 + 0.02f;
        /// C AT HIGH ENERGIES THE ISOSPIN DEPENDENCE IS NEGLIGIBLE
        /// C THE TOTAL CROSS SECTION IS TAKEN AS THAT OF THE PP
        if (srt <= cutoff) {
          goto statement_400;
        }
        if (srt > 2.245f) {
          signn = pp2(cmn, srt);
        } else {
          signn = 35.0f / (1.f + (srt - cutoff) * 100.0f) + 20.0f;
        }
        if (signn <= 0) {
          goto statement_400;
        }
        xddin(cmn, pcx, pcy, pcz, srt, i1, i2, xinel, sigk, xsk1, xsk2, xsk3,
              xsk4, xsk5);
        sig = signn + xinel;
        ec = fem::pow2((em1 + em2 + 0.02f));
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C
        /// Clin-6/2008 Deuteron production:
        ianti = 0;
        if (lb(i1) < 0 && lb(i2) < 0) {
          ianti = 1;
        }
        sbbdm(cmn, srt, sdprod, ianti, lbm, xmm, pfinal);
        sig += sdprod;
        /// Clin-6/2008 perturbative treatment of deuterons:
        ipdflag = 0;
        if (idpert == 1) {
          ipert1 = 1;
          sigr0 = sig;
          dspert = fem::sqrt(sigr0 / pi / 10.f);
          dsrpert = dspert + 0.1f;
          distce(cmn, i1, i2, dsrpert, dspert, dt, ec, srt, ic, px1cm, py1cm,
                 pz1cm);
          if (ic == -1) {
            goto statement_367;
          }
          signn0 = 0.f;
          crdd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag,
               signn0, sigr0, nt, ipert1);
          /// C     1          IBLOCK,NTAG,SIGNN,SIG)
          ipdflag = 1;
        statement_367:
          ipert1 = 0;
        }
        if (idpert == 2) {
          ipert1 = 1;
        }
        /// C
        ds = fem::sqrt(sig / 31.4f);
        dsr = ds + 0.1f;
        distce(cmn, i1, i2, dsr, ds, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        /// C        IF(IC.EQ.-1) GO TO 400
        if (ic == -1) {
          if (ipdflag == 1) {
            iblock = 501;
          }
          goto statement_400;
        }
        /// C
        /// C CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON+NUCLEON OR
        /// C RESONANCE+RESONANCE COLLISIONS
        goto statement_364;
      /// C
      /// C CHECK WHAT KIND OF COLLISION HAS HAPPENED
      statement_364:
        ekaon(2, iss)++;
        /// C for resonance+resonance
        /// Clin-6/2008:
        crdd(cmn, irun, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ntag, signn,
             sig, nt, ipert1);
        /// C     1  IBLOCK,NTAG,SIGNN,SIG)
        if (iblock == 0 && ipdflag == 1) {
          iblock = 501;
        }
        /// C
        if (fem::iabs(iblock) == 10) {
          /// C momentum of the three particles in the final state have been
          /// calculated C in the crnn, go out of the loop
          lcoll++;
          if (iblock == 10) {
            lddk++;
          } else if (iblock == -10) {
          }
          goto statement_400;
        }
        /// Clin-6/2008
        /// C        if(iblock .eq. 222)then
        if (iblock == 222 || iblock == 501) {
          /// C    !! sp12/17/01
          goto statement_400;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C FOR PION+PION,pion+eta, eta+eta and rho(omega)+pion(rho,omega) or
      /// eta
      statement_777:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        /// C energy thresh for collisions
        ec0 = em1 + em2 + 0.02f;
        if (srt <= ec0) {
          goto statement_400;
        }
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// C we negelect the elastic collision between mesons except that
        /// betwen C two pions because of the lack of information about these
        /// collisions C However, we do let them to collide inelastically to
        /// produce kaons Clin-8/15/02       ppel=1.e-09
        ppel = 20.f;
        ipp = 1;
        if (lb1 < 3 || lb1 > 5 || lb2 < 3 || lb2 > 5) {
          goto statement_778;
        }
        ppxs(cmn, lb1, lb2, srt, ppsig, spprho, ipp);
        ppel = ppsig;
      statement_778:
        ppink = pipik(cmn, srt);
        /// C
        /// C pi+eta and eta+eta are assumed to be the same as pipik( for pi+pi
        /// -> K+K-) C estimated from Ko's paper:
        ppink = 2.0f * ppink;
        if (lb1 >= 25 && lb2 >= 25) {
          ppink = rrkk;
        }
        /// C
        /// Clin-2/13/03 include omega the same as rho, eta the same as pi:
        /// C        if(((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.25.and.lb2.le.27))
        /// C     1 .or.((lb2.ge.3.and.lb2.le.5).and.(lb1.ge.25.and.lb1.le.27)))
        if (((lb1 == 0 || (lb1 >= 3 && lb1 <= 5)) &&
             (lb2 >= 25 && lb2 <= 28)) ||
            ((lb2 == 0 || (lb2 >= 3 && lb2 <= 5)) &&
             (lb1 >= 25 && lb1 <= 28))) {
          ppink = 0.f;
          if (srt >= (aka + aks)) {
            ppink = prkk;
          }
        }
        /// C
        /// C pi pi <-> rho rho:
        spprr(cmn, lb1, lb2, srt);
        /// Clin-4/03/02 pi pi <-> eta eta:
        sppee(cmn, lb1, lb2, srt);
        /// Clin-4/03/02 pi pi <-> pi eta:
        spppe(cmn, lb1, lb2, srt);
        /// Clin-4/03/02 rho pi <-> rho eta:
        srpre(cmn, lb1, lb2, srt);
        /// Clin-4/03/02 omega pi <-> omega eta:
        sopoe(cmn, lb1, lb2, srt);
        /// Clin-4/03/02 rho rho <-> eta eta:
        srree(cmn, lb1, lb2, srt);
        /// C
        ppinnb = 0.f;
        if (srt > thresh(1)) {
          getnst(cmn, srt);
          if (lb1 >= 3 && lb1 <= 5 && lb2 >= 3 && lb2 <= 5) {
            ppinnb = ppbbar(cmn, srt);
          } else if ((lb1 >= 3 && lb1 <= 5 && lb2 >= 25 && lb2 <= 27) ||
                     (lb2 >= 3 && lb2 <= 5 && lb1 >= 25 && lb1 <= 27)) {
            ppinnb = prbbar(cmn, srt);
          } else if (lb1 >= 25 && lb1 <= 27 && lb2 >= 25 && lb2 <= 27) {
            ppinnb = rrbbar(cmn, srt);
          } else if ((lb1 >= 3 && lb1 <= 5 && lb2 == 28) ||
                     (lb2 >= 3 && lb2 <= 5 && lb1 == 28)) {
            ppinnb = pobbar(cmn, srt);
          } else if ((lb1 >= 25 && lb1 <= 27 && lb2 == 28) ||
                     (lb2 >= 25 && lb2 <= 27 && lb1 == 28)) {
            ppinnb = robbar(cmn, srt);
          } else if (lb1 == 28 && lb2 == 28) {
            ppinnb = oobbar(cmn, srt);
          } else {
            if (lb1 != 0 && lb2 != 0) {
              write(6, star), "missed MM lb1,lb2=", lb1, lb2;
            }
          }
        }
        ppin = ppink + ppinnb + cmn.pprr + cmn.ppee + cmn.pppe + cmn.rpre +
               cmn.xopoe + cmn.rree;
        /// C
        /// C check if a collision can happen
        if ((ppel + ppin) <= 0.01f) {
          goto statement_400;
        }
        dspp = fem::sqrt((ppel + ppin) / 31.4f);
        dsppr = dspp + 0.1f;
        distce(cmn, i1, i2, dsppr, dspp, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        if (ppel == 0) {
          goto statement_400;
        }
        /// C the collision can happen
        /// C check what kind collision has happened
        ekaon(5, iss)++;
        crpp(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock, ppel, ppin, spprho,
             ipp);
        /// C
        /// C rho formation, go to 400
        /// C       if(iblock.eq.666)go to 600
        if (iblock == 666) {
          goto statement_555;
        }
        if (iblock == 6) {
          lpp++;
        }
        if (iblock == 66) {
          lppk++;
        } else if (iblock == 366) {
          lppk++;
        } else if (iblock == 367) {
          lppk++;
        }
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C In this block we treat annihilations of
      /// Clin-9/28/00* an anti-nucleon and a baryon or baryon resonance
      /// C an anti-baryon and a baryon (including resonances)
      statement_2799:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// Clin assume the same cross section (as a function of sqrt s) as for
        /// PPbar:
        /// C
        /// Clin-ctest annih maximum
        /// C        DSppb=SQRT(amin1(xppbar(srt),30.)/PI/10.)
        dsppb = fem::sqrt(xppbar(cmn, srt) / pi / 10.f);
        dsppbr = dsppb + 0.1f;
        distce(cmn, i1, i2, dsppbr, dsppb, dt, ec, srt, ic, px1cm, py1cm,
               pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crppba(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      statement_3555:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        dskk = fem::sqrt(sig / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crlaba(cmn, px1cm, py1cm, pz1cm, srt, brel, brsgm, i1, i2, nt, iblock,
               nchrg, icase);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C perturbative production of cascade and omega
      statement_3455:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        pertur(cmn, px1cm, py1cm, pz1cm, srt, irun, i1, i2, nt, kp, icontp);
        if (icontp == 0) {
          /// C     inelastic collisions:
          em1 = e(i1);
          em2 = e(i2);
          iblock = 727;
          goto statement_440;
        }
        /// C     elastic collisions:
        if (e(i1) == 0.f) {
          goto statement_800;
        }
        if (e(i2) == 0.f) {
          goto statement_600;
        }
        goto statement_400;
      /// C
      /// C* phi + N --> pi+N(D),  N(D,N*)+N(D,N*),  K+ +La
      /// C* phi + D --> pi+N(D)
      statement_7222:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        xphib(cmn, lb1, lb2, em1, em2, srt, xsk1, xsk2, xsk3, xsk4, xsk5, sigp);
        dskk = fem::sqrt(sigp / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crphib(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, xsk1, xsk2, xsk3, xsk4,
               xsk5, sigp, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C* phi + M --> K+ + K* .....
      statement_7444:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        phimes(cmn, i1, i2, srt, xsk1, xsk2, xsk3, xsk4, xsk5, xsk6, sve.xsk7,
               sigphi);
        dskk = fem::sqrt(sigphi / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        /// C*---
        pzrt = p(3, i1) + p(3, i2);
        er1 = fem::sqrt(fem::pow2(p(1, i1)) + fem::pow2(p(2, i1)) +
                        fem::pow2(p(3, i1)) + fem::pow2(e(i1)));
        er2 = fem::sqrt(fem::pow2(p(1, i2)) + fem::pow2(p(2, i2)) +
                        fem::pow2(p(3, i2)) + fem::pow2(e(i2)));
        ert = er1 + er2;
        yy = 0.5f * fem::log((ert + pzrt) / (ert - pzrt));
        /// C*------
        crphim(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, xsk1, xsk2, xsk3, xsk4,
               xsk5, xsk6, sigphi, ikkg, ikkl, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C lambda-N elastic xsection, Li & Ko, PRC 54(1996)1897.
      statement_7799:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        lambar(cmn, i1, i2, srt, siglab);
        dshn = fem::sqrt(siglab / pi / 10.f);
        dshnr = dshn + 0.1f;
        distce(cmn, i1, i2, dshnr, dshn, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crhb(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C* K+ + La(Si) --> Meson + B
      /// C* K- + La(Si)-bar --> Meson + B-bar
      statement_5699:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        xkhype(cmn, i1, i2, srt, xky1, xky2, xky3, xky4, xky5, xky6, xky7, xky8,
               xky9, xky10, xky11, xky12, xky13, xky14, xky15, xky16, xky17,
               sigk);
        dskk = fem::sqrt(sigk / pi);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        /// C
        if (lb(i1) == 23 || lb(i2) == 23) {
          ikmp = 1;
        } else {
          ikmp = -1;
        }
        crkhyp(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, xky1, xky2, xky3, xky4,
               xky5, xky6, xky7, xky8, xky9, xky10, xky11, xky12, xky13, xky14,
               xky15, xky16, xky17, sigk, ikmp, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C khyperon end
      /// C
      /// Csp11/03/01 La/Si-bar + N --> pi + K+
      /// C  La/Si + N-bar --> pi + K-
      statement_5999:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        sigkp = 15.f;
        /// C      if((lb1.ge.14.and.lb1.le.17)
        /// C     &    .or.(lb2.ge.14.and.lb2.le.17))sigkp=10.
        dskk = fem::sqrt(sigkp / pi / 10.f);
        dskk0 = dskk + 0.1f;
        distce(cmn, i1, i2, dskk0, dskk, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        /// C
        crlan(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C*
      /// C K(K*) + K(K*) --> phi + pi(rho,omega)
      statement_8699:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// C  CALL CROSSKKPHI(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)  used for
        /// KK*->phi+rho
        /// C
        crkphi(cmn, px1cm, py1cm, pz1cm, ec, srt, iblock, emm1, emm2, lbp1,
               lbp2, i1, i2, sve.ikk, icase, rrkk, prkk);
        if (icase == 0) {
          iblock = 0;
          goto statement_400;
        }
        /// C
        /// C*---
        if (lbp1 == 29 || lbp2 == 29) {
          pzrt = p(3, i1) + p(3, i2);
          er1 = fem::sqrt(fem::pow2(p(1, i1)) + fem::pow2(p(2, i1)) +
                          fem::pow2(p(3, i1)) + fem::pow2(e(i1)));
          er2 = fem::sqrt(fem::pow2(p(1, i2)) + fem::pow2(p(2, i2)) +
                          fem::pow2(p(3, i2)) + fem::pow2(e(i2)));
          ert = er1 + er2;
          yy = 0.5f * fem::log((ert + pzrt) / (ert - pzrt));
          /// C*------
          iblock = 222;
          ntag = 0;
        }
        /// C
        lb(i1) = lbp1;
        lb(i2) = lbp2;
        e(i1) = emm1;
        e(i2) = emm2;
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C*
      /// C rho(omega) + K(K*)  --> phi + K(K*)
      statement_8799:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        /// C  CALL CROSSKKPHI(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)  used for
        /// KK*->phi+rho
        crksph(cmn, px1cm, py1cm, pz1cm, ec, srt, emm1, emm2, lbp1, lbp2, i1,
               i2, ikkg, ikkl, iblock, icase, srhoks);
        if (icase == 0) {
          iblock = 0;
          goto statement_400;
        }
        /// C
        if (lbp1 == 29 || lbp2 == 20) {
          /// C*---
          pzrt = p(3, i1) + p(3, i2);
          er1 = fem::sqrt(fem::pow2(p(1, i1)) + fem::pow2(p(2, i1)) +
                          fem::pow2(p(3, i1)) + fem::pow2(e(i1)));
          er2 = fem::sqrt(fem::pow2(p(1, i2)) + fem::pow2(p(2, i2)) +
                          fem::pow2(p(3, i2)) + fem::pow2(e(i2)));
          ert = er1 + er2;
          yy = 0.5f * fem::log((ert + pzrt) / (ert - pzrt));
        }
        /// C
        lb(i1) = lbp1;
        lb(i2) = lbp2;
        e(i1) = emm1;
        e(i2) = emm2;
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C
      /// C for kaon+baryon scattering, using a constant xsection of 10 mb.
      statement_888:
        px1cm = pcx;
        py1cm = pcy;
        pz1cm = pcz;
        ec = fem::pow2((em1 + em2 + 0.02f));
        sig = 10.f;
        if (fem::iabs(lb1) == 14 || fem::iabs(lb2) == 14 ||
            fem::iabs(lb1) == 30 || fem::iabs(lb2) == 30) {
          sig = 20.f;
        }
        if (lb1 == 29 || lb2 == 29) {
          sig = 5.0f;
        }
        /// C
        dskn = fem::sqrt(sig / pi / 10.f);
        dsknr = dskn + 0.1f;
        distce(cmn, i1, i2, dsknr, dskn, dt, ec, srt, ic, px1cm, py1cm, pz1cm);
        if (ic == -1) {
          goto statement_400;
        }
        crkn(cmn, px1cm, py1cm, pz1cm, srt, i1, i2, iblock);
        em1 = e(i1);
        em2 = e(i2);
        goto statement_440;
      /// C**
      /// C
      statement_440:
        /// C                IBLOCK = 0 ; NOTHING HAS HAPPENED
        /// C                IBLOCK = 1 ; ELASTIC N-N COLLISION
        /// C                IBLOCK = 2 ; N + N -> N + DELTA
        /// C                IBLOCK = 3 ; N + DELTA -> N + N
        /// C                IBLOCK = 4 ; N + N -> d + d + PION,DIRECT PROCESS
        /// C               IBLOCK = 5 ; D(N*)+D(N*) COLLISIONS
        /// C                IBLOCK = 6 ; PION+PION COLLISIONS
        /// C                iblock = 7 ; pion+nucleon-->l/s+kaon
        /// C               iblock =77;  pion+nucleon-->delta+pion
        /// C               iblock = 8 ; kaon+baryon rescattering
        /// C                IBLOCK = 9 ; NN-->KAON+X
        /// C                IBLOCK = 10; DD-->KAON+X
        /// C               IBLOCK = 11; ND-->KAON+X
        /// Cbali2/1/99
        /// C
        /// C           iblock   - 1902 annihilation-->pion(+)+pion(-)   (2
        /// pion) C           iblock   - 1903 annihilation-->pion(+)+rho(-) (3
        /// pion) C           iblock   - 1904 annihilation-->rho(+)+rho(-) (4
        /// pion) C           iblock   - 1905 annihilation-->rho(0)+omega (5
        /// pion) C           iblock   - 1906 annihilation-->omega+omega (6
        /// pion) Cbali3/5/99 C           iblock   - 1907 K+K- to pi+pi-
        /// Cbali3/5/99 end
        /// Cbz3/9/99 khyperon
        /// C           iblock   - 1908 K+Y -> piN
        /// Cbz3/9/99 khyperon end
        /// Cbali2/1/99end
        /// C
        /// Clin-9/28/00 Processes: m(pi rho omega)+m(pi rho omega)
        /// C     to anti-(p n D N*1 N*2)+(p n D N*1 N*2):
        /// C           iblock   - 1801  mm -->pbar p
        /// C           iblock   - 18021 mm -->pbar n
        /// C           iblock   - 18022 mm -->nbar p
        /// C           iblock   - 1803  mm -->nbar n
        /// C           iblock   - 18041 mm -->pbar Delta
        /// C           iblock   - 18042 mm -->anti-Delta p
        /// C           iblock   - 18051 mm -->nbar Delta
        /// C           iblock   - 18052 mm -->anti-Delta n
        /// C           iblock   - 18061 mm -->pbar N*(1400)
        /// C           iblock   - 18062 mm -->anti-N*(1400) p
        /// C           iblock   - 18071 mm -->nbar N*(1400)
        /// C           iblock   - 18072 mm -->anti-N*(1400) n
        /// C           iblock   - 1808  mm -->anti-Delta Delta
        /// C           iblock   - 18091 mm -->pbar N*(1535)
        /// C           iblock   - 18092 mm -->anti-N*(1535) p
        /// C           iblock   - 18101 mm -->nbar N*(1535)
        /// C           iblock   - 18102 mm -->anti-N*(1535) n
        /// C           iblock   - 18111 mm -->anti-Delta N*(1440)
        /// C           iblock   - 18112 mm -->anti-N*(1440) Delta
        /// C           iblock   - 18121 mm -->anti-Delta N*(1535)
        /// C           iblock   - 18122 mm -->anti-N*(1535) Delta
        /// C           iblock   - 1813  mm -->anti-N*(1440) N*(1440)
        /// C           iblock   - 18141 mm -->anti-N*(1440) N*(1535)
        /// C           iblock   - 18142 mm -->anti-N*(1535) N*(1440)
        /// C           iblock   - 1815  mm -->anti-N*(1535) N*(1535)
        /// Clin-9/28/00-end
        /// C
        /// Clin-10/08/00 Processes: pi pi <-> rho rho
        /// C           iblock   - 1850  pi pi -> rho rho
        /// C           iblock   - 1851  rho rho -> pi pi
        /// Clin-10/08/00-end
        /// C
        /// Clin-08/14/02 Processes: pi pi <-> eta eta
        /// C           iblock   - 1860  pi pi -> eta eta
        /// C           iblock   - 1861  eta eta -> pi pi
        /// C Processes: pi pi <-> pi eta
        /// C           iblock   - 1870  pi pi -> pi eta
        /// C           iblock   - 1871  pi eta -> pi pi
        /// C Processes: rho pi <-> rho eta
        /// C           iblock   - 1880  pi pi -> pi eta
        /// C           iblock   - 1881  pi eta -> pi pi
        /// C Processes: omega pi <-> omega eta
        /// C           iblock   - 1890  pi pi -> pi eta
        /// C           iblock   - 1891  pi eta -> pi pi
        /// C Processes: rho rho <-> eta eta
        /// C           iblock   - 1895  rho rho -> eta eta
        /// C           iblock   - 1896  eta eta -> rho rho
        /// Clin-08/14/02-end
        /// C
        /// Clin-11/07/00 Processes:
        /// C           iblock   - 366  pi rho -> K* Kbar or K*bar K
        /// C           iblock   - 466  pi rho <- K* Kbar or K*bar K
        /// C
        /// Clin-9/2008 Deuteron:
        /// C           iblock   - 501  B+B -> Deuteron+Meson
        /// C           iblock   - 502  Deuteron+Meson -> B+B
        /// C           iblock   - 503  Deuteron+Baryon elastic
        /// C           iblock   - 504  Deuteron+Meson elastic
        /// C
        if (iblock == 0) {
          goto statement_400;
        }
        /// CCOM: FOR DIRECT PROCESS WE HAVE TREATED THE PAULI BLOCKING AND FIND
        /// C     THE MOMENTUM OF PARTICLES IN THE ''LAB'' FRAME. SO GO TO 400
        /// C A COLLISION HAS TAKEN PLACE !!
        lcoll++;
        /// C WAS COLLISION PAULI-FORBIDEN? IF YES, NTAG = -1
        ntag = 0;
        /// C
        /// C             LORENTZ-TRANSFORMATION INTO CMS FRAME
        e1cm = fem::sqrt(fem::pow2(em1) + fem::pow2(px1cm) + fem::pow2(py1cm) +
                         fem::pow2(pz1cm));
        p1beta = px1cm * betax + py1cm * betay + pz1cm * betaz;
        transf = gamma * (gamma * p1beta / (gamma + 1) + e1cm);
        pt1i1 = betax * transf + px1cm;
        pt2i1 = betay * transf + py1cm;
        pt3i1 = betaz * transf + pz1cm;
        /// C negelect the pauli blocking at high energies
        goto statement_90002;
      /// C
      /// Clin-10/25/02-comment out following, since there is no path to it:
      /// C*CHECK IF PARTICLE #1 IS PAULI BLOCKED
      /// C              CALL PAULat(I1,occup)
      /// C              if (RANART(NSEED) .lt. occup) then
      /// C                ntag = -1
      /// C              else
      /// C                ntag = 0
      /// C              end if
      /// Clin-10/25/02-end
      /// C
      statement_90002:
        /// CIF PARTICLE #1 IS NOT PAULI BLOCKED
        /// C              IF (NTAG .NE. -1) THEN
        e2cm = fem::sqrt(fem::pow2(em2) + fem::pow2(px1cm) + fem::pow2(py1cm) +
                         fem::pow2(pz1cm));
        transf = gamma * (-gamma * p1beta / (gamma + 1.f) + e2cm);
        pt1i2 = betax * transf - px1cm;
        pt2i2 = betay * transf - py1cm;
        pt3i2 = betaz * transf - pz1cm;
        goto statement_90003;
      /// C
      /// Clin-10/25/02-comment out following, since there is no path to it:
      /// C*CHECK IF PARTICLE #2 IS PAULI BLOCKED
      /// C                CALL PAULat(I2,occup)
      /// C                if (RANART(NSEED) .lt. occup) then
      /// C                  ntag = -1
      /// C                else
      /// C                  ntag = 0
      /// C                end if
      /// Cc              END IF
      /// C* IF COLLISION IS BLOCKED,RESTORE THE MOMENTUM,MASSES
      /// C* AND LABELS OF I1 AND I2
      /// Cc             IF (NTAG .EQ. -1) THEN
      /// C                LBLOC  = LBLOC + 1
      /// C                P(1,I1) = PX1
      /// C                P(2,I1) = PY1
      /// C                P(3,I1) = PZ1
      /// C                P(1,I2) = PX2
      /// C                P(2,I2) = PY2
      /// C                P(3,I2) = PZ2
      /// C                E(I1)   = EM1
      /// C                E(I2)   = EM2
      /// C                LB(I1)  = LB1
      /// C                LB(I2)  = LB2
      /// Cc              ELSE
      /// Clin-10/25/02-end
      /// C
      statement_90003:
        if (iblock == 1) {
          lcnne++;
        }
        if (iblock == 5) {
          ldd++;
        }
        if (iblock == 2) {
          lcnnd++;
        }
        if (iblock == 8) {
          lkn++;
        }
        if (iblock == 43) {
          ldou++;
        }
        /// C                IF(IBLOCK.EQ.2) THEN
        /// C CALCULATE THE AVERAGE SRT FOR N + N---> N + DELTA PROCESS
        /// C                NODELT=NODELT+1
        /// C                SUMSRT=SUMSRT+SRT
        /// C                ENDIF
        if (iblock == 3) {
          lcndn++;
        }
        /// C assign final momenta to particles while keep the leadng particle
        /// C behaviour
        /// C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
        p(1, i1) = pt1i1;
        p(2, i1) = pt2i1;
        p(3, i1) = pt3i1;
        p(1, i2) = pt1i2;
        p(2, i2) = pt2i2;
        p(3, i2) = pt3i2;
        /// C              else
        /// C              p(1,i1)=pt1i2
        /// C              p(2,i1)=pt2i2
        /// C              p(3,i1)=pt3i2
        /// C              p(1,i2)=pt1i1
        /// C              p(2,i2)=pt2i1
        /// C              p(3,i2)=pt3i1
        /// C              endif
        px1 = p(1, i1);
        py1 = p(2, i1);
        pz1 = p(3, i1);
        em1 = e(i1);
        em2 = e(i2);
        lb1 = lb(i1);
        lb2 = lb(i2);
        id(i1) = 2;
        id(i2) = 2;
        e1 = fem::sqrt(fem::pow2(em1) + fem::pow2(px1) + fem::pow2(py1) +
                       fem::pow2(pz1));
        id1 = id(i1);
        goto statement_90004;
      /// Clin-10/25/02-comment out following, since there is no path to it:
      /// C* change phase space density FOR NUCLEONS INVOLVED :
      /// C* NOTE THAT f is the phase space distribution function for nucleons
      /// only C                if ((abs(ix1).le.mx) .and. (abs(iy1).le.my)
      /// .and. C     &              (abs(iz1).le.mz)) then C ipx1p =
      /// nint(p(1,i1)/dpx) C                  ipy1p = nint(p(2,i1)/dpy) C ipz1p
      /// = nint(p(3,i1)/dpz) C                  if ((ipx1p.ne.ipx1) .or.
      /// (ipy1p.ne.ipy1) .or. C     &                (ipz1p.ne.ipz1)) then C if
      /// ((abs(ipx1).le.mpx) .and. (abs(ipy1).le.my) C     & .and.
      /// (ipz1.ge.-mpz) .and. (ipz1.le.mpzp) C     &                .AND.
      /// (AM1.LT.1.)) C     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) = C
      /// &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) - 1. C if
      /// ((abs(ipx1p).le.mpx) .and. (abs(ipy1p).le.my) C     & .and.
      /// (ipz1p.ge.-mpz).and. (ipz1p.le.mpzp) C     &                .AND.
      /// (EM1.LT.1.)) C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) =
      /// C     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) + 1.
      /// C                  end if
      /// C                end if
      /// C                if ((abs(ix2).le.mx) .and. (abs(iy2).le.my) .and.
      /// C     &              (abs(iz2).le.mz)) then
      /// C                  ipx2p = nint(p(1,i2)/dpx)
      /// C                  ipy2p = nint(p(2,i2)/dpy)
      /// C                  ipz2p = nint(p(3,i2)/dpz)
      /// C                  if ((ipx2p.ne.ipx2) .or. (ipy2p.ne.ipy2) .or.
      /// C     &                (ipz2p.ne.ipz2)) then
      /// C                    if ((abs(ipx2).le.mpx) .and. (abs(ipy2).le.my)
      /// C     &                .and. (ipz2.ge.-mpz) .and. (ipz2.le.mpzp)
      /// C     &                .AND. (AM2.LT.1.))
      /// C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) =
      /// C     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) - 1.
      /// C                    if ((abs(ipx2p).le.mpx) .and. (abs(ipy2p).le.my)
      /// C     &                .and. (ipz2p.ge.-mpz) .and. (ipz2p.le.mpzp)
      /// C     &                .AND. (EM2.LT.1.))
      /// C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) =
      /// C     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) + 1.
      /// C                  end if
      /// C                end if
      /// Clin-10/25/02-end
      /// C
      statement_90004:
        am1 = em1;
        am2 = em2;
      /// C            END IF
      /// C
      statement_400:
      /// C
      /// Clin-6/10/03 skips the info output on resonance creations:
      /// C            goto 550
      /// Cclin-4/30/03 study phi,K*,Lambda(1520) resonances at creation:
      /// Cc     note that no decays give these particles, so don't need to
      /// consider nnn: C if(iblock.ne.0.and.(lb(i1).eq.29.or.iabs(lb(i1)).eq.30
      /// C     1           .or.lb(i2).eq.29.or.iabs(lb(i2)).eq.30
      /// C     2           .or.lb1i.eq.29.or.iabs(lb1i).eq.30
      /// C     3           .or.lb2i.eq.29.or.iabs(lb2i).eq.30)) then
      /// C               lb1now=lb(i1)
      /// C               lb2now=lb(i2)
      /// Cc
      /// C               nphi0=0
      /// C               nksp0=0
      /// C               nksm0=0
      /// Cc               nlar0=0
      /// Cc               nlarbar0=0
      /// C               if(lb1i.eq.29) then
      /// C                  nphi0=nphi0+1
      /// C               elseif(lb1i.eq.30) then
      /// C                  nksp0=nksp0+1
      /// C               elseif(lb1i.eq.-30) then
      /// C                  nksm0=nksm0+1
      /// C               endif
      /// C               if(lb2i.eq.29) then
      /// C                  nphi0=nphi0+1
      /// C               elseif(lb2i.eq.30) then
      /// C                  nksp0=nksp0+1
      /// C               elseif(lb2i.eq.-30) then
      /// C                  nksm0=nksm0+1
      /// C               endif
      /// Cc
      /// C               nphi=0
      /// C               nksp=0
      /// C               nksm=0
      /// C               nlar=0
      /// C               nlarbar=0
      /// C               if(lb1now.eq.29) then
      /// C                  nphi=nphi+1
      /// C               elseif(lb1now.eq.30) then
      /// C                  nksp=nksp+1
      /// C               elseif(lb1now.eq.-30) then
      /// C                  nksm=nksm+1
      /// C               endif
      /// C               if(lb2now.eq.29) then
      /// C                  nphi=nphi+1
      /// C               elseif(lb2now.eq.30) then
      /// C                  nksp=nksp+1
      /// C               elseif(lb2now.eq.-30) then
      /// C                  nksm=nksm+1
      /// C               endif
      /// Cc
      /// C               if(nphi.eq.2.or.nksp.eq.2.or.nksm.eq.2) then
      /// C                  write(91,*) '2 same resonances in one reaction!'
      /// C                  write(91,*) nphi,nksp,nksm,iblock
      /// C               endif
      /// C
      /// Cc     All reactions create or destroy no more than 1 these resonance,
      /// Cc     otherwise file "fort.91" warns us:
      /// C               do 222 ires=1,3
      /// C                  if(ires.eq.1.and.nphi.ne.nphi0) then
      /// C                     idr=29
      /// C                  elseif(ires.eq.2.and.nksp.ne.nksp0) then
      /// C                     idr=30
      /// C                  elseif(ires.eq.3.and.nksm.ne.nksm0) then
      /// C                     idr=-30
      /// C                  else
      /// C                     goto 222
      /// C                  endif
      /// Cctest off for resonance (phi, K*) studies:
      /// Cc               if(lb1now.eq.idr) then
      /// Cc       write(17,112)
      /// 'collision',lb1now,P(1,I1),P(2,I1),P(3,I1),e(I1),nt Cc
      /// elseif(lb2now.eq.idr) then Cc       write(17,112)
      /// 'collision',lb2now,P(1,I2),P(2,I2),P(3,I2),e(I2),nt Cc
      /// elseif(lb1i.eq.idr) then Cc       write(18,112)
      /// 'collision',lb1i,px1i,py1i,pz1i,em1i,nt Cc elseif(lb2i.eq.idr) then Cc
      /// write(18,112) 'collision',lb2i,px2i,py2i,pz2i,em2i,nt Cc endif C 222
      /// continue
      /// C
      /// C            else
      /// C            endif
      /// Cc 112        format(a10,I4,4(1x,f9.3),1x,I4)
      /// C
      /// Clin-2/26/03 skips the check of energy conservation after each binary
      /// search: C 550        goto 555 C            pxfin=0 C pyfin=0 C pzfin=0
      /// C            efin=0
      /// C            if(e(i1).ne.0.or.lb(i1).eq.10022) then
      /// C efin=efin+SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2) C
      /// pxfin=pxfin+P(1,I1) C               pyfin=pyfin+P(2,I1) C
      /// pzfin=pzfin+P(3,I1) C            endif C
      /// if(e(i2).ne.0.or.lb(i2).eq.10022) then C
      /// efin=efin+SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2) C
      /// pxfin=pxfin+P(1,I2) C               pyfin=pyfin+P(2,I2) C
      /// pzfin=pzfin+P(3,I2) C            endif C if((nnn-nnnini).ge.1) then C
      /// do imore=nnnini+1,nnn C                  if(EPION(imore,IRUN).ne.0)
      /// then C efin=efin+SQRT(EPION(imore,IRUN)**2 C     1
      /// +PPION(1,imore,IRUN)**2+PPION(2,imore,IRUN)**2 C     2
      /// +PPION(3,imore,IRUN)**2) C pxfin=pxfin+PPION(1,imore,IRUN) C
      /// pyfin=pyfin+PPION(2,imore,IRUN) C pzfin=pzfin+PPION(3,imore,IRUN) C
      /// endif C               enddo C            endif C
      /// devio=sqrt((pxfin-pxini)**2+(pyfin-pyini)**2 C     1
      /// +(pzfin-pzini)**2+(efin-eini)**2) Cc C            if(devio.ge.0.1)
      /// then C               write(92,'a20,5(1x,i6),2(1x,f8.3)')
      /// 'iblock,lb,npi=', C     1 iblock,lb1i,lb2i,lb(i1),lb(i2),e(i1),e(i2)
      /// C               do imore=nnnini+1,nnn
      /// C                  if(EPION(imore,IRUN).ne.0) then
      /// C                     write(92,'a10,2(1x,i6)') 'ipi,lbm=',
      /// C     1                    imore,LPION(imore,IRUN)
      /// C                  endif
      /// C               enddo
      /// C               write(92,'a3,4(1x,f8.3)') 'I:',eini,pxini,pyini,pzini
      /// C               write(92,'a3,5(1x,f8.3)')
      /// C     1              'F:',efin,pxfin,pyfin,pzfin,devio
      /// C            endif
      /// C
      statement_555:
      /// Ctest off only one collision for the same 2 particles in the same
      /// timestep: C            if(iblock.ne.0) then C               goto 800 C
      /// endif Ctest off collisions history: C            if(iblock.ne.0) then
      /// C write(10,*) nt,i1,i2,iblock,x1,z1,x2,z2 C            endif
      /// C
      statement_600:;
      }
    /// C
    /// Clin-4/2012 option of pi0 decays:
    /// C     particles in lpion() may be a pi0, and when ipi0dcy=1
    /// C     we need to decay them at nt=ntmax after all lb(i1) decays are
    /// done:
    statement_798:
      if (nt == ntmax && ipi0dcy == 1 && i1 == (massr(irun) + msum)) {
        FEM_DO_SAFE(ipion, 1, nnn) {
          if (lpion(ipion, irun) == 4) {
            wid = 7.85e-9f;
            resdec(cmn, i1, nt, nnn, wid, idecay, ipion);
          }
        }
      }
    /// Ctest off
    /// C          if(nt.eq.ntmax.and.i1.eq.(MASSR(IRUN)+MSUM)) then
    /// C             do ip=1,i1
    /// C                write(98,*) lb(ip),e(ip),ip
    /// C             enddo
    /// C          endif
    /// C
    /// Clin-4/2012 option of pi0 decays-end
    /// C
    statement_800:;
    }
    /// C RELABLE MESONS LEFT IN THIS RUN EXCLUDING THOSE BEING CREATED DURING
    /// C THIS TIME STEP AND COUNT THE TOTAL NO. OF PARTICLES IN THIS RUN
    /// C note that the first mass=mta+mpr particles are baryons
    /// C        write(*,*)'I: NNN,massr ', nnn,massr(irun)
    n0 = mass + msum;
    FEM_DO_SAFE(n, n0 + 1, massr(irun) + msum) {
      /// Cbz11/25/98
      /// Clin-2/19/03 lb>5000: keep particles with no LB codes in
      /// ART(photon,lepton,..): C        IF(E(N).GT.0.)THEN
      if (e(n) > 0.f || lb(n) > 5000) {
        /// Cbz11/25/98end
        nnn++;
        rpion(1, nnn, irun) = r(1, n);
        rpion(2, nnn, irun) = r(2, n);
        rpion(3, nnn, irun) = r(3, n);
        /// Clin-10/28/03:
        if (nt == ntmax) {
          ftpisv(nnn, irun) = ftsv(n);
          tfdpi(nnn, irun) = tfdcy(n);
        }
        /// C
        ppion(1, nnn, irun) = p(1, n);
        ppion(2, nnn, irun) = p(2, n);
        ppion(3, nnn, irun) = p(3, n);
        epion(nnn, irun) = e(n);
        lpion(nnn, irun) = lb(n);
        /// C       !! sp 12/19/00
        propi(nnn, irun) = proper(n);
        /// Clin-5/2008:
        dppion(nnn, irun) = dpertp(n);
        /// C        if(lb(n) .eq. 45)
        /// C    &   write(*,*)'IN-1  NT,NNN,LB,P ',nt,NNN,lb(n),proper(n)
      }
    }
    massrn(irun) = nnn + mass;
    /// C        write(*,*)'F: NNN,massrn ', nnn,massrn(irun)
  }
  /// C CALCULATE THE AVERAGE SRT FOR N + N--->N +DELTA PROCESSES
  /// C        IF(NODELT.NE.0)THEN
  /// C        AVSRT=SUMSRT/FLOAT(NODELT)
  /// C        ELSE
  /// C        AVSRT=0.
  /// C        ENDIF
  /// C        WRITE(1097,'(F8.2,2X,E10.3)')FLOAT(NT)*DT,AVSRT
  /// C RELABLE ALL THE PARTICLES EXISTING AFTER THIS TIME STEP
  ia = 0;
  ib = 0;
  FEM_DO_SAFE(irun, 1, num) {
    ia += massr(irun - 1);
    ib += massrn(irun - 1);
    FEM_DO_SAFE(ic, 1, massrn(irun)) {
      ie = ia + ic;
      ig = ib + ic;
      if (ic <= mass) {
        rt(1, ig) = r(1, ie);
        rt(2, ig) = r(2, ie);
        rt(3, ig) = r(3, ie);
        /// Clin-10/28/03:
        if (nt == ntmax) {
          fttemp(ig) = ftsv(ie);
          tft(ig) = tfdcy(ie);
        }
        /// C
        pt(1, ig) = p(1, ie);
        pt(2, ig) = p(2, ie);
        pt(3, ig) = p(3, ie);
        et(ig) = e(ie);
        lt(ig) = lb(ie);
        prot(ig) = proper(ie);
        /// Clin-5/2008:
        dptemp(ig) = dpertp(ie);
      } else {
        i0 = ic - mass;
        rt(1, ig) = rpion(1, i0, irun);
        rt(2, ig) = rpion(2, i0, irun);
        rt(3, ig) = rpion(3, i0, irun);
        /// Clin-10/28/03:
        if (nt == ntmax) {
          fttemp(ig) = ftpisv(i0, irun);
          tft(ig) = tfdpi(i0, irun);
        }
        /// C
        pt(1, ig) = ppion(1, i0, irun);
        pt(2, ig) = ppion(2, i0, irun);
        pt(3, ig) = ppion(3, i0, irun);
        et(ig) = epion(i0, irun);
        lt(ig) = lpion(i0, irun);
        prot(ig) = propi(i0, irun);
        /// Clin-5/2008:
        dptemp(ig) = dppion(i0, irun);
      }
    }
  }
  /// C
  il = 0;
  /// Clin-10/26/01-hbt:
  /// C        DO 10002 IRUN=1,NUM
  FEM_DO_SAFE(irun, 1, num) {
    /// C
    massr(irun) = massrn(irun);
    il += massr(irun - 1);
    FEM_DO_SAFE(im, 1, massr(irun)) {
      in = il + im;
      r(1, in) = rt(1, in);
      r(2, in) = rt(2, in);
      r(3, in) = rt(3, in);
      /// Clin-10/28/03:
      if (nt == ntmax) {
        ftsv(in) = fttemp(in);
        tfdcy(in) = tft(in);
      }
      p(1, in) = pt(1, in);
      p(2, in) = pt(2, in);
      p(3, in) = pt(3, in);
      e(in) = et(in);
      lb(in) = lt(in);
      proper(in) = prot(in);
      /// Clin-5/2008:
      dpertp(in) = dptemp(in);
      if (lb(in) < 1 || lb(in) > 2) {
        id(in) = 0;
      }
    }
    /// Clin-ctest off check energy conservation after each timestep
    /// C         enetot=0.
    /// C         do ip=1,MASSR(IRUN)
    /// C            if(e(ip).ne.0.or.lb(ip).eq.10022) enetot=enetot
    /// C     1           +sqrt(p(1,ip)**2+p(2,ip)**2+p(3,ip)**2+e(ip)**2)
    /// C         enddo
    /// C         write(91,*) 'B:',nt,enetot,massr(irun),bimp
    /// Clin-3/2009 move to the end of a timestep to take care of freezeout
    /// spacetime: C        call hbtout(MASSR(IRUN),nt,ntmax)
  }
  /// C
}

struct init_save {
  float beta;
  float epart;
  int i;
  int idir;
  int idnum;
  int irun;
  int npart;
  float pfermi;
  arr<float> ptot;
  float px;
  float py;
  float pz;
  float rdist;
  float rhow0;
  float rhows;
  float scheck;
  float sign;
  float x;
  float y;
  float z;

  init_save()
      : beta(fem::float0),
        epart(fem::float0),
        i(fem::int0),
        idir(fem::int0),
        idnum(fem::int0),
        irun(fem::int0),
        npart(fem::int0),
        pfermi(fem::float0),
        ptot(dimension(3), fem::fill0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        rdist(fem::float0),
        rhow0(fem::float0),
        rhows(fem::float0),
        scheck(fem::float0),
        sign(fem::float0),
        x(fem::float0),
        y(fem::float0),
        z(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void init(common& cmn, int const& minnum, int const& maxnum, int const& num,
          float const& radius, float const& x0, float const& z0,
          float const& p0, float const& gamma, int const& /* iseed */,
          int const& mass, int const& iopt) {
  FEM_CMN_SVE(init);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  int& nseed = cmn.nseed;
  ///
  float& beta = sve.beta;
  float& epart = sve.epart;
  int& i = sve.i;
  int& idir = sve.idir;
  int& idnum = sve.idnum;
  int& irun = sve.irun;
  int& npart = sve.npart;
  float& pfermi = sve.pfermi;
  arr_ref<float> ptot(sve.ptot, dimension(3));
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& rdist = sve.rdist;
  float& rhow0 = sve.rhow0;
  float& rhows = sve.rhows;
  float& scheck = sve.scheck;
  float& sign = sve.sign;
  float& x = sve.x;
  float& y = sve.y;
  float& z = sve.z;
  const float amu = 0.9383f;
  const float pi = 3.1415926f;
  /// C                                                                      *
  /// C       PURPOSE:     PROVIDING INITIAL CONDITIONS FOR PHASE-SPACE      *
  /// C                    DISTRIBUTION OF TESTPARTICLES                     *
  /// C       VARIABLES:   (ALL INPUT)                                       *
  /// C         MINNUM  - FIRST TESTPARTICLE TREATED IN ONE RUN    (INTEGER) *
  /// C         MAXNUM  - LAST TESTPARTICLE TREATED IN ONE RUN     (INTEGER) *
  /// C         NUM     - NUMBER OF TESTPARTICLES PER NUCLEON      (INTEGER) *
  /// C         RADIUS  - RADIUS OF NUCLEUS "FM"                      (REAL) *
  /// C         X0,Z0   - DISPLACEMENT OF CENTER OF NUCLEUS IN X,Z-          *
  /// C                   DIRECTION "FM"                              (REAL) *
  /// C         P0      - MOMENTUM-BOOST IN C.M. FRAME "GEV/C"        (REAL) *
  /// C         GAMMA   - RELATIVISTIC GAMMA-FACTOR                   (REAL) *
  /// C         ISEED   - SEED FOR RANDOM-NUMBER GENERATOR         (INTEGER) *
  /// C         MASS    - TOTAL MASS OF THE SYSTEM                 (INTEGER) *
  /// C         IOPT    - OPTION FOR DIFFERENT OCCUPATION OF MOMENTUM        *
  /// C                   SPACE                                    (INTEGER) *
  /// C                                                                      *
  /// C*********************************
  /// C
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ss/
  /// Cc      SAVE /RNDF77/
  /// C----------------------------------------------------------------------
  /// C     PREPARATION FOR LORENTZ-TRANSFORMATIONS
  /// C
  if (p0 != 0.f) {
    sign = p0 / fem::abs(p0);
  } else {
    sign = 0.f;
  }
  /// C
  /// Clin-9/2012: check argument in sqrt():
  scheck = fem::pow2(gamma) - 1.f;
  if (scheck < 0) {
    write(99, star), "scheck10: ", scheck;
    scheck = 0.f;
  }
  beta = sign * fem::sqrt(scheck) / gamma;
  /// C      BETA = SIGN * SQRT(GAMMA**2-1.)/GAMMA
  /// C
  /// C-----------------------------------------------------------------------
  /// C     TARGET-ID = 1 AND PROJECTILE-ID = -1
  /// C
  if (minnum == 1) {
    idnum = 1;
  } else {
    idnum = -1;
  }
  /// C-----------------------------------------------------------------------
  /// C     IDENTIFICATION OF TESTPARTICLES AND ASSIGMENT OF RESTMASS
  /// C
  /// C     LOOP OVER ALL PARALLEL RUNS:
  FEM_DO_SAFE(irun, 1, num) {
    FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
      id(i) = idnum;
      e(i) = amu;
    }
    /// C-----------------------------------------------------------------------
    /// C       OCCUPATION OF COORDINATE-SPACE
    /// C
    FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
    statement_200:
      x = 1.0f - 2.0f * ranart(nseed);
      y = 1.0f - 2.0f * ranart(nseed);
      z = 1.0f - 2.0f * ranart(nseed);
      if ((x * x + y * y + z * z) > 1.0f) {
        goto statement_200;
      }
      r(1, i) = x * radius;
      r(2, i) = y * radius;
      r(3, i) = z * radius;
    }
  }
  /// C=======================================================================
  if (iopt != 3) {
    /// C-----
    /// C     OPTION 1: USE WOODS-SAXON PARAMETRIZATION FOR DENSITY AND
    /// C-----          CALCULATE LOCAL FERMI-MOMENTUM
    /// C
    rhow0 = 0.168f;
    FEM_DO_SAFE(irun, 1, num) {
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
      statement_500:
        px = 1.0f - 2.0f * ranart(nseed);
        py = 1.0f - 2.0f * ranart(nseed);
        pz = 1.0f - 2.0f * ranart(nseed);
        if (px * px + py * py + pz * pz > 1.0f) {
          goto statement_500;
        }
        rdist = fem::sqrt(fem::pow2(r(1, i)) + fem::pow2(r(2, i)) +
                          fem::pow2(r(3, i)));
        rhows = rhow0 / (1.0f + fem::exp((rdist - radius) / 0.55f));
        pfermi = 0.197f * fem::pow((1.5f * pi * pi * rhows), (1.f / 3.f));
        /// C-----
        /// C     OPTION 2: NUCLEAR MATTER CASE
        if (iopt == 2) {
          pfermi = 0.27f;
        }
        if (iopt == 4) {
          pfermi = 0.f;
        }
        /// C-----
        p(1, i) = pfermi * px;
        p(2, i) = pfermi * py;
        p(3, i) = pfermi * pz;
      }
      /// C
      /// C         SET TOTAL MOMENTUM TO 0 IN REST FRAME AND BOOST
      /// C
      FEM_DO_SAFE(idir, 1, 3) { ptot(idir) = 0.0f; }
      npart = 0;
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
        npart++;
        FEM_DO_SAFE(idir, 1, 3) { ptot(idir) += p(idir, i); }
      }
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
        FEM_DO_SAFE(idir, 1, 3) {
          p(idir, i) = p(idir, i) - ptot(idir) / fem::ffloat(npart);
        }
        /// C           BOOST
        if ((iopt == 1) || (iopt == 2)) {
          epart = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                            fem::pow2(p(3, i)) + fem::pow2(amu));
          p(3, i) = gamma * (p(3, i) + beta * epart);
        } else {
          p(3, i) += p0;
        }
      }
    }
    /// C-----
  } else {
    /// C-----
    /// C     OPTION 3: GIVE ALL NUCLEONS JUST A Z-MOMENTUM ACCORDING TO
    /// C               THE BOOST OF THE NUCLEI
    /// C
    FEM_DO_SAFE(irun, 1, num) {
      FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
        p(1, i) = 0.0f;
        p(2, i) = 0.0f;
        p(3, i) = p0;
      }
    }
    /// C-----
  }
  /// C=======================================================================
  /// C     PUT PARTICLES IN THEIR POSITION IN COORDINATE-SPACE
  /// C     (SHIFT AND RELATIVISTIC CONTRACTION)
  /// C
  FEM_DO_SAFE(irun, 1, num) {
    FEM_DO_SAFE(i, minnum + (irun - 1) * mass, maxnum + (irun - 1) * mass) {
      r(1, i) += x0;
      /// C two nuclei in touch after contraction
      r(3, i) = (r(3, i) + z0) / gamma;
      /// C two nuclei in touch before contraction
      /// C          R(3,I) = R(3,I) / GAMMA + Z0
    }
  }
  /// C
}

struct dens_save {
  static const int maxx = 20;
  static const int maxz = 24;

  float a;
  float b;
  float big;
  float denr;
  float gamma;
  int i;
  int irun;
  int ix;
  int iy;
  int iz;
  int j;
  int msum;
  arr<float, 3> pxl;
  arr<float, 3> pyl;
  arr<float, 3> pzl;
  float rho0;
  float s;
  float small;
  float smass;
  float smass2;
  float u;
  arr<float> zet;

  dens_save()
      : a(fem::float0),
        b(fem::float0),
        big(fem::float0),
        denr(fem::float0),
        gamma(fem::float0),
        i(fem::int0),
        irun(fem::int0),
        ix(fem::int0),
        iy(fem::int0),
        iz(fem::int0),
        j(fem::int0),
        msum(fem::int0),
        pxl(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        pyl(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        pzl(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
        rho0(fem::float0),
        s(fem::float0),
        small(fem::float0),
        smass(fem::float0),
        smass2(fem::float0),
        u(fem::float0),
        zet(dim1(-45, 45), fem::fill0) {}
};

const int dens_save::maxx;
const int dens_save::maxz;

/// C*********************************
/// C                                                                      *
void dens(common& cmn, int const& ipot, int const& mass, int const& num,
          int& nesc) {
  FEM_CMN_SVE(dens);
  const int maxstr = 150001;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  const int maxx = 20;
  const int maxz = 24;
  arr_ref<float, 3> rho(cmn.rho,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> rhop(cmn.rhop,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> rhon(cmn.rhon,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> pirho(
      cmn.pirho, dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  const int maxr = 1;
  arr_cref<int> massr(cmn.massr, dim1(0, maxr));
  arr_ref<float, 3> pel(cmn.pel,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> bxx(cmn.bxx,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> byy(cmn.byy,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> bzz(cmn.bzz,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  ///
  float& a = sve.a;
  float& b = sve.b;
  float& big = sve.big;
  float& denr = sve.denr;
  float& gamma = sve.gamma;
  int& i = sve.i;
  int& irun = sve.irun;
  int& ix = sve.ix;
  int& iy = sve.iy;
  int& iz = sve.iz;
  int& j = sve.j;
  int& msum = sve.msum;
  arr_ref<float, 3> pxl(sve.pxl,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> pyl(sve.pyl,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<float, 3> pzl(sve.pzl,
                        dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  float& rho0 = sve.rho0;
  float& s = sve.s;
  float& small = sve.small;
  float& smass = sve.smass;
  float& smass2 = sve.smass2;
  float& u = sve.u;
  arr_ref<float> zet(sve.zet, dim1(-45, 45));
  if (is_called_first_time) {
    static const float values[] = {
        1.f,  0.f,  0.f, 0.f,  0.f,  1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, -1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, 0.f,  -1.f, 0.f, 1.f,  0.f, -1.f, 0.f, -1.f, 0.f,
        -2.f, -1.f, 0.f, 1.f,  0.f,  0.f, 0.f,  0.f, -1.f, 0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, -1.f, 0.f,  1.f, 2.f,  0.f, 1.f,  0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, 0.f,  0.f,  0.f, -1.f, 0.f, 1.f,  0.f, -1.f, 0.f,
        1.f,  0.f,  0.f, 1.f,  0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  -1.f, 0.f, 0.f,  0.f,  0.f, -1.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), zet;
  }
  /// C                                                                      *
  /// C       PURPOSE:     CALCULATION OF LOCAL BARYON, MESON AND ENERGY     *
  /// C                    DENSITY FROM SPATIAL DISTRIBUTION OF TESTPARTICLES*
  /// C                                                                      *
  /// C       VARIABLES (ALL INPUT, ALL INTEGER)                             *
  /// C         MASS    -  MASS NUMBER OF THE SYSTEM                         *
  /// C         NUM     -  NUMBER OF TESTPARTICLES PER NUCLEON               *
  /// C                                                                      *
  /// C         NESC    -  NUMBER OF ESCAPED PARTICLES      (INTEGER,OUTPUT) *
  /// C                                                                      *
  /// C*********************************
  /// C
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /DDpi/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /ss/
  /// Cc      SAVE /RR/
  /// Cc      SAVE /tt/
  /// C
  FEM_DO_SAFE(iz, -maxz, maxz) {
    FEM_DO_SAFE(iy, -maxx, maxx) {
      FEM_DO_SAFE(ix, -maxx, maxx) {
        rho(ix, iy, iz) = 0.0f;
        rhon(ix, iy, iz) = 0.0f;
        rhop(ix, iy, iz) = 0.0f;
        pirho(ix, iy, iz) = 0.0f;
        pxl(ix, iy, iz) = 0.0f;
        pyl(ix, iy, iz) = 0.0f;
        pzl(ix, iy, iz) = 0.0f;
        pel(ix, iy, iz) = 0.0f;
        bxx(ix, iy, iz) = 0.0f;
        byy(ix, iy, iz) = 0.0f;
        bzz(ix, iy, iz) = 0.0f;
      }
    }
  }
  /// C
  nesc = 0;
  big = 1.0f / (3.0f * fem::ffloat(num));
  small = 1.0f / (9.0f * fem::ffloat(num));
  /// C
  msum = 0;
  FEM_DO_SAFE(irun, 1, num) {
    msum += massr(irun - 1);
    FEM_DO_SAFE(j, 1, massr(irun)) {
      i = j + msum;
      ix = fem::nint(r(1, i));
      iy = fem::nint(r(2, i));
      iz = fem::nint(r(3, i));
      if (ix <= -maxx || ix >= maxx || iy <= -maxx || iy >= maxx ||
          iz <= -maxz || iz >= maxz) {
        nesc++;
      } else {
        /// C
        /// Csp01/04/02 include baryon density
        if (j > mass) {
          goto statement_30;
        }
        /// C         if( (lb(i).eq.1.or.lb(i).eq.2) .or.
        /// C    &    (lb(i).ge.6.and.lb(i).le.17) )then
        /// C (1) baryon density
        rho(ix, iy, iz) += big;
        rho(ix + 1, iy, iz) += small;
        rho(ix - 1, iy, iz) += small;
        rho(ix, iy + 1, iz) += small;
        rho(ix, iy - 1, iz) += small;
        rho(ix, iy, iz + 1) += small;
        rho(ix, iy, iz - 1) += small;
        /// C (2) CALCULATE THE PROTON DENSITY
        if (zet(lb(i)) != 0) {
          rhop(ix, iy, iz) += big;
          rhop(ix + 1, iy, iz) += small;
          rhop(ix - 1, iy, iz) += small;
          rhop(ix, iy + 1, iz) += small;
          rhop(ix, iy - 1, iz) += small;
          rhop(ix, iy, iz + 1) += small;
          rhop(ix, iy, iz - 1) += small;
          goto statement_40;
        }
        /// C (3) CALCULATE THE NEUTRON DENSITY
        if (zet(lb(i)) == 0) {
          rhon(ix, iy, iz) += big;
          rhon(ix + 1, iy, iz) += small;
          rhon(ix - 1, iy, iz) += small;
          rhon(ix, iy + 1, iz) += small;
          rhon(ix, iy - 1, iz) += small;
          rhon(ix, iy, iz + 1) += small;
          rhon(ix, iy, iz - 1) += small;
          goto statement_40;
        }
      /// C           else    !! sp01/04/02
      /// C (4) meson density
      statement_30:
        pirho(ix, iy, iz) += big;
        pirho(ix + 1, iy, iz) += small;
        pirho(ix - 1, iy, iz) += small;
        pirho(ix, iy + 1, iz) += small;
        pirho(ix, iy - 1, iz) += small;
        pirho(ix, iy, iz + 1) += small;
        pirho(ix, iy, iz - 1) += small;
      /// C           endif    !! sp01/04/02
      /// C to calculate the Gamma factor in each cell
      /// C(1) PX
      statement_40:
        pxl(ix, iy, iz) += p(1, i) * big;
        pxl(ix + 1, iy, iz) += p(1, i) * small;
        pxl(ix - 1, iy, iz) += p(1, i) * small;
        pxl(ix, iy + 1, iz) += p(1, i) * small;
        pxl(ix, iy - 1, iz) += p(1, i) * small;
        pxl(ix, iy, iz + 1) += p(1, i) * small;
        pxl(ix, iy, iz - 1) += p(1, i) * small;
        /// C(2) PY
        pyl(ix, iy, iz) += p(2, i) * big;
        pyl(ix + 1, iy, iz) += p(2, i) * small;
        pyl(ix - 1, iy, iz) += p(2, i) * small;
        pyl(ix, iy + 1, iz) += p(2, i) * small;
        pyl(ix, iy - 1, iz) += p(2, i) * small;
        pyl(ix, iy, iz + 1) += p(2, i) * small;
        pyl(ix, iy, iz - 1) += p(2, i) * small;
        /// C (3) PZ
        pzl(ix, iy, iz) += p(3, i) * big;
        pzl(ix + 1, iy, iz) += p(3, i) * small;
        pzl(ix - 1, iy, iz) += p(3, i) * small;
        pzl(ix, iy + 1, iz) += p(3, i) * small;
        pzl(ix, iy - 1, iz) += p(3, i) * small;
        pzl(ix, iy, iz + 1) += p(3, i) * small;
        pzl(ix, iy, iz - 1) += p(3, i) * small;
        /// C (4) ENERGY
        pel(ix, iy, iz) += fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                                     fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
                           big;
        pel(ix + 1, iy, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix - 1, iy, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy + 1, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy - 1, iz) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy, iz + 1) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
        pel(ix, iy, iz - 1) +=
            fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                      fem::pow2(p(2, i)) + fem::pow2(p(3, i))) *
            small;
      }
    }
  }
  /// C
  FEM_DO_SAFE(iz, -maxz, maxz) {
    FEM_DO_SAFE(iy, -maxx, maxx) {
      FEM_DO_SAFE(ix, -maxx, maxx) {
        if ((rho(ix, iy, iz) == 0) || (pel(ix, iy, iz) == 0)) {
          goto statement_101;
        }
        smass2 = fem::pow2(pel(ix, iy, iz)) - fem::pow2(pxl(ix, iy, iz)) -
                 fem::pow2(pyl(ix, iy, iz)) - fem::pow2(pzl(ix, iy, iz));
        if (smass2 <= 0) {
          smass2 = 1.e-06f;
        }
        smass = fem::sqrt(smass2);
        if (smass == 0.f) {
          smass = 1.e-06f;
        }
        gamma = pel(ix, iy, iz) / smass;
        if (gamma == 0) {
          goto statement_101;
        }
        bxx(ix, iy, iz) = pxl(ix, iy, iz) / pel(ix, iy, iz);
        byy(ix, iy, iz) = pyl(ix, iy, iz) / pel(ix, iy, iz);
        bzz(ix, iy, iz) = pzl(ix, iy, iz) / pel(ix, iy, iz);
        rho(ix, iy, iz) = rho(ix, iy, iz) / gamma;
        rhon(ix, iy, iz) = rhon(ix, iy, iz) / gamma;
        rhop(ix, iy, iz) = rhop(ix, iy, iz) / gamma;
        pirho(ix, iy, iz) = pirho(ix, iy, iz) / gamma;
        pel(ix, iy, iz) = pel(ix, iy, iz) / (fem::pow2(gamma));
        rho0 = 0.163f;
        if (ipot == 0) {
          u = 0;
          goto statement_70;
        }
        if (ipot == 1 || ipot == 6) {
          a = -0.1236f;
          b = 0.0704f;
          s = 2;
          goto statement_60;
        }
        if (ipot == 2 || ipot == 7) {
          a = -0.218f;
          b = 0.164f;
          s = 4.f / 3.f;
        }
        if (ipot == 3) {
          a = -0.3581f;
          b = 0.3048f;
          s = 1.167f;
          goto statement_60;
        }
        if (ipot == 4) {
          denr = rho(ix, iy, iz) / rho0;
          b = 0.3048f;
          s = 1.167f;
          if (denr <= 4 || denr > 7) {
            a = -0.3581f;
          } else {
            a = -b * fem::pow(denr, (1.f / 6.f)) -
                2.f * 0.036f / 3.f * fem::pow(denr, (-0.333f));
          }
          goto statement_60;
        }
      statement_60:
        u = 0.5f * a * fem::pow2(rho(ix, iy, iz)) / rho0 +
            b / (1 + s) * fem::pow((rho(ix, iy, iz) / rho0), s) *
                rho(ix, iy, iz);
      statement_70:
        pel(ix, iy, iz) += u;
      statement_101:;
      }
    }
  }
}

struct gradu_save {
  float acoef;
  float acoef1;
  float acoef2;
  float cf0;
  float den0;
  float denr;
  float ef;
  float eh;
  float ene0;
  float eqgp;
  float expnt;
  float expnt2;
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  gradu_save()
      : acoef(fem::float0),
        acoef1(fem::float0),
        acoef2(fem::float0),
        cf0(fem::float0),
        den0(fem::float0),
        denr(fem::float0),
        ef(fem::float0),
        eh(fem::float0),
        ene0(fem::float0),
        eqgp(fem::float0),
        expnt(fem::float0),
        expnt2(fem::float0),
        rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

/// C
/// C*********************************
/// C                                                                      *
void gradu(common& cmn, int const& iopt, int const& ix, int const& iy,
           int const& iz, float& gradx, float& grady, float& gradz) {
  FEM_CMN_SVE(gradu);
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rho(cmn.rho,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_cref<float, 3> pel(cmn.pel,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  ///
  float& acoef = sve.acoef;
  float& acoef1 = sve.acoef1;
  float& acoef2 = sve.acoef2;
  float& cf0 = sve.cf0;
  float& den0 = sve.den0;
  float& denr = sve.denr;
  float& ef = sve.ef;
  float& eh = sve.eh;
  float& ene0 = sve.ene0;
  float& eqgp = sve.eqgp;
  float& expnt = sve.expnt;
  float& expnt2 = sve.expnt2;
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  const float rho0 = 0.167f;
  /// C                                                                      *
  /// C       PURPOSE:     DETERMINE GRAD(U(RHO(X,Y,Z)))                     *
  /// C       VARIABLES:                                                     *
  /// C         IOPT                - METHOD FOR EVALUATING THE GRADIENT     *
  /// C                                                      (INTEGER,INPUT) *
  /// C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
  /// C         GRADX, GRADY, GRADZ - GRADIENT OF U            (REAL,OUTPUT) *
  /// C                                                                      *
  /// C*********************************
  /// C
  /// Cc      SAVE /DD/
  /// Cc      SAVE /ss/
  /// Cc      SAVE /tt/
  /// C
  rxplus = rho(ix + 1, iy, iz) / rho0;
  rxmins = rho(ix - 1, iy, iz) / rho0;
  ryplus = rho(ix, iy + 1, iz) / rho0;
  rymins = rho(ix, iy - 1, iz) / rho0;
  rzplus = rho(ix, iy, iz + 1) / rho0;
  rzmins = rho(ix, iy, iz - 1) / rho0;
  den0 = rho(ix, iy, iz) / rho0;
  ene0 = pel(ix, iy, iz);
  /// C-----------------------------------------------------------------------
  switch (iopt) {
    case 1:
      goto statement_1;
    case 2:
      goto statement_2;
    case 3:
      goto statement_3;
    case 4:
      goto statement_4;
    case 5:
      goto statement_5;
    default:
      break;
  }
  if (iopt == 6) {
    goto statement_6;
  }
  if (iopt == 7) {
    goto statement_7;
  }
/// C
statement_1:
  /// C       POTENTIAL USED IN 1) (STIFF):
  /// C       U = -.124 * RHO/RHO0 + .0705 (RHO/RHO0)**2 GEV
  /// C
  gradx = -0.062f * (rxplus - rxmins) +
          0.03525f * (fem::pow2(rxplus) - fem::pow2(rxmins));
  grady = -0.062f * (ryplus - rymins) +
          0.03525f * (fem::pow2(ryplus) - fem::pow2(rymins));
  gradz = -0.062f * (rzplus - rzmins) +
          0.03525f * (fem::pow2(rzplus) - fem::pow2(rzmins));
  return;
/// C
statement_2:
  /// C       POTENTIAL USED IN 2):
  /// C       U = -.218 * RHO/RHO0 + .164 (RHO/RHO0)**(4/3) GEV
  /// C
  expnt = 1.3333333f;
  gradx = -0.109f * (rxplus - rxmins) +
          0.082f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
  grady = -0.109f * (ryplus - rymins) +
          0.082f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
  gradz = -0.109f * (rzplus - rzmins) +
          0.082f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  return;
/// C
statement_3:
  /// C       POTENTIAL USED IN 3) (SOFT):
  /// C       U = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
  /// C
  expnt = 1.1666667f;
  acoef = 0.178f;
  gradx = -acoef * (rxplus - rxmins) +
          0.1515f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
  grady = -acoef * (ryplus - rymins) +
          0.1515f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
  gradz = -acoef * (rzplus - rzmins) +
          0.1515f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  return;
/// C
statement_4:
  /// C       POTENTIAL USED IN 4) (super-soft in the mixed phase of 4 < rho/rho
  /// <7): C       U1 = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV C
  /// normal phase, soft eos of iopt=3 C       U2 = -.02 * (RHO/RHO0)**(2/3)
  /// -0.0253 * (RHO/RHO0)**(7/6)  GEV
  /// C
  eh = 4.f;
  eqgp = 7.f;
  acoef = 0.178f;
  expnt = 1.1666667f;
  denr = rho(ix, iy, iz) / rho0;
  if (denr <= eh || denr >= eqgp) {
    gradx = -acoef * (rxplus - rxmins) +
            0.1515f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
    grady = -acoef * (ryplus - rymins) +
            0.1515f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
    gradz = -acoef * (rzplus - rzmins) +
            0.1515f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  } else {
    acoef1 = 0.178f;
    acoef2 = 0.0f;
    expnt2 = 2.f / 3.f;
    gradx = -acoef1 * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt)) -
            acoef2 * (fem::pow(rxplus, expnt2) - fem::pow(rxmins, expnt2));
    grady = -acoef1 * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt)) -
            acoef2 * (fem::pow(ryplus, expnt2) - fem::pow(rymins, expnt2));
    gradz = -acoef1 * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt)) -
            acoef2 * (fem::pow(rzplus, expnt2) - fem::pow(rzmins, expnt2));
  }
  return;
/// C
statement_5:
  /// C       POTENTIAL USED IN 5) (SUPER STIFF):
  /// C       U = -.10322 * RHO/RHO0 + .04956 * (RHO/RHO0)**(2.77)  GEV
  /// C
  expnt = 2.77f;
  gradx = -0.0516f * (rxplus - rxmins) +
          0.02498f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
  grady = -0.0516f * (ryplus - rymins) +
          0.02498f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
  gradz = -0.0516f * (rzplus - rzmins) +
          0.02498f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
  return;
/// C
statement_6:
  /// C       POTENTIAL USED IN 6) (STIFF-qgp):
  /// C       U = -.124 * RHO/RHO0 + .0705 (RHO/RHO0)**2 GEV
  /// C
  if (ene0 <= 0.5f) {
    gradx = -0.062f * (rxplus - rxmins) +
            0.03525f * (fem::pow2(rxplus) - fem::pow2(rxmins));
    grady = -0.062f * (ryplus - rymins) +
            0.03525f * (fem::pow2(ryplus) - fem::pow2(rymins));
    gradz = -0.062f * (rzplus - rzmins) +
            0.03525f * (fem::pow2(rzplus) - fem::pow2(rzmins));
    return;
  }
  if (ene0 > 0.5f && ene0 <= 1.5f) {
    /// C       U=c1-ef*rho/rho0**2/3
    ef = 36.f / 1000.f;
    gradx = -0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = -0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = -0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
  if (ene0 > 1.5f) {
    /// C U=800*(rho/rho0)**1/3.-Ef*(rho/rho0)**2/3.-c2
    ef = 36.f / 1000.f;
    cf0 = 0.8f;
    gradx = 0.5f * cf0 * (fem::pow(rxplus, 0.333f) - fem::pow(rxmins, 0.333f)) -
            0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = 0.5f * cf0 * (fem::pow(ryplus, 0.333f) - fem::pow(rymins, 0.333f)) -
            0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = 0.5f * cf0 * (fem::pow(rzplus, 0.333f) - fem::pow(rzmins, 0.333f)) -
            0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
/// C
statement_7:
  /// C       POTENTIAL USED IN 7) (Soft-qgp):
  if (den0 <= 4.5f) {
    /// C       POTENTIAL USED is the same as IN 3) (SOFT):
    /// C       U = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
    /// C
    expnt = 1.1666667f;
    acoef = 0.178f;
    gradx = -acoef * (rxplus - rxmins) +
            0.1515f * (fem::pow(rxplus, expnt) - fem::pow(rxmins, expnt));
    grady = -acoef * (ryplus - rymins) +
            0.1515f * (fem::pow(ryplus, expnt) - fem::pow(rymins, expnt));
    gradz = -acoef * (rzplus - rzmins) +
            0.1515f * (fem::pow(rzplus, expnt) - fem::pow(rzmins, expnt));
    return;
  }
  if (den0 > 4.5f && den0 <= 5.1f) {
    /// C       U=c1-ef*rho/rho0**2/3
    ef = 36.f / 1000.f;
    gradx = -0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = -0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = -0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
  if (den0 > 5.1f) {
    /// C U=800*(rho/rho0)**1/3.-Ef*(rho/rho0)**2/3.-c2
    ef = 36.f / 1000.f;
    cf0 = 0.8f;
    gradx = 0.5f * cf0 * (fem::pow(rxplus, 0.333f) - fem::pow(rxmins, 0.333f)) -
            0.5f * ef * (fem::pow(rxplus, 0.67f) - fem::pow(rxmins, 0.67f));
    grady = 0.5f * cf0 * (fem::pow(ryplus, 0.333f) - fem::pow(rymins, 0.333f)) -
            0.5f * ef * (fem::pow(ryplus, 0.67f) - fem::pow(rymins, 0.67f));
    gradz = 0.5f * cf0 * (fem::pow(rzplus, 0.333f) - fem::pow(rzmins, 0.333f)) -
            0.5f * ef * (fem::pow(rzplus, 0.67f) - fem::pow(rzmins, 0.67f));
    return;
  }
}

struct graduk_save {
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  graduk_save()
      : rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

/// C*********************************
/// C                                                                      *
void graduk(common& cmn, int const& ix, int const& iy, int const& iz,
            float& gradxk, float& gradyk, float& gradzk) {
  FEM_CMN_SVE(graduk);
  /// COMMON dd
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rho(cmn.rho,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  ///
  /// SAVE
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  ///
  /// C                                                                      *
  /// C       PURPOSE:     DETERMINE the baryon density gradient for         *
  /// C                    proporgating kaons in a mean field caused by      *
  /// C                    surrounding baryons                               *
  /// C       VARIABLES:                                                     *
  /// C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
  /// C         GRADXk, GRADYk, GRADZk                       (REAL,OUTPUT)   *
  /// C                                                                      *
  /// C*********************************
  /// C
  /// Cc      SAVE /DD/
  /// Cc      SAVE /ss/
  /// C
  rxplus = rho(ix + 1, iy, iz);
  rxmins = rho(ix - 1, iy, iz);
  ryplus = rho(ix, iy + 1, iz);
  rymins = rho(ix, iy - 1, iz);
  rzplus = rho(ix, iy, iz + 1);
  rzmins = rho(ix, iy, iz - 1);
  gradxk = (rxplus - rxmins) / 2.f;
  gradyk = (ryplus - rymins) / 2.f;
  gradzk = (rzplus - rzmins) / 2.f;
}

struct gradup_save {
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  gradup_save()
      : rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

/// C-----------------------------------------------------------------------
void gradup(common& cmn, int const& ix, int const& iy, int const& iz,
            float& gradxp, float& gradyp, float& gradzp) {
  FEM_CMN_SVE(gradup);
  /// COMMON dd
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rhop(
      cmn.rhop, dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  ///
  /// SAVE
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  ///
  /// C                                                                      *
  /// C       PURPOSE:     DETERMINE THE GRADIENT OF THE PROTON DENSITY      *
  /// C       VARIABLES:                                                     *
  /// C * C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT)
  /// * C         GRADXP, GRADYP, GRADZP - GRADIENT OF THE PROTON              *
  /// C                                  DENSITY(REAL,OUTPUT)                *
  /// C                                                                      *
  /// C*********************************
  /// C
  /// Cc      SAVE /DD/
  /// Cc      SAVE /ss/
  /// C
  const float rho0 = 0.168f;
  rxplus = rhop(ix + 1, iy, iz) / rho0;
  rxmins = rhop(ix - 1, iy, iz) / rho0;
  ryplus = rhop(ix, iy + 1, iz) / rho0;
  rymins = rhop(ix, iy - 1, iz) / rho0;
  rzplus = rhop(ix, iy, iz + 1) / rho0;
  rzmins = rhop(ix, iy, iz - 1) / rho0;
  /// C-----------------------------------------------------------------------
  /// C
  gradxp = (rxplus - rxmins) / 2.f;
  gradyp = (ryplus - rymins) / 2.f;
  gradzp = (rzplus - rzmins) / 2.f;
}

struct gradun_save {
  float rxmins;
  float rxplus;
  float rymins;
  float ryplus;
  float rzmins;
  float rzplus;

  gradun_save()
      : rxmins(fem::float0),
        rxplus(fem::float0),
        rymins(fem::float0),
        ryplus(fem::float0),
        rzmins(fem::float0),
        rzplus(fem::float0) {}
};

/// C-----------------------------------------------------------------------
void gradun(common& cmn, int const& ix, int const& iy, int const& iz,
            float& gradxn, float& gradyn, float& gradzn) {
  FEM_CMN_SVE(gradun);
  /// COMMON dd
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rhon(
      cmn.rhon, dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  ///
  /// SAVE
  float& rxmins = sve.rxmins;
  float& rxplus = sve.rxplus;
  float& rymins = sve.rymins;
  float& ryplus = sve.ryplus;
  float& rzmins = sve.rzmins;
  float& rzplus = sve.rzplus;
  ///
  /// C                                                                      *
  /// C       PURPOSE:     DETERMINE THE GRADIENT OF THE NEUTRON DENSITY     *
  /// C       VARIABLES:                                                     *
  /// C * C         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT)
  /// * C         GRADXN, GRADYN, GRADZN - GRADIENT OF THE NEUTRON             *
  /// C                                  DENSITY(REAL,OUTPUT)                *
  /// C                                                                      *
  /// C*********************************
  /// C
  /// Cc      SAVE /DD/
  /// Cc      SAVE /ss/
  /// C
  const float rho0 = 0.168f;
  rxplus = rhon(ix + 1, iy, iz) / rho0;
  rxmins = rhon(ix - 1, iy, iz) / rho0;
  ryplus = rhon(ix, iy + 1, iz) / rho0;
  rymins = rhon(ix, iy - 1, iz) / rho0;
  rzplus = rhon(ix, iy, iz + 1) / rho0;
  rzmins = rhon(ix, iy, iz - 1) / rho0;
  /// C-----------------------------------------------------------------------
  /// C
  gradxn = (rxplus - rxmins) / 2.f;
  gradyn = (ryplus - rymins) / 2.f;
  gradzn = (rzplus - rzmins) / 2.f;
}

struct tablem_save {
  float anorm;
  int l;
  float ptmax;
  float rr;
  float x;

  tablem_save()
      : anorm(fem::float0),
        l(fem::int0),
        ptmax(fem::float0),
        rr(fem::float0),
        x(fem::float0) {}
};

/// C***************************************
/// C generate a table for pt distribution for
void tablem(common& cmn) {
  FEM_CMN_SVE(tablem);
  /// COMMON table
  arr_ref<float> xarray(cmn.xarray, dim1(0, 1000));
  arr_ref<float> earray(cmn.earray, dim1(0, 1000));
  ///
  /// SAVE
  float& anorm = sve.anorm;
  int& l = sve.l;
  float& ptmax = sve.ptmax;
  float& rr = sve.rr;
  float& x = sve.x;
  ///
  /// C THE PROCESS N+N--->N+N+PION
  /// C       DATE : July 11, 1994
  /// C****************************************
  /// Cc      SAVE /TABLE/
  ptmax = 2.01f;
  anorm = ptdis(cmn, ptmax);
  FEM_DO_SAFE(l, 0, 200) {
    x = 0.01f * fem::ffloat(l + 1);
    rr = ptdis(cmn, x) / anorm;
    earray(l) = rr;
    xarray(l) = x;
  }
}

struct flow_save {
  float dnuc;
  float dnuck;
  float dnucp;
  float dy;
  float dykaon;
  float dypion;
  float dypr;
  float e00;
  int i;
  int is;
  int iy;
  int j;
  int kk;
  int ly;
  int m;
  int nkaon;
  int npion;
  int npr;
  int npt;
  int nrun;
  arr<float> pxkaon;
  arr<float> pxpion;
  arr<float> pxpro;
  float y00;
  float ycut1;
  float ycut2;
  arr<float> ykaon;
  arr<float> ypion;
  arr<float> ypr;

  flow_save()
      : dnuc(fem::float0),
        dnuck(fem::float0),
        dnucp(fem::float0),
        dy(fem::float0),
        dykaon(fem::float0),
        dypion(fem::float0),
        dypr(fem::float0),
        e00(fem::float0),
        i(fem::int0),
        is(fem::int0),
        iy(fem::int0),
        j(fem::int0),
        kk(fem::int0),
        ly(fem::int0),
        m(fem::int0),
        nkaon(fem::int0),
        npion(fem::int0),
        npr(fem::int0),
        npt(fem::int0),
        nrun(fem::int0),
        pxkaon(dim1(-80, 80), fem::fill0),
        pxpion(dim1(-80, 80), fem::fill0),
        pxpro(dim1(-80, 80), fem::fill0),
        y00(fem::float0),
        ycut1(fem::float0),
        ycut2(fem::float0),
        ykaon(dim1(-80, 80), fem::fill0),
        ypion(dim1(-80, 80), fem::fill0),
        ypr(dim1(-80, 80), fem::fill0) {}
};

/// C*********************************
/// C PURPOSE : flow analysis
/// C DATE : Feb. 1, 1995
/// C**********************************
void flow(common& cmn, int const& /* nt */) {
  FEM_CMN_SVE(flow);
  const int maxstr = 150001;
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  const int maxr = 1;
  arr_cref<int> massr(cmn.massr, dim1(0, maxr));
  ///
  float& dy = sve.dy;
  float& dykaon = sve.dykaon;
  float& dypion = sve.dypion;
  float& dypr = sve.dypr;
  float& e00 = sve.e00;
  int& i = sve.i;
  int& is = sve.is;
  int& iy = sve.iy;
  int& j = sve.j;
  int& kk = sve.kk;
  int& ly = sve.ly;
  int& m = sve.m;
  int& nkaon = sve.nkaon;
  int& npion = sve.npion;
  int& npr = sve.npr;
  int& npt = sve.npt;
  int& nrun = sve.nrun;
  arr_ref<float> pxkaon(sve.pxkaon, dim1(-80, 80));
  arr_ref<float> pxpion(sve.pxpion, dim1(-80, 80));
  arr_ref<float> pxpro(sve.pxpro, dim1(-80, 80));
  float& y00 = sve.y00;
  float& ycut1 = sve.ycut1;
  float& ycut2 = sve.ycut2;
  arr_ref<float> ykaon(sve.ykaon, dim1(-80, 80));
  arr_ref<float> ypion(sve.ypion, dim1(-80, 80));
  arr_ref<float> ypr(sve.ypr, dim1(-80, 80));
  /// C       IMPLICIT REAL*4 (A-H,O-Z)
  /// C----------------------------------------------------------------------*
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /RR/
  /// Cc      SAVE /RUN/
  /// Cc      SAVE /input1/
  /// C----------------------------------------------------------------------*
  ycut1 = -2.6f;
  ycut2 = 2.6f;
  dy = 0.2f;
  ly = fem::nint((ycut2 - ycut1) / dy);
  /// C**********************************
  /// C initialize the transverse momentum counters
  FEM_DO_SAFE(kk, -80, 80) {
    pxpion(kk) = 0;
    pxpro(kk) = 0;
    pxkaon(kk) = 0;
  }
  FEM_DO_SAFE(j, -ly, ly) {
    ypion(j) = 0;
    ykaon(j) = 0;
    ypr(j) = 0;
  }
  nkaon = 0;
  npr = 0;
  npion = 0;
  is = 0;
  FEM_DO_SAFE(nrun, 1, cmn.num) {
    is += massr(nrun - 1);
    FEM_DO_SAFE(j, 1, massr(nrun)) {
      i = j + is;
      /// C for protons go to 200 to calculate its rapidity and transvese
      /// momentum C distributions
      e00 = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                      fem::pow2(p(3, i)) + fem::pow2(e(i)));
      y00 = 0.5f * fem::alog((e00 + p(3, i)) / (e00 - p(3, i)));
      if (fem::abs(y00) >= ycut2) {
        goto statement_20;
      }
      iy = fem::nint(y00 / dy);
      if (fem::abs(iy) >= 80) {
        goto statement_20;
      }
      if (e(i) == 0) {
        goto statement_20;
      }
      if (lb(i) >= 25) {
        goto statement_20;
      }
      if ((lb(i) <= 5) && (lb(i) >= 3)) {
        goto statement_50;
      }
      if (lb(i) == 1 || lb(i) == 2) {
        goto statement_200;
      }
      /// Cbz3/10/99
      /// C       if(lb(i).ge.6.and.lb(i).le.15)go to 200
      if (lb(i) >= 6 && lb(i) <= 17) {
        goto statement_200;
      }
      /// Cbz3/10/99 end
      if (lb(i) == 23) {
        goto statement_400;
      }
      goto statement_20;
    /// C calculate rapidity and transverse momentum distribution for pions
    statement_50:
      npion++;
      /// C (2) rapidity distribution in the cms frame
      ypion(iy)++;
      pxpion(iy) += p(1, i) / e(i);
      goto statement_20;
    /// C calculate rapidity and transverse energy distribution for baryons
    statement_200:
      npr++;
      pxpro(iy) += p(1, i) / e(i);
      ypr(iy) += 1.f;
      goto statement_20;
    statement_400:
      nkaon++;
      ykaon(iy) += 1.f;
      pxkaon(iy) += p(1, i) / e(i);
    statement_20:;
    }
  }
  /// C PRINT OUT NUCLEON'S TRANSVERSE MOMENTUM distribution
  /// C       write(1041,*)Nt
  /// C       write(1042,*)Nt
  /// C       write(1043,*)Nt
  /// C       write(1090,*)Nt
  /// C       write(1091,*)Nt
  /// C       write(1092,*)Nt
  FEM_DO_SAFE(npt, -10, 10) {
    if (ypr(npt) == 0) {
      goto statement_101;
    }
    pxpro(npt) = -pxpro(npt) / ypr(npt);
    sve.dnuc = pxpro(npt) / fem::sqrt(ypr(npt));
  /// C       WRITE(1041,*)NPT*DY,Pxpro(NPT),DNUC
  /// C print pion's transverse momentum distribution
  statement_101:
    if (ypion(npt) == 0) {
      goto statement_102;
    }
    pxpion(npt) = -pxpion(npt) / ypion(npt);
    sve.dnucp = pxpion(npt) / fem::sqrt(ypion(npt));
  /// C       WRITE(1042,*)NPT*DY,Pxpion(NPT),DNUCp
  /// C kaons
  statement_102:
    if (ykaon(npt) == 0) {
      goto statement_3;
    }
    pxkaon(npt) = -pxkaon(npt) / ykaon(npt);
    sve.dnuck = pxkaon(npt) / fem::sqrt(ykaon(npt));
  /// C       WRITE(1043,*)NPT*DY,Pxkaon(NPT),DNUCk
  statement_3:;
  }
  /// C*******************************
  /// C OUTPUT PION AND PROTON RAPIDITY DISTRIBUTIONS
  FEM_DO_SAFE(m, -ly, ly) {
    /// C PROTONS
    dypr = 0;
    if (ypr(m) != 0) {
      dypr = fem::sqrt(ypr(m)) / fem::ffloat(nrun) / dy;
    }
    ypr(m) = ypr(m) / fem::ffloat(nrun) / dy;
    /// C       WRITE(1090,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YPR(M),DYPR
    /// C PIONS
    dypion = 0;
    if (ypion(m) != 0) {
      dypion = fem::sqrt(ypion(m)) / fem::ffloat(nrun) / dy;
    }
    ypion(m) = ypion(m) / fem::ffloat(nrun) / dy;
    /// C       WRITE(1091,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YPION(M),DYPION
    /// C KAONS
    dykaon = 0;
    if (ykaon(m) != 0) {
      dykaon = fem::sqrt(ykaon(m)) / fem::ffloat(nrun) / dy;
    }
    ykaon(m) = ykaon(m) / fem::ffloat(nrun) / dy;
    /// C       WRITE(1092,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YKAON(M),DYKAON
  }
}

struct hoscar_save {
  fem::str<8> code;
  float ebeam;
  float ene;
  int i;
  int ievent;
  int nff;
  int ntestp;
  float phi;
  fem::str<8> reffra;
  float xmp;
  float xmt;

  hoscar_save()
      : code(fem::char0),
        ebeam(fem::float0),
        ene(fem::float0),
        i(fem::int0),
        ievent(fem::int0),
        nff(fem::int0),
        ntestp(fem::int0),
        phi(fem::float0),
        reffra(fem::char0),
        xmp(fem::float0),
        xmt(fem::float0) {}
};

/// C
/// C=======================================================================
void hoscar(common& cmn) {
  FEM_CMN_SVE(hoscar);
  common_write write(cmn);
  /// COMMON snn
  float& efrm = cmn.efrm;
  /// COMMON hbt
  const int maxstr = 150001;
  arr_cref<int> lblast(cmn.lblast, dimension(maxstr));
  arr_cref<float, 2> xlast(cmn.xlast, dimension(4, maxstr));
  arr_cref<float, 2> plast(cmn.plast, dimension(4, maxstr));
  int& nlast = cmn.nlast;
  /// COMMON oscar1
  int& iap = cmn.iap;
  int& izp = cmn.izp;
  int& iat = cmn.iat;
  int& izt = cmn.izt;
  /// COMMON oscar2
  fem::str<8>& frame = cmn.frame;
  ///
  /// SAVE
  fem::str<8>& code = sve.code;
  float& ebeam = sve.ebeam;
  float& ene = sve.ene;
  int& i = sve.i;
  int& ievent = sve.ievent;
  int& nff = sve.nff;
  int& ntestp = sve.ntestp;
  float& phi = sve.phi;
  fem::str<8>& reffra = sve.reffra;
  float& xmp = sve.xmp;
  float& xmt = sve.xmt;
  ///
  if (is_called_first_time) {
    nff = 0;
  }
  /// C
  /// Cc      SAVE /snn/
  /// Cc      SAVE /lastt/
  /// Cc      SAVE /hbt/
  /// Cc      SAVE /oscar1/
  /// Cc      SAVE /oscar2/
  /// C
  /// C       file header
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  if (nff == 0) {
    write(19, "(a10)"), "OSCAR1997A";
    write(19, "(a12)"), "final_id_p_x";
    code = "AMPT";
    if (frame == "CMS") {
      reffra = "nncm";
      xmp = (amp * izp + amn * (iap - izp)) / iap;
      xmt = (amp * izt + amn * (iat - izt)) / iat;
      ebeam = (fem::pow2(efrm) - fem::pow2(xmp) - fem::pow2(xmt)) / 2.f / xmt;
    } else if (frame == "LAB") {
      reffra = "lab";
      ebeam = efrm;
    } else {
      reffra = "unknown";
      ebeam = 0.f;
    }
    ntestp = 1;
    write(19,
          "(a4,1x,a20,1x,'(',i3,',',i3,')+(',i3,',',i3,')',2x,a4,2x,e10.4,2x,"
          "i8)"),
        code, cmn.amptvn, iap, izp, iat, izt, reffra, ebeam, ntestp;
    nff = 1;
    ievent = 1;
    phi = 0.f;
    if (frame == "CMS") {
      write(19, "('# Center-of-mass energy/nucleon-pair is',f12.3,'GeV')"),
          efrm;
    }
  }
  /// C       comment
  /// C       event header
  write(19, "(i10,2x,i10,2x,f8.3,2x,f8.3)"), ievent, nlast, cmn.bimp, phi;
  /// C       particles
  FEM_DO_SAFE(i, 1, nlast) {
    ene = fem::sqrt(fem::pow2(plast(1, i)) + fem::pow2(plast(2, i)) +
                    fem::pow2(plast(3, i)) + fem::pow2(plast(4, i)));
    write(19, "(i10,2x,i10,2x,9(e12.6,2x))"), i, invflv(cmn, lblast(i)),
        plast(1, i), plast(2, i), plast(3, i), ene, plast(4, i), xlast(1, i),
        xlast(2, i), xlast(3, i), xlast(4, i);
  }
  ievent++;
  /// C
}

struct hbtout_save {
  static const int maxstr = 150001;

  float deltat;
  float dr;
  float ene;
  int i;
  int ii;
  int ip;
  int ip2;
  int iplast;
  arr<int> lastkp;
  int ndpert;
  arr<int> newkp;
  arr<float> xnew;

  hbtout_save()
      : deltat(fem::float0),
        dr(fem::float0),
        ene(fem::float0),
        i(fem::int0),
        ii(fem::int0),
        ip(fem::int0),
        ip2(fem::int0),
        iplast(fem::int0),
        lastkp(dimension(maxstr), fem::fill0),
        ndpert(fem::int0),
        newkp(dimension(maxstr), fem::fill0),
        xnew(dimension(3), fem::fill0) {}
};

const int hbtout_save::maxstr;

/// C
/// C.................... linana.f
/// C=======================================================================
/// C     10/26/01 update freezeout positions in case of interactions:
/// Clin-3/2009 Note: freezeout spacetime values cannot be trusted for K0S & K0L
/// C     as K0S/K0L are converted from K+/K- by hand at the end of hadron
/// cascade.
void hbtout(common& cmn, int const& nnew, int const& nt, int const& ntmax) {
  FEM_CMN_SVE(hbtout);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<int> lblast(cmn.lblast, dimension(maxstr));
  arr_ref<float, 2> xlast(cmn.xlast, dimension(4, maxstr));
  arr_ref<float, 2> plast(cmn.plast, dimension(4, maxstr));
  int& nlast = cmn.nlast;
  float& dt = cmn.dt;
  arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  arr_cref<int> lb(cmn.lb, dimension(maxstr));
  float& bimp = cmn.bimp;
  arr_cref<float> tfdcy(cmn.tfdcy, dimension(maxstr));
  int& iaevt = cmn.iaevt;
  int& iarun = cmn.iarun;
  int& npart1 = cmn.npart1;
  int& npart2 = cmn.npart2;
  float& epsipz = cmn.epsipz;
  float& epsipt = cmn.epsipt;
  int& nelt = cmn.nelt;
  int& ninthj = cmn.ninthj;
  int& nelp = cmn.nelp;
  int& ninp = cmn.ninp;
  arr_cref<float> ftsv(cmn.ftsv, dimension(maxstr));
  arr_cref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float> dplast(cmn.dplast, dimension(maxstr));
  int& idpert = cmn.idpert;
  ///
  float& deltat = sve.deltat;
  float& dr = sve.dr;
  float& ene = sve.ene;
  int& i = sve.i;
  int& ii = sve.ii;
  int& ip = sve.ip;
  int& ip2 = sve.ip2;
  int& iplast = sve.iplast;
  arr_ref<int> lastkp(sve.lastkp, dimension(maxstr));
  int& ndpert = sve.ndpert;
  arr_ref<int> newkp(sve.newkp, dimension(maxstr));
  arr_ref<float> xnew(sve.xnew, dimension(3));
  const float oneminus = 0.99999f;
  const float oneplus = 1.00001f;
  static const char* format_200 = "(i6,2(1x,f8.3),1x,f11.4,1x,f6.3,4(1x,f8.2))";
  static const char* format_250 =
      "(i5,2(1x,f8.3),1x,f10.3,2(1x,f7.1),1x,f8.2,1x,f7.2,1x,e10.4)";
  /// C
  /// Clin-5/2008 give tolerance to regular particles (perturbative probability
  /// 1): Cc      SAVE /para7/ Cc      SAVE /hbt/ Cc      SAVE /input1/ Cc SAVE
  /// /AA/ Cc      SAVE /BB/ Cc      SAVE /CC/ Cc      SAVE /EE/ Cc      SAVE
  /// /lastt/ Cc      SAVE /tdecay/ Cc      SAVE /AREVT/ Cc      SAVE /snn/ Cc
  /// SAVE /HJGLBR/ Clin-12/14/03: Clin-2/2012:
  /// C
  FEM_DO_SAFE(i, 1, fem::max0(nlast, nnew)) { lastkp(i) = 0; }
  FEM_DO_SAFE(i, 1, nnew) { newkp(i) = 0; }
  /// C     for each of the particles, search the freezeout record (common
  /// /hbt/) C     to find & keep those which do not have interactions during
  /// this timestep:
  FEM_DO_SAFE(ip, 1, nnew) {
    FEM_DO_SAFE(iplast, 1, nlast) {
      if (p(1, ip) == plast(1, iplast) && p(2, ip) == plast(2, iplast) &&
          p(3, ip) == plast(3, iplast) && e(ip) == plast(4, iplast) &&
          lb(ip) == lblast(iplast) && dpertp(ip) == dplast(iplast) &&
          lastkp(iplast) == 0) {
        /// Clin-5/2008 modified below to the above in case we have perturbative
        /// particles: C     5           lastkp(iplast).eq.0) then
        deltat = nt * dt - xlast(4, iplast);
        ene = fem::sqrt(
            fem::pow2(plast(1, iplast)) + fem::pow2(plast(2, iplast)) +
            fem::pow2(plast(3, iplast)) + fem::pow2(plast(4, iplast)));
        /// C     xnew gives the coordinate if a particle free-streams to
        /// current time:
        FEM_DO_SAFE(ii, 1, 3) {
          xnew(ii) = xlast(ii, iplast) + plast(ii, iplast) / ene * deltat;
        }
        dr = fem::sqrt(fem::pow2((r(1, ip) - xnew(1))) +
                       fem::pow2((r(2, ip) - xnew(2))) +
                       fem::pow2((r(3, ip) - xnew(3))));
        /// C     find particles with dp=0 and dr<0.01, considered to be those
        /// C     without any interactions during this timestep,
        /// C     thus keep their last positions and time:
        if (dr <= 0.01f) {
          lastkp(iplast) = 1;
          newkp(ip) = 1;
          /// C                  if(lb(ip).eq.41) then
          /// C                write(95,*)
          /// 'nt,ip,px,x=',nt,ip,p(1,ip),r(1,ip),ftsv(ip) C write(95,*)
          /// 'xnew=',xnew(1),xnew(2),xnew(3),xlast(4,ip) C endif Clin-5/2009
          /// Take care of formation time of particles read in at nt=ntmax-1:
          if (nt == ntmax && ftsv(ip) > ((ntmax - 1) * dt)) {
            xlast(4, iplast) = ftsv(ip);
          }
          goto statement_100;
        }
      }
    }
  statement_100:;
  }
  /// C     for current particles with interactions, fill their current info in
  /// C     the freezeout record (if that record entry needs not to be kept):
  FEM_DO_SAFE(ip, 1, nnew) {
    if (newkp(ip) == 0) {
      FEM_DO_SAFE(iplast, 1, nnew) {
        if (lastkp(iplast) == 0) {
          /// Ctest off: write collision info
          /// C                  if(lb(ip).eq.41) then
          /// C                     write(95,*) 'nt,lb(ip)=',nt,lb(ip)
          /// C                  write(95,*) '  last p=',plast(1,iplast),
          /// C     1 plast(2,iplast),plast(3,iplast),plast(4,iplast)
          /// C                  write(95,*) '  after
          /// p=',p(1,ip),p(2,ip),p(3,ip),e(ip) C                  write(95,*)
          /// 'after x=',r(1,ip),r(2,ip),r(3,ip),ftsv(ip) C endif
          /// C
          xlast(1, iplast) = r(1, ip);
          xlast(2, iplast) = r(2, ip);
          xlast(3, iplast) = r(3, ip);
          xlast(4, iplast) = nt * dt;
          /// C
          if (nt == ntmax) {
            /// C     freezeout time for decay daughters at the last timestep
            /// C     needs to include the decay time of the parent:
            if (tfdcy(ip) > (ntmax * dt + 0.001f)) {
              xlast(4, iplast) = tfdcy(ip);
              /// C     freezeout time for particles unformed at the
              /// next-to-last timestep C     needs to be their formation time
              /// instead of (ntmax*dt):
            } else if (ftsv(ip) > ((ntmax - 1) * dt)) {
              xlast(4, iplast) = ftsv(ip);
            }
          }
          plast(1, iplast) = p(1, ip);
          plast(2, iplast) = p(2, ip);
          plast(3, iplast) = p(3, ip);
          plast(4, iplast) = e(ip);
          lblast(iplast) = lb(ip);
          lastkp(iplast) = 1;
          /// Clin-5/2008:
          dplast(iplast) = dpertp(ip);
          goto statement_150;
        }
      }
    }
  statement_150:;
  }
  /// C     if the current particle list is shorter than the freezeout record,
  /// C     condense the last-collision record by filling new record from 1 to
  /// nnew, C     and label these entries as keep:
  if (nnew < nlast) {
    FEM_DO_SAFE(iplast, 1, nlast) {
      if (lastkp(iplast) == 0) {
        FEM_DO_SAFE(ip2, iplast + 1, nlast) {
          if (lastkp(ip2) == 1) {
            xlast(1, iplast) = xlast(1, ip2);
            xlast(2, iplast) = xlast(2, ip2);
            xlast(3, iplast) = xlast(3, ip2);
            xlast(4, iplast) = xlast(4, ip2);
            plast(1, iplast) = plast(1, ip2);
            plast(2, iplast) = plast(2, ip2);
            plast(3, iplast) = plast(3, ip2);
            plast(4, iplast) = plast(4, ip2);
            lblast(iplast) = lblast(ip2);
            lastkp(iplast) = 1;
            /// Clin-5/2008:
            dplast(iplast) = dplast(ip2);
            goto statement_170;
          }
        }
      }
    statement_170:;
    }
  }
  nlast = nnew;
  /// Ctest off look inside each NT timestep (for debugging purpose):
  /// C      do ip=1,nlast
  /// C         write(99,*) ' p ',nt,ip,lblast(ip),plast(1,ip),
  /// C     1        plast(2,ip),plast(3,ip),plast(4,ip),dplast(ip)
  /// C         write(99,*) '  x ',nt,ip,lblast(ip),xlast(1,ip),
  /// C     1        xlast(2,ip),xlast(3,ip),xlast(4,ip),dplast(ip)
  /// C      enddo
  /// C
  if (nt == ntmax) {
    /// Clin-5/2008 find final number of perturbative particles (deuterons
    /// only):
    ndpert = 0;
    FEM_DO_SAFE(ip, 1, nlast) {
      if (dplast(ip) > oneminus && dplast(ip) < oneplus) {
      } else {
        ndpert++;
      }
    }
    /// C
    /// C         write(16,190) IAEVT,IARUN,nlast,bimp,npart1,npart2,
    /// C     1 NELP,NINP,NELT,NINTHJ
    /// Clin-2/2012:
    /// C         write(16,190) IAEVT,IARUN,nlast-ndpert,bimp,npart1,npart2,
    /// C     1 NELP,NINP,NELT,NINTHJ
    write(16, "(3(i7),f10.4,5x,6(i4),5x,f7.4)"), iaevt, iarun, nlast - ndpert,
        bimp, npart1, npart2, nelp, ninp, nelt, ninthj, cmn.phirp;
    /// Clin-5/2008 write out perturbatively-produced particles (deuterons
    /// only):
    if (idpert == 1 || idpert == 2) {
      write(90, "(3(i7),f10.4,5x,6(i4))"), iaevt, iarun, ndpert, bimp, npart1,
          npart2, nelp, ninp, nelt, ninthj;
    }
    FEM_DO_SAFE(ip, 1, nlast) {
      /// Clin-12/14/03   No formation time for spectator projectile or target
      /// nucleons, C     see ARINI1 in 'amptsub.f': Clin-3/2009 To be
      /// consistent with new particles produced in hadron cascade C     that
      /// are limited by the time-resolution (DT) of the hadron cascade, C
      /// freezeout time of spectator projectile or target nucleons is written
      /// as C     DT as they are read at the 1st timestep and then propagated
      /// to time DT:
      /// C
      /// Clin-9/2011 determine spectator nucleons consistently
      /// C            if(plast(1,ip).eq.0.and.plast(2,ip).eq.0
      /// C     1 .and.(sqrt(plast(3,ip)**2+plast(4,ip)**2)*2/HINT1(1)) C     2
      /// .gt.0.99.and.(lblast(ip).eq.1.or.lblast(ip).eq.2)) then
      if (fem::abs(plast(1, ip)) <= epsipt &&
          fem::abs(plast(2, ip)) <= epsipt &&
          (plast(3, ip) > fem::amax1(0.f, cmn.pzproj - epsipz) ||
           plast(3, ip) < (-cmn.pztarg + epsipz)) &&
          (lblast(ip) == 1 || lblast(ip) == 2)) {
        /// Clin-5/2008 perturbatively-produced particles (currently only
        /// deuterons) C     are written to ana/ampt_pert.dat (without the
        /// column for the mass); C     ana/ampt.dat has regularly-produced
        /// particles (including deuterons); C     these two sets of deuteron
        /// data are close to each other(but not the same C     because of the
        /// bias from triggering the perturbative production); C     ONLY use
        /// one data set for analysis to avoid double-counting:
        if (dplast(ip) > oneminus && dplast(ip) < oneplus) {
          write(16, format_200), invflv(cmn, lblast(ip)), plast(1, ip),
              plast(2, ip), plast(3, ip), plast(4, ip), xlast(1, ip),
              xlast(2, ip), xlast(3, ip), xlast(4, ip);
          /// Clin-12/14/03-end
        } else {
          if (idpert == 1 || idpert == 2) {
            write(90, format_250), invflv(cmn, lblast(ip)), plast(1, ip),
                plast(2, ip), plast(3, ip), xlast(1, ip), xlast(2, ip),
                xlast(3, ip), xlast(4, ip);
          } else {
            write(99, star), "Unexpected perturbative particles";
          }
        }
      } else if (fem::amax1(fem::abs(xlast(1, ip)), fem::abs(xlast(2, ip)),
                            fem::abs(xlast(3, ip)),
                            fem::abs(xlast(4, ip))) < 9999) {
        if (dplast(ip) > oneminus && dplast(ip) < oneplus) {
          write(16, format_200), invflv(cmn, lblast(ip)), plast(1, ip),
              plast(2, ip), plast(3, ip), plast(4, ip), xlast(1, ip),
              xlast(2, ip), xlast(3, ip), xlast(4, ip);
        } else {
          if (idpert == 1 || idpert == 2) {
            write(90, format_250), invflv(cmn, lblast(ip)), plast(1, ip),
                plast(2, ip), plast(3, ip), xlast(1, ip), xlast(2, ip),
                xlast(3, ip), xlast(4, ip), dplast(ip);
          } else {
            write(99, star), "Unexpected perturbative particles";
          }
        }
      } else {
        /// C     change format for large numbers:
        if (dplast(ip) > oneminus && dplast(ip) < oneplus) {
          write(16, "(i6,2(1x,f8.3),1x,f11.4,1x,f6.3,4(1x,e8.2))"),
              invflv(cmn, lblast(ip)), plast(1, ip), plast(2, ip), plast(3, ip),
              plast(4, ip), xlast(1, ip), xlast(2, ip), xlast(3, ip),
              xlast(4, ip);
        } else {
          if (idpert == 1 || idpert == 2) {
            write(90, "(i5,2(1x,f8.3),1x,f10.3,4(1x,e8.2),1x,e10.4)"),
                invflv(cmn, lblast(ip)), plast(1, ip), plast(2, ip),
                plast(3, ip), xlast(1, ip), xlast(2, ip), xlast(3, ip),
                xlast(4, ip), dplast(ip);
          } else {
            write(99, star), "Unexpected perturbative particles";
          }
        }
      }
    }
    if (cmn.ioscar == 1) {
      hoscar(cmn);
    }
  }
  /// Clin-3/2009 improve the output accuracy of Pz
  /// C
}

struct artmn_save {
  static const int maxstr = 150001;
  static const int maxr = 1;

  float acndn;
  float acnnd;
  float acoll;
  float add;
  float addk;
  float addrho;
  float adecay;
  float adirt;
  float adou;
  float akaon;
  float akg;
  float akn;
  float ald;
  float ale;
  float alkaon;
  float aln;
  float aln5;
  float alp;
  float andk;
  float annk;
  float annom;
  float annrho;
  float aom;
  float apd;
  float apn;
  float app;
  float appk;
  float ares;
  float arh;
  float asy;
  float atotal;
  float b;
  float b2;
  float betac;
  float betapr;
  float betata;
  float bkg;
  float bmax;
  float bx;
  float by;
  float cden;
  float ct;
  float ctlong;
  float ddx;
  float ddy;
  float ddz;
  float den;
  float denst;
  float drr;
  float ecms0;
  float ecor;
  float edenst;
  float ekin;
  float engs;
  float epr;
  float esbin;
  arr<float, 2> et;
  float eta;
  float etotal;
  float facl;
  float gammas;
  float gammc;
  float gammpr;
  float gammta;
  float gradx;
  float gradxk;
  float gradxn;
  float gradxp;
  float grady;
  float gradyk;
  float gradyn;
  float gradyp;
  float gradz;
  float gradzk;
  float gradzn;
  float gradzp;
  float grp;
  int i;
  int i0;
  int ia;
  int ib;
  int ic;
  int idir;
  int ie;
  int ii;
  int ikaon;
  int il;
  int imany;
  int ipart;
  int ir;
  int irun;
  int is;
  int iso;
  int iss;
  int ix;
  int iy;
  int iz;
  int j;
  int jl;
  int kkk;
  int l0;
  int lb1;
  int lbloc;
  int lcndn;
  int lcnnd;
  int lcnne;
  int lcoll;
  int ld;
  int ld1;
  int ld2;
  int ld3;
  int ld4;
  int ldd;
  int lddk;
  int lddrho;
  int ldecay;
  int ldirt;
  int ldou;
  int le;
  int lkaon;
  int lkaons;
  int lkn;
  int ln;
  int ln1;
  int ln2;
  int ln5;
  int lndk;
  int lnnk;
  int lnnom;
  int lnnrho;
  int lomega;
  int lp;
  int lp1;
  int lp2;
  int lp3;
  int lpd;
  int lpn;
  int lpp;
  int lppk;
  int lres;
  int lrho;
  int lrun;
  arr<int, 2> lt;
  int mass;
  int mean;
  int mrun;
  int nbaryn;
  int ncen;
  int nlost;
  int np;
  int np1;
  arr<int> npi;
  int nquark;
  int nsh;
  int nt;
  int ntotal;
  int numnt;
  int outpar;
  float pr0;
  float pr1;
  arr<float, 2> prot;
  float psqare;
  arr<float, 3> pt;
  float pzpr;
  float pzta;
  float radpr;
  float rads;
  float radta;
  float radut;
  float rbloc;
  float rcndn;
  float rcnnd;
  float rcnne;
  float rcoll;
  float rdd;
  float rddk;
  float rdecay;
  float rdiff;
  float rdirt;
  float rkn;
  float rndk;
  float rnnk;
  float rnsg;
  float rpd;
  float rpn;
  float rpp;
  float rppk;
  float rres;
  arr<float, 3> rt;
  float s;
  arr<float, 2> sekaon;
  float sk;
  float ska0;
  float ska1;
  arr<float> skaon;
  float sp;
  float spt;
  float spz;
  float sumene;
  arr<float, 2> temp;
  float tz;
  float udt;
  float vols;
  float xx1;
  float xx2;
  float zdist;
  arr<float> zet;
  float zras;

  artmn_save()
      : acndn(fem::float0),
        acnnd(fem::float0),
        acoll(fem::float0),
        add(fem::float0),
        addk(fem::float0),
        addrho(fem::float0),
        adecay(fem::float0),
        adirt(fem::float0),
        adou(fem::float0),
        akaon(fem::float0),
        akg(fem::float0),
        akn(fem::float0),
        ald(fem::float0),
        ale(fem::float0),
        alkaon(fem::float0),
        aln(fem::float0),
        aln5(fem::float0),
        alp(fem::float0),
        andk(fem::float0),
        annk(fem::float0),
        annom(fem::float0),
        annrho(fem::float0),
        aom(fem::float0),
        apd(fem::float0),
        apn(fem::float0),
        app(fem::float0),
        appk(fem::float0),
        ares(fem::float0),
        arh(fem::float0),
        asy(fem::float0),
        atotal(fem::float0),
        b(fem::float0),
        b2(fem::float0),
        betac(fem::float0),
        betapr(fem::float0),
        betata(fem::float0),
        bkg(fem::float0),
        bmax(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        cden(fem::float0),
        ct(fem::float0),
        ctlong(fem::float0),
        ddx(fem::float0),
        ddy(fem::float0),
        ddz(fem::float0),
        den(fem::float0),
        denst(fem::float0),
        drr(fem::float0),
        ecms0(fem::float0),
        ecor(fem::float0),
        edenst(fem::float0),
        ekin(fem::float0),
        engs(fem::float0),
        epr(fem::float0),
        esbin(fem::float0),
        et(dimension(maxstr, maxr), fem::fill0),
        eta(fem::float0),
        etotal(fem::float0),
        facl(fem::float0),
        gammas(fem::float0),
        gammc(fem::float0),
        gammpr(fem::float0),
        gammta(fem::float0),
        gradx(fem::float0),
        gradxk(fem::float0),
        gradxn(fem::float0),
        gradxp(fem::float0),
        grady(fem::float0),
        gradyk(fem::float0),
        gradyn(fem::float0),
        gradyp(fem::float0),
        gradz(fem::float0),
        gradzk(fem::float0),
        gradzn(fem::float0),
        gradzp(fem::float0),
        grp(fem::float0),
        i(fem::int0),
        i0(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        idir(fem::int0),
        ie(fem::int0),
        ii(fem::int0),
        ikaon(fem::int0),
        il(fem::int0),
        imany(fem::int0),
        ipart(fem::int0),
        ir(fem::int0),
        irun(fem::int0),
        is(fem::int0),
        iso(fem::int0),
        iss(fem::int0),
        ix(fem::int0),
        iy(fem::int0),
        iz(fem::int0),
        j(fem::int0),
        jl(fem::int0),
        kkk(fem::int0),
        l0(fem::int0),
        lb1(fem::int0),
        lbloc(fem::int0),
        lcndn(fem::int0),
        lcnnd(fem::int0),
        lcnne(fem::int0),
        lcoll(fem::int0),
        ld(fem::int0),
        ld1(fem::int0),
        ld2(fem::int0),
        ld3(fem::int0),
        ld4(fem::int0),
        ldd(fem::int0),
        lddk(fem::int0),
        lddrho(fem::int0),
        ldecay(fem::int0),
        ldirt(fem::int0),
        ldou(fem::int0),
        le(fem::int0),
        lkaon(fem::int0),
        lkaons(fem::int0),
        lkn(fem::int0),
        ln(fem::int0),
        ln1(fem::int0),
        ln2(fem::int0),
        ln5(fem::int0),
        lndk(fem::int0),
        lnnk(fem::int0),
        lnnom(fem::int0),
        lnnrho(fem::int0),
        lomega(fem::int0),
        lp(fem::int0),
        lp1(fem::int0),
        lp2(fem::int0),
        lp3(fem::int0),
        lpd(fem::int0),
        lpn(fem::int0),
        lpp(fem::int0),
        lppk(fem::int0),
        lres(fem::int0),
        lrho(fem::int0),
        lrun(fem::int0),
        lt(dimension(maxstr, maxr), fem::fill0),
        mass(fem::int0),
        mean(fem::int0),
        mrun(fem::int0),
        nbaryn(fem::int0),
        ncen(fem::int0),
        nlost(fem::int0),
        np(fem::int0),
        np1(fem::int0),
        npi(dimension(maxr), fem::fill0),
        nquark(fem::int0),
        nsh(fem::int0),
        nt(fem::int0),
        ntotal(fem::int0),
        numnt(fem::int0),
        outpar(fem::int0),
        pr0(fem::float0),
        pr1(fem::float0),
        prot(dimension(maxstr, maxr), fem::fill0),
        psqare(fem::float0),
        pt(dimension(3, maxstr, maxr), fem::fill0),
        pzpr(fem::float0),
        pzta(fem::float0),
        radpr(fem::float0),
        rads(fem::float0),
        radta(fem::float0),
        radut(fem::float0),
        rbloc(fem::float0),
        rcndn(fem::float0),
        rcnnd(fem::float0),
        rcnne(fem::float0),
        rcoll(fem::float0),
        rdd(fem::float0),
        rddk(fem::float0),
        rdecay(fem::float0),
        rdiff(fem::float0),
        rdirt(fem::float0),
        rkn(fem::float0),
        rndk(fem::float0),
        rnnk(fem::float0),
        rnsg(fem::float0),
        rpd(fem::float0),
        rpn(fem::float0),
        rpp(fem::float0),
        rppk(fem::float0),
        rres(fem::float0),
        rt(dimension(3, maxstr, maxr), fem::fill0),
        s(fem::float0),
        sekaon(dim1(7).dim2(0, 2000), fem::fill0),
        sk(fem::float0),
        ska0(fem::float0),
        ska1(fem::float0),
        skaon(dimension(7), fem::fill0),
        sp(fem::float0),
        spt(fem::float0),
        spz(fem::float0),
        sumene(fem::float0),
        temp(dimension(3, maxstr), fem::fill0),
        tz(fem::float0),
        udt(fem::float0),
        vols(fem::float0),
        xx1(fem::float0),
        xx2(fem::float0),
        zdist(fem::float0),
        zet(dim1(-45, 45), fem::fill0),
        zras(fem::float0) {}
};

const int artmn_save::maxstr;
const int artmn_save::maxr;

/// C....................art1f.f
/// C*************************************
/// C
/// C                           PROGRAM ART1.0
/// C
/// C        A relativistic transport (ART) model for heavy-ion collisions
/// C
/// C   sp/01/04/2002
/// C   calculates K+K- from phi decay, dimuons from phi decay
/// C   has finite baryon density & possibilites of varying Kaon
/// C   in-medium mass in phiproduction-annhilation channel only.
/// C
/// C RELEASING DATE: JAN., 1997
/// C**************************************
/// C
/// C Bao-An Li & Che Ming Ko
/// C Cyclotron Institute, Texas A&M University.
/// C Phone: (409) 845-1411
/// C e-mail: Bali@comp.tamu.edu & Ko@comp.tamu.edu
/// C http:///wwwcyc.tamu.edu/~bali
/// C**************************************
/// C Speical notice on the limitation of the code:
/// C
/// C (1) ART is a hadronic transport model
/// C
/// C (2) E_beam/A <= 15 GeV
/// C
/// C (3) The mass of the colliding system is limited by the dimensions of
/// arrays C    which can be extended purposely. Presently the dimensions are
/// large enough C     for running Au+Au at 15 GeV/A.
/// C
/// C (4) The production and absorption of antiparticles (e.g., ki-,
/// anti-nucleons, C     etc) are not fully included in this version of the
/// model. They, however, C     have essentially no effect on the reaction
/// dynamics and observables C     related to nucleons, pions and kaons (K+) at
/// and below AGS energies.
/// C
/// C (5) Bose enhancement for mesons and Pauli blocking for fermions are
/// C     turned off.
/// C
/// C********************************
/// C
/// C USEFUL REFERENCES ON PHYSICS AND NUMERICS OF NUCLEAR TRANSPORT MODELS:
/// C     G.F. BERTSCH AND DAS GUPTA, PHYS. REP. 160 (1988) 189.
/// C     B.A. LI AND W. BAUER, PHYS. REV. C44 (1991) 450.
/// C     B.A. LI, W. BAUER AND G.F. BERTSCH, PHYS. REV. C44 (1991) 2095.
/// C     P. DANIELEWICZ AND G.F. BERTSCH, NUCL. PHYS. A533 (1991) 712.
/// C
/// C MAIN REFERENCES ON THIS VERSION OF ART MODEL:
/// C     B.A. LI AND C.M. KO, PHYS. REV. C52 (1995) 2037;
/// C                          NUCL. PHYS. A601 (1996) 457.
/// C
/// C*********************************
/// C  VARIABLES IN INPUT-SECTION: * C * C  1) TARGET-RELATED QUANTITIES * C
/// MASSTA, ZTA -  TARGET MASS IN AMU, TARGET CHARGE  (INTEGER)    * C * C  2)
/// PROJECTILE-RELATED QUANTITIES                                    * C MASSPR,
/// ZPR -  PROJECTILE MASS IN AMU, PROJ. CHARGE(INTEGER)   * C       ELAB     -
/// BEAM ENERGY IN [MEV/NUCLEON]               (REAL)  * C       ZEROPT   -
/// DISPLACEMENT OF THE SYSTEM IN Z-DIREC. [FM](REAL)  * C       B        -
/// IMPACT PARAMETER [FM]                      (REAL)  * C * C  3)
/// PROGRAM-CONTROL PARAMETERS                                       * C ISEED
/// -  SEED FOR RANDOM NUMBER GENERATOR        (INTEGER)  * C       DT       -
/// TIME-STEP-SIZE [FM/C]                      (REAL)  * C       NTMAX    -
/// TOTAL NUMBER OF TIMESTEPS               (INTEGER)  * C       ICOLL    -  (=
/// 1 -> MEAN FIELD ONLY,                           * C                -   =-1
/// -> CACADE ONLY, ELSE FULL ART)     (INTEGER)  * C       NUM      -  NUMBER
/// OF TESTPARTICLES PER NUCLEON     (INTEGER)  * C       INSYS    -  (=0 ->
/// LAB-SYSTEM, ELSE C.M. SYSTEM)    (INTEGER)  * C       IPOT     -  1 ->
/// SIGMA=2; 2 -> SIGMA=4/3; 3 -> SIGMA=7/6       * C                   IN MEAN
/// FIELD POTENTIAL                 (INTEGER)  * C       MODE     -  (=1 ->
/// interpolation for pauli-blocking,           * C                    =2 ->
/// local lookup, other -> unblocked)(integer)  * C       DX,DY,DZ -  widths of
/// cell for paulat in coor. sp. [fm](real)  * C       DPX,DPY,DPZ-widths of
/// cell for paulat in mom. sp.[GeV/c](real) * C       IAVOID   -  (=1 -> AVOID
/// FIRST COLL. WITHIN SAME NUCL.         * C                    =0 -> ALLOW
/// THEM) (INTEGER) * C       IMOMEN   -  FLAG FOR CHOICE OF INITIAL MOMENTUM
/// DISTRIBUTION   * C                   (=1 -> WOODS-SAXON DENSITY AND LOCAL
/// THOMAS-FERMI  * C                    =2 -> NUCLEAR MATTER DEN. AND LOCAL
/// THOMAS-FERMI  * C                    =3 -> COHERENT BOOST IN Z-DIRECTION)
/// (INTEGER)  * C  4) CONTROL-PRINTOUT OPTIONS * C       NFREQ    -  NUMBER OF
/// TIMSTEPS AFTER WHICH PRINTOUT            * C                   IS REQUIRED
/// OR ON-LINE ANALYSIS IS PERFORMED       * C       ICFLOW      =1 PERFORM
/// ON-LINE FLOW ANALYSIS EVERY NFREQ STEPS * C       ICRHO       =1 PRINT OUT
/// THE BARYON,PION AND ENERGY MATRIX IN  * C                      THE REACTION
/// PLANE EVERY NFREQ TIME-STEPS       * C  5) C       CYCBOX   -  ne.0 =>
/// cyclic boundary conditions;boxsize CYCBOX  *
/// C
/// C*********************************
/// C               Lables of particles used in this code                     *
/// C*********************************
/// C
/// C         LB(I) IS USED TO LABEL PARTICLE'S CHARGE STATE
/// C
/// C         LB(I)   =
/// Clin-11/07/00:
/// C                -30 K*-
/// Clin-8/29/00
/// C                -13 anti-N*(+1)(1535),s_11
/// C                -12 anti-N*0(1535),s_11
/// C                 -11 anti-N*(+1)(1440),p_11
/// C                 -10 anti-N*0(1440), p_11
/// C                  -9 anti-DELTA+2
/// C                  -8 anti-DELTA+1
/// C                  -7 anti-DELTA0
/// C                  -6 anti-DELTA-1
/// Clin-8/29/00-end
/// C
/// Cbali2/7/99
/// C                  -2 antineutron
/// C                             -1       antiproton
/// Cbali2/7/99 end
/// C                   0 eta
/// C                        1 PROTON
/// C                   2 NUETRON
/// C                   3 PION-
/// C                   4 PION0
/// C                   5 PION+
/// C                   6 DELTA-1
/// C                   7 DELTA0
/// C                   8 DELTA+1
/// C                   9 DELTA+2
/// C                   10 N*0(1440), p_11
/// C                   11 N*(+1)(1440),p_11
/// C                  12 N*0(1535),s_11
/// C                  13 N*(+1)(1535),s_11
/// C                  14 LAMBDA
/// C                   15 sigma-, since we used isospin averaged xsection for
/// C                   16 sigma0  sigma associated K+ production, sigma0 and
/// C                   17 sigma+  sigma+ are counted as sigma-
/// C                   21 kaon-
/// C                   23 KAON+
/// C                   24 kaon0
/// C                   25 rho-
/// C                         26 rho0
/// C                   27 rho+
/// C                   28 omega meson
/// C                   29 phi
/// Clin-11/07/00:
/// C                  30 K*+
/// C sp01/03/01
/// C                 -14 LAMBDA(bar)
/// C                  -15 sigma-(bar)
/// C                  -16 sigma0(bar)
/// C                  -17 sigma+(bar)
/// C                   31 eta-prime
/// C                   40 cascade-
/// C                  -40 cascade-(bar)
/// C                   41 cascade0
/// C                  -41 cascade0(bar)
/// C                   45 Omega baryon
/// C                  -45 Omega baryon(bar)
/// C sp01/03/01 end
/// Clin-5/2008:
/// C                   42 Deuteron (same in ampt.dat)
/// C                  -42 anti-Deuteron (same in ampt.dat)
/// C
/// C                   ++  ------- SEE BAO-AN LI'S NOTE BOOK
/// C*********************************
/// Cbz11/16/98
/// C      PROGRAM ART
void artmn(common& cmn) {
  FEM_CMN_SVE(artmn);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_ref<float, 2> r(static_cast<common_aa&>(cmn).r, dimension(3, maxstr));
  arr_ref<float, 2> p(static_cast<common_bb&>(cmn).p, dimension(3, maxstr));
  arr_ref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
  const int maxx = 20;
  const int maxz = 24;
  arr_cref<float, 3> rho(cmn.rho,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  arr_ref<int> id(cmn.id, dimension(maxstr));
  arr_ref<int> lb(cmn.lb, dimension(maxstr));
  arr_ref<float> proper(cmn.proper, dimension(maxstr));
  const int maxr = 1;
  arr_ref<int> massr(cmn.massr, dim1(0, maxr));
  int& num = cmn.num;
  int& masspr = cmn.masspr;
  int& massta = cmn.massta;
  int& iseed = cmn.iseed;
  float& dt = cmn.dt;
  arr_cref<float, 3> pel(cmn.pel,
                         dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz));
  int& manyb = cmn.manyb;
  int& ntmax = cmn.ntmax;
  int& icoll = cmn.icoll;
  int& ipot = cmn.ipot;
  int& imomen = cmn.imomen;
  int& nfreq = cmn.nfreq;
  int& icou = cmn.icou;
  int& kpoten = cmn.kpoten;
  float& zeropt = cmn.zeropt;
  float& bi = cmn.bi;
  float& cycbox = cmn.cycbox;
  arr_cref<int> iapar2(cmn.iapar2, dimension(50));
  arr_ref<float, 2> pro1(cmn.pro1, dimension(maxstr, maxr));
  arr_ref<int> multi1(cmn.multi1, dimension(maxr));
  arr_ref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
  arr_ref<float, 2> gx1(cmn.gx1, dimension(maxstr, maxr));
  arr_ref<float, 2> gy1(cmn.gy1, dimension(maxstr, maxr));
  arr_ref<float, 2> gz1(cmn.gz1, dimension(maxstr, maxr));
  arr_ref<float, 2> ft1(cmn.ft1, dimension(maxstr, maxr));
  arr_ref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                        dimension(maxstr, maxr));
  arr_ref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
  arr_ref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
  arr_ref<int> lblast(cmn.lblast, dimension(maxstr));
  arr_ref<float, 2> xlast(cmn.xlast, dimension(4, maxstr));
  arr_ref<float, 2> plast(cmn.plast, dimension(4, maxstr));
  int& nseed = cmn.nseed;
  arr_ref<float> ftsv(cmn.ftsv, dimension(maxstr));
  arr_ref<float, 2> ftsvt(cmn.ftsvt, dimension(maxstr, maxr));
  arr_ref<float, 2> dpertt(cmn.dpertt, dimension(maxstr, maxr));
  arr_ref<float> dpertp(cmn.dpertp, dimension(maxstr));
  arr_ref<float, 2> dpp1(cmn.dpp1, dimension(maxstr, maxr));
  ///
  float& akg = sve.akg;
  float& ald = sve.ald;
  float& aln = sve.aln;
  float& aln5 = sve.aln5;
  float& alp = sve.alp;
  float& asy = sve.asy;
  float& b = sve.b;
  float& b2 = sve.b2;
  float& betac = sve.betac;
  float& betapr = sve.betapr;
  float& betata = sve.betata;
  float& bkg = sve.bkg;
  float& bx = sve.bx;
  float& by = sve.by;
  float& ct = sve.ct;
  float& ctlong = sve.ctlong;
  float& ddx = sve.ddx;
  float& ddy = sve.ddy;
  float& ddz = sve.ddz;
  float& den = sve.den;
  float& denst = sve.denst;
  float& drr = sve.drr;
  float& ecor = sve.ecor;
  float& edenst = sve.edenst;
  float& ekin = sve.ekin;
  float& engs = sve.engs;
  float& epr = sve.epr;
  arr_ref<float, 2> et(sve.et, dimension(maxstr, maxr));
  float& eta = sve.eta;
  float& etotal = sve.etotal;
  float& facl = sve.facl;
  float& gammas = sve.gammas;
  float& gammpr = sve.gammpr;
  float& gammta = sve.gammta;
  float& gradx = sve.gradx;
  float& gradxk = sve.gradxk;
  float& gradxn = sve.gradxn;
  float& gradxp = sve.gradxp;
  float& grady = sve.grady;
  float& gradyk = sve.gradyk;
  float& gradyn = sve.gradyn;
  float& gradyp = sve.gradyp;
  float& gradz = sve.gradz;
  float& gradzk = sve.gradzk;
  float& gradzn = sve.gradzn;
  float& gradzp = sve.gradzp;
  float& grp = sve.grp;
  int& i = sve.i;
  int& i0 = sve.i0;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& idir = sve.idir;
  int& ie = sve.ie;
  int& ii = sve.ii;
  int& il = sve.il;
  int& ir = sve.ir;
  int& irun = sve.irun;
  int& is = sve.is;
  int& iso = sve.iso;
  int& iss = sve.iss;
  int& ix = sve.ix;
  int& iy = sve.iy;
  int& iz = sve.iz;
  int& j = sve.j;
  int& jl = sve.jl;
  int& kkk = sve.kkk;
  int& l0 = sve.l0;
  int& lb1 = sve.lb1;
  int& lbloc = sve.lbloc;
  int& lcndn = sve.lcndn;
  int& lcnnd = sve.lcnnd;
  int& lcnne = sve.lcnne;
  int& lcoll = sve.lcoll;
  int& ld = sve.ld;
  int& ld1 = sve.ld1;
  int& ld2 = sve.ld2;
  int& ld3 = sve.ld3;
  int& ld4 = sve.ld4;
  int& ldd = sve.ldd;
  int& lddk = sve.lddk;
  int& lddrho = sve.lddrho;
  int& ldecay = sve.ldecay;
  int& ldirt = sve.ldirt;
  int& ldou = sve.ldou;
  int& le = sve.le;
  int& lkaon = sve.lkaon;
  int& lkaons = sve.lkaons;
  int& lkn = sve.lkn;
  int& ln = sve.ln;
  int& ln1 = sve.ln1;
  int& ln2 = sve.ln2;
  int& ln5 = sve.ln5;
  int& lndk = sve.lndk;
  int& lnnk = sve.lnnk;
  int& lnnom = sve.lnnom;
  int& lnnrho = sve.lnnrho;
  int& lomega = sve.lomega;
  int& lp = sve.lp;
  int& lp1 = sve.lp1;
  int& lp2 = sve.lp2;
  int& lp3 = sve.lp3;
  int& lpd = sve.lpd;
  int& lpn = sve.lpn;
  int& lpp = sve.lpp;
  int& lppk = sve.lppk;
  int& lres = sve.lres;
  int& lrho = sve.lrho;
  int& lrun = sve.lrun;
  arr_ref<int, 2> lt(sve.lt, dimension(maxstr, maxr));
  int& mass = sve.mass;
  int& mean = sve.mean;
  int& mrun = sve.mrun;
  int& nbaryn = sve.nbaryn;
  int& ncen = sve.ncen;
  int& np = sve.np;
  int& np1 = sve.np1;
  arr_ref<int> npi(sve.npi, dimension(maxr));
  int& nquark = sve.nquark;
  int& nsh = sve.nsh;
  int& nt = sve.nt;
  int& ntotal = sve.ntotal;
  int& numnt = sve.numnt;
  int& outpar = sve.outpar;
  arr_ref<float, 2> prot(sve.prot, dimension(maxstr, maxr));
  float& psqare = sve.psqare;
  arr_ref<float, 3> pt(sve.pt, dimension(3, maxstr, maxr));
  float& pzpr = sve.pzpr;
  float& pzta = sve.pzta;
  float& radpr = sve.radpr;
  float& rads = sve.rads;
  float& radta = sve.radta;
  float& radut = sve.radut;
  float& rbloc = sve.rbloc;
  float& rcndn = sve.rcndn;
  float& rcnnd = sve.rcnnd;
  float& rcnne = sve.rcnne;
  float& rcoll = sve.rcoll;
  float& rdd = sve.rdd;
  float& rddk = sve.rddk;
  float& rdecay = sve.rdecay;
  float& rdiff = sve.rdiff;
  float& rdirt = sve.rdirt;
  float& rkn = sve.rkn;
  float& rndk = sve.rndk;
  float& rnnk = sve.rnnk;
  float& rnsg = sve.rnsg;
  float& rpd = sve.rpd;
  float& rpn = sve.rpn;
  float& rpp = sve.rpp;
  float& rppk = sve.rppk;
  float& rres = sve.rres;
  arr_ref<float, 3> rt(sve.rt, dimension(3, maxstr, maxr));
  float& s = sve.s;
  float& spt = sve.spt;
  float& spz = sve.spz;
  float& sumene = sve.sumene;
  arr_ref<float, 2> temp(sve.temp, dimension(3, maxstr));
  float& tz = sve.tz;
  float& udt = sve.udt;
  float& vols = sve.vols;
  float& xx1 = sve.xx1;
  float& xx2 = sve.xx2;
  float& zdist = sve.zdist;
  arr_ref<float> zet(sve.zet, dim1(-45, 45));
  float& zras = sve.zras;
  if (is_called_first_time) {
    static const float values[] = {
        1.f,  0.f,  0.f, 0.f,  0.f,  1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, -1.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  0.f,  0.f, 0.f,  -1.f, 0.f, 1.f,  0.f, -1.f, 0.f, -1.f, 0.f,
        -2.f, -1.f, 0.f, 1.f,  0.f,  0.f, 0.f,  0.f, -1.f, 0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, -1.f, 0.f,  1.f, 2.f,  0.f, 1.f,  0.f, 1.f,  0.f,
        -1.f, 0.f,  1.f, 0.f,  0.f,  0.f, -1.f, 0.f, 1.f,  0.f, -1.f, 0.f,
        1.f,  0.f,  0.f, 1.f,  0.f,  0.f, 0.f,  0.f, 0.f,  0.f, 0.f,  0.f,
        0.f,  -1.f, 0.f, 0.f,  0.f,  0.f, -1.f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), zet;
  }
  const float amu = 0.9383f;
  arr_ref<float> skaon(sve.skaon, dimension(7));
  arr_ref<float, 2> sekaon(sve.sekaon, dim1(7).dim2(0, 2000));
  /// Cbz11/16/98end
  /// C*********************************
  /// C PARAMETERS:                                                           *
  /// C  MAXPAR     - MAXIMUM NUMBER OF PARTICLES      PROGRAM CAN HANDLE     *
  /// C  MAXP       - MAXIMUM NUMBER OF CREATED MESONS PROGRAM CAN HANDLE     *
  /// C  MAXR       - MAXIMUM NUMBER OF EVENTS AT EACH IMPACT PARAMETER       *
  /// C  MAXX       - NUMBER OF MESHPOINTS IN X AND Y DIRECTION = 2 MAXX + 1  *
  /// C  MAXZ       - NUMBER OF MESHPOINTS IN Z DIRECTION       = 2 MAXZ + 1  *
  /// C  AMU        - 1 ATOMIC MASS UNIT "GEV/C**2"                           *
  /// C  MX,MY,MZ   - MESH SIZES IN COORDINATE SPACE [FM] FOR PAULI LATTICE   *
  /// C  MPX,MPY,MPZ- MESH SIZES IN MOMENTUM SPACE [GEV/C] FOR PAULI LATTICE  *
  /// C---------------------------------------------------------------------- *
  /// Clin      PARAMETER     (maxpar=200000,MAXR=50,AMU= 0.9383,
  /// Clin      PARAMETER (MAXP = 14000)
  /// C----------------------------------------------------------------------*
  /// Cc      SAVE /AA/
  /// Cc      SAVE /BB/
  /// Cc      SAVE /CC/
  /// Cc      SAVE /DD/
  /// Cc      SAVE /EE/
  /// Cc      SAVE /HH/
  /// Cc      SAVE /ff/
  /// Cc      SAVE /gg/
  /// Cc      SAVE /INPUT/
  /// Cc      SAVE /RR/
  /// Cc      SAVE /ss/
  /// Cc      SAVE /zz/
  /// Cc      SAVE /RUN/
  /// Clin-4/2008:
  /// C      COMMON  /KKK/     TKAON(7),EKAON(7,0:200)
  /// Cc      SAVE /KKK/
  /// Cc      SAVE /KAON/
  /// Cc      SAVE /TABLE/
  /// Cc      SAVE /input1/
  /// Cc      SAVE /DDpi/
  /// Cc      SAVE /tt/
  /// Clin-4/2008:
  /// C      DIMENSION TEMP(3,MAXSTR),SKAON(7),SEKAON(7,0:200)
  /// Cbz12/2/98
  /// Cc      SAVE /INPUT2/
  /// Cc      SAVE /INPUT3/
  /// Cbz12/2/98end
  /// Cbz11/16/98
  /// Cc      SAVE /ARPRNT/
  /// C
  /// C.....note in the below, since a common block in ART is called EE,
  /// C.....the variable EE in /ARPRC/is changed to PEAR.
  /// Clin-9/29/03 changed name in order to distinguish from /prec2/
  /// C        COMMON /ARPRC/ ITYPAR(MAXSTR),
  /// C     &       GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
  /// C     &       PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
  /// C     &       XMAR(MAXSTR)
  /// Cc      SAVE /ARPRC/
  /// Clin-9/29/03-end
  /// Cc      SAVE /ARERCP/
  /// Cc      SAVE /ARERC1/
  /// Cc      SAVE /ARPRC1/
  /// C
  /// Cbz11/16/98end
  /// Cc      SAVE /lastt/
  /// Cc      SAVE /snn/
  /// Cc      SAVE /hbt/
  /// Cc      SAVE /resdcy/
  /// Cc      SAVE /RNDF77/
  /// Clin-4/2008 zet() expanded to avoid out-of-bound errors:
  /// C
  cmn.nlast = 0;
  FEM_DO_SAFE(i, 1, maxstr) {
    ftsv(i) = 0.f;
    FEM_DO_SAFE(irun, 1, maxr) { ftsvt(i, irun) = 0.f; }
    lblast(i) = 999;
    FEM_DO_SAFE(j, 1, 4) {
      /// Clin-4/2008 bugs pointed out by Vander Molen & Westfall:
      /// C            xlast(i,j)=0.
      /// C            plast(i,j)=0.
      xlast(j, i) = 0.f;
      plast(j, i) = 0.f;
    }
  }
  /// C
  /// C-------------------------------------------------------------------*
  /// C Input information about the reaction system and contral parameters*
  /// C-------------------------------------------------------------------*
  /// C              input section starts here                           *
  /// C-------------------------------------------------------------------*
  /// C
  /// Cbz12/2/98
  /// C.....input section is moved to subroutine ARTSET
  /// Cbz12/2/98end
  /// C
  /// C-----------------------------------------------------------------------*
  /// C                   input section ends here                            *
  /// C-----------------------------------------------------------------------*
  /// C read in the table for gengrating the transverse momentum
  /// C IN THE NN-->DDP PROCESS
  tablem(cmn);
  /// C several control parameters, keep them fixed in this code.
  sve.ikaon = 1;
  cmn.nstar = 1;
  cmn.ndirct = 0;
  cmn.dir = 0.02f;
  asy = 0.032f;
  sve.esbin = 0.04f;
  cmn.mf = 36;
  /// C----------------------------------------------------------------------*
  /// C      CALL FRONT(12,MASSTA,MASSPR,ELAB)
  /// C----------------------------------------------------------------------*
  radta = 1.124f * fem::pow(fem::ffloat(massta), (1.f / 3.f));
  radpr = 1.124f * fem::pow(fem::ffloat(masspr), (1.f / 3.f));
  zdist = radta + radpr;
  /// C      if ( cycbox.ne.0 ) zdist=0
  sve.bmax = radta + radpr;
  mass = massta + masspr;
  ntotal = num * mass;
  /// C
  if (ntotal > maxstr) {
    write(12, "(///10X,'**** FATAL ERROR: TOO MANY TEST PART. ****" +
                  str_cref(" ')"));
    FEM_STOP(0);
  }
  /// C
  /// C-----------------------------------------------------------------------
  /// C       RELATIVISTIC KINEMATICS
  /// C
  /// C       1) LABSYSTEM
  /// C
  eta = fem::ffloat(massta) * amu;
  pzta = 0.0f;
  betata = 0.0f;
  gammta = 1.0f;
  /// C
  epr = fem::ffloat(masspr) * (amu + 0.001f * cmn.elab);
  pzpr = fem::sqrt(fem::pow2(epr) - fem::pow2((amu * fem::ffloat(masspr))));
  betapr = pzpr / epr;
  gammpr = 1.0f / fem::sqrt(1.0f - fem::pow2(betapr));
  /// C
  /// C BETAC AND GAMMAC OF THE C.M. OBSERVED IN THE LAB. FRAME
  betac = (pzpr + pzta) / (epr + eta);
  sve.gammc = 1.0f / fem::sqrt(1.f - fem::pow2(betac));
  /// C
  /// C      WRITE(12,'(/10x,''****    KINEMATICAL PARAMETERS    ****''/)')
  /// C      WRITE(12,'(10x,''1) LAB-FRAME:        TARGET PROJECTILE'')')
  /// C      WRITE(12,'(10x,''   ETOTAL "GEV" '',2F11.4)') ETA, EPR
  /// C      WRITE(12,'(10x,''   P "GEV/C"    '',2F11.4)') PZTA, PZPR
  /// C      WRITE(12,'(10x,''   BETA         '',2F11.4)') BETATA, BETAPR
  /// C      WRITE(12,'(10x,''   GAMMA        '',2F11.4)') GAMMTA, GAMMPR
  if (cmn.insys != 0) {
    /// C
    /// C       2) C.M. SYSTEM
    /// C
    s = fem::pow2((epr + eta)) - fem::pow2(pzpr);
    xx1 = 4.f * fem::alog(fem::ffloat(massta));
    xx2 = 4.f * fem::alog(fem::ffloat(masspr));
    xx1 = fem::exp(xx1);
    xx2 = fem::exp(xx2);
    psqare = (fem::pow2(s) + (xx1 + xx2) * fem::pow4(amu) -
              2.0f * s * fem::pow2(amu) *
                  fem::ffloat(fem::pow2(massta) + fem::pow2(masspr)) -
              2.0f * fem::ffloat(fem::pow2(massta) * fem::pow2(masspr)) *
                  fem::pow4(amu)) /
             (4.0f * s);
    /// C
    eta = fem::sqrt(psqare + fem::pow2((fem::ffloat(massta) * amu)));
    pzta = -fem::sqrt(psqare);
    betata = pzta / eta;
    gammta = 1.0f / fem::sqrt(1.0f - fem::pow2(betata));
    /// C
    epr = fem::sqrt(psqare + fem::pow2((fem::ffloat(masspr) * amu)));
    pzpr = fem::sqrt(psqare);
    betapr = pzpr / epr;
    gammpr = 1.0f / fem::sqrt(1.0f - fem::pow2(betapr));
    /// C
    /// C        WRITE(12,'(10x,''2) C.M.-FRAME:  '')')
    /// C        WRITE(12,'(10x,''   ETOTAL "GEV" '',2F11.4)') ETA, EPR
    /// C        WRITE(12,'(10x,''   P "GEV/C"    '',2F11.4)') PZTA, PZPR
    /// C        WRITE(12,'(10x,''   BETA         '',2F11.4)') BETATA, BETAPR
    /// C        WRITE(12,'(10x,''   GAMMA        '',2F11.4)') GAMMTA, GAMMPR
    /// C        WRITE(12,'(10x,''S "GEV**2"      '',F11.4)')  S
    /// C        WRITE(12,'(10x,''PSQARE "GEV/C"2 '',E14.3)')  PSQARE
    /// C        WRITE(12,'(/10x,''*** CALCULATION DONE IN CM-FRAME ***''/)')
  } else {
    /// C        WRITE(12,'(/10x,''*** CALCULATION DONE IN LAB-FRAME ***''/)')
  }
  /// C MOMENTUM PER PARTICLE
  pzta = pzta / fem::ffloat(massta);
  pzpr = pzpr / fem::ffloat(masspr);
  /// C total initial energy in the N-N cms frame
  sve.ecms0 = eta + epr;
  /// C-----------------------------------------------------------------------
  /// C
  /// C Start loop over many runs of different impact parameters
  /// C IF MANYB=1, RUN AT A FIXED IMPACT PARAMETER B0, OTHERWISE GENERATE
  /// C MINIMUM BIAS EVENTS WITHIN THE IMPACT PARAMETER RANGE OF B_MIN AND B_MAX
  FEM_DO_SAFE(sve.imany, 1, manyb) {
    /// C------------------------------------------------------------------------
    /// C Initialize the impact parameter B
    if (manyb > 1) {
    statement_111:
      bx = 1.0f - 2.0f * ranart(nseed);
      by = 1.0f - 2.0f * ranart(nseed);
      b2 = bx * bx + by * by;
      if (b2 > 1.0f) {
        goto statement_111;
      }
      b = fem::sqrt(b2) * (cmn.bm - bi) + bi;
    } else {
      b = cmn.b0;
    }
    /// C      WRITE(12,'(////10X,''RUN NUMBER:'',I6)') IMANY
    /// C      WRITE(12,'(///10X,''IMPACT PARAMETER B FOR THIS RUN:'',
    /// C     &             F9.3,'' FM''/10X,49(''*'')/)') B
    /// C
    /// C-----------------------------------------------------------------------
    /// C       INITIALIZATION
    /// C1 INITIALIZATION IN ISOSPIN SPACE FOR BOTH THE PROJECTILE AND TARGET
    coulin(cmn, masspr, massta, num);
    /// C2 INITIALIZATION IN PHASE SPACE FOR THE TARGET
    init(cmn, 1, massta, num, radta, b / 2.f, zeropt + zdist / 2.f, pzta,
         gammta, iseed, mass, imomen);
    /// C3.1 INITIALIZATION IN PHASE SPACE FOR THE PROJECTILE
    init(cmn, 1 + massta, mass, num, radpr, -b / 2.f, zeropt - zdist / 2.f,
         pzpr, gammpr, iseed, mass, imomen);
    /// C3.2 OUTPAR IS THE NO. OF ESCAPED PARTICLES
    outpar = 0;
    /// C3.3 INITIALIZATION FOR THE NO. OF PARTICLES IN EACH SAMPLE
    /// C    THIS IS NEEDED DUE TO THE FACT THAT PIONS CAN BE PRODUCED OR
    /// ABSORBED
    massr(0) = 0;
    FEM_DO_SAFE(ir, 1, num) { massr(ir) = mass; }
    /// C3.4 INITIALIZation FOR THE KAON SPECTRUM
    /// C      CALL KSPEC0(BETAC,GAMMC)
    /// C calculate the local baryon density matrix
    dens(cmn, ipot, mass, num, outpar);
    /// C
    /// C-----------------------------------------------------------------------
    /// C       CONTROL PRINTOUT OF INITIAL CONFIGURATION
    /// C
    /// C      WRITE(12,'(''**********  INITIAL CONFIGURATION  **********''/)')
    /// C
    /// C print out the INITIAL density matrix in the reaction plane
    /// C       do ix=-10,10
    /// C       do iz=-10,10
    /// C       write(1053,992)ix,iz,rho(ix,0,iz)/0.168
    /// C       end do
    /// C-----------------------------------------------------------------------
    /// C       CALCULATE MOMENTA FOR T = 0.5 * DT
    /// C       (TO OBTAIN 2ND DEGREE ACCURACY!)
    /// C       "Reference: J. AICHELIN ET AL., PHYS. REV. C31, 1730 (1985)"
    /// C
    if (icoll != -1) {
      FEM_DO_SAFE(i, 1, ntotal) {
        ix = fem::nint(r(1, i));
        iy = fem::nint(r(2, i));
        iz = fem::nint(r(3, i));
        /// Clin-4/2008 check bounds:
        if (ix >= maxx || iy >= maxx || iz >= maxz || ix <= -maxx ||
            iy <= -maxx || iz <= -maxz) {
          goto statement_700;
        }
        gradu(cmn, ipot, ix, iy, iz, gradx, grady, gradz);
        p(1, i) = p(1, i) - (0.5f * dt) * gradx;
        p(2, i) = p(2, i) - (0.5f * dt) * grady;
        p(3, i) = p(3, i) - (0.5f * dt) * gradz;
      statement_700:;
      }
    }
    /// C-----------------------------------------------------------------------
    /// C4 INITIALIZATION OF TIME-LOOP VARIABLES
    /// C4.1 COLLISION NUMBER COUNTERS
    /// Clin 51      RCNNE  = 0
    rcnne = 0;
    rdd = 0;
    rpp = 0;
    rppk = 0;
    rpn = 0;
    rpd = 0;
    rkn = 0;
    rnnk = 0;
    rddk = 0;
    rndk = 0;
    rcnnd = 0;
    rcndn = 0;
    rcoll = 0;
    rbloc = 0;
    rdirt = 0;
    rdecay = 0;
    rres = 0;
    /// C4.11 KAON PRODUCTION PROBABILITY COUNTER FOR PERTURBATIVE CALCULATIONS
    /// ONLY
    FEM_DO_SAFE(kkk, 1, 5) {
      skaon(kkk) = 0;
      FEM_DO_SAFE(is, 1, 2000) { sekaon(kkk, is) = 0; }
    }
    /// C4.12 anti-proton and anti-kaon counters
    sve.pr0 = 0.f;
    sve.pr1 = 0.f;
    sve.ska0 = 0.f;
    sve.ska1 = 0.f;
    /// C       ============== LOOP OVER ALL TIME STEPS ================       *
    /// C                             STARTS HERE                              *
    /// C       ========================================================       *
    /// Cbz11/16/98
    if (iapar2(1) != 1) {
      FEM_DO_SAFE(i, 1, maxstr) {
        FEM_DO_SAFE(j, 1, 3) {
          r(j, i) = 0.f;
          p(j, i) = 0.f;
        }
        e(i) = 0.f;
        lb(i) = 0;
        /// Cbz3/25/00
        id(i) = 0;
        /// C     sp 12/19/00
        proper(i) = 1.f;
      }
      mass = 0;
      /// Cbz12/22/98
      /// C         MASSR(1) = 0
      /// C         NP = 0
      /// C         NPI = 1
      np = 0;
      FEM_DO_SAFE(j, 1, num) {
        massr(j) = 0;
        npi(j) = 1;
      }
      FEM_DO_SAFE(i, 1, maxr) {
        FEM_DO_SAFE(j, 1, maxstr) {
          rt(1, j, i) = 0.f;
          rt(2, j, i) = 0.f;
          rt(3, j, i) = 0.f;
          pt(1, j, i) = 0.f;
          pt(2, j, i) = 0.f;
          pt(3, j, i) = 0.f;
          et(j, i) = 0.f;
          lt(j, i) = 0;
          /// C     sp 12/19/00
          prot(j, i) = 1.f;
        }
      }
      /// Cbz12/22/98end
    }
    /// Cbz11/16/98end
    /// C
    FEM_DO_SAFE(nt, 1, ntmax) {
      /// CTEMPORARY PARTICLE COUNTERS
      /// C4.2 PION COUNTERS : LP1,LP2 AND LP3 ARE THE NO. OF P+,P0 AND P-
      lp1 = 0;
      lp2 = 0;
      lp3 = 0;
      /// C4.3 DELTA COUNTERS : LD1,LD2,LD3 AND LD4 ARE THE NO. OF D++,D+,D0 AND
      /// D-
      ld1 = 0;
      ld2 = 0;
      ld3 = 0;
      ld4 = 0;
      /// C4.4 N*(1440) COUNTERS : LN1 AND LN2 ARE THE NO. OF N*+ AND N*0
      ln1 = 0;
      ln2 = 0;
      /// C4.5 N*(1535) counters
      ln5 = 0;
      /// C4.6 ETA COUNTERS
      le = 0;
      /// C4.7 KAON COUNTERS
      lkaon = 0;
      /// C
      /// Clin-11/09/00:
      /// C KAON* COUNTERS
      lkaons = 0;
      /// C
      /// C-----------------------------------------------------------------------
      if (icoll != 1) {
        /// C STUDYING BINARY COLLISIONS AMONG PARTICLES DURING THIS TIME
        /// INTERVAL * Clin-10/25/02 get rid of argument usage mismatch in
        /// relcol(.nt.):
        numnt = nt;
        relcol(cmn, lcoll, lbloc, lcnne, ldd, lpp, lppk, lpn, lpd, lrho, lomega,
               lkn, lnnk, lddk, lndk, lcnnd, lcndn, ldirt, ldecay, lres, ldou,
               lddrho, lnnrho, lnnom, numnt, ntmax, sve.sp, sve.akaon, sve.sk);
        /// C     &    LNNOM,NT,ntmax,sp,akaon,sk)
        /// Clin-10/25/02-end
        /// C-----------------------------------------------------------------------
        /// C
        /// C dilepton production from Dalitz decay
        /// C of pi0 at final time
        /// C      if(nt .eq. ntmax) call dalitz_pi(nt,ntmax)
        /// C * C********************************* C                Lables of
        /// collision channels                             *
        /// C*********************************
        /// C         LCOLL   - NUMBER OF COLLISIONS (INTEGER,OUTPUT) * C LBLOC
        /// - NUMBER OF PULI-BLOCKED COLLISIONS (INTEGER,OUTPUT) * C LCNNE
        /// - NUMBER OF ELASTIC COLLISION       (INTEGER,OUTPUT) * C LCNND
        /// - NUMBER OF N+N->N+DELTA REACTION   (INTEGER,OUTPUT) * C LCNDN
        /// - NUMBER OF N+DELTA->N+N REACTION   (INTEGER,OUTPUT) * C         LDD
        /// - NUMBER OF RESONANCE+RESONANCE COLLISIONS C         LPP     -
        /// NUMBER OF PION+PION elastic COLIISIONS C         lppk    - number of
        /// pion(RHO,OMEGA)+pion(RHO,OMEGA) C                 -->K+K- collisions
        /// C         LPN     - NUMBER OF PION+N-->KAON+X
        /// C         lpd     - number of pion+n-->delta+pion
        /// C         lrho    - number of pion+n-->Delta+rho
        /// C         lomega  - number of pion+n-->Delta+omega
        /// C         LKN     - NUMBER OF KAON RESCATTERINGS
        /// C         LNNK    - NUMBER OF bb-->kAON PROCESS
        /// C         LDDK    - NUMBER OF DD-->KAON PROCESS
        /// C         LNDK    - NUMBER OF ND-->KAON PROCESS
        /// C**********************************
        /// C TIME-INTEGRATED COLLISIONS NUMBERS OF VARIOUS PROCESSES
        rcoll += fem::ffloat(lcoll) / num;
        rbloc += fem::ffloat(lbloc) / num;
        rcnne += fem::ffloat(lcnne) / num;
        rdd += fem::ffloat(ldd) / num;
        rpp += fem::ffloat(lpp) / num;
        rppk += fem::ffloat(lppk) / num;
        rpn += fem::ffloat(lpn) / num;
        rpd += fem::ffloat(lpd) / num;
        rkn += fem::ffloat(lkn) / num;
        rnnk += fem::ffloat(lnnk) / num;
        rddk += fem::ffloat(lddk) / num;
        rndk += fem::ffloat(lndk) / num;
        rcnnd += fem::ffloat(lcnnd) / num;
        rcndn += fem::ffloat(lcndn) / num;
        rdirt += fem::ffloat(ldirt) / num;
        rdecay += fem::ffloat(ldecay) / num;
        rres += fem::ffloat(lres) / num;
        /// C AVERAGE RATES OF VARIOUS COLLISIONS IN THE CURRENT TIME STEP
        sve.adirt = ldirt / dt / num;
        sve.acoll = (lcoll - lbloc) / dt / num;
        sve.acnnd = lcnnd / dt / num;
        sve.acndn = lcndn / dt / num;
        sve.adecay = ldecay / dt / num;
        sve.ares = lres / dt / num;
        sve.adou = ldou / dt / num;
        sve.addrho = lddrho / dt / num;
        sve.annrho = lnnrho / dt / num;
        sve.annom = lnnom / dt / num;
        sve.add = ldd / dt / num;
        sve.app = lpp / dt / num;
        sve.appk = lppk / dt / num;
        sve.apn = lpn / dt / num;
        sve.apd = lpd / dt / num;
        sve.arh = lrho / dt / num;
        sve.aom = lomega / dt / num;
        sve.akn = lkn / dt / num;
        sve.annk = lnnk / dt / num;
        sve.addk = lddk / dt / num;
        sve.andk = lndk / dt / num;
        /// C PRINT OUT THE VARIOUS COLLISION RATES
        /// C (1)N-N COLLISIONS
        /// C       WRITE(1010,9991)NT*DT,ACNND,ADOU,ADIRT,ADDRHO,ANNRHO+ANNOM
        /// C9991       FORMAT(6(E10.3,2X))
        /// C (2)PION-N COLLISIONS
        /// C       WRITE(1011,'(5(E10.3,2X))')NT*DT,apd,ARH,AOM,APN
        /// C (3)KAON PRODUCTION CHANNELS
        /// C        WRITE(1012,9993)NT*DT,ANNK,ADDK,ANDK,APN,Appk
        /// C (4)D(N*)+D(N*) COLLISION
        /// C       WRITE(1013,'(4(E10.3,2X))')NT*DT,ADDK,ADD,ADD+ADDK
        /// C (5)MESON+MESON
        /// C       WRITE(1014,'(4(E10.3,2X))')NT*DT,APPK,APP,APP+APPK
        /// C (6)DECAY AND RESONANCE
        /// C       WRITE(1016,'(3(E10.3,2X))')NT*DT,ARES,ADECAY
        /// C (7)N+D(N*)
        /// C       WRITE(1017,'(4(E10.3,2X))')NT*DT,ACNDN,ANDK,ACNDN+ANDK
        /// C9992    FORMAT(5(E10.3,2X))
        /// C9993    FORMAT(6(E10.3,2X))
        /// C PRINT OUT TIME-INTEGRATED COLLISION INFORMATION
        /// Cbz12/28/98
        /// C        write(1018,'(5(e10.3,2x),/, 4(e10.3,2x))')
        /// C     &           RCNNE,RCNND,RCNDN,RDIRT,rpd,
        /// C     &           RDECAY,RRES,RDD,RPP
        /// C        write(1018,'(6(e10.3,2x),/, 5(e10.3,2x))')
        /// C     &           NT*DT,RCNNE,RCNND,RCNDN,RDIRT,rpd,
        /// C     &           NT*DT,RDECAY,RRES,RDD,RPP
        /// Cbz12/18/98end
        /// C PRINT OUT TIME-INTEGRATED KAON MULTIPLICITIES FROM DIFFERENT
        /// CHANNELS C WRITE(1019,'(7(E10.3,2X))')NT*DT,RNNK,RDDK,RNDK,RPN,Rppk,
        /// C     &                           RNNK+RDDK+RNDK+RPN+Rppk
        /// C *
        /// C
      }
      /// C
      /// C       UPDATE BARYON DENSITY
      /// C
      dens(cmn, ipot, mass, num, outpar);
      /// C
      /// C       UPDATE POSITIONS FOR ALL THE PARTICLES PRESENT AT THIS TIME
      /// C
      sumene = 0;
      iso = 0;
      FEM_DO_SAFE(mrun, 1, num) {
        iso += massr(mrun - 1);
        FEM_DO_SAFE(i0, 1, massr(mrun)) {
          i = i0 + iso;
          etotal = fem::sqrt(fem::pow2(e(i)) + fem::pow2(p(1, i)) +
                             fem::pow2(p(2, i)) + fem::pow2(p(3, i)));
          sumene += etotal;
          /// C for kaons, if there is a potential
          /// C CALCULATE THE ENERGY OF THE KAON ACCORDING TO THE IMPULSE
          /// APPROXIMATION C REFERENCE: B.A. LI AND C.M. KO, PHYS. REV. C 54
          /// (1996) 3283.
          if (kpoten != 0 && lb(i) == 23) {
            den = 0.f;
            ix = fem::nint(r(1, i));
            iy = fem::nint(r(2, i));
            iz = fem::nint(r(3, i));
            /// Clin-4/2008:
            /// C       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            /// C     & ABS(IZ) .LT. MAXZ) den=rho(ix,iy,iz)
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
            }
            /// C         ecor=0.1973**2*0.255*kmul*4*3.14159*(1.+0.4396/0.938)
            /// C         etotal=sqrt(etotal**2+ecor*den)
            /// C** G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV,
            /// m^*=m C     GeV^2 fm^3
            akg = 0.1727f;
            /// C     GeV fm^3
            bkg = 0.333f;
            rnsg = den;
            ecor = -akg * rnsg + fem::pow2((bkg * den));
            etotal = fem::sqrt(fem::pow2(etotal) + ecor);
          }
          /// C
          if (kpoten != 0 && lb(i) == 21) {
            den = 0.f;
            ix = fem::nint(r(1, i));
            iy = fem::nint(r(2, i));
            iz = fem::nint(r(3, i));
            /// Clin-4/2008:
            /// C       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            /// C     & ABS(IZ) .LT. MAXZ) den=rho(ix,iy,iz)
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
            }
            /// C* for song potential no effect on position
            /// C** G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV,
            /// m^*=m C     GeV^2 fm^3
            akg = 0.1727f;
            /// C     GeV fm^3
            bkg = 0.333f;
            rnsg = den;
            ecor = -akg * rnsg + fem::pow2((bkg * den));
            etotal = fem::sqrt(fem::pow2(etotal) + ecor);
          }
          /// C
          /// C UPDATE POSITIONS
          r(1, i) += dt * p(1, i) / etotal;
          r(2, i) += dt * p(2, i) / etotal;
          r(3, i) += dt * p(3, i) / etotal;
          /// C use cyclic boundary conitions
          if (cycbox != 0) {
            if (r(1, i) > cycbox / 2) {
              r(1, i) = r(1, i) - cycbox;
            }
            if (r(1, i) <= -cycbox / 2) {
              r(1, i) += cycbox;
            }
            if (r(2, i) > cycbox / 2) {
              r(2, i) = r(2, i) - cycbox;
            }
            if (r(2, i) <= -cycbox / 2) {
              r(2, i) += cycbox;
            }
            if (r(3, i) > cycbox / 2) {
              r(3, i) = r(3, i) - cycbox;
            }
            if (r(3, i) <= -cycbox / 2) {
              r(3, i) += cycbox;
            }
          }
          /// C UPDATE THE DELTA, N* AND PION COUNTERS
          lb1 = lb(i);
          /// C 1. FOR DELTA++
          if (lb1 == 9) {
            ld1++;
          }
          /// C 2. FOR DELTA+
          if (lb1 == 8) {
            ld2++;
          }
          /// C 3. FOR DELTA0
          if (lb1 == 7) {
            ld3++;
          }
          /// C 4. FOR DELTA-
          if (lb1 == 6) {
            ld4++;
          }
          /// C 5. FOR N*+(1440)
          if (lb1 == 11) {
            ln1++;
          }
          /// C 6. FOR N*0(1440)
          if (lb1 == 10) {
            ln2++;
          }
          /// C 6.1 FOR N*(1535)
          if ((lb1 == 13) || (lb1 == 12)) {
            ln5++;
          }
          /// C 6.2 FOR ETA
          if (lb1 == 0) {
            le++;
          }
          /// C 6.3 FOR KAONS
          if (lb1 == 23) {
            lkaon++;
          }
          /// Clin-11/09/00: FOR KAON*
          if (lb1 == 30) {
            lkaons++;
          }
          /// C
          /// C UPDATE PION COUNTER
          /// C 7. FOR PION+
          if (lb1 == 5) {
            lp1++;
          }
          /// C 8. FOR PION0
          if (lb1 == 4) {
            lp2++;
          }
          /// C 9. FOR PION-
          if (lb1 == 3) {
            lp3++;
          }
        }
      }
      lp = lp1 + lp2 + lp3;
      ld = ld1 + ld2 + ld3 + ld4;
      ln = ln1 + ln2;
      alp = fem::ffloat(lp) / fem::ffloat(num);
      ald = fem::ffloat(ld) / fem::ffloat(num);
      aln = fem::ffloat(ln) / fem::ffloat(num);
      aln5 = fem::ffloat(ln5) / fem::ffloat(num);
      sve.atotal = alp + ald + aln + 0.5f * aln5;
      sve.ale = fem::ffloat(le) / fem::ffloat(num);
      sve.alkaon = fem::ffloat(lkaon) / fem::ffloat(num);
      /// C UPDATE MOMENTUM DUE TO COULOMB INTERACTION
      if (icou == 1) {
        /// C       with Coulomb interaction
        iso = 0;
        FEM_DO_SAFE(irun, 1, num) {
          iso += massr(irun - 1);
          FEM_DO_SAFE(il, 1, massr(irun)) {
            temp(1, il) = 0.f;
            temp(2, il) = 0.f;
            temp(3, il) = 0.f;
          }
          FEM_DO_SAFE(il, 1, massr(irun)) {
            i = iso + il;
            if (zet(lb(i)) != 0) {
              FEM_DO_SAFE(jl, 1, il - 1) {
                j = iso + jl;
                if (zet(lb(j)) != 0) {
                  ddx = r(1, i) - r(1, j);
                  ddy = r(2, i) - r(2, j);
                  ddz = r(3, i) - r(3, j);
                  rdiff = fem::sqrt(fem::pow2(ddx) + fem::pow2(ddy) +
                                    fem::pow2(ddz));
                  if (rdiff <= 1.f) {
                    rdiff = 1.f;
                  }
                  grp = zet(lb(i)) * zet(lb(j)) / fem::pow3(rdiff);
                  ddx = ddx * grp;
                  ddy = ddy * grp;
                  ddz = ddz * grp;
                  temp(1, il) += ddx;
                  temp(2, il) += ddy;
                  temp(3, il) += ddz;
                  temp(1, jl) = temp(1, jl) - ddx;
                  temp(2, jl) = temp(2, jl) - ddy;
                  temp(3, jl) = temp(3, jl) - ddz;
                }
              }
            }
          }
          FEM_DO_SAFE(il, 1, massr(irun)) {
            i = iso + il;
            if (zet(lb(i)) != 0) {
              FEM_DO_SAFE(idir, 1, 3) {
                p(idir, i) += temp(idir, il) * dt * 0.00144f;
              }
            }
          }
        }
      }
      /// C       In the following, we shall:
      /// C       (1) UPDATE MOMENTA DUE TO THE MEAN FIELD FOR BARYONS AND
      /// KAONS, C       (2) calculate the thermalization, temperature in a
      /// sphere of C           radius 2.0 fm AROUND THE CM C       (3) AND
      /// CALCULATE THE NUMBER OF PARTICLES IN THE HIGH DENSITY REGION
      spt = 0;
      spz = 0;
      ncen = 0;
      ekin = 0;
      sve.nlost = 0;
      mean = 0;
      nquark = 0;
      nbaryn = 0;
      /// Csp06/18/01
      rads = 2.f;
      zras = 0.1f;
      denst = 0.f;
      edenst = 0.f;
      /// Csp06/18/01 end
      FEM_DO_SAFE(irun, 1, num) {
        mean += massr(irun - 1);
        FEM_DO_SAFE(j, 1, massr(irun)) {
          i = j + mean;
          /// C
          /// Csp06/18/01
          radut = fem::sqrt(fem::pow2(r(1, i)) + fem::pow2(r(2, i)));
          if (radut <= rads) {
            if (fem::abs(r(3, i)) <= zras * nt * dt) {
              /// C         vols = 3.14159*radut**2*abs(r(3,i))      ! cylinder
              /// pi*r^2*l C     cylinder pi*r^2*l
              vols = 3.14159f * fem::pow2(rads) * zras;
              engs = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                               fem::pow2(p(3, i)) + fem::pow2(e(i)));
              gammas = 1.f;
              if (e(i) != 0.f) {
                gammas = engs / e(i);
              }
              /// C     rho
              denst += 1.f / gammas / vols;
              /// C     energy density
              edenst += engs / gammas / gammas / vols;
            }
          }
          /// Csp06/18/01 end
          /// C
          drr = fem::sqrt(fem::pow2(r(1, i)) + fem::pow2(r(2, i)) +
                          fem::pow2(r(3, i)));
          if (drr <= 2.0f) {
            spt += fem::pow2(p(1, i)) + fem::pow2(p(2, i));
            spz += fem::pow2(p(3, i));
            ncen++;
            ekin += fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                              fem::pow2(p(3, i)) + fem::pow2(e(i))) -
                    e(i);
          }
          ix = fem::nint(r(1, i));
          iy = fem::nint(r(2, i));
          iz = fem::nint(r(3, i));
          /// C calculate the No. of particles in the high density region
          /// Clin-4/2008:
          /// C              IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
          /// C     & ABS(IZ) .LT. MAXZ) THEN
          if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx && iy > -maxx &&
              iz > -maxz) {
            if (rho(ix, iy, iz) / 0.168f > cmn.dencut) {
              goto statement_5800;
            }
            if ((rho(ix, iy, iz) / 0.168f > 5.f) && (e(i) > 0.9f)) {
              nbaryn++;
            }
            if (pel(ix, iy, iz) > 2.0f) {
              nquark++;
            }
          }
          /// C*
          /// C If there is a kaon potential, propogating kaons
          if (kpoten != 0 && lb(i) == 23) {
            den = 0.f;
            /// Clin-4/2008:
            /// C       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            /// C     & ABS(IZ) .LT. MAXZ)then
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
              /// C        ecor=0.1973**2*0.255*kmul*4*3.14159*(1.+0.4396/0.938)
              /// C etotal=sqrt(P(1,i)**2+p(2,I)**2+p(3,i)**2+e(i)**2+ecor*den)
              /// C** for G.Q Li potential form with n_s = n_b and pot(n_0)=29
              /// MeV C     !! GeV^2 fm^3
              akg = 0.1727f;
              /// C     !! GeV fm^3
              bkg = 0.333f;
              rnsg = den;
              ecor = -akg * rnsg + fem::pow2((bkg * den));
              etotal = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                                 fem::pow2(p(3, i)) + fem::pow2(e(i)) + ecor);
              ecor = -akg + 2.f * fem::pow2(bkg) * den + 2.f * bkg * etotal;
              /// C** G.Q. Li potential (END)
              graduk(cmn, ix, iy, iz, gradxk, gradyk, gradzk);
              p(1, i) = p(1, i) - dt * gradxk * ecor / (2.f * etotal);
              p(2, i) = p(2, i) - dt * gradyk * ecor / (2.f * etotal);
              p(3, i) = p(3, i) - dt * gradzk * ecor / (2.f * etotal);
            }
          }
          /// C
          if (kpoten != 0 && lb(i) == 21) {
            den = 0.f;
            /// Clin-4/2008:
            /// C           IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
            /// C     &        ABS(IZ) .LT. MAXZ)then
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              den = rho(ix, iy, iz);
              graduk(cmn, ix, iy, iz, gradxk, gradyk, gradzk);
              /// C        P(1,I) = P(1,I) - DT * GRADXk*(-0.12/0.168)    !!
              /// song potential C        P(2,I) = P(2,I) - DT *
              /// GRADYk*(-0.12/0.168) C        P(3,I) = P(3,I) - DT *
              /// GRADZk*(-0.12/0.168) C** for G.Q Li potential form with n_s =
              /// n_b and pot(n_0)=29 MeV C    !! GeV^2 fm^3
              akg = 0.1727f;
              /// C     !! GeV fm^3
              bkg = 0.333f;
              rnsg = den;
              ecor = -akg * rnsg + fem::pow2((bkg * den));
              etotal = fem::sqrt(fem::pow2(p(1, i)) + fem::pow2(p(2, i)) +
                                 fem::pow2(p(3, i)) + fem::pow2(e(i)) + ecor);
              ecor = -akg + 2.f * fem::pow2(bkg) * den - 2.f * bkg * etotal;
              p(1, i) = p(1, i) - dt * gradxk * ecor / (2.f * etotal);
              p(2, i) = p(2, i) - dt * gradyk * ecor / (2.f * etotal);
              p(3, i) = p(3, i) - dt * gradzk * ecor / (2.f * etotal);
              /// C** G.Q. Li potential (END)
            }
          }
          /// C
          /// C for other mesons, there is no potential
          if (j > mass) {
            goto statement_5800;
          }
          /// C  with mean field interaction for baryons   (open endif below)
          /// !!sp05 C*      if( (iabs(lb(i)).eq.1.or.iabs(lb(i)).eq.2) .or. C*
          /// & (iabs(lb(i)).ge.6.and.iabs(lb(i)).le.17) .or. C*    &
          /// iabs(lb(i)).eq.40.or.iabs(lb(i)).eq.41 )then
          if (icoll != -1) {
            /// C check if the baryon has run off the lattice
            /// C             IX0=NINT(R(1,I)/DX)
            /// C             IY0=NINT(R(2,I)/DY)
            /// C             IZ0=NINT(R(3,I)/DZ)
            /// C             IPX0=NINT(P(1,I)/DPX)
            /// C             IPY0=NINT(P(2,I)/DPY)
            /// C             IPZ0=NINT(P(3,I)/DPZ)
            /// C      if ( (abs(ix0).gt.mx) .or. (abs(iy0).gt.my) .or.
            /// (abs(iz0).gt.mz) C     &  .or. (abs(ipx0).gt.mpx) .or.
            /// (abs(ipy0) C     &  .or. (ipz0.lt.-mpz) .or. (ipz0.gt.mpzp))
            /// NLOST=NLOST+1 Clin-4/2008: C              IF (ABS(IX) .LT. MAXX
            /// .AND. ABS(IY) .LT. MAXX .AND. C     & ABS(IZ) .LT. MAXZ ) THEN
            if (ix < maxx && iy < maxx && iz < maxz && ix > -maxx &&
                iy > -maxx && iz > -maxz) {
              gradu(cmn, ipot, ix, iy, iz, gradx, grady, gradz);
              tz = 0.f;
              gradxn = 0;
              gradyn = 0;
              gradzn = 0;
              gradxp = 0;
              gradyp = 0;
              gradzp = 0;
              if (icou == 1) {
                gradup(cmn, ix, iy, iz, gradxp, gradyp, gradzp);
                gradun(cmn, ix, iy, iz, gradxn, gradyn, gradzn);
                if (zet(lb(i)) != 0) {
                  tz = -1;
                }
                if (zet(lb(i)) == 0) {
                  tz = 1;
                }
              }
              if (fem::iabs(lb(i)) >= 14 && fem::iabs(lb(i)) <= 17) {
                facl = 2.f / 3.f;
              } else if (fem::iabs(lb(i)) == 40 || fem::iabs(lb(i)) == 41) {
                facl = 1.f / 3.f;
              } else {
                facl = 1.f;
              }
              p(1, i) =
                  p(1, i) - facl * dt * (gradx + asy * (gradxn - gradxp) * tz);
              p(2, i) =
                  p(2, i) - facl * dt * (grady + asy * (gradyn - gradyp) * tz);
              p(3, i) =
                  p(3, i) - facl * dt * (gradz + asy * (gradzn - gradzp) * tz);
            }
          }
        /// C*          endif          !!sp05
        statement_5800:;
        }
      }
      /// C print out the average no. of particles in regions where the local
      /// C baryon density is higher than 5*rho0
      /// C       write(1072,'(e10.3,2x,e10.3)')nt*dt,float(nbaryn)/float(num)
      /// C print out the average no. of particles in regions where the local
      /// C energy density is higher than 2 GeV/fm^3.
      /// C       write(1073,'(e10.3,2x,e10.3)')nt*dt,float(nquark)/float(num)
      /// C print out the no. of particles that have run off the lattice
      /// C          IF (NLOST .NE. 0 .AND. (NT/NFREQ)*NFREQ .EQ. NT) THEN
      /// C            WRITE(12,'(5X,''***'',I7,'' TESTPARTICLES LOST AFTER '',
      /// C     &                   ''TIME STEP NUMBER'',I4)') NLOST, NT
      /// C         END IF
      /// C
      /// C       update phase space density
      /// C        call platin(mode,mass,num,dx,dy,dz,dpx,dpy,dpz,fnorm)
      /// C
      /// C       CONTROL-PRINTOUT OF CONFIGURATION (IF REQUIRED)
      /// C
      /// C        if (inout(5) .eq. 2) CALL ENERGY(NT,IPOT,NUM,MASS,EMIN,EMAX)
      /// C
      /// C print out central baryon density as a function of time
      sve.cden = rho(0, 0, 0) / 0.168f;
      /// Cc        WRITE(1002,990)FLOAT(NT)*DT,CDEN
      /// C        WRITE(1002,1990)FLOAT(NT)*DT,CDEN,denst/real(num)
      /// C print out the central energy density as a function of time
      /// Cc        WRITE(1003,990)FLOAT(NT)*DT,PEL(0,0,0)
      /// C        WRITE(1003,1990)FLOAT(NT)*DT,PEL(0,0,0),edenst/real(num)
      /// C print out the no. of pion-like particles as a function of time
      /// C        WRITE(1004,9999)FLOAT(NT)*DT,ALD,ALN,ALP,ALN5,
      /// C     &               ALD+ALN+ALP+0.5*ALN5
      /// C print out the no. of eta-like particles as a function of time
      /// C        WRITE(1005,991)FLOAT(NT)*DT,ALN5,ALE,ALE+0.5*ALN5
      /// C990       FORMAT(E10.3,2X,E10.3)
      /// C1990       FORMAT(E10.3,2X,E10.3,2X,E10.3)
      /// C991       FORMAT(E10.3,2X,E10.3,2X,E10.3,2X,E10.3)
      /// C9999    FORMAT(e10.3,2X,e10.3,2X,E10.3,2X,E10.3,2X,
      /// C     1  E10.3,2X,E10.3)
      /// C THE FOLLOWING OUTPUTS CAN BE TURNED ON/OFF by setting icflow and
      /// icrho=0 C print out the baryon and meson density matrix in the
      /// reaction plane
      if ((nt / nfreq) * nfreq == nt) {
        if (cmn.icflow == 1) {
          flow(cmn, nt);
        }
        /// Cbz11/18/98
        /// C       if(icrho.ne.1)go to 10000
        /// C       if (icrho .eq. 1) then
        /// Cbz11/18/98end
        /// C       do ix=-10,10
        /// C       do iz=-10,10
        /// C       write(1053,992)ix,iz,rho(ix,0,iz)/0.168
        /// C       write(1054,992)ix,iz,pirho(ix,0,iz)/0.168
        /// C       write(1055,992)ix,iz,pel(ix,0,iz)
        /// C       end do
        /// Cbz11/18/98
        /// C        end if
        /// Cbz11/18/98end
        /// C992       format(i3,i3,e11.4)
      }
      /// C print out the ENERGY density matrix in the reaction plane
      /// C CHECK LOCAL MOMENTUM EQUILIBRIUM IN EACH CELL,
      /// C AND PERFORM ON-LINE FLOW ANALYSIS AT A FREQUENCY OF NFREQ
      /// C        IF ((NT/NFREQ)*NFREQ .EQ. NT ) THEN
      /// C       call flow(nt)
      /// C       call equ(ipot,mass,num,outpar)
      /// C       do ix=-10,10
      /// C       do iz=-10,10
      /// C       write(1055,992)ix,iz,pel(ix,0,iz)
      /// C       write(1056,992)ix,iz,rxy(ix,0,iz)
      /// C       end do
      /// C       endif
      /// C calculate the volume of high BARYON AND ENERGY density
      /// C matter as a function of time
      /// C       vbrho=0.
      /// C       verho=0.
      /// C       do ix=-20,20
      /// C       do iy=-20,20
      /// C       do iz=-20,20
      /// C       if(rho(ix,iy,iz)/0.168.gt.5.)vbrho=vbrho+1.
      /// C       if(pel(ix,iy,iz).gt.2.)verho=verho+1.
      /// C       end do
      /// C       write(1081,993)dt*nt,vbrho
      /// C       write(1082,993)dt*nt,verho
      /// C993       format(e11.4,2x,e11.4)
      /// C-----------------------------------------------------------------------
      /// Cbz11/16/98
      /// C.....for read-in initial conditions produce particles from read-in
      /// C.....common block.
      /// C.....note that this part is only for cascade with number of test
      /// particles C.....NUM = 1.
      if (iapar2(1) != 1) {
        ct = nt * dt;
        /// Cbz12/22/98
        /// C         NP = MASSR(1)
        /// C         DO WHILE (FTAR(NPI) .GT. CT - DT .AND. FTAR(NPI) .LE. CT)
        /// C            NP = NP + 1
        /// C            R(1, NP) = GXAR(NPI) + PXAR(NPI) / PEAR(NPI) * (CT -
        /// FTAR(NPI)) C            R(2, NP) = GYAR(NPI) + PYAR(NPI) / PEAR(NPI)
        /// * (CT - FTAR(NPI)) C            R(3, NP) = GZAR(NPI) + PZAR(NPI) /
        /// PEAR(NPI) * (CT - FTAR(NPI)) C            P(1, NP) = PXAR(NPI) C
        /// P(2, NP) = PYAR(NPI) C            P(3, NP) = PZAR(NPI) C E(NP) =
        /// XMAR(NPI) C            LB(NP) = IARFLV(ITYPAR(NPI)) C            NPI
        /// = NPI + 1 C         END DO C         MASSR(1) = NP
        ia = 0;
        FEM_DO_SAFE(irun, 1, num) {
          FEM_DO_SAFE(ic, 1, massr(irun)) {
            ie = ia + ic;
            rt(1, ic, irun) = r(1, ie);
            rt(2, ic, irun) = r(2, ie);
            rt(3, ic, irun) = r(3, ie);
            pt(1, ic, irun) = p(1, ie);
            pt(2, ic, irun) = p(2, ie);
            pt(3, ic, irun) = p(3, ie);
            et(ic, irun) = e(ie);
            lt(ic, irun) = lb(ie);
            /// C         !! sp 12/19/00
            prot(ic, irun) = proper(ie);
            /// Clin-5/2008:
            dpertt(ic, irun) = dpertp(ie);
          }
          np = massr(irun);
          np1 = npi(irun);
          /// C
          /// Cbz10/05/99
          /// C            DO WHILE (FT1(NP1, IRUN) .GT. CT - DT .AND.
          /// C     &           FT1(NP1, IRUN) .LE. CT)
          /// Cbz10/06/99
          /// C            DO WHILE (NPI(IRUN).LE.MULTI1(IRUN).AND.
          /// Cbz10/06/99 end
          /// Clin-11/13/00 finally read in all unformed particles and do the
          /// decays in ART: C           DO WHILE (NP1.LE.MULTI1(IRUN).AND. C &
          /// FT1(NP1, IRUN) .GT. CT - DT .AND. C    &           FT1(NP1, IRUN)
          /// .LE. CT)
          /// C
          ctlong = ct;
          if (nt == (ntmax - 1)) {
            ctlong = 1.e30f;
          } else if (nt == ntmax) {
            goto statement_1111;
          }
          /// C
          while (np1 <= multi1(irun) && ft1(np1, irun) > ((nt - 1) * dt) &&
                 ft1(np1, irun) <= ctlong) {
            /// Clin-ma-5/2016 changed the following to 2nd line above to avoid
            /// bug C     that leads to loss of hadrons inside ART due to finite
            /// accuracy C     [which results in (ct-dt) + dt != ct exactly]: C
            /// & FT1(NP1, IRUN) .GT. (CT - DT) .AND.
            np++;
            udt = (ct - ft1(np1, irun)) / ee1(np1, irun);
            /// Clin-10/28/03 since all unformed hadrons at time ct are read in
            /// at nt=ntmax-1, C     their positions should not be propagated to
            /// time ct:
            if (nt == (ntmax - 1)) {
              ftsvt(np, irun) = ft1(np1, irun);
              if (ft1(np1, irun) > ct) {
                udt = 0.f;
              }
            }
            rt(1, np, irun) = gx1(np1, irun) + px1(np1, irun) * udt;
            rt(2, np, irun) = gy1(np1, irun) + py1(np1, irun) * udt;
            rt(3, np, irun) = gz1(np1, irun) + pz1(np1, irun) * udt;
            pt(1, np, irun) = px1(np1, irun);
            pt(2, np, irun) = py1(np1, irun);
            pt(3, np, irun) = pz1(np1, irun);
            et(np, irun) = xm1(np1, irun);
            lt(np, irun) = iarflv(cmn, ityp1(np1, irun));
            /// Clin-5/2008:
            dpertt(np, irun) = dpp1(np1, irun);
            /// Clin-4/30/03 ctest off
            /// C     record initial phi,K*,Lambda(1520) resonances formed
            /// during the timestep: C               if(LT(NP,
            /// IRUN).eq.29.or.iabs(LT(NP, IRUN)).eq.30) C     1 write(17,112)
            /// 'formed',LT(NP, IRUN),PX1(NP1, IRUN), C     2 PY1(NP1,
            /// IRUN),PZ1(NP1, IRUN),XM1(NP1, IRUN),nt C 112
            /// format(a10,1x,I4,4(1x,f9.3),1x,I4)
            /// C
            np1++;
            /// C     !! sp 12/19/00
            prot(np, irun) = 1.f;
          }
        /// C
        statement_1111:
          npi(irun) = np1;
          ia += massr(irun);
          massr(irun) = np;
        }
        ia = 0;
        FEM_DO_SAFE(irun, 1, num) {
          ia += massr(irun - 1);
          FEM_DO_SAFE(ic, 1, massr(irun)) {
            ie = ia + ic;
            r(1, ie) = rt(1, ic, irun);
            r(2, ie) = rt(2, ic, irun);
            r(3, ie) = rt(3, ic, irun);
            p(1, ie) = pt(1, ic, irun);
            p(2, ie) = pt(2, ic, irun);
            p(3, ie) = pt(3, ic, irun);
            e(ie) = et(ic, irun);
            lb(ie) = lt(ic, irun);
            /// C     !! sp 12/19/00
            proper(ie) = prot(ic, irun);
            if (nt == (ntmax - 1)) {
              ftsv(ie) = ftsvt(ic, irun);
            }
            /// Clin-5/2008:
            dpertp(ie) = dpertt(ic, irun);
          }
          /// Clin-3/2009 Moved here to better take care of freezeout spacetime:
          hbtout(cmn, massr(irun), nt, ntmax);
        }
        /// Cbz12/22/98end
      }
      /// Cbz11/16/98end
      /// C
      /// Clin-5/2009 ctest off:
      /// C      call flowh(ct)
      /// C
    }
    /// C
    /// C                                                                      *
    /// C       ==============  END OF TIME STEP LOOP   ================       *
    /// C
    /// C***********************************
    /// C     WRITE OUT particle's MOMENTA ,and/OR COORDINATES ,
    /// C     label and/or their local baryon density in the final state
    iss = 0;
    FEM_DO_SAFE(lrun, 1, num) {
      iss += massr(lrun - 1);
      FEM_DO_SAFE(l0, 1, massr(lrun)) { sve.ipart = iss + l0; }
    }
    /// C
    /// Cbz11/16/98
    if (iapar2(1) != 1) {
      /// Cbz12/22/98
      /// C        NSH = MASSR(1) - NPI + 1
      /// C        IAINT2(1) = IAINT2(1) + NSH
      /// C.....to shift the unformed particles to the end of the common block
      /// C        IF (NSH .GT. 0) THEN
      /// C           IB = IAINT2(1)
      /// C           IE = MASSR(1) + 1
      /// C           II = -1
      /// C        ELSE IF (NSH .LT. 0) THEN
      /// C           IB = MASSR(1) + 1
      /// C           IE = IAINT2(1)
      /// C           II = 1
      /// C        END IF
      /// C        IF (NSH .NE. 0) THEN
      /// C           DO I = IB, IE, II
      /// C              J = I - NSH
      /// C              ITYPAR(I) = ITYPAR(J)
      /// C              GXAR(I) = GXAR(J)
      /// C              GYAR(I) = GYAR(J)
      /// C              GZAR(I) = GZAR(J)
      /// C              FTAR(I) = FTAR(J)
      /// C              PXAR(I) = PXAR(J)
      /// C              PYAR(I) = PYAR(J)
      /// C              PZAR(I) = PZAR(J)
      /// C              PEAR(I) = PEAR(J)
      /// C              XMAR(I) = XMAR(J)
      /// C           END DO
      /// C        END IF
      /// C
      /// C.....to copy ART particle info to COMMON /ARPRC/
      /// C        DO I = 1, MASSR(1)
      /// C           ITYPAR(I) = INVFLV(LB(I))
      /// C           GXAR(I) = R(1, I)
      /// C           GYAR(I) = R(2, I)
      /// C           GZAR(I) = R(3, I)
      /// C           FTAR(I) = CT
      /// C           PXAR(I) = P(1, I)
      /// C           PYAR(I) = P(2, I)
      /// C           PZAR(I) = P(3, I)
      /// C           XMAR(I) = E(I)
      /// C           PEAR(I) = SQRT(PXAR(I) ** 2 + PYAR(I) ** 2 + PZAR(I) ** 2
      /// C     &        + XMAR(I) ** 2)
      /// C        END DO
      ia = 0;
      FEM_DO_SAFE(irun, 1, num) {
        ia += massr(irun - 1);
        np1 = npi(irun);
        nsh = massr(irun) - np1 + 1;
        multi1(irun) += nsh;
        /// C.....to shift the unformed particles to the end of the common block
        if (nsh > 0) {
          ib = multi1(irun);
          ie = massr(irun) + 1;
          ii = -1;
        } else if (nsh < 0) {
          ib = massr(irun) + 1;
          ie = multi1(irun);
          ii = 1;
        }
        if (nsh != 0) {
          FEM_DOSTEP(i, ib, ie, ii) {
            j = i - nsh;
            ityp1(i, irun) = ityp1(j, irun);
            gx1(i, irun) = gx1(j, irun);
            gy1(i, irun) = gy1(j, irun);
            gz1(i, irun) = gz1(j, irun);
            ft1(i, irun) = ft1(j, irun);
            px1(i, irun) = px1(j, irun);
            py1(i, irun) = py1(j, irun);
            pz1(i, irun) = pz1(j, irun);
            ee1(i, irun) = ee1(j, irun);
            xm1(i, irun) = xm1(j, irun);
            /// C     !! sp 12/19/00
            pro1(i, irun) = pro1(j, irun);
            /// Clin-5/2008:
            dpp1(i, irun) = dpp1(j, irun);
          }
        }
        /// C
        /// C.....to copy ART particle info to COMMON /ARPRC1/
        FEM_DO_SAFE(i, 1, massr(irun)) {
          ib = ia + i;
          ityp1(i, irun) = invflv(cmn, lb(ib));
          gx1(i, irun) = r(1, ib);
          gy1(i, irun) = r(2, ib);
          gz1(i, irun) = r(3, ib);
          /// Clin-10/28/03:
          /// C since all unformed hadrons at time ct are read in at nt=ntmax-1,
          /// C their formation time ft1 should be kept to determine their
          /// freezeout(x,t): C              FT1(I, IRUN) = CT
          if (ft1(i, irun) < ct) {
            ft1(i, irun) = ct;
          }
          px1(i, irun) = p(1, ib);
          py1(i, irun) = p(2, ib);
          pz1(i, irun) = p(3, ib);
          xm1(i, irun) = e(ib);
          ee1(i, irun) =
              fem::sqrt(fem::pow2(px1(i, irun)) + fem::pow2(py1(i, irun)) +
                        fem::pow2(pz1(i, irun)) + fem::pow2(xm1(i, irun)));
          /// C     !! sp 12/19/00
          pro1(i, irun) = proper(ib);
        }
      }
      /// Cbz12/22/98end
    }
    /// Cbz11/16/98end
    /// C
    /// C*********************************
    /// C                                                                      *
    /// C       ======= END OF MANY LOOPS OVER IMPACT PARAMETERS ==========    *
    /// C                                                               *
    /// C*********************************
  }
  /// C
  /// C-----------------------------------------------------------------------
  /// C                       ==== ART COMPLETED ====
  /// C-----------------------------------------------------------------------
  /// Cbz11/16/98
  /// C      STOP
  /// Cbz11/16/98end
}

struct blockdata_ppbdat_save {
  int i;

  blockdata_ppbdat_save() : i(fem::int0) {}
};

/// C
/// C*******************************
void blockdata_ppbdat(common& cmn) {
  FEM_CMN_SVE(blockdata_ppbdat);
  /// COMMON ppbmas
  arr_ref<int> niso(cmn.niso, dimension(15));
  arr_ref<float, 2> ppbm(cmn.ppbm, dimension(15, 2));
  arr_ref<float> thresh(cmn.thresh, dimension(15));
  /// COMMON ppb1
  arr_ref<float> factr2(cmn.factr2, dimension(6));
  ///
  const float amp = 0.93828f;
  const float amn = 0.939457f;
  const float am0 = 1.232f;
  const float am1440 = 1.44f;
  const float am1535 = 1.535f;
  if (is_called_first_time) {
    {
      static const float values[] = {1.87656f,  1.877737f, 1.878914f, 2.17028f,
                                     2.171457f, 2.37828f,  2.379457f, 2.464f,
                                     2.47328f,  2.474457f, 2.672f,    2.767f,
                                     2.88f,     2.975f,    3.07f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), thresh;
    }
    {
      fem::data_values data;
      data.values, amp, amp, amn, amp, amn, amp, amn, am0;
      data.values, amp, amn, am0, am0, am1440, am1440, am1535;
      FEM_DO_SAFE(sve.i, 1, 15) { data, ppbm(sve.i, 1); }
    }
    {
      fem::data_values data;
      data.values, amp, amn, amn, am0, am0, am1440, am1440, am0;
      data.values, am1535, am1535, am1440, am1535, am1440, am1535, am1535;
      FEM_DO_SAFE(sve.i, 1, 15) { data, ppbm(sve.i, 2); }
    }
    fem::data((values, 0, 1, 1.17e-01f, 3.27e-03f, 3.58e-05f, 1.93e-07f)),
        factr2;
    {
      static const int values[] = {1, 2, 1,  16, 16, 4, 4, 64,
                                   4, 4, 32, 32, 4,  8, 4};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), niso;
    }
  }
  /// C
  /// C     to give default values to parameters for BbarB production from
  /// mesons Cc      SAVE /ppbmas/ Cc      SAVE /ppb1/ Cc      SAVE /ppmm/ C
  /// thresh(i) gives the mass thresh for final channel i: C     ppbm(i,j=1,2)
  /// gives masses for the two final baryons of channel i, C     with j=1 for
  /// the lighter baryon: C     factr2(i) gives weights for producing i pions
  /// from ppbar annihilation: C     niso(i) gives the degeneracy factor for
  /// final channel i:
  /// C
}

struct hjana1_save {
  arr<float> deyg1;
  arr<float> deyg1c;
  arr<float> deyp1;
  arr<float> dmyg1;
  arr<float> dmyg1c;
  arr<float> dmyp1;
  arr<float> dnrin1;
  arr<float> dnrpj1;
  arr<float> dnrtg1;
  arr<float> dnrtt1;
  float dxmt;
  arr<float> dyg1;
  arr<float> dyg1c;
  arr<float> dyp1;
  int i;
  int imt;
  int ir;
  int isevt;
  int isrun;
  int ityp;
  int iw;
  int iy;
  int j;
  int nisg;
  int nisgs;
  int nsubg;
  int nsubgs;
  int nsubp;
  int nsubps;
  float pe;
  float pm;
  float px;
  float py;
  float pz;
  float rap;
  arr<float> seyg1;
  arr<float> seyg1c;
  arr<float> seyp1;
  arr<float> smyg1;
  arr<float> smyg1c;
  arr<float> smyp1;
  arr<float> snrin1;
  arr<float> snrpj1;
  arr<float> snrtg1;
  arr<float> snrtt1;
  arr<float> snyg1;
  arr<float> snyg1c;
  arr<float> snyp1;
  float xmt;
  float y1;
  float y2;
  float yr;

  hjana1_save()
      : deyg1(dimension(50), fem::fill0),
        deyg1c(dimension(50), fem::fill0),
        deyp1(dimension(50), fem::fill0),
        dmyg1(dimension(200), fem::fill0),
        dmyg1c(dimension(50), fem::fill0),
        dmyp1(dimension(200), fem::fill0),
        dnrin1(dimension(50), fem::fill0),
        dnrpj1(dimension(50), fem::fill0),
        dnrtg1(dimension(50), fem::fill0),
        dnrtt1(dimension(50), fem::fill0),
        dxmt(fem::float0),
        dyg1(dimension(50), fem::fill0),
        dyg1c(dimension(50), fem::fill0),
        dyp1(dimension(50), fem::fill0),
        i(fem::int0),
        imt(fem::int0),
        ir(fem::int0),
        isevt(fem::int0),
        isrun(fem::int0),
        ityp(fem::int0),
        iw(fem::int0),
        iy(fem::int0),
        j(fem::int0),
        nisg(fem::int0),
        nisgs(fem::int0),
        nsubg(fem::int0),
        nsubgs(fem::int0),
        nsubp(fem::int0),
        nsubps(fem::int0),
        pe(fem::float0),
        pm(fem::float0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        rap(fem::float0),
        seyg1(dimension(50), fem::fill0),
        seyg1c(dimension(50), fem::fill0),
        seyp1(dimension(50), fem::fill0),
        smyg1(dimension(200), fem::fill0),
        smyg1c(dimension(50), fem::fill0),
        smyp1(dimension(200), fem::fill0),
        snrin1(dimension(50), fem::fill0),
        snrpj1(dimension(50), fem::fill0),
        snrtg1(dimension(50), fem::fill0),
        snrtt1(dimension(50), fem::fill0),
        snyg1(dimension(50), fem::fill0),
        snyg1c(dimension(50), fem::fill0),
        snyp1(dimension(50), fem::fill0),
        xmt(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        yr(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....analysis subroutine in HIJING before parton cascade evolution
void hjana1(common& cmn) {
  FEM_CMN_SVE(hjana1);
  common_write write(cmn);
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<int> npj(cmn.npj, dimension(300));
  arr_cref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_cref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_cref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_cref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_cref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_cref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_cref<int> ntj(cmn.ntj, dimension(300));
  arr_cref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_cref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_cref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_cref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_cref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_cref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  int& nsg = cmn.nsg;
  const int maxstr = 150001;
  arr_cref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_cref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_cref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_cref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_cref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_cref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_cref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_cref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  const int maxptn = 400001;
  arr_cref<double> px0(cmn.px0, dimension(maxptn));
  arr_cref<double> py0(cmn.py0, dimension(maxptn));
  arr_cref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_cref<double> e0(cmn.e0, dimension(maxptn));
  arr_cref<double> xmass0(cmn.xmass0, dimension(maxptn));
  arr_cref<int> ityp0(cmn.ityp0, dimension(maxptn));
  int& iaevt = cmn.iaevt;
  int& iarun = cmn.iarun;
  ///
  arr_ref<float> deyg1(sve.deyg1, dimension(50));
  arr_ref<float> deyg1c(sve.deyg1c, dimension(50));
  arr_ref<float> deyp1(sve.deyp1, dimension(50));
  arr_ref<float> dmyg1(sve.dmyg1, dimension(200));
  arr_ref<float> dmyg1c(sve.dmyg1c, dimension(50));
  arr_ref<float> dmyp1(sve.dmyp1, dimension(200));
  arr_ref<float> dnrin1(sve.dnrin1, dimension(50));
  arr_ref<float> dnrpj1(sve.dnrpj1, dimension(50));
  arr_ref<float> dnrtg1(sve.dnrtg1, dimension(50));
  arr_ref<float> dnrtt1(sve.dnrtt1, dimension(50));
  float& dxmt = sve.dxmt;
  arr_ref<float> dyg1(sve.dyg1, dimension(50));
  arr_ref<float> dyg1c(sve.dyg1c, dimension(50));
  arr_ref<float> dyp1(sve.dyp1, dimension(50));
  int& i = sve.i;
  int& imt = sve.imt;
  int& ir = sve.ir;
  int& isevt = sve.isevt;
  int& isrun = sve.isrun;
  int& ityp = sve.ityp;
  int& iw = sve.iw;
  int& iy = sve.iy;
  int& j = sve.j;
  int& nisg = sve.nisg;
  int& nisgs = sve.nisgs;
  int& nsubg = sve.nsubg;
  int& nsubgs = sve.nsubgs;
  int& nsubp = sve.nsubp;
  int& nsubps = sve.nsubps;
  float& pe = sve.pe;
  float& pm = sve.pm;
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& rap = sve.rap;
  arr_ref<float> seyg1(sve.seyg1, dimension(50));
  arr_ref<float> seyg1c(sve.seyg1c, dimension(50));
  arr_ref<float> seyp1(sve.seyp1, dimension(50));
  arr_ref<float> smyg1(sve.smyg1, dimension(200));
  arr_ref<float> smyg1c(sve.smyg1c, dimension(50));
  arr_ref<float> smyp1(sve.smyp1, dimension(200));
  arr_ref<float> snrin1(sve.snrin1, dimension(50));
  arr_ref<float> snrpj1(sve.snrpj1, dimension(50));
  arr_ref<float> snrtg1(sve.snrtg1, dimension(50));
  arr_ref<float> snrtt1(sve.snrtt1, dimension(50));
  arr_ref<float> snyg1(sve.snyg1, dimension(50));
  arr_ref<float> snyg1c(sve.snyg1c, dimension(50));
  arr_ref<float> snyp1(sve.snyp1, dimension(50));
  float& xmt = sve.xmt;
  float& y1 = sve.y1;
  float& y2 = sve.y2;
  float& yr = sve.yr;
  if (is_called_first_time) {
    iw = 0;
  }
  const float dy = 0.2f;
  const float dmt = 0.05f;
  const float ymax = 1.0f;
  const float ymin = -1.0f;
  const float dr = 0.2f;
  /// C
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /AREVT/
  /// Cc      SAVE /AROUT/
  /// C
  if (isevt == iaevt && isrun == iarun) {
    FEM_DO_SAFE(i, 1, 200) {
      dmyp1(i) = smyp1(i);
      dmyg1(i) = smyg1(i);
    }
    /// C
    FEM_DO_SAFE(i, 1, 50) {
      dyp1(i) = snyp1(i);
      deyp1(i) = seyp1(i);
      dyg1(i) = snyg1(i);
      deyg1(i) = seyg1(i);
      dnrpj1(i) = snrpj1(i);
      dnrtg1(i) = snrtg1(i);
      dnrin1(i) = snrin1(i);
      dnrtt1(i) = snrtt1(i);
      dyg1c(i) = snyg1c(i);
      dmyg1c(i) = smyg1c(i);
      deyg1c(i) = seyg1c(i);
    }
    nsubp = nsubps;
    nsubg = nsubgs;
    nisg = nisgs;
  } else {
    FEM_DO_SAFE(i, 1, 200) {
      smyp1(i) = dmyp1(i);
      smyg1(i) = dmyg1(i);
    }
    /// C
    FEM_DO_SAFE(i, 1, 50) {
      snyp1(i) = dyp1(i);
      seyp1(i) = deyp1(i);
      snyg1(i) = dyg1(i);
      seyg1(i) = deyg1(i);
      snrpj1(i) = dnrpj1(i);
      snrtg1(i) = dnrtg1(i);
      snrin1(i) = dnrin1(i);
      snrtt1(i) = dnrtt1(i);
      snyg1c(i) = dyg1c(i);
      smyg1c(i) = dmyg1c(i);
      seyg1c(i) = deyg1c(i);
    }
    nsubps = nsubp;
    nsubgs = nsubg;
    nisgs = nisg;
    isevt = iaevt;
    isrun = iarun;
    iw++;
  }
  /// C.....analysis
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      ityp = kfpj(i, j);
      px = pjpx(i, j);
      py = pjpy(i, j);
      pz = pjpz(i, j);
      pe = pjpe(i, j);
      pm = pjpm(i, j);
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
      dxmt = xmt - pm;
      /// Clin-9/2012 determine rapidity more generally:
      /// C            IF (ABS(PZ) .GE. PE) THEN
      /// C               PRINT *, ' IN HJANA1, PROJ STR ', I, ' PART ', J
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', PE
      /// C               PRINT *, ' XM = ', PM
      /// C               GOTO 200
      /// C            END IF
      /// C            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
      if (xmt > 0.f) {
        rap = asinh(pz / xmt);
      } else {
        rap = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      iy = 1 + fem::fint(fem::abs(rap) / dy);
      /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
      /// C            IF (IY .GT. 50) GOTO 100
      if (iy < 1 || iy > 50) {
        goto statement_100;
      }
      dyp1(iy) += 1.0f;
      deyp1(iy) += xmt;
      if (ityp == 21) {
        dyg1(iy) += 1.0f;
        deyg1(iy) += xmt;
      }
    statement_100:
      imt = 1 + fem::fint(dxmt / dmt);
      if (rap > ymax || rap <= ymin) {
        goto statement_200;
      }
      if (imt > 200) {
        goto statement_200;
      }
      dmyp1(imt) += 1.0f / xmt;
      if (ityp == 21) {
        dmyg1(imt) += 1.0f / xmt;
      }
    statement_200:;
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      ityp = kftj(i, j);
      px = pjtx(i, j);
      py = pjty(i, j);
      pz = pjtz(i, j);
      pe = pjte(i, j);
      pm = pjtm(i, j);
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
      dxmt = xmt - pm;
      /// Clin-9/2012 determine rapidity more generally:
      /// C            IF (ABS(PZ) .GE. PE) THEN
      /// C               PRINT *, ' IN HJANA1, TARG STR ', I, ' PART ', J
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', PE
      /// C               PRINT *, ' XM = ', PM
      /// C               GOTO 400
      /// C            END IF
      /// C            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
      if (xmt > 0.f) {
        rap = asinh(pz / xmt);
      } else {
        write(6, star), " IN HJANA1 mt=0";
        rap = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      iy = 1 + fem::fint(fem::abs(rap) / dy);
      /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
      /// C            IF (IY .GT. 50) GOTO 300
      if (iy < 1 || iy > 50) {
        goto statement_300;
      }
      dyp1(iy) += 1.0f;
      deyp1(iy) += xmt;
      if (ityp == 21) {
        dyg1(iy) += 1.0f;
        deyg1(iy) += xmt;
      }
    statement_300:
      if (rap > ymax || rap <= ymin) {
        goto statement_400;
      }
      imt = 1 + fem::fint(dxmt / dmt);
      if (imt > 200) {
        goto statement_400;
      }
      dmyp1(imt) += 1.0f / xmt;
      if (ityp == 21) {
        dmyg1(imt) += 1.0f / xmt;
      }
    statement_400:;
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, nsg) {
    FEM_DO_SAFE(j, 1, njsg(i)) {
      ityp = k2sg(i, j);
      px = pxsg(i, j);
      py = pysg(i, j);
      pz = pzsg(i, j);
      pe = pesg(i, j);
      pm = pmsg(i, j);
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
      dxmt = xmt - pm;
      /// Clin-9/2012 determine rapidity more generally:
      /// C            IF (ABS(PZ) .GE. PE) THEN
      /// C               PRINT *, ' IN HJANA1, INDP STR ', I, ' PART ', J
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', PE
      /// C               PRINT *, ' XM = ', PM
      /// C               GOTO 600
      /// C            END IF
      /// C            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
      if (xmt > 0.f) {
        rap = asinh(pz / xmt);
      } else {
        write(6, star), " IN HJANA1 mt=0";
        rap = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      iy = 1 + fem::fint(fem::abs(rap) / dy);
      /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
      /// C            IF (IY .GT. 50) GOTO 500
      if (iy < 1 || iy > 50) {
        goto statement_500;
      }
      dyp1(iy) += 1.0f;
      deyp1(iy) += xmt;
      if (ityp == 21) {
        dyg1(iy) += 1.0f;
        deyg1(iy) += xmt;
      }
    statement_500:
      if (rap > ymax || rap <= ymin) {
        goto statement_600;
      }
      imt = 1 + fem::fint(dxmt / dmt);
      if (imt > 200) {
        goto statement_600;
      }
      dmyp1(imt) += 1.0f / xmt;
      if (ityp == 21) {
        dmyg1(imt) += 1.0f / xmt;
      }
    statement_600:;
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    yr = fem::sqrt(fem::pow2(yp(1, i)) + fem::pow2(yp(2, i)));
    ir = 1 + fem::fint(yr / dr);
    /// Clin-4/2008 protect against out-of-bound errors:
    /// C         IF (IR .GT. 50) GOTO 601
    if (ir > 50 || ir < 1) {
      goto statement_601;
    }
    dnrpj1(ir) += 1.0f;
    dnrtt1(ir) += 1.0f;
  statement_601:;
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    yr = fem::sqrt(fem::pow2(yt(1, i)) + fem::pow2(yt(2, i)));
    ir = 1 + fem::fint(yr / dr);
    if (ir > 50 || ir < 1) {
      goto statement_602;
    }
    dnrtg1(ir) += 1.0f;
    dnrtt1(ir) += 1.0f;
  statement_602:;
  }
  /// C
  FEM_DO_SAFE(i, 1, nsg) {
    y1 = 0.5f * (yp(1, iasg(i, 1)) + yt(1, iasg(i, 2)));
    y2 = 0.5f * (yp(2, iasg(i, 1)) + yt(2, iasg(i, 2)));
    yr = fem::sqrt(fem::pow2(y1) + fem::pow2(y2));
    ir = 1 + fem::fint(yr / dr);
    if (ir > 50 || ir < 1) {
      goto statement_603;
    }
    dnrin1(ir) += 1.0f;
    dnrtt1(ir) += 1.0f;
  statement_603:;
  }
  /// C
  FEM_DO_SAFE(i, 1, cmn.mul) {
    ityp = ityp0(i);
    px = fem::sngl(px0(i));
    py = fem::sngl(py0(i));
    pz = fem::sngl(pz0(i));
    pe = fem::sngl(e0(i));
    pm = fem::sngl(xmass0(i));
    xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
    dxmt = xmt - pm;
    /// Clin-9/2012 determine rapidity more generally:
    /// C         IF (ABS(PZ) .GE. PE) THEN
    /// C            PRINT *, ' IN HJANA1, GLUON ', I
    /// C            PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
    /// C            PRINT *, ' PZ = ', PZ, ' EE = ', PE
    /// C            PRINT *, ' XM = ', PM
    /// C            GOTO 800
    /// C         END IF
    /// C         RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
    if (xmt > 0.f) {
      rap = asinh(pz / xmt);
    } else {
      write(6, star), " IN HJANA1 mt=0";
      rap = 1000000.0f * fem::sign(1.f, pz);
    }
    /// C
    iy = 1 + fem::fint(fem::abs(rap) / dy);
    /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
    /// C         IF (IY .GT. 50) GOTO 700
    if (iy < 1 || iy > 50) {
      goto statement_700;
    }
    dyg1c(iy) += 1.0f;
    deyg1c(iy) += xmt;
  statement_700:
    if (rap > ymax || rap <= ymin) {
      goto statement_800;
    }
    imt = 1 + fem::fint(dxmt / dmt);
    if (imt > 50) {
      goto statement_800;
    }
    dmyg1c(imt) += 1.0f / xmt;
  statement_800:;
  }
  /// C.....count number of particles
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      nsubp++;
      if (kfpj(i, j) == 21) {
        nsubg++;
      }
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      nsubp++;
      if (kftj(i, j) == 21) {
        nsubg++;
      }
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, nsg) {
    FEM_DO_SAFE(j, 1, njsg(i)) {
      nsubp++;
      if (k2sg(i, j) == 21) {
        nsubg++;
      }
    }
  }
  nisg += nsg;
  if (cmn.iout == 1) {
    /// Cbzdbg2/16/99
    /// C      PRINT *, ' in HJANA1 '
    /// C      PRINT *, ' total number of partons = ', nsubp
    /// C      PRINT *, ' total number of gluons = ', nsubg, MUL
    /// C      PRINT *, ' number of projectile strings = ', IHNT2(1)
    /// C      PRINT *, ' number of target strings = ', IHNT2(3)
    /// C      PRINT *, ' number of independent strings = ', NSG
    write(6, star), " in HJANA1 ";
    write(6, star), " total number of partons = ", nsubp / iw;
    write(6, star), " total number of gluons = ", nsubg / iw;
    /// C      PRINT *, ' number of projectile strings = ', IHNT2(1)
    /// C      PRINT *, ' number of target strings = ', IHNT2(3)
    write(6, star), " number of independent strings = ", nisg / iw;
    /// Cbzdbg2/16/99end
  }
  /// C
}

struct hjan2a_save {
  fem::variant_bindings prec2_bindings;
  arr<float> dgxg2a;
  arr<float> dgxp2a;
  arr<float> dgyg2a;
  arr<float> dgyp2a;
  float diff2;
  arr<float> dtg2a;
  arr<float> dtp2a;
  int i;
  int igx;
  int igy;
  int isevt;
  int isrun;
  int it;
  int iw;
  int j;
  arr<float> sgxg2a;
  arr<float> sgxp2a;
  arr<float> sgyg2a;
  arr<float> sgyp2a;
  arr<float> stg2a;
  arr<float> stp2a;

  hjan2a_save()
      : dgxg2a(dimension(50), fem::fill0),
        dgxp2a(dimension(50), fem::fill0),
        dgyg2a(dimension(50), fem::fill0),
        dgyp2a(dimension(50), fem::fill0),
        diff2(fem::float0),
        dtg2a(dimension(50), fem::fill0),
        dtp2a(dimension(50), fem::fill0),
        i(fem::int0),
        igx(fem::int0),
        igy(fem::int0),
        isevt(fem::int0),
        isrun(fem::int0),
        it(fem::int0),
        iw(fem::int0),
        j(fem::int0),
        sgxg2a(dimension(50), fem::fill0),
        sgxp2a(dimension(50), fem::fill0),
        sgyg2a(dimension(50), fem::fill0),
        sgyp2a(dimension(50), fem::fill0),
        stg2a(dimension(50), fem::fill0),
        stp2a(dimension(50), fem::fill0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....subroutine called by HJANA2
void hjan2a(common& cmn) {
  FEM_CMN_SVE(hjan2a);
  common_write write(cmn);
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<int> npj(cmn.npj, dimension(300));
  arr_cref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_cref<int> ntj(cmn.ntj, dimension(300));
  arr_cref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  const int maxstr = 150001;
  arr_cref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_cref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_cref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  int& iaevt = cmn.iaevt;
  int& iarun = cmn.iarun;
  ///
  const int maxptn = 400001;
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  arr_ref<float> dgxg2a(sve.dgxg2a, dimension(50));
  arr_ref<float> dgxp2a(sve.dgxp2a, dimension(50));
  arr_ref<float> dgyg2a(sve.dgyg2a, dimension(50));
  arr_ref<float> dgyp2a(sve.dgyp2a, dimension(50));
  float& diff2 = sve.diff2;
  arr_ref<float> dtg2a(sve.dtg2a, dimension(50));
  arr_ref<float> dtp2a(sve.dtp2a, dimension(50));
  int& i = sve.i;
  int& igx = sve.igx;
  int& igy = sve.igy;
  int& isevt = sve.isevt;
  int& isrun = sve.isrun;
  int& it = sve.it;
  int& iw = sve.iw;
  int& j = sve.j;
  arr_ref<float> sgxg2a(sve.sgxg2a, dimension(50));
  arr_ref<float> sgxp2a(sve.sgxp2a, dimension(50));
  arr_ref<float> sgyg2a(sve.sgyg2a, dimension(50));
  arr_ref<float> sgyp2a(sve.sgyp2a, dimension(50));
  arr_ref<float> stg2a(sve.stg2a, dimension(50));
  arr_ref<float> stp2a(sve.stp2a, dimension(50));
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx5(dimension(maxptn));
      mbr<double> gy5(dimension(maxptn));
      mbr<double> gz5(dimension(maxptn));
      mbr<double> ft5(dimension(maxptn));
      mbr<double> px5(dimension(maxptn));
      mbr<double> py5(dimension(maxptn));
      mbr<double> pz5(dimension(maxptn));
      mbr<double> e5(dimension(maxptn));
      mbr<double> xmass5(dimension(maxptn));
      mbr<int> ityp5(dimension(maxptn));
      prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5, ityp5;
    }
  }
  arr_cref<double> gx5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass5( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp5( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  if (is_called_first_time) {
    iw = 0;
  }
  const float dgx = 0.2f;
  const float dgy = 0.2f;
  const float dt = 0.2f;
  /// C
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /AREVT/
  /// Cc      SAVE /AROUT/
  /// C
  if (isevt == iaevt && isrun == iarun) {
    FEM_DO_SAFE(i, 1, 50) {
      dgxp2a(i) = sgxp2a(i);
      dgyp2a(i) = sgyp2a(i);
      dtp2a(i) = stp2a(i);
      dgxg2a(i) = sgxg2a(i);
      dgyg2a(i) = sgyg2a(i);
      dtg2a(i) = stg2a(i);
    }
  } else {
    FEM_DO_SAFE(i, 1, 50) {
      sgxp2a(i) = dgxp2a(i);
      sgyp2a(i) = dgyp2a(i);
      stp2a(i) = dtp2a(i);
      sgxg2a(i) = dgxg2a(i);
      sgyg2a(i) = dgyg2a(i);
      stg2a(i) = dtg2a(i);
    }
    isevt = iaevt;
    isrun = iarun;
    iw++;
  }
  /// C.....analysis
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      if (kfpj(i, j) != 21) {
        igx = 1 + fem::fint(fem::abs(yp(1, i)) / dgx);
        if (igx > 50 || igx < 1) {
          goto statement_100;
        }
        dgxp2a(igx) += 1.0f;
      statement_100:
        igy = 1 + fem::fint(fem::abs(yp(2, i)) / dgy);
        if (igy > 50 || igy < 1) {
          goto statement_200;
        }
        dgyp2a(igy) += 1.0f;
      statement_200:
        it = 1;
        dtp2a(it) += 1.0f;
      }
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      if (kftj(i, j) != 21) {
        igx = 1 + fem::fint(fem::abs(yt(1, i)) / dgx);
        if (igx > 50 || igx < 1) {
          goto statement_300;
        }
        dgxp2a(igx) += 1.0f;
      statement_300:
        igy = 1 + fem::fint(fem::abs(yt(2, i)) / dgy);
        if (igy > 50 || igy < 1) {
          goto statement_400;
        }
        dgyp2a(igy) += 1.0f;
      statement_400:
        it = 1;
        dtp2a(it) += 1.0f;
      }
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, cmn.nsg) {
    FEM_DO_SAFE(j, 1, njsg(i)) {
      if (k2sg(i, j) != 21) {
        igx = 1 + fem::fint(
                      fem::abs(0.5f * (yp(1, iasg(i, 1)) + yt(1, iasg(i, 2)))) /
                      dgx);
        if (igx > 50 || igx < 1) {
          goto statement_500;
        }
        dgxp2a(igx) += 1.0f;
      statement_500:
        igy = 1 + fem::fint(
                      fem::abs(0.5f * (yp(2, iasg(i, 1)) + yt(2, iasg(i, 2)))) /
                      dgy);
        if (igy > 50 || igy < 1) {
          goto statement_600;
        }
        dgyp2a(igy) += 1.0f;
      statement_600:
        it = 1;
        dtp2a(it) += 1.0f;
      }
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, cmn.mul) {
    igx = 1 + fem::fint(fem::abs(fem::sngl(gx5(i))) / dgx);
    if (igx > 50 || igx < 1) {
      goto statement_700;
    }
    dgxg2a(igx) += 1.0f;
    dgxp2a(igx) += 1.0f;
  statement_700:
    igy = 1 + fem::fint(fem::abs(fem::sngl(gy5(i))) / dgy);
    if (igy > 50 || igy < 1) {
      goto statement_800;
    }
    dgyg2a(igy) += 1.0f;
    dgyp2a(igy) += 1.0f;
  statement_800:
    /// Clin-9/2015 to avoid Floating-Point Exception:
    /// C         IT = 1 + int(SQRT(sngl(FT5(I) ** 2 - GZ5(I) ** 2)) / DT)
    diff2 = fem::sngl(fem::pow2(ft5(i)) - fem::pow2(gz5(i)));
    if (diff2 < 0.f) {
      write(6, star), "3:I,ft5,gz5,diff2=", i, ft5(i), gz5(i), diff2;
      it = 1;
    } else {
      it = 1 + fem::fint(fem::sqrt(diff2) / dt);
    }
    /// C
    if (it > 50 || it < 1) {
      goto statement_900;
    }
    dtg2a(it) += 1.0f;
    dtp2a(it) += 1.0f;
  statement_900:;
  }
  /// C
}

struct hjan2b_save {
  fem::variant_bindings prec2_bindings;
  float diff2;
  arr<float> dnrg2b;
  float dtau;
  arr<float> dtg2b;
  float gx0;
  float gy0;
  int i;
  int ir;
  int isevt;
  int isrun;
  int it;
  int iw;
  int j;
  float r0;
  arr<float> snrg2b;
  arr<float> stg2b;
  float tau7;

  hjan2b_save()
      : diff2(fem::float0),
        dnrg2b(dimension(50), fem::fill0),
        dtau(fem::float0),
        dtg2b(dim1(-24, 25), fem::fill0),
        gx0(fem::float0),
        gy0(fem::float0),
        i(fem::int0),
        ir(fem::int0),
        isevt(fem::int0),
        isrun(fem::int0),
        it(fem::int0),
        iw(fem::int0),
        j(fem::int0),
        r0(fem::float0),
        snrg2b(dimension(50), fem::fill0),
        stg2b(dim1(-24, 25), fem::fill0),
        tau7(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....analysis subroutine in HJANA2
/// C
void hjan2b(common& cmn) {
  FEM_CMN_SVE(hjan2b);
  common_write write(cmn);
  const int maxptn = 400001;
  arr_cref<int> lstrg1(cmn.lstrg1, dimension(maxptn));
  const int maxstr = 150001;
  arr_cref<double> ataui(cmn.ataui, dimension(maxstr));
  arr_cref<double> zt1(cmn.zt1, dimension(maxstr));
  arr_cref<double> zt2(cmn.zt2, dimension(maxstr));
  int& iaevt = cmn.iaevt;
  int& iarun = cmn.iarun;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  float& diff2 = sve.diff2;
  arr_ref<float> dnrg2b(sve.dnrg2b, dimension(50));
  float& dtau = sve.dtau;
  arr_ref<float> dtg2b(sve.dtg2b, dim1(-24, 25));
  float& gx0 = sve.gx0;
  float& gy0 = sve.gy0;
  int& i = sve.i;
  int& ir = sve.ir;
  int& isevt = sve.isevt;
  int& isrun = sve.isrun;
  int& it = sve.it;
  int& iw = sve.iw;
  int& j = sve.j;
  float& r0 = sve.r0;
  arr_ref<float> snrg2b(sve.snrg2b, dimension(50));
  arr_ref<float> stg2b(sve.stg2b, dim1(-24, 25));
  float& tau7 = sve.tau7;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx5(dimension(maxptn));
      mbr<double> gy5(dimension(maxptn));
      mbr<double> gz5(dimension(maxptn));
      mbr<double> ft5(dimension(maxptn));
      mbr<double> px5(dimension(maxptn));
      mbr<double> py5(dimension(maxptn));
      mbr<double> pz5(dimension(maxptn));
      mbr<double> e5(dimension(maxptn));
      mbr<double> xmass5(dimension(maxptn));
      mbr<int> ityp5(dimension(maxptn));
      prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5, ityp5;
    }
  }
  arr_cref<double> gx5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass5( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp5( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  if (is_called_first_time) {
    iw = 0;
  }
  const float dr = 0.2f;
  const float dt = 0.2f;
  /// C
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /ilist8/
  /// Cc      SAVE /SREC1/
  /// Cc      SAVE /SREC2/
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /AREVT/
  /// Cc      SAVE /AROUT/
  /// C
  if (isevt == iaevt && isrun == iarun) {
    FEM_DO_SAFE(i, 1, 50) {
      dnrg2b(i) = snrg2b(i);
      dtg2b(i - 25) = stg2b(i - 25);
    }
  } else {
    FEM_DO_SAFE(i, 1, 50) {
      snrg2b(i) = dnrg2b(i);
      stg2b(i - 25) = dtg2b(i - 25);
    }
    isevt = iaevt;
    isrun = iarun;
    iw++;
  }
  /// C.....analysis
  FEM_DO_SAFE(i, 1, cmn.mul) {
    j = lstrg1(i);
    gx0 = fem::sngl(zt1(j));
    gy0 = fem::sngl(zt2(j));
    r0 = fem::sqrt(fem::pow2((fem::sngl(gx5(i)) - gx0)) +
                   fem::pow2((fem::sngl(gy5(i)) - gy0)));
    ir = 1 + fem::fint(r0 / dr);
    if (ir > 50 || ir < 1) {
      goto statement_100;
    }
    dnrg2b(ir) += 1.0f;
  statement_100:
    /// Clin-9/2015 to avoid Floating-Point Exception:
    /// C         TAU7 = SQRT(sngl(FT5(I) ** 2 - GZ5(I) ** 2))
    diff2 = fem::sngl(fem::pow2(ft5(i)) - fem::pow2(gz5(i)));
    if (diff2 < 0.f) {
      write(6, star), "4:I,ft5,gz5,diff2=", i, ft5(i), gz5(i), diff2;
      tau7 = 1e-6f;
    } else {
      tau7 = fem::sqrt(diff2);
    }
    /// C
    dtau = tau7 - fem::sngl(ataui(j));
    it = 1 + fem::fint(dtau / dt);
    /// Cbzdbg2/21/99
    /// C         IF (ABS(IT) .GT. 25) GOTO 200
    if (it > 25 || it < -24) {
      goto statement_200;
    }
    /// Cbzdbg2/21/99end
    dtg2b(it) += 1.0f;
  statement_200:;
  }
  /// C
}

struct hjana2_save {
  fem::variant_bindings prec2_bindings;
  arr<float> deyg2;
  arr<float> deyg2c;
  arr<float> deyp2;
  arr<float> dmyg2;
  arr<float> dmyg2c;
  arr<float> dmyp2;
  arr<float> dnrin2;
  arr<float> dnrpj2;
  arr<float> dnrtg2;
  arr<float> dnrtt2;
  arr<float> dtin2;
  arr<float> dtpj2;
  arr<float> dttg2;
  arr<float> dttot2;
  float dxmt;
  arr<float> dyg2;
  arr<float> dyg2c;
  arr<float> dyp2;
  int i;
  int imt;
  int ir;
  int isevt;
  int isrun;
  int it;
  int ityp;
  int iw;
  int iy;
  int j;
  int nisg;
  int nisgs;
  int nj;
  int nsubg;
  int nsubgs;
  int nsubp;
  int nsubps;
  float pe;
  float pm;
  float px;
  float py;
  float pz;
  float rap;
  arr<float> seyg2;
  arr<float> seyg2c;
  arr<float> seyp2;
  arr<float> smyg2;
  arr<float> smyg2c;
  arr<float> smyp2;
  arr<float> snrin2;
  arr<float> snrpj2;
  arr<float> snrtg2;
  arr<float> snrtt2;
  arr<float> snyg2;
  arr<float> snyg2c;
  arr<float> snyp2;
  arr<float> stin2;
  arr<float> stpj2;
  arr<float> sttg2;
  arr<float> sttot2;
  float xmt;
  float yr;

  hjana2_save()
      : deyg2(dimension(50), fem::fill0),
        deyg2c(dimension(50), fem::fill0),
        deyp2(dimension(50), fem::fill0),
        dmyg2(dimension(200), fem::fill0),
        dmyg2c(dimension(50), fem::fill0),
        dmyp2(dimension(200), fem::fill0),
        dnrin2(dimension(50), fem::fill0),
        dnrpj2(dimension(50), fem::fill0),
        dnrtg2(dimension(50), fem::fill0),
        dnrtt2(dimension(50), fem::fill0),
        dtin2(dimension(50), fem::fill0),
        dtpj2(dimension(50), fem::fill0),
        dttg2(dimension(50), fem::fill0),
        dttot2(dimension(50), fem::fill0),
        dxmt(fem::float0),
        dyg2(dimension(50), fem::fill0),
        dyg2c(dimension(50), fem::fill0),
        dyp2(dimension(50), fem::fill0),
        i(fem::int0),
        imt(fem::int0),
        ir(fem::int0),
        isevt(fem::int0),
        isrun(fem::int0),
        it(fem::int0),
        ityp(fem::int0),
        iw(fem::int0),
        iy(fem::int0),
        j(fem::int0),
        nisg(fem::int0),
        nisgs(fem::int0),
        nj(fem::int0),
        nsubg(fem::int0),
        nsubgs(fem::int0),
        nsubp(fem::int0),
        nsubps(fem::int0),
        pe(fem::float0),
        pm(fem::float0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        rap(fem::float0),
        seyg2(dimension(50), fem::fill0),
        seyg2c(dimension(50), fem::fill0),
        seyp2(dimension(50), fem::fill0),
        smyg2(dimension(200), fem::fill0),
        smyg2c(dimension(50), fem::fill0),
        smyp2(dimension(200), fem::fill0),
        snrin2(dimension(50), fem::fill0),
        snrpj2(dimension(50), fem::fill0),
        snrtg2(dimension(50), fem::fill0),
        snrtt2(dimension(50), fem::fill0),
        snyg2(dimension(50), fem::fill0),
        snyg2c(dimension(50), fem::fill0),
        snyp2(dimension(50), fem::fill0),
        stin2(dimension(50), fem::fill0),
        stpj2(dimension(50), fem::fill0),
        sttg2(dimension(50), fem::fill0),
        sttot2(dimension(50), fem::fill0),
        xmt(fem::float0),
        yr(fem::float0) {}
};

/// C
/// C-----------------------------------------------------------------------
/// C
/// C.....analysis subroutine in HIJING after parton cascade evolution
void hjana2(common& cmn) {
  FEM_CMN_SVE(hjana2);
  common_write write(cmn);
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  const int maxstr = 150001;
  arr_cref<double> ataui(cmn.ataui, dimension(maxstr));
  arr_cref<double> zt1(cmn.zt1, dimension(maxstr));
  arr_cref<double> zt2(cmn.zt2, dimension(maxstr));
  arr_cref<int> npj(cmn.npj, dimension(300));
  arr_cref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_cref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_cref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_cref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_cref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_cref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_cref<int> ntj(cmn.ntj, dimension(300));
  arr_cref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_cref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_cref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_cref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_cref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_cref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  int& nsg = cmn.nsg;
  arr_cref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_cref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_cref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_cref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_cref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_cref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_cref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  int& iaevt = cmn.iaevt;
  int& iarun = cmn.iarun;
  int& isoft = cmn.isoft;
  arr_cref<double, 2> pxsgs(cmn.pxsgs, dimension(maxstr, 3));
  arr_cref<double, 2> pysgs(cmn.pysgs, dimension(maxstr, 3));
  arr_cref<double, 2> pzsgs(cmn.pzsgs, dimension(maxstr, 3));
  arr_cref<double, 2> pesgs(cmn.pesgs, dimension(maxstr, 3));
  arr_cref<double, 2> pmsgs(cmn.pmsgs, dimension(maxstr, 3));
  arr_cref<int, 2> k2sgs(cmn.k2sgs, dimension(maxstr, 3));
  arr_cref<int> njsgs(cmn.njsgs, dimension(maxstr));
  ///
  const int maxptn = 400001;
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  arr_ref<float> deyg2(sve.deyg2, dimension(50));
  arr_ref<float> deyg2c(sve.deyg2c, dimension(50));
  arr_ref<float> deyp2(sve.deyp2, dimension(50));
  arr_ref<float> dmyg2(sve.dmyg2, dimension(200));
  arr_ref<float> dmyg2c(sve.dmyg2c, dimension(50));
  arr_ref<float> dmyp2(sve.dmyp2, dimension(200));
  arr_ref<float> dnrin2(sve.dnrin2, dimension(50));
  arr_ref<float> dnrpj2(sve.dnrpj2, dimension(50));
  arr_ref<float> dnrtg2(sve.dnrtg2, dimension(50));
  arr_ref<float> dnrtt2(sve.dnrtt2, dimension(50));
  arr_ref<float> dtin2(sve.dtin2, dimension(50));
  arr_ref<float> dtpj2(sve.dtpj2, dimension(50));
  arr_ref<float> dttg2(sve.dttg2, dimension(50));
  arr_ref<float> dttot2(sve.dttot2, dimension(50));
  float& dxmt = sve.dxmt;
  arr_ref<float> dyg2(sve.dyg2, dimension(50));
  arr_ref<float> dyg2c(sve.dyg2c, dimension(50));
  arr_ref<float> dyp2(sve.dyp2, dimension(50));
  int& i = sve.i;
  int& imt = sve.imt;
  int& ir = sve.ir;
  int& isevt = sve.isevt;
  int& isrun = sve.isrun;
  int& it = sve.it;
  int& ityp = sve.ityp;
  int& iw = sve.iw;
  int& iy = sve.iy;
  int& j = sve.j;
  int& nisg = sve.nisg;
  int& nisgs = sve.nisgs;
  int& nj = sve.nj;
  int& nsubg = sve.nsubg;
  int& nsubgs = sve.nsubgs;
  int& nsubp = sve.nsubp;
  int& nsubps = sve.nsubps;
  float& pe = sve.pe;
  float& pm = sve.pm;
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& rap = sve.rap;
  arr_ref<float> seyg2(sve.seyg2, dimension(50));
  arr_ref<float> seyg2c(sve.seyg2c, dimension(50));
  arr_ref<float> seyp2(sve.seyp2, dimension(50));
  arr_ref<float> smyg2(sve.smyg2, dimension(200));
  arr_ref<float> smyg2c(sve.smyg2c, dimension(50));
  arr_ref<float> smyp2(sve.smyp2, dimension(200));
  arr_ref<float> snrin2(sve.snrin2, dimension(50));
  arr_ref<float> snrpj2(sve.snrpj2, dimension(50));
  arr_ref<float> snrtg2(sve.snrtg2, dimension(50));
  arr_ref<float> snrtt2(sve.snrtt2, dimension(50));
  arr_ref<float> snyg2(sve.snyg2, dimension(50));
  arr_ref<float> snyg2c(sve.snyg2c, dimension(50));
  arr_ref<float> snyp2(sve.snyp2, dimension(50));
  arr_ref<float> stin2(sve.stin2, dimension(50));
  arr_ref<float> stpj2(sve.stpj2, dimension(50));
  arr_ref<float> sttg2(sve.sttg2, dimension(50));
  arr_ref<float> sttot2(sve.sttot2, dimension(50));
  float& xmt = sve.xmt;
  float& yr = sve.yr;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx5(dimension(maxptn));
      mbr<double> gy5(dimension(maxptn));
      mbr<double> gz5(dimension(maxptn));
      mbr<double> ft5(dimension(maxptn));
      mbr<double> px5(dimension(maxptn));
      mbr<double> py5(dimension(maxptn));
      mbr<double> pz5(dimension(maxptn));
      mbr<double> e5(dimension(maxptn));
      mbr<double> xmass5(dimension(maxptn));
      mbr<int> ityp5(dimension(maxptn));
      prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5, ityp5;
    }
  }
  /* arr_cref<double> gx5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> ft5( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  arr_cref<double> px5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> xmass5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<int> ityp5(prec2.bind<int>(), dimension(maxptn));
  if (is_called_first_time) {
    iw = 0;
  }
  const float dy = 0.2f;
  const float ymax = 1.0f;
  const float ymin = -1.0f;
  const float dmt = 0.05f;
  const float dr = 0.2f;
  const float dt = 0.2f;
  /// C
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /SREC2/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /AREVT/
  /// Cc      SAVE /AROUT/
  /// Cc      SAVE /anim/
  /// Cc      SAVE /SOFT/
  /// C
  if (isevt == iaevt && isrun == iarun) {
    FEM_DO_SAFE(i, 1, 200) {
      dmyp2(i) = smyp2(i);
      dmyg2(i) = smyg2(i);
    }
    /// C
    FEM_DO_SAFE(i, 1, 50) {
      dyp2(i) = snyp2(i);
      deyp2(i) = seyp2(i);
      dyg2(i) = snyg2(i);
      deyg2(i) = seyg2(i);
      dnrpj2(i) = snrpj2(i);
      dnrtg2(i) = snrtg2(i);
      dnrin2(i) = snrin2(i);
      dnrtt2(i) = snrtt2(i);
      dtpj2(i) = stpj2(i);
      dttg2(i) = sttg2(i);
      dtin2(i) = stin2(i);
      dttot2(i) = sttot2(i);
      dyg2c(i) = snyg2c(i);
      dmyg2c(i) = smyg2c(i);
      deyg2c(i) = seyg2c(i);
    }
    nsubp = nsubps;
    nsubg = nsubgs;
    nisg = nisgs;
  } else {
    FEM_DO_SAFE(i, 1, 200) {
      smyp2(i) = dmyp2(i);
      smyg2(i) = dmyg2(i);
    }
    /// C
    FEM_DO_SAFE(i, 1, 50) {
      snyp2(i) = dyp2(i);
      seyp2(i) = deyp2(i);
      snyg2(i) = dyg2(i);
      seyg2(i) = deyg2(i);
      snrpj2(i) = dnrpj2(i);
      snrtg2(i) = dnrtg2(i);
      snrin2(i) = dnrin2(i);
      snrtt2(i) = dnrtt2(i);
      stpj2(i) = dtpj2(i);
      sttg2(i) = dttg2(i);
      stin2(i) = dtin2(i);
      sttot2(i) = dttot2(i);
      snyg2c(i) = dyg2c(i);
      smyg2c(i) = dmyg2c(i);
      seyg2c(i) = deyg2c(i);
    }
    nsubps = nsubp;
    nsubgs = nsubg;
    nisgs = nisg;
    isevt = iaevt;
    isrun = iarun;
    iw++;
  }
  /// C
  /// Clin-4/28/01:
  if (isoft == 3 || isoft == 4 || isoft == 5) {
    goto statement_510;
  }
  /// C
  /// C.....analysis
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      ityp = kfpj(i, j);
      px = pjpx(i, j);
      py = pjpy(i, j);
      pz = pjpz(i, j);
      pe = pjpe(i, j);
      pm = pjpm(i, j);
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
      dxmt = xmt - pm;
      /// Clin-9/2012 determine rapidity more generally:
      /// Ccbzdbg2/16/99
      /// Cc            IF (ABS(PZ) .GE. PE) GOTO 200
      /// C            IF (ABS(PZ) .GE. PE) THEN
      /// C               PRINT *, ' IN HJANA2, PROJ STR ', I, ' PART ', J
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', PE
      /// C               PRINT *, ' XM = ', PM
      /// C               GOTO 200
      /// C            END IF
      /// Ccbzdbg2/16/99end
      /// C            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
      if (xmt > 0.f) {
        rap = asinh(pz / xmt);
      } else {
        write(6, star), " IN HJANA2 mt=0";
        rap = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      iy = 1 + fem::fint(fem::abs(rap) / dy);
      /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
      /// C            IF (IY .GT. 50) GOTO 100
      if (iy < 1 || iy > 50) {
        goto statement_100;
      }
      dyp2(iy) += 1.0f;
      deyp2(iy) += xmt;
      if (ityp == 21) {
        dyg2(iy) += 1.0f;
        deyg2(iy) += xmt;
      }
    statement_100:
      if (rap > ymax || rap <= ymin) {
        goto statement_200;
      }
      imt = 1 + fem::fint(dxmt / dmt);
      if (imt > 200) {
        goto statement_200;
      }
      dmyp2(imt) += 1.0f / xmt;
      if (ityp == 21) {
        dmyg2(imt) += 1.0f / xmt;
      }
    statement_200:;
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      ityp = kftj(i, j);
      px = pjtx(i, j);
      py = pjty(i, j);
      pz = pjtz(i, j);
      pe = pjte(i, j);
      pm = pjtm(i, j);
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
      dxmt = xmt - pm;
      /// Clin-9/2012 determine rapidity more generally:
      /// Ccbzdbg2/16/99
      /// Cc            IF (ABS(PZ) .GE. PE) GOTO 400
      /// C            IF (ABS(PZ) .GE. PE) THEN
      /// C               PRINT *, ' IN HJANA2, TARG STR ', I, ' PART ', J
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', PE
      /// C               PRINT *, ' XM = ', PM
      /// C               GOTO 400
      /// C            END IF
      /// Ccbzdbg2/16/99end
      /// C            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
      if (xmt > 0.f) {
        rap = asinh(pz / xmt);
      } else {
        write(6, star), " IN HJANA2 mt=0";
        rap = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      iy = 1 + fem::fint(fem::abs(rap) / dy);
      /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
      /// C            IF (IY .GT. 50) GOTO 300
      if (iy < 1 || iy > 50) {
        goto statement_300;
      }
      dyp2(iy) += 1.0f;
      deyp2(iy) += xmt;
      if (ityp == 21) {
        dyg2(iy) += 1.0f;
        deyg2(iy) += xmt;
      }
    statement_300:
      if (rap > ymax || rap <= ymin) {
        goto statement_400;
      }
      imt = 1 + fem::fint(dxmt / dmt);
      if (imt > 200) {
        goto statement_400;
      }
      dmyp2(imt) += 1.0f / xmt;
      if (ityp == 21) {
        dmyg2(imt) += 1.0f / xmt;
      }
    statement_400:;
    }
  }
/// C
/// Clin-4/28/01:
statement_510:
  /// C
  FEM_DO_SAFE(i, 1, nsg) {
    /// Clin-4/25/01 soft3:
    /// C         DO J = 1, NJSG(I)
    nj = njsg(i);
    if (isoft == 3 || isoft == 4 || isoft == 5) {
      nj = njsgs(i);
    }
    FEM_DO_SAFE(j, 1, nj) {
      /// Clin-4/25/01-end
      /// C
      ityp = k2sg(i, j);
      px = pxsg(i, j);
      py = pysg(i, j);
      pz = pzsg(i, j);
      pe = pesg(i, j);
      pm = pmsg(i, j);
      /// Clin-4/25/01 soft3:
      if (isoft == 3 || isoft == 4 || isoft == 5) {
        ityp = k2sgs(i, j);
        px = fem::sngl(pxsgs(i, j));
        py = fem::sngl(pysgs(i, j));
        pz = fem::sngl(pzsgs(i, j));
        pe = fem::sngl(pesgs(i, j));
        pm = fem::sngl(pmsgs(i, j));
      }
      /// Clin-4/25/01-end
      /// C
      /// Clin-9/2012 determine rapidity more generally:
      xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
      dxmt = xmt - pm;
      /// Ccbzdbg2/16/99
      /// Cc            IF (ABS(PZ) .GE. PE) GOTO 600
      /// C            IF (ABS(PZ) .GE. PE) THEN
      /// C               PRINT *, ' IN HJANA2, INDP STR ', I, ' PART ', J
      /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
      /// C               PRINT *, ' PZ = ', PZ, ' EE = ', PE
      /// C               PRINT *, ' XM = ', PM
      /// C               GOTO 600
      /// C            END IF
      /// Ccbzdbg2/16/99end
      /// C            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
      if (xmt > 0.f) {
        rap = asinh(pz / xmt);
      } else {
        write(6, star), " IN HJANA2 mt=0";
        rap = 1000000.0f * fem::sign(1.f, pz);
      }
      /// C
      iy = 1 + fem::fint(fem::abs(rap) / dy);
      /// Clin-8/2014 prevent possible segmentation fault (due to IY<=0):
      /// C            IF (IY .GT. 50) GOTO 500
      if (iy < 1 || iy > 50) {
        goto statement_500;
      }
      dyp2(iy) += 1.0f;
      deyp2(iy) += xmt;
      if (ityp == 21) {
        dyg2(iy) += 1.0f;
        deyg2(iy) += xmt;
      }
    statement_500:
      if (rap > ymax || rap <= ymin) {
        goto statement_600;
      }
      imt = 1 + fem::fint(dxmt / dmt);
      if (imt > 200) {
        goto statement_600;
      }
      dmyp2(imt) += 1.0f / xmt;
      if (ityp == 21) {
        dmyg2(imt) += 1.0f / xmt;
      }
    statement_600:;
    }
  }
  /// C
  /// Clin-4/28/01:
  if (isoft == 3 || isoft == 4 || isoft == 5) {
    goto statement_520;
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    j = i;
    yr = fem::sqrt(fem::sngl(fem::pow2(zt1(j)) + fem::pow2(zt2(j))));
    ir = 1 + fem::fint(yr / dr);
    if (ir > 50 || ir < 1) {
      goto statement_601;
    }
    dnrpj2(ir) += 1.0f;
    dnrtt2(ir) += 1.0f;
  statement_601:
    it = 1 + fem::fint(fem::sngl(ataui(j)) / dt);
    if (it > 50 || it < 1) {
      goto statement_602;
    }
    dtpj2(it) += 1.0f;
    dttot2(it) += 1.0f;
  statement_602:;
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    j = i + ihnt2(1);
    yr = fem::sqrt(fem::sngl(fem::pow2(zt1(j)) + fem::pow2(zt2(j))));
    ir = 1 + fem::fint(yr / dr);
    if (ir > 50 || ir < 1) {
      goto statement_603;
    }
    dnrtg2(ir) += 1.0f;
    dnrtt2(ir) += 1.0f;
  statement_603:
    it = 1 + fem::fint(fem::sngl(ataui(j)) / dt);
    if (it > 50 || it < 1) {
      goto statement_604;
    }
    dttg2(it) += 1.0f;
    dttot2(it) += 1.0f;
  statement_604:;
  }
/// C
/// Clin-4/28/01:
statement_520:
  /// C
  FEM_DO_SAFE(i, 1, nsg) {
    j = i + ihnt2(1) + ihnt2(3);
    /// Clin-4/28/01:
    if (isoft == 3 || isoft == 4 || isoft == 5) {
      j = i;
    }
    /// C
    yr = fem::sqrt(fem::sngl(fem::pow2(zt1(j)) + fem::pow2(zt2(j))));
    ir = 1 + fem::fint(yr / dr);
    if (ir > 50 || ir < 1) {
      goto statement_605;
    }
    dnrin2(ir) += 1.0f;
    dnrtt2(ir) += 1.0f;
  statement_605:
    it = 1 + fem::fint(fem::sngl(ataui(j)) / dt);
    if (it > 50 || it < 1) {
      goto statement_606;
    }
    dtin2(it) += 1.0f;
    dttot2(it) += 1.0f;
  statement_606:;
  }
  /// C
  FEM_DO_SAFE(i, 1, cmn.mul) {
    ityp = ityp5(i);
    px = fem::sngl(px5(i));
    py = fem::sngl(py5(i));
    pz = fem::sngl(pz5(i));
    pe = fem::sngl(e5(i));
    pm = fem::sngl(xmass5(i));
    /// Clin-9/2012 determine rapidity more generally:
    xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(pm));
    dxmt = xmt - pm;
    /// Ccbzdbg2/16/99
    /// Cc            IF (ABS(PZ) .GE. PE) GOTO 800
    /// C         IF (ABS(PZ) .GE. PE) THEN
    /// C            PRINT *, ' IN HJANA2, GLUON ', I
    /// C            PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
    /// C            PRINT *, ' PZ = ', PZ, ' EE = ', PE
    /// C            PRINT *, ' XM = ', PM
    /// C            GOTO 800
    /// C         END IF
    /// Ccbzdbg2/16/99end
    /// C         RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
    if (xmt > 0.f) {
      rap = asinh(pz / xmt);
    } else {
      write(6, star), " IN HJANA2 mt=0";
      rap = 1000000.0f * fem::sign(1.f, pz);
    }
    /// C
    iy = 1 + fem::fint(fem::abs(rap) / dy);
    /// Clin-9/2012 prevent possible segmentation fault (due to IY<=0):
    /// C         IF (IY .GT. 50) GOTO 700
    if (iy < 1 || iy > 50) {
      goto statement_700;
    }
    dyg2c(iy) += 1.0f;
    deyg2c(iy) += xmt;
  statement_700:
    if (rap > ymax || rap <= ymin) {
      goto statement_800;
    }
    imt = 1 + fem::fint(dxmt / dmt);
    if (imt > 50) {
      goto statement_800;
    }
    dmyg2c(imt) += 1.0f / xmt;
  statement_800:;
  }
  /// C
  /// Clin-4/25/01 soft3:
  if (isoft == 3 || isoft == 4 || isoft == 5) {
    goto statement_530;
  }
  /// C
  /// C.....count number of particles
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      nsubp++;
      if (kfpj(i, j) == 21) {
        nsubg++;
      }
    }
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      nsubp++;
      if (kftj(i, j) == 21) {
        nsubg++;
      }
    }
  }
/// C
/// Clin-4/25/01 soft3:
statement_530:
  /// C
  FEM_DO_SAFE(i, 1, nsg) {
    /// Clin-4/25/01 soft3:
    /// C         DO J = 1, NJSG(I)
    nj = njsg(i);
    if (isoft == 3 || isoft == 4 || isoft == 5) {
      nj = njsgs(i);
    }
    FEM_DO_SAFE(j, 1, nj) {
      /// Clin-4/25/01-end
      /// C
      nsubp++;
      /// C
      /// Clin-4/25/01
      /// C            IF (K2SG(I, J) .EQ. 21) nsubg = nsubg + 1
      if (isoft == 3 || isoft == 4 || isoft == 5) {
        if (k2sgs(i, j) == 21) {
          nsubg++;
        }
      } else {
        if (k2sg(i, j) == 21) {
          nsubg++;
        }
      }
      /// Clin-4/25/01-end
    }
  }
  /// Cbzdbg2/16/99
  nisg += nsg;
  /// C
  if (cmn.iout == 1) {
    /// Cbzdbg2/16/99end
    /// Cbzdbg2/16/99
    /// C      PRINT *, ' in HJANA2 '
    /// C      PRINT *, ' total number of partons = ', nsubp
    /// C      PRINT *, ' total number of gluons = ', nsubg, MUL
    /// C      PRINT *, ' number of projectile strings = ', IHNT2(1)
    /// C      PRINT *, ' number of target strings = ', IHNT2(3)
    /// C      PRINT *, ' number of independent strings = ', NSG
    write(6, star), " in HJANA2 ";
    write(6, star), " total number of partons = ", nsubp / iw;
    write(6, star), " total number of gluons = ", nsubg / iw;
    /// C      PRINT *, ' number of projectile strings = ', IHNT2(1)
    /// C      PRINT *, ' number of target strings = ', IHNT2(3)
    write(6, star), " number of independent strings = ", nisg / iw;
  }
  /// C
  hjan2a(cmn);
  hjan2b(cmn);
  /// C
}

struct hboost_save {
  float amt;
  double db;
  double dbeta;
  double dga;
  double dp3;
  double dp4;
  int i;
  float y;

  hboost_save()
      : amt(fem::float0),
        db(fem::double0),
        dbeta(fem::double0),
        dga(fem::double0),
        dp3(fem::double0),
        dp4(fem::double0),
        i(fem::int0),
        y(fem::float0) {}
};

void hboost(common& cmn) {
  FEM_CMN_SVE(hboost);
  common_write write(cmn);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  float& amt = sve.amt;
  double& db = sve.db;
  double& dbeta = sve.dbeta;
  double& dga = sve.dga;
  double& dp3 = sve.dp3;
  double& dp4 = sve.dp4;
  int& i = sve.i;
  float& y = sve.y;
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /LUDAT1/
  /// Cc      SAVE /HPARNT/
  FEM_DO_SAFE(i, 1, n) {
    dbeta = fem::dble(p(i, 3) / p(i, 4));
    if (fem::abs(dbeta) >= 1.e0) {
      db = fem::dble(hint1(2));
      if (db > 0.99999999e0) {
        /// C                ********Rescale boost vector if too close to unity.
        write(6, star), "(HIBOOT:) boost vector too large";
        db = 0.99999999e0;
      }
      dga = 1e0 / fem::sqrt(1e0 - fem::pow2(db));
      dp3 = fem::dble(p(i, 3));
      dp4 = fem::dble(p(i, 4));
      p(i, 3) = fem::sngl((dp3 + db * dp4) * dga);
      p(i, 4) = fem::sngl((dp4 + db * dp3) * dga);
      goto statement_100;
    }
    y = 0.5f * fem::sngl(fem::dlog((1.e0 + dbeta) / (1.e0 - dbeta)));
    amt =
        fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) + fem::pow2(p(i, 5)));
    p(i, 3) = amt * fem::sinh(y + hint1(3));
    p(i, 4) = amt * fem::cosh(y + hint1(3));
  statement_100:;
  }
}

struct quench_save {
  fem::variant_bindings hstrng_bindings;
  float amshu;
  float bb;
  float bbx;
  float bby;
  float de;
  float dp;
  float dp1;
  float dp2;
  float dp3;
  float dphi;
  float drr;
  float dx;
  float dy;
  float ershu;
  int i;
  int i2;
  int isg;
  int j2;
  int jp;
  int jt;
  int kp;
  int kt;
  int lq;
  arr<int> lqp;
  arr<int> lqt;
  int mp;
  int mt;
  int nq;
  float phi;
  float phip;
  float phiq;
  float phit;
  float prshu;
  float ptjet0;
  float ptot;
  float r0;
  float rd;
  float rd0;
  arr<float> rdp;
  arr<float> rdt;
  float rn;
  float v1;
  float v2;
  float v3;
  float xj;
  float yj;

  quench_save()
      : amshu(fem::float0),
        bb(fem::float0),
        bbx(fem::float0),
        bby(fem::float0),
        de(fem::float0),
        dp(fem::float0),
        dp1(fem::float0),
        dp2(fem::float0),
        dp3(fem::float0),
        dphi(fem::float0),
        drr(fem::float0),
        dx(fem::float0),
        dy(fem::float0),
        ershu(fem::float0),
        i(fem::int0),
        i2(fem::int0),
        isg(fem::int0),
        j2(fem::int0),
        jp(fem::int0),
        jt(fem::int0),
        kp(fem::int0),
        kt(fem::int0),
        lq(fem::int0),
        lqp(dimension(300), fem::fill0),
        lqt(dimension(300), fem::fill0),
        mp(fem::int0),
        mt(fem::int0),
        nq(fem::int0),
        phi(fem::float0),
        phip(fem::float0),
        phiq(fem::float0),
        phit(fem::float0),
        prshu(fem::float0),
        ptjet0(fem::float0),
        ptot(fem::float0),
        r0(fem::float0),
        rd(fem::float0),
        rd0(fem::float0),
        rdp(dimension(300), fem::fill0),
        rdt(dimension(300), fem::fill0),
        rn(fem::float0),
        v1(fem::float0),
        v2(fem::float0),
        v3(fem::float0),
        xj(fem::float0),
        yj(fem::float0) {}
};

void quench(common& cmn, int const& jpjt, int const& ntp) {
  FEM_CMN_SVE(quench);
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_ref<int> npj(cmn.npj, dimension(300));
  arr_ref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_ref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_ref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_ref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_ref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_ref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_ref<int> ntj(cmn.ntj, dimension(300));
  arr_ref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_ref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_ref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_ref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_ref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_ref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  const int maxstr = 150001;
  arr_cref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_cref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_cref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_ref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_ref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_ref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_ref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_cref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  int& nseed = cmn.nseed;
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  float& amshu = sve.amshu;
  float& bb = sve.bb;
  float& bbx = sve.bbx;
  float& bby = sve.bby;
  float& de = sve.de;
  float& dp = sve.dp;
  float& dp1 = sve.dp1;
  float& dp2 = sve.dp2;
  float& dp3 = sve.dp3;
  float& dphi = sve.dphi;
  float& drr = sve.drr;
  float& dx = sve.dx;
  float& dy = sve.dy;
  float& ershu = sve.ershu;
  int& i = sve.i;
  int& i2 = sve.i2;
  int& isg = sve.isg;
  int& j2 = sve.j2;
  int& jp = sve.jp;
  int& jt = sve.jt;
  int& kp = sve.kp;
  int& kt = sve.kt;
  int& lq = sve.lq;
  arr_ref<int> lqp(sve.lqp, dimension(300));
  arr_ref<int> lqt(sve.lqt, dimension(300));
  int& mp = sve.mp;
  int& mt = sve.mt;
  int& nq = sve.nq;
  float& phi = sve.phi;
  float& phip = sve.phip;
  float& phiq = sve.phiq;
  float& phit = sve.phit;
  float& prshu = sve.prshu;
  float& ptjet0 = sve.ptjet0;
  float& ptot = sve.ptot;
  float& r0 = sve.r0;
  float& rd = sve.rd;
  float& rd0 = sve.rd0;
  arr_ref<float> rdp(sve.rdp, dimension(300));
  arr_ref<float> rdt(sve.rdt, dimension(300));
  float& rn = sve.rn;
  float& v1 = sve.v1;
  float& v2 = sve.v2;
  float& v3 = sve.v3;
  float& xj = sve.xj;
  float& yj = sve.yj;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_cref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_cref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HPARNT/
  /// C
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /RNDF77/
  /// C
  /// C     Uzhi:
  bb = hint1(19);
  phi = hint1(20);
  bbx = bb * fem::cos(phi);
  bby = bb * fem::sin(phi);
  /// C
  if (ntp == 2) {
    goto statement_400;
  }
  if (ntp == 3) {
    goto statement_2000;
  }
  /// C*******************************************************
  /// C Jet interaction for proj jet in the direction PHIP
  /// C******************************************************
  /// C
  if (nfp(jpjt, 7) != 1) {
    return;
  }
  /// C
  jp = jpjt;
  FEM_DO_SAFE(i, 1, npj(jp)) {
    ptjet0 = fem::sqrt(fem::pow2(pjpx(jp, i)) + fem::pow2(pjpy(jp, i)));
    if (ptjet0 <= hipr1(11)) {
      goto statement_290;
    }
    ptot = fem::sqrt(ptjet0 * ptjet0 + fem::pow2(pjpz(jp, i)));
    if (ptot < hipr1(8)) {
      goto statement_290;
    }
    phip = ulangl(cmn, pjpx(jp, i), pjpy(jp, i));
    /// C******* find the wounded proj which can interact with jet***
    kp = 0;
    FEM_DO_SAFE(i2, 1, ihnt2(1)) {
      if (nfp(i2, 5) != 3 || i2 == jp) {
        goto statement_100;
      }
      dx = yp(1, i2) - yp(1, jp);
      dy = yp(2, i2) - yp(2, jp);
      phi = ulangl(cmn, dx, dy);
      dphi = fem::abs(phi - phip);
      /// C     Uzhi:
      if (dphi >= hipr1(40)) {
        dphi = 2.f * hipr1(40) - dphi;
      }
      if (dphi >= hipr1(40) / 2.0f) {
        goto statement_100;
      }
      rd0 = fem::sqrt(dx * dx + dy * dy);
      if (rd0 * fem::sin(dphi) > hipr1(12)) {
        goto statement_100;
      }
      kp++;
      lqp(kp) = i2;
      rdp(kp) = fem::cos(dphi) * rd0;
    statement_100:;
    }
    /// C*******        rearrange according decending rd************
    FEM_DO_SAFE(i2, 1, kp - 1) {
      FEM_DO_SAFE(j2, i2 + 1, kp) {
        if (rdp(i2) < rdp(j2)) {
          goto statement_110;
        }
        rd = rdp(i2);
        lq = lqp(i2);
        rdp(i2) = rdp(j2);
        lqp(i2) = lqp(j2);
        rdp(j2) = rd;
        lqp(j2) = lq;
      statement_110:;
      }
    }
    /// C****** find wounded targ which can interact with jet********
    kt = 0;
    FEM_DO_SAFE(i2, 1, ihnt2(3)) {
      if (nft(i2, 5) != 3) {
        goto statement_120;
      }
      dx = yt(1, i2) - yp(1, jp) - bbx;
      dy = yt(2, i2) - yp(2, jp) - bby;
      phi = ulangl(cmn, dx, dy);
      dphi = fem::abs(phi - phip);
      /// C     Uzhi:
      if (dphi >= hipr1(40)) {
        dphi = 2.f * hipr1(40) - dphi;
      }
      if (dphi > hipr1(40) / 2.0f) {
        goto statement_120;
      }
      rd0 = fem::sqrt(dx * dx + dy * dy);
      if (rd0 * fem::sin(dphi) > hipr1(12)) {
        goto statement_120;
      }
      kt++;
      lqt(kt) = i2;
      rdt(kt) = fem::cos(dphi) * rd0;
    statement_120:;
    }
    /// C*******        rearrange according decending rd************
    FEM_DO_SAFE(i2, 1, kt - 1) {
      FEM_DO_SAFE(j2, i2 + 1, kt) {
        if (rdt(i2) < rdt(j2)) {
          goto statement_130;
        }
        rd = rdt(i2);
        lq = lqt(i2);
        rdt(i2) = rdt(j2);
        lqt(i2) = lqt(j2);
        rdt(j2) = rd;
        lqt(j2) = lq;
      statement_130:;
      }
    }
    /// C
    mp = 0;
    mt = 0;
    r0 = 0.0f;
    nq = 0;
    dp = 0.0f;
    ptot = fem::sqrt(fem::pow2(pjpx(jp, i)) + fem::pow2(pjpy(jp, i)) +
                     fem::pow2(pjpz(jp, i)));
    v1 = pjpx(jp, i) / ptot;
    v2 = pjpy(jp, i) / ptot;
    v3 = pjpz(jp, i) / ptot;
  /// C
  statement_200:
    rn = ranart(nseed);
  statement_210:
    if (mt >= kt && mp >= kp) {
      goto statement_290;
    }
    if (mt >= kt) {
      goto statement_220;
    }
    if (mp >= kp) {
      goto statement_240;
    }
    if (rdp(mp + 1) > rdt(mt + 1)) {
      goto statement_240;
    }
  statement_220:
    mp++;
    drr = rdp(mp) - r0;
    if (rn >= 1.0f - fem::exp(-drr / hipr1(13))) {
      goto statement_210;
    }
    dp = drr * hipr1(14);
    if (kfpj(jp, i) != 21) {
      dp = 0.5f * dp;
    }
    /// C        ********string tension of quark jet is 0.5 of gluon's
    if (dp <= 0.2f) {
      goto statement_210;
    }
    if (ptot <= 0.4f) {
      goto statement_290;
    }
    if (ptot <= dp) {
      dp = ptot - 0.2f;
    }
    de = dp;
    /// C
    if (kfpj(jp, i) != 21) {
      prshu = fem::pow2(pp(lqp(mp), 1)) + fem::pow2(pp(lqp(mp), 2)) +
              fem::pow2(pp(lqp(mp), 3));
      de = fem::sqrt(fem::pow2(pjpm(jp, i)) + fem::pow2(ptot)) -
           fem::sqrt(fem::pow2(pjpm(jp, i)) + fem::pow2((ptot - dp)));
      ershu = fem::pow2((pp(lqp(mp), 4) + de - dp));
      amshu = ershu - prshu;
      if (amshu < hipr1(1) * hipr1(1)) {
        goto statement_210;
      }
      pp(lqp(mp), 4) = fem::sqrt(ershu);
      pp(lqp(mp), 5) = fem::sqrt(amshu);
    }
    /// C                ********reshuffle the energy when jet has mass
    r0 = rdp(mp);
    dp1 = dp * v1;
    dp2 = dp * v2;
    dp3 = dp * v3;
    /// C                ********momentum and energy transfer from jet
    /// C
    npj(lqp(mp))++;
    kfpj(lqp(mp), npj(lqp(mp))) = 21;
    pjpx(lqp(mp), npj(lqp(mp))) = dp1;
    pjpy(lqp(mp), npj(lqp(mp))) = dp2;
    pjpz(lqp(mp), npj(lqp(mp))) = dp3;
    pjpe(lqp(mp), npj(lqp(mp))) = dp;
    pjpm(lqp(mp), npj(lqp(mp))) = 0.0f;
    goto statement_260;
  /// C
  statement_240:
    mt++;
    drr = rdt(mt) - r0;
    if (rn >= 1.0f - fem::exp(-drr / hipr1(13))) {
      goto statement_210;
    }
    dp = drr * hipr1(14);
    if (dp <= 0.2f) {
      goto statement_210;
    }
    if (ptot <= 0.4f) {
      goto statement_290;
    }
    if (ptot <= dp) {
      dp = ptot - 0.2f;
    }
    de = dp;
    /// C
    if (kfpj(jp, i) != 21) {
      prshu = fem::pow2(pt(lqt(mt), 1)) + fem::pow2(pt(lqt(mt), 2)) +
              fem::pow2(pt(lqt(mt), 3));
      de = fem::sqrt(fem::pow2(pjpm(jp, i)) + fem::pow2(ptot)) -
           fem::sqrt(fem::pow2(pjpm(jp, i)) + fem::pow2((ptot - dp)));
      ershu = fem::pow2((pt(lqt(mt), 4) + de - dp));
      amshu = ershu - prshu;
      if (amshu < hipr1(1) * hipr1(1)) {
        goto statement_210;
      }
      pt(lqt(mt), 4) = fem::sqrt(ershu);
      pt(lqt(mt), 5) = fem::sqrt(amshu);
    }
    /// C                ********reshuffle the energy when jet has mass
    /// C
    r0 = rdt(mt);
    dp1 = dp * v1;
    dp2 = dp * v2;
    dp3 = dp * v3;
    /// C                ********momentum and energy transfer from jet
    ntj(lqt(mt))++;
    kftj(lqt(mt), ntj(lqt(mt))) = 21;
    pjtx(lqt(mt), ntj(lqt(mt))) = dp1;
    pjty(lqt(mt), ntj(lqt(mt))) = dp2;
    pjtz(lqt(mt), ntj(lqt(mt))) = dp3;
    pjte(lqt(mt), ntj(lqt(mt))) = dp;
    pjtm(lqt(mt), ntj(lqt(mt))) = 0.0f;
  /// C
  statement_260:
    pjpx(jp, i) = (ptot - dp) * v1;
    pjpy(jp, i) = (ptot - dp) * v2;
    pjpz(jp, i) = (ptot - dp) * v3;
    pjpe(jp, i) = pjpe(jp, i) - de;
    /// C
    ptot = ptot - dp;
    nq++;
    goto statement_200;
  statement_290:;
  }
  /// C
  return;
/// C
/// C*******************************************************
/// C Jet interaction for target jet in the direction PHIT
/// C******************************************************
/// C
/// C******* find the wounded proj which can interact with jet***
/// C
statement_400:
  if (nft(jpjt, 7) != 1) {
    return;
  }
  jt = jpjt;
  FEM_DO_SAFE(i, 1, ntj(jt)) {
    ptjet0 = fem::sqrt(fem::pow2(pjtx(jt, i)) + fem::pow2(pjty(jt, i)));
    if (ptjet0 <= hipr1(11)) {
      goto statement_690;
    }
    ptot = fem::sqrt(ptjet0 * ptjet0 + fem::pow2(pjtz(jt, i)));
    if (ptot < hipr1(8)) {
      goto statement_690;
    }
    phit = ulangl(cmn, pjtx(jt, i), pjty(jt, i));
    kp = 0;
    FEM_DO_SAFE(i2, 1, ihnt2(1)) {
      if (nfp(i2, 5) != 3) {
        goto statement_500;
      }
      dx = yp(1, i2) + bbx - yt(1, jt);
      dy = yp(2, i2) + bby - yt(2, jt);
      phi = ulangl(cmn, dx, dy);
      dphi = fem::abs(phi - phit);
      /// C     Uzhi:
      if (dphi >= hipr1(40)) {
        dphi = 2.f * hipr1(40) - dphi;
      }
      if (dphi > hipr1(40) / 2.0f) {
        goto statement_500;
      }
      rd0 = fem::sqrt(dx * dx + dy * dy);
      if (rd0 * fem::sin(dphi) > hipr1(12)) {
        goto statement_500;
      }
      kp++;
      lqp(kp) = i2;
      rdp(kp) = fem::cos(dphi) * rd0;
    statement_500:;
    }
    /// C*******        rearrange according to decending rd************
    FEM_DO_SAFE(i2, 1, kp - 1) {
      FEM_DO_SAFE(j2, i2 + 1, kp) {
        if (rdp(i2) < rdp(j2)) {
          goto statement_510;
        }
        rd = rdp(i2);
        lq = lqp(i2);
        rdp(i2) = rdp(j2);
        lqp(i2) = lqp(j2);
        rdp(j2) = rd;
        lqp(j2) = lq;
      statement_510:;
      }
    }
    /// C****** find wounded targ which can interact with jet********
    kt = 0;
    FEM_DO_SAFE(i2, 1, ihnt2(3)) {
      if (nft(i2, 5) != 3 || i2 == jt) {
        goto statement_520;
      }
      dx = yt(1, i2) - yt(1, jt);
      dy = yt(2, i2) - yt(2, jt);
      phi = ulangl(cmn, dx, dy);
      dphi = fem::abs(phi - phit);
      /// C     Uzhi:
      if (dphi >= hipr1(40)) {
        dphi = 2.f * hipr1(40) - dphi;
      }
      if (dphi > hipr1(40) / 2.0f) {
        goto statement_520;
      }
      rd0 = fem::sqrt(dx * dx + dy * dy);
      if (rd0 * fem::sin(dphi) > hipr1(12)) {
        goto statement_520;
      }
      kt++;
      lqt(kt) = i2;
      rdt(kt) = fem::cos(dphi) * rd0;
    statement_520:;
    }
    /// C*******        rearrange according to decending rd************
    FEM_DO_SAFE(i2, 1, kt - 1) {
      FEM_DO_SAFE(j2, i2 + 1, kt) {
        if (rdt(i2) < rdt(j2)) {
          goto statement_530;
        }
        rd = rdt(i2);
        lq = lqt(i2);
        rdt(i2) = rdt(j2);
        lqt(i2) = lqt(j2);
        rdt(j2) = rd;
        lqt(j2) = lq;
      statement_530:;
      }
    }
    /// C
    mp = 0;
    mt = 0;
    nq = 0;
    dp = 0.0f;
    r0 = 0.0f;
    ptot = fem::sqrt(fem::pow2(pjtx(jt, i)) + fem::pow2(pjty(jt, i)) +
                     fem::pow2(pjtz(jt, i)));
    v1 = pjtx(jt, i) / ptot;
    v2 = pjty(jt, i) / ptot;
    v3 = pjtz(jt, i) / ptot;
  /// C
  statement_600:
    rn = ranart(nseed);
  statement_610:
    if (mt >= kt && mp >= kp) {
      goto statement_690;
    }
    if (mt >= kt) {
      goto statement_620;
    }
    if (mp >= kp) {
      goto statement_640;
    }
    if (rdp(mp + 1) > rdt(mt + 1)) {
      goto statement_640;
    }
  statement_620:
    mp++;
    drr = rdp(mp) - r0;
    if (rn >= 1.0f - fem::exp(-drr / hipr1(13))) {
      goto statement_610;
    }
    dp = drr * hipr1(14);
    if (kftj(jt, i) != 21) {
      dp = 0.5f * dp;
    }
    /// C        ********string tension of quark jet is 0.5 of gluon's
    if (dp <= 0.2f) {
      goto statement_610;
    }
    if (ptot <= 0.4f) {
      goto statement_690;
    }
    if (ptot <= dp) {
      dp = ptot - 0.2f;
    }
    de = dp;
    /// C
    if (kftj(jt, i) != 21) {
      prshu = fem::pow2(pp(lqp(mp), 1)) + fem::pow2(pp(lqp(mp), 2)) +
              fem::pow2(pp(lqp(mp), 3));
      de = fem::sqrt(fem::pow2(pjtm(jt, i)) + fem::pow2(ptot)) -
           fem::sqrt(fem::pow2(pjtm(jt, i)) + fem::pow2((ptot - dp)));
      ershu = fem::pow2((pp(lqp(mp), 4) + de - dp));
      amshu = ershu - prshu;
      if (amshu < hipr1(1) * hipr1(1)) {
        goto statement_610;
      }
      pp(lqp(mp), 4) = fem::sqrt(ershu);
      pp(lqp(mp), 5) = fem::sqrt(amshu);
    }
    /// C                ********reshuffle the energy when jet has mass
    /// C
    r0 = rdp(mp);
    dp1 = dp * v1;
    dp2 = dp * v2;
    dp3 = dp * v3;
    /// C                ********momentum and energy transfer from jet
    npj(lqp(mp))++;
    kfpj(lqp(mp), npj(lqp(mp))) = 21;
    pjpx(lqp(mp), npj(lqp(mp))) = dp1;
    pjpy(lqp(mp), npj(lqp(mp))) = dp2;
    pjpz(lqp(mp), npj(lqp(mp))) = dp3;
    pjpe(lqp(mp), npj(lqp(mp))) = dp;
    pjpm(lqp(mp), npj(lqp(mp))) = 0.0f;
    /// C
    goto statement_660;
  /// C
  statement_640:
    mt++;
    drr = rdt(mt) - r0;
    if (rn >= 1.0f - fem::exp(-drr / hipr1(13))) {
      goto statement_610;
    }
    dp = drr * hipr1(14);
    if (dp <= 0.2f) {
      goto statement_610;
    }
    if (ptot <= 0.4f) {
      goto statement_690;
    }
    if (ptot <= dp) {
      dp = ptot - 0.2f;
    }
    de = dp;
    /// C
    if (kftj(jt, i) != 21) {
      prshu = fem::pow2(pt(lqt(mt), 1)) + fem::pow2(pt(lqt(mt), 2)) +
              fem::pow2(pt(lqt(mt), 3));
      de = fem::sqrt(fem::pow2(pjtm(jt, i)) + fem::pow2(ptot)) -
           fem::sqrt(fem::pow2(pjtm(jt, i)) + fem::pow2((ptot - dp)));
      ershu = fem::pow2((pt(lqt(mt), 4) + de - dp));
      amshu = ershu - prshu;
      if (amshu < hipr1(1) * hipr1(1)) {
        goto statement_610;
      }
      pt(lqt(mt), 4) = fem::sqrt(ershu);
      pt(lqt(mt), 5) = fem::sqrt(amshu);
    }
    /// C                ********reshuffle the energy when jet has mass
    /// C
    r0 = rdt(mt);
    dp1 = dp * v1;
    dp2 = dp * v2;
    dp3 = dp * v3;
    /// C                ********momentum and energy transfer from jet
    ntj(lqt(mt))++;
    kftj(lqt(mt), ntj(lqt(mt))) = 21;
    pjtx(lqt(mt), ntj(lqt(mt))) = dp1;
    pjty(lqt(mt), ntj(lqt(mt))) = dp2;
    pjtz(lqt(mt), ntj(lqt(mt))) = dp3;
    pjte(lqt(mt), ntj(lqt(mt))) = dp;
    pjtm(lqt(mt), ntj(lqt(mt))) = 0.0f;
  /// C
  statement_660:
    pjtx(jt, i) = (ptot - dp) * v1;
    pjty(jt, i) = (ptot - dp) * v2;
    pjtz(jt, i) = (ptot - dp) * v3;
    pjte(jt, i) = pjte(jt, i) - de;
    /// C
    ptot = ptot - dp;
    nq++;
    goto statement_600;
  statement_690:;
  }
  return;
/// C********************************************************
/// C        Q-QBAR jet interaction
/// C********************************************************
statement_2000:
  isg = jpjt;
  if (iasg(isg, 3) != 1) {
    return;
  }
  /// C
  jp = iasg(isg, 1);
  jt = iasg(isg, 2);
  xj = (yp(1, jp) + bbx + yt(1, jt)) / 2.0f;
  yj = (yp(2, jp) + bby + yt(2, jt)) / 2.0f;
  FEM_DO_SAFE(i, 1, njsg(isg)) {
    ptjet0 = fem::sqrt(fem::pow2(pxsg(isg, i)) + fem::pow2(pysg(isg, i)));
    if (ptjet0 <= hipr1(11) || pesg(isg, i) < hipr1(1)) {
      goto statement_2690;
    }
    ptot = fem::sqrt(ptjet0 * ptjet0 + fem::pow2(pzsg(isg, i)));
    if (ptot < fem::max(hipr1(1), hipr1(8))) {
      goto statement_2690;
    }
    phiq = ulangl(cmn, pxsg(isg, i), pysg(isg, i));
    kp = 0;
    FEM_DO_SAFE(i2, 1, ihnt2(1)) {
      if (nfp(i2, 5) != 3 || i2 == jp) {
        goto statement_2500;
      }
      dx = yp(1, i2) + bbx - xj;
      dy = yp(2, i2) + bby - yj;
      phi = ulangl(cmn, dx, dy);
      dphi = fem::abs(phi - phiq);
      /// C     Uzhi:
      if (dphi >= hipr1(40)) {
        dphi = 2.f * hipr1(40) - dphi;
      }
      if (dphi > hipr1(40) / 2.0f) {
        goto statement_2500;
      }
      rd0 = fem::sqrt(dx * dx + dy * dy);
      if (rd0 * fem::sin(dphi) > hipr1(12)) {
        goto statement_2500;
      }
      kp++;
      lqp(kp) = i2;
      rdp(kp) = fem::cos(dphi) * rd0;
    statement_2500:;
    }
    /// C*******        rearrange according to decending rd************
    FEM_DO_SAFE(i2, 1, kp - 1) {
      FEM_DO_SAFE(j2, i2 + 1, kp) {
        if (rdp(i2) < rdp(j2)) {
          goto statement_2510;
        }
        rd = rdp(i2);
        lq = lqp(i2);
        rdp(i2) = rdp(j2);
        lqp(i2) = lqp(j2);
        rdp(j2) = rd;
        lqp(j2) = lq;
      statement_2510:;
      }
    }
    /// C****** find wounded targ which can interact with jet********
    kt = 0;
    FEM_DO_SAFE(i2, 1, ihnt2(3)) {
      if (nft(i2, 5) != 3 || i2 == jt) {
        goto statement_2520;
      }
      dx = yt(1, i2) - xj;
      dy = yt(2, i2) - yj;
      phi = ulangl(cmn, dx, dy);
      dphi = fem::abs(phi - phiq);
      /// C     Uzhi:
      if (dphi >= hipr1(40)) {
        dphi = 2.f * hipr1(40) - dphi;
      }
      if (dphi > hipr1(40) / 2.0f) {
        goto statement_2520;
      }
      rd0 = fem::sqrt(dx * dx + dy * dy);
      if (rd0 * fem::sin(dphi) > hipr1(12)) {
        goto statement_2520;
      }
      kt++;
      lqt(kt) = i2;
      rdt(kt) = fem::cos(dphi) * rd0;
    statement_2520:;
    }
    /// C*******        rearrange according to decending rd************
    FEM_DO_SAFE(i2, 1, kt - 1) {
      FEM_DO_SAFE(j2, i2 + 1, kt) {
        if (rdt(i2) < rdt(j2)) {
          goto statement_2530;
        }
        rd = rdt(i2);
        lq = lqt(i2);
        rdt(i2) = rdt(j2);
        lqt(i2) = lqt(j2);
        rdt(j2) = rd;
        lqt(j2) = lq;
      statement_2530:;
      }
    }
    /// C
    mp = 0;
    mt = 0;
    nq = 0;
    dp = 0.0f;
    r0 = 0.0f;
    ptot = fem::sqrt(fem::pow2(pxsg(isg, i)) + fem::pow2(pysg(isg, i)) +
                     fem::pow2(pzsg(isg, i)));
    v1 = pxsg(isg, i) / ptot;
    v2 = pysg(isg, i) / ptot;
    v3 = pzsg(isg, i) / ptot;
  /// C
  statement_2600:
    rn = ranart(nseed);
  statement_2610:
    if (mt >= kt && mp >= kp) {
      goto statement_2690;
    }
    if (mt >= kt) {
      goto statement_2620;
    }
    if (mp >= kp) {
      goto statement_2640;
    }
    if (rdp(mp + 1) > rdt(mt + 1)) {
      goto statement_2640;
    }
  statement_2620:
    mp++;
    drr = rdp(mp) - r0;
    if (rn >= 1.0f - fem::exp(-drr / hipr1(13))) {
      goto statement_2610;
    }
    dp = drr * hipr1(14) / 2.0f;
    if (dp <= 0.2f) {
      goto statement_2610;
    }
    if (ptot <= 0.4f) {
      goto statement_2690;
    }
    if (ptot <= dp) {
      dp = ptot - 0.2f;
    }
    de = dp;
    /// C
    if (k2sg(isg, i) != 21) {
      if (ptot < dp + hipr1(1)) {
        goto statement_2690;
      }
      prshu = fem::pow2(pp(lqp(mp), 1)) + fem::pow2(pp(lqp(mp), 2)) +
              fem::pow2(pp(lqp(mp), 3));
      de = fem::sqrt(fem::pow2(pmsg(isg, i)) + fem::pow2(ptot)) -
           fem::sqrt(fem::pow2(pmsg(isg, i)) + fem::pow2((ptot - dp)));
      ershu = fem::pow2((pp(lqp(mp), 4) + de - dp));
      amshu = ershu - prshu;
      if (amshu < hipr1(1) * hipr1(1)) {
        goto statement_2610;
      }
      pp(lqp(mp), 4) = fem::sqrt(ershu);
      pp(lqp(mp), 5) = fem::sqrt(amshu);
    }
    /// C                ********reshuffle the energy when jet has mass
    /// C
    r0 = rdp(mp);
    dp1 = dp * v1;
    dp2 = dp * v2;
    dp3 = dp * v3;
    /// C                ********momentum and energy transfer from jet
    npj(lqp(mp))++;
    kfpj(lqp(mp), npj(lqp(mp))) = 21;
    pjpx(lqp(mp), npj(lqp(mp))) = dp1;
    pjpy(lqp(mp), npj(lqp(mp))) = dp2;
    pjpz(lqp(mp), npj(lqp(mp))) = dp3;
    pjpe(lqp(mp), npj(lqp(mp))) = dp;
    pjpm(lqp(mp), npj(lqp(mp))) = 0.0f;
    /// C
    goto statement_2660;
  /// C
  statement_2640:
    mt++;
    drr = rdt(mt) - r0;
    if (rn >= 1.0f - fem::exp(-drr / hipr1(13))) {
      goto statement_2610;
    }
    dp = drr * hipr1(14);
    if (dp <= 0.2f) {
      goto statement_2610;
    }
    if (ptot <= 0.4f) {
      goto statement_2690;
    }
    if (ptot <= dp) {
      dp = ptot - 0.2f;
    }
    de = dp;
    /// C
    if (k2sg(isg, i) != 21) {
      if (ptot < dp + hipr1(1)) {
        goto statement_2690;
      }
      prshu = fem::pow2(pt(lqt(mt), 1)) + fem::pow2(pt(lqt(mt), 2)) +
              fem::pow2(pt(lqt(mt), 3));
      de = fem::sqrt(fem::pow2(pmsg(isg, i)) + fem::pow2(ptot)) -
           fem::sqrt(fem::pow2(pmsg(isg, i)) + fem::pow2((ptot - dp)));
      ershu = fem::pow2((pt(lqt(mt), 4) + de - dp));
      amshu = ershu - prshu;
      if (amshu < hipr1(1) * hipr1(1)) {
        goto statement_2610;
      }
      pt(lqt(mt), 4) = fem::sqrt(ershu);
      pt(lqt(mt), 5) = fem::sqrt(amshu);
    }
    /// C               ********reshuffle the energy when jet has mass
    /// C
    r0 = rdt(mt);
    dp1 = dp * v1;
    dp2 = dp * v2;
    dp3 = dp * v3;
    /// C                ********momentum and energy transfer from jet
    ntj(lqt(mt))++;
    kftj(lqt(mt), ntj(lqt(mt))) = 21;
    pjtx(lqt(mt), ntj(lqt(mt))) = dp1;
    pjty(lqt(mt), ntj(lqt(mt))) = dp2;
    pjtz(lqt(mt), ntj(lqt(mt))) = dp3;
    pjte(lqt(mt), ntj(lqt(mt))) = dp;
    pjtm(lqt(mt), ntj(lqt(mt))) = 0.0f;
  /// C
  statement_2660:
    pxsg(isg, i) = (ptot - dp) * v1;
    pysg(isg, i) = (ptot - dp) * v2;
    pzsg(isg, i) = (ptot - dp) * v3;
    pesg(isg, i) = pesg(isg, i) - de;
    /// C
    ptot = ptot - dp;
    nq++;
    goto statement_2600;
  statement_2690:;
  }
}

struct ar3jet_save {
  float a;
  float c;
  float d;
  float exp1;
  float exp3;
  float fg;
  int neg;
  int ntry;
  float sm1;
  float sm3;
  float x2;
  float xt2;
  float xt2m;
  float y;
  float yma;
  float ymax;

  ar3jet_save()
      : a(fem::float0),
        c(fem::float0),
        d(fem::float0),
        exp1(fem::float0),
        exp3(fem::float0),
        fg(fem::float0),
        neg(fem::int0),
        ntry(fem::int0),
        sm1(fem::float0),
        sm3(fem::float0),
        x2(fem::float0),
        xt2(fem::float0),
        xt2m(fem::float0),
        y(fem::float0),
        yma(fem::float0),
        ymax(fem::float0) {}
};

void ar3jet(common& cmn, float const& s, float& x1, float& x3, int const& jl) {
  FEM_CMN_SVE(ar3jet);
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_cref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  int& nseed = cmn.nseed;
  ///
  float& a = sve.a;
  float& c = sve.c;
  float& d = sve.d;
  float& exp1 = sve.exp1;
  float& exp3 = sve.exp3;
  float& fg = sve.fg;
  int& neg = sve.neg;
  int& ntry = sve.ntry;
  float& sm1 = sve.sm1;
  float& sm3 = sve.sm3;
  float& x2 = sve.x2;
  float& xt2 = sve.xt2;
  float& xt2m = sve.xt2m;
  float& y = sve.y;
  float& yma = sve.yma;
  float& ymax = sve.ymax;
  /// C
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /RNDF77/
  /// C
  c = 1.f / 3.f;
  if (k(jl, 2) != 21 && k(jl + 1, 2) != 21) {
    c = 8.f / 27.f;
  }
  exp1 = 3;
  exp3 = 3;
  if (k(jl, 2) != 21) {
    exp1 = 2;
  }
  if (k(jl + 1, 2) != 21) {
    exp3 = 2;
  }
  a = fem::pow2(0.24f) / s;
  yma = fem::alog(.5f / fem::sqrt(a) + fem::sqrt(.25f / a - 1));
  d = 4.f * c * yma;
  sm1 = fem::pow2(p(jl, 5)) / s;
  sm3 = fem::pow2(p(jl + 1, 5)) / s;
  xt2m = (1.f - 2.f * fem::sqrt(sm1) + sm1 - sm3) *
         (1.f - 2.f * fem::sqrt(sm3) - sm1 + sm3);
  xt2m = fem::min(.25f, xt2m);
  ntry = 0;
statement_1:
  if (ntry == 5000) {
    x1 = .5f * (2.f * fem::sqrt(sm1) + 1.f + sm1 - sm3);
    x3 = .5f * (2.f * fem::sqrt(sm3) + 1.f - sm1 + sm3);
    return;
  }
  ntry++;
  /// C
  xt2 = a * fem::pow((xt2m / a), (fem::pow(ranart(nseed), (1.f / d))));
  /// C
  ymax = fem::alog(.5f / fem::sqrt(xt2) + fem::sqrt(.25f / xt2 - 1.f));
  y = (2.f * ranart(nseed) - 1.f) * ymax;
  x1 = 1.f - fem::sqrt(xt2) * fem::exp(y);
  x3 = 1.f - fem::sqrt(xt2) * fem::exp(-y);
  x2 = 2.f - x1 - x3;
  neg = 0;
  if (k(jl, 2) != 21 || k(jl + 1, 2) != 21) {
    if ((1.f - x1) * (1.f - x2) * (1.f - x3) - x2 * sm1 * (1.f - x1) -
                x2 * sm3 * (1.f - x3) <=
            0.f ||
        x1 <= 2.f * fem::sqrt(sm1) - sm1 + sm3 ||
        x3 <= 2.f * fem::sqrt(sm3) - sm3 + sm1) {
      neg = 1;
    }
    x1 += sm1 - sm3;
    x3 = x3 - sm1 + sm3;
  }
  if (neg == 1) {
    goto statement_1;
  }
  /// C
  fg = 2.f * ymax * c * (fem::pow(x1, exp1) + fem::pow(x3, exp3)) / d;
  xt2m = xt2;
  if (fg < ranart(nseed)) {
    goto statement_1;
  }
  /// C
}

struct arorie_save {
  float bet;
  float cbet;
  float del;
  float e1;
  float e3;
  float p1;
  float p3;
  float psi;
  float pt1;
  float pt3;
  float pz1;
  float pz3;
  float w;
  float x2;

  arorie_save()
      : bet(fem::float0),
        cbet(fem::float0),
        del(fem::float0),
        e1(fem::float0),
        e3(fem::float0),
        p1(fem::float0),
        p3(fem::float0),
        psi(fem::float0),
        pt1(fem::float0),
        pt3(fem::float0),
        pz1(fem::float0),
        pz3(fem::float0),
        w(fem::float0),
        x2(fem::float0) {}
};

/// C*************************************************************
/// C
void arorie(common& cmn, float const& s, float const& x1, float const& x3,
            int const& jl) {
  FEM_CMN_SVE(arorie);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  /// COMMON lujets
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  ///
  /// SAVE
  float& bet = sve.bet;
  float& cbet = sve.cbet;
  float& del = sve.del;
  float& e1 = sve.e1;
  float& e3 = sve.e3;
  float& p1 = sve.p1;
  float& p3 = sve.p3;
  float& psi = sve.psi;
  float& pt1 = sve.pt1;
  float& pt3 = sve.pt3;
  float& pz1 = sve.pz1;
  float& pz3 = sve.pz3;
  float& w = sve.w;
  float& x2 = sve.x2;
  ///
  /// C
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /RNDF77/
  /// C
  w = fem::sqrt(s);
  x2 = 2.f - x1 - x3;
  e1 = .5f * x1 * w;
  e3 = .5f * x3 * w;
  p1 = fem::sqrt(fem::pow2(e1) - fem::pow2(p(jl, 5)));
  p3 = fem::sqrt(fem::pow2(e3) - fem::pow2(p(jl + 1, 5)));
  cbet = 1.f;
  if (p1 > 0.f && p3 > 0.f) {
    cbet = (fem::pow2(p(jl, 5)) + fem::pow2(p(jl + 1, 5)) + 2.f * e1 * e3 -
            s * (1.f - x2)) /
           (2.f * p1 * p3);
  }
  if (fem::abs(cbet) > 1.0f) {
    cbet = fem::max(-1.f, fem::min(1.f, cbet));
  }
  bet = fem::acos(cbet);
  /// C
  /// C.....MINIMIZE PT1-SQUARED PLUS PT3-SQUARED.....
  if (p1 >= p3) {
    psi = .5f * ulangl(cmn, fem::pow2(p1) + fem::pow2(p3) * fem::cos(2.f * bet),
                       -fem::pow2(p3) * fem::sin(2.f * bet));
    pt1 = p1 * fem::sin(psi);
    pz1 = p1 * fem::cos(psi);
    pt3 = p3 * fem::sin(psi + bet);
    pz3 = p3 * fem::cos(psi + bet);
  } else if (p3 > p1) {
    psi = .5f * ulangl(cmn, fem::pow2(p3) + fem::pow2(p1) * fem::cos(2.f * bet),
                       -fem::pow2(p1) * fem::sin(2.f * bet));
    pt1 = p1 * fem::sin(bet + psi);
    pz1 = -p1 * fem::cos(bet + psi);
    pt3 = p3 * fem::sin(psi);
    pz3 = -p3 * fem::cos(psi);
  }
  /// C
  del = 2.0f * hipr1(40) * ranart(cmn.nseed);
  p(jl, 4) = e1;
  p(jl, 1) = pt1 * fem::sin(del);
  p(jl, 2) = -pt1 * fem::cos(del);
  p(jl, 3) = pz1;
  p(jl + 2, 4) = e3;
  p(jl + 2, 1) = pt3 * fem::sin(del);
  p(jl + 2, 2) = -pt3 * fem::cos(del);
  p(jl + 2, 3) = pz3;
  p(jl + 1, 4) = w - e1 - e3;
  p(jl + 1, 1) = -p(jl, 1) - p(jl + 2, 1);
  p(jl + 1, 2) = -p(jl, 2) - p(jl + 2, 2);
  p(jl + 1, 3) = -p(jl, 3) - p(jl + 2, 3);
}

struct atrobo_save {
  double dbep;
  double dbex;
  double dbey;
  double dbez;
  double dga;
  double dga2;
  double dgabep;
  arr<double> dp;
  int i;
  int j;
  arr<float> pv;
  arr<float, 2> rot;

  atrobo_save()
      : dbep(fem::double0),
        dbex(fem::double0),
        dbey(fem::double0),
        dbez(fem::double0),
        dga(fem::double0),
        dga2(fem::double0),
        dgabep(fem::double0),
        dp(dimension(4), fem::fill0),
        i(fem::int0),
        j(fem::int0),
        pv(dimension(3), fem::fill0),
        rot(dimension(3, 3), fem::fill0) {}
};

/// C
/// C*******************************************************************
/// C        make  boost and rotation to entries from IMIN to IMAX
/// C*******************************************************************
void atrobo(common& cmn, float const& the, float const& phi, float const& bex,
            float const& bey, float const& bez, int const& imin,
            int const& imax, int& ierror) {
  FEM_CMN_SVE(atrobo);
  /// COMMON lujets
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  ///
  /// SAVE
  double& dbep = sve.dbep;
  double& dbex = sve.dbex;
  double& dbey = sve.dbey;
  double& dbez = sve.dbez;
  double& dga = sve.dga;
  double& dga2 = sve.dga2;
  double& dgabep = sve.dgabep;
  arr_ref<double> dp(sve.dp, dimension(4));
  int& i = sve.i;
  int& j = sve.j;
  arr_ref<float> pv(sve.pv, dimension(3));
  arr_ref<float, 2> rot(sve.rot, dimension(3, 3));
  ///
  /// Cc      SAVE /LUJETS/
  ierror = 0;
  /// C
  if (imin <= 0 || imax > n || imin > imax) {
    return;
  }
  /// C
  if (fem::pow2(the) + fem::pow2(phi) > 1e-20f) {
    /// C...ROTATE (TYPICALLY FROM Z AXIS TO DIRECTION THETA,PHI)
    rot(1, 1) = fem::cos(the) * fem::cos(phi);
    rot(1, 2) = -fem::sin(phi);
    rot(1, 3) = fem::sin(the) * fem::cos(phi);
    rot(2, 1) = fem::cos(the) * fem::sin(phi);
    rot(2, 2) = fem::cos(phi);
    rot(2, 3) = fem::sin(the) * fem::sin(phi);
    rot(3, 1) = -fem::sin(the);
    rot(3, 2) = 0.f;
    rot(3, 3) = fem::cos(the);
    FEM_DO_SAFE(i, imin, imax) {
      /// C**************           IF(MOD(K(I,1)/10000,10).GE.6) GOTO 120
      FEM_DO_SAFE(j, 1, 3) { pv(j) = p(i, j); }
      FEM_DO_SAFE(j, 1, 3) {
        p(i, j) = rot(j, 1) * pv(1) + rot(j, 2) * pv(2) + rot(j, 3) * pv(3);
      }
    }
  }
  /// C
  if (fem::pow2(bex) + fem::pow2(bey) + fem::pow2(bez) > 1e-20f) {
    /// C...LORENTZ BOOST (TYPICALLY FROM REST TO MOMENTUM/ENERGY=BETA)
    dbex = fem::dble(bex);
    dbey = fem::dble(bey);
    dbez = fem::dble(bez);
    dga2 = 1e0 - fem::pow2(dbex) - fem::pow2(dbey) - fem::pow2(dbez);
    if (dga2 <= 0e0) {
      ierror = 1;
      return;
    }
    dga = 1e0 / fem::dsqrt(dga2);
    FEM_DO_SAFE(i, imin, imax) {
      /// C*************           IF(MOD(K(I,1)/10000,10).GE.6) GOTO 140
      FEM_DO_SAFE(j, 1, 4) { dp(j) = fem::dble(p(i, j)); }
      dbep = dbex * dp(1) + dbey * dp(2) + dbez * dp(3);
      dgabep = dga * (dga * dbep / (1e0 + dga) + dp(4));
      p(i, 1) = fem::sngl(dp(1) + dgabep * dbex);
      p(i, 2) = fem::sngl(dp(2) + dgabep * dbey);
      p(i, 3) = fem::sngl(dp(3) + dgabep * dbez);
      p(i, 4) = fem::sngl(dga * (dp(4) + dbep));
    }
  }
  /// C
}

struct attrad_save {
  float bex;
  float bey;
  float bez;
  float btt;
  float cth;
  float fmfact;
  int i;
  int imax;
  int imin;
  int j;
  int jl;
  int m;
  float p1;
  float p2;
  float p3;
  float p4;
  float pbt1;
  float pbt2;
  float pbt3;
  float pbt4;
  float phi;
  float ptg;
  float ptg1;
  float ptg2;
  float ptg3;
  float s;
  float sm;
  float theta;
  float wp;
  float x1;
  float x3;

  attrad_save()
      : bex(fem::float0),
        bey(fem::float0),
        bez(fem::float0),
        btt(fem::float0),
        cth(fem::float0),
        fmfact(fem::float0),
        i(fem::int0),
        imax(fem::int0),
        imin(fem::int0),
        j(fem::int0),
        jl(fem::int0),
        m(fem::int0),
        p1(fem::float0),
        p2(fem::float0),
        p3(fem::float0),
        p4(fem::float0),
        pbt1(fem::float0),
        pbt2(fem::float0),
        pbt3(fem::float0),
        pbt4(fem::float0),
        phi(fem::float0),
        ptg(fem::float0),
        ptg1(fem::float0),
        ptg2(fem::float0),
        ptg3(fem::float0),
        s(fem::float0),
        sm(fem::float0),
        theta(fem::float0),
        wp(fem::float0),
        x1(fem::float0),
        x3(fem::float0) {}
};

/// C
/// C****************************************************************
/// C        conduct soft radiation according to dipole approxiamtion
/// C****************************************************************
void attrad(common& cmn, int& ierror) {
  FEM_CMN_SVE(attrad);
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hidat(cmn.hidat, dimension(10));
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  ///
  float& bex = sve.bex;
  float& bey = sve.bey;
  float& bez = sve.bez;
  float& btt = sve.btt;
  float& cth = sve.cth;
  float& fmfact = sve.fmfact;
  int& i = sve.i;
  int& imax = sve.imax;
  int& imin = sve.imin;
  int& j = sve.j;
  int& jl = sve.jl;
  int& m = sve.m;
  float& p1 = sve.p1;
  float& p2 = sve.p2;
  float& p3 = sve.p3;
  float& p4 = sve.p4;
  float& pbt1 = sve.pbt1;
  float& pbt2 = sve.pbt2;
  float& pbt3 = sve.pbt3;
  float& pbt4 = sve.pbt4;
  float& phi = sve.phi;
  float& ptg = sve.ptg;
  float& ptg1 = sve.ptg1;
  float& ptg2 = sve.ptg2;
  float& ptg3 = sve.ptg3;
  float& s = sve.s;
  float& sm = sve.sm;
  float& theta = sve.theta;
  float& wp = sve.wp;
  float& x1 = sve.x1;
  float& x3 = sve.x3;
  /// C
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HIJDAT/
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /RNDF77/
  ierror = 0;
/// C
/// C.....S INVARIANT MASS-SQUARED BETWEEN PARTONS I AND I+1......
/// C.....SM IS THE LARGEST MASS-SQUARED....
/// C
statement_40:
  sm = 0.f;
  jl = 1;
  FEM_DO_SAFE(i, 1, n - 1) {
    s = 2.f * (p(i, 4) * p(i + 1, 4) - p(i, 1) * p(i + 1, 1) -
               p(i, 2) * p(i + 1, 2) - p(i, 3) * p(i + 1, 3)) +
        fem::pow2(p(i, 5)) + fem::pow2(p(i + 1, 5));
    if (s < 0.f) {
      s = 0.f;
    }
    wp = fem::sqrt(s) - 1.5f * (p(i, 5) + p(i + 1, 5));
    if (wp > sm) {
      pbt1 = p(i, 1) + p(i + 1, 1);
      pbt2 = p(i, 2) + p(i + 1, 2);
      pbt3 = p(i, 3) + p(i + 1, 3);
      pbt4 = p(i, 4) + p(i + 1, 4);
      btt = (fem::pow2(pbt1) + fem::pow2(pbt2) + fem::pow2(pbt3)) /
            fem::pow2(pbt4);
      if (btt >= 1.0f - 1.0e-10f) {
        goto statement_30;
      }
      if ((i != 1 || i != n - 1) && (k(i, 2) != 21 && k(i + 1, 2) != 21)) {
        goto statement_30;
      }
      jl = i;
      sm = wp;
    }
  statement_30:;
  }
  s = fem::pow2((sm + 1.5f * (p(jl, 5) + p(jl + 1, 5))));
  if (sm < hipr1(5)) {
    goto statement_2;
  }
  /// C
  /// C.....MAKE PLACE FOR ONE GLUON.....
  if (jl + 1 == n) {
    goto statement_190;
  }
  FEM_DOSTEP(j, n, jl + 2, -1) {
    k(j + 1, 1) = k(j, 1);
    k(j + 1, 2) = k(j, 2);
    FEM_DO_SAFE(m, 1, 5) { p(j + 1, m) = p(j, m); }
  }
statement_190:
  n++;
  /// C
  /// C.....BOOST TO REST SYSTEM FOR PARTICLES JL AND JL+1.....
  p1 = p(jl, 1) + p(jl + 1, 1);
  p2 = p(jl, 2) + p(jl + 1, 2);
  p3 = p(jl, 3) + p(jl + 1, 3);
  p4 = p(jl, 4) + p(jl + 1, 4);
  bex = -p1 / p4;
  bey = -p2 / p4;
  bez = -p3 / p4;
  imin = jl;
  imax = jl + 1;
  atrobo(cmn, 0.f, 0.f, bex, bey, bez, imin, imax, ierror);
  if (ierror != 0) {
    return;
  }
  /// C.....ROTATE TO Z-AXIS....
  cth = p(jl, 3) / fem::sqrt(fem::pow2(p(jl, 4)) - fem::pow2(p(jl, 5)));
  if (fem::abs(cth) > 1.0f) {
    cth = fem::max(-1.f, fem::min(1.f, cth));
  }
  theta = fem::acos(cth);
  phi = ulangl(cmn, p(jl, 1), p(jl, 2));
  atrobo(cmn, 0.f, -phi, 0.f, 0.f, 0.f, imin, imax, ierror);
  atrobo(cmn, -theta, 0.f, 0.f, 0.f, 0.f, imin, imax, ierror);
/// C
/// C.....CREATE ONE GLUON AND ORIENTATE.....
/// C
statement_1:
  ar3jet(cmn, s, x1, x3, jl);
  arorie(cmn, s, x1, x3, jl);
  if (hidat(2) > 0.0f) {
    ptg1 = fem::sqrt(fem::pow2(p(jl, 1)) + fem::pow2(p(jl, 2)));
    ptg2 = fem::sqrt(fem::pow2(p(jl + 1, 1)) + fem::pow2(p(jl + 1, 2)));
    ptg3 = fem::sqrt(fem::pow2(p(jl + 2, 1)) + fem::pow2(p(jl + 2, 2)));
    ptg = fem::max(ptg1, ptg2, ptg3);
    if (ptg > hidat(2)) {
      fmfact = fem::exp(-(fem::pow2(ptg) - fem::pow2(hidat(2))) /
                        fem::pow2(hipr1(2)));
      if (ranart(cmn.nseed) > fmfact) {
        goto statement_1;
      }
    }
  }
  /// C.....ROTATE AND BOOST BACK.....
  imin = jl;
  imax = jl + 2;
  atrobo(cmn, theta, phi, -bex, -bey, -bez, imin, imax, ierror);
  if (ierror != 0) {
    return;
  }
  /// C.....ENUMERATE THE GLUONS.....
  k(jl + 2, 1) = k(jl + 1, 1);
  k(jl + 2, 2) = k(jl + 1, 2);
  k(jl + 2, 3) = k(jl + 1, 3);
  k(jl + 2, 4) = k(jl + 1, 4);
  k(jl + 2, 5) = k(jl + 1, 5);
  p(jl + 2, 5) = p(jl + 1, 5);
  k(jl + 1, 1) = 2;
  k(jl + 1, 2) = 21;
  k(jl + 1, 3) = 0;
  k(jl + 1, 4) = 0;
  k(jl + 1, 5) = 0;
  p(jl + 1, 5) = 0.f;
  /// C----THETA FUNCTION DAMPING OF THE EMITTED GLUONS. FOR HADRON-HADRON.
  /// C----R0=VFR(2)
  /// C              IF(VFR(2).GT.0.) THEN
  /// C              PTG=SQRT(P(JL+1,1)**2+P(JL+1,2)**2)
  /// C              PTGMAX=WSTRI/2.
  /// C              DOPT=SQRT((4.*PAR(71)*VFR(2))/WSTRI)
  /// C              PTOPT=(DOPT*WSTRI)/(2.*VFR(2))
  /// C              IF(PTG.GT.PTOPT) IORDER=IORDER-1
  /// C              IF(PTG.GT.PTOPT) GOTO 1
  /// C              ENDIF
  /// C-----
  if (sm >= hipr1(5)) {
    goto statement_40;
  }
/// C
statement_2:
  k(1, 1) = 2;
  k(1, 3) = 0;
  k(1, 4) = 0;
  k(1, 5) = 0;
  k(n, 1) = 1;
  k(n, 3) = 0;
  k(n, 4) = 0;
  k(n, 5) = 0;
  /// C
}

/// C
/// C*********************************************************************
/// C
void luprep(common& cmn, int const& ip) {
  common_write write(cmn);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  int i1 = fem::int0;
  int mqgst = fem::int0;
  int i = fem::int0;
  int kc = fem::int0;
  int kq = fem::int0;
  int kcs = fem::int0;
  int ia = fem::int0;
  int nstp = fem::int0;
  int j = fem::int0;
  int ib = fem::int0;
  int mrev = fem::int0;
  int ns = fem::int0;
  int nsin = fem::int0;
  float pdm = fem::float0;
  int ic = fem::int0;
  arr_1d<5, double> dps(fem::fill0);
  float pd = fem::float0;
  arr_1d<5, double> dpc(fem::fill0);
  int ic1 = fem::int0;
  int ic2 = fem::int0;
  int nsav = fem::int0;
  float pecm = fem::float0;
  int kc1 = fem::int0;
  int kc2 = fem::int0;
  int kq1 = fem::int0;
  int kq2 = fem::int0;
  int kfln = fem::int0;
  int kfldmp = fem::int0;
  int kfdmp = fem::int0;
  int kflm = fem::int0;
  float pa = fem::float0;
  arr_1d<3, float> ue(fem::fill0);
  float phi = fem::float0;
  int np = fem::int0;
  float ha = fem::float0;
  float hd1 = fem::float0;
  float hd2 = fem::float0;
  float hr = fem::float0;
  float hc = fem::float0;
  float hk1 = fem::float0;
  float hk2 = fem::float0;
  int ir = fem::int0;
  int mcomb = fem::int0;
  int kci = fem::int0;
  float hcr = fem::float0;
  float hb = fem::float0;
  float hd = fem::float0;
  int kfn = fem::int0;
  int kqs = fem::int0;
  /// C
  /// C...Purpose: to rearrange partons along strings, to allow small systems
  /// C...to collapse into one or two particles and to check flavours.
  /// C
  /// C...Rearrange parton shower product listing along strings: begin loop.
  i1 = n;
  FEM_DO_SAFE(mqgst, 1, 2) {
    FEM_DO_SAFE(i, fem::max(1, ip), n) {
      if (k(i, 1) != 3) {
        goto statement_120;
      }
      kc = lucomp(cmn, k(i, 2));
      if (kc == 0) {
        goto statement_120;
      }
      kq = kchg(kc, 2);
      if (kq == 0 || (mqgst == 1 && kq == 2)) {
        goto statement_120;
      }
      /// C
      /// C...Pick up loose string end.
      kcs = 4;
      if (kq * fem::isign(1, k(i, 2)) < 0) {
        kcs = 5;
      }
      ia = i;
      nstp = 0;
    statement_100:
      nstp++;
      if (nstp > 4 * n) {
        luerrm(cmn, 14, "(LUPREP:) caught in infinite loop");
        return;
      }
      /// C
      /// C...Copy undecayed parton.
      if (k(ia, 1) == 3) {
        if (i1 >= mstu(4) - mstu(32) - 5) {
          luerrm(cmn, 11, "(LUPREP:) no more memory left in LUJETS");
          return;
        }
        i1++;
        k(i1, 1) = 2;
        if (nstp >= 2 && fem::iabs(k(ia, 2)) != 21) {
          k(i1, 1) = 1;
        }
        k(i1, 2) = k(ia, 2);
        k(i1, 3) = ia;
        k(i1, 4) = 0;
        k(i1, 5) = 0;
        FEM_DO_SAFE(j, 1, 5) {
          p(i1, j) = p(ia, j);
          v(i1, j) = v(ia, j);
        }
        k(ia, 1) += 10;
        if (k(i1, 1) == 1) {
          goto statement_120;
        }
      }
      /// C
      /// C...Go to next parton in colour space.
      ib = ia;
      if (fem::mod(k(ib, kcs) / fem::pow2(mstu(5)), 2) == 0 &&
          fem::mod(k(ib, kcs), mstu(5)) != 0) {
        ia = fem::mod(k(ib, kcs), mstu(5));
        k(ib, kcs) += fem::pow2(mstu(5));
        mrev = 0;
      } else {
        if (k(ib, kcs) >= 2 * fem::pow2(mstu(5)) ||
            fem::mod(k(ib, kcs) / mstu(5), mstu(5)) == 0) {
          kcs = 9 - kcs;
        }
        ia = fem::mod(k(ib, kcs) / mstu(5), mstu(5));
        k(ib, kcs) += 2 * fem::pow2(mstu(5));
        mrev = 1;
      }
      if (ia <= 0 || ia > n) {
        luerrm(cmn, 12, "(LUPREP:) colour rearrangement failed");
        return;
      }
      if (fem::mod(k(ia, 4) / mstu(5), mstu(5)) == ib ||
          fem::mod(k(ia, 5) / mstu(5), mstu(5)) == ib) {
        if (mrev == 1) {
          kcs = 9 - kcs;
        }
        if (fem::mod(k(ia, kcs) / mstu(5), mstu(5)) != ib) {
          kcs = 9 - kcs;
        }
        k(ia, kcs) += 2 * fem::pow2(mstu(5));
      } else {
        if (mrev == 0) {
          kcs = 9 - kcs;
        }
        if (fem::mod(k(ia, kcs), mstu(5)) != ib) {
          kcs = 9 - kcs;
        }
        k(ia, kcs) += fem::pow2(mstu(5));
      }
      if (ia != i) {
        goto statement_100;
      }
      k(i1, 1) = 1;
    statement_120:;
    }
  }
  n = i1;
  /// C
  /// C...Find lowest-mass colour singlet jet system, OK if above thresh.
  if (mstj(14) <= 0) {
    goto statement_320;
  }
  ns = n;
statement_140:
  nsin = n - ns;
  pdm = 1.f + parj(32);
  ic = 0;
  FEM_DO_SAFE(i, fem::max(1, ip), ns) {
    if (k(i, 1) != 1 && k(i, 1) != 2) {
    } else if (k(i, 1) == 2 && ic == 0) {
      nsin++;
      ic = i;
      FEM_DO_SAFE(j, 1, 4) { dps(j) = fem::dble(p(i, j)); }
      mstj(93) = 1;
      dps(5) = fem::dble(ulmass(cmn, k(i, 2)));
    } else if (k(i, 1) == 2) {
      FEM_DO_SAFE(j, 1, 4) { dps(j) += fem::dble(p(i, j)); }
    } else if (ic != 0 && kchg(lucomp(cmn, k(i, 2)), 2) != 0) {
      FEM_DO_SAFE(j, 1, 4) { dps(j) += fem::dble(p(i, j)); }
      mstj(93) = 1;
      dps(5) += fem::dble(ulmass(cmn, k(i, 2)));
      pd = fem::sngl(
          fem::sqrt(fem::max(0e0, fem::pow2(dps(4)) - fem::pow2(dps(1)) -
                                      fem::pow2(dps(2)) - fem::pow2(dps(3)))) -
          dps(5));
      if (pd < pdm) {
        pdm = pd;
        FEM_DO_SAFE(j, 1, 5) { dpc(j) = dps(j); }
        ic1 = ic;
        ic2 = i;
      }
      ic = 0;
    } else {
      nsin++;
    }
  }
  if (pdm >= parj(32)) {
    goto statement_320;
  }
  /// C
  /// C...Fill small-mass system as cluster.
  nsav = n;
  pecm = fem::sngl(
      fem::sqrt(fem::max(0e0, fem::pow2(dpc(4)) - fem::pow2(dpc(1)) -
                                  fem::pow2(dpc(2)) - fem::pow2(dpc(3)))));
  k(n + 1, 1) = 11;
  k(n + 1, 2) = 91;
  k(n + 1, 3) = ic1;
  k(n + 1, 4) = n + 2;
  k(n + 1, 5) = n + 3;
  p(n + 1, 1) = fem::sngl(dpc(1));
  p(n + 1, 2) = fem::sngl(dpc(2));
  p(n + 1, 3) = fem::sngl(dpc(3));
  p(n + 1, 4) = fem::sngl(dpc(4));
  p(n + 1, 5) = pecm;
  /// C
  /// C...Form two particles from flavours of lowest-mass system, if feasible.
  k(n + 2, 1) = 1;
  k(n + 3, 1) = 1;
  if (mstu(16) != 2) {
    k(n + 2, 3) = n + 1;
    k(n + 3, 3) = n + 1;
  } else {
    k(n + 2, 3) = ic1;
    k(n + 3, 3) = ic2;
  }
  k(n + 2, 4) = 0;
  k(n + 3, 4) = 0;
  k(n + 2, 5) = 0;
  k(n + 3, 5) = 0;
  if (fem::iabs(k(ic1, 2)) != 21) {
    kc1 = lucomp(cmn, k(ic1, 2));
    kc2 = lucomp(cmn, k(ic2, 2));
    if (kc1 == 0 || kc2 == 0) {
      goto statement_320;
    }
    kq1 = kchg(kc1, 2) * fem::isign(1, k(ic1, 2));
    kq2 = kchg(kc2, 2) * fem::isign(1, k(ic2, 2));
    if (kq1 + kq2 != 0) {
      goto statement_320;
    }
  statement_200:
    lukfdi(cmn, k(ic1, 2), 0, kfln, k(n + 2, 2));
    lukfdi(cmn, k(ic2, 2), -kfln, kfldmp, k(n + 3, 2));
    if (k(n + 2, 2) == 0 || k(n + 3, 2) == 0) {
      goto statement_200;
    }
  } else {
    if (fem::iabs(k(ic2, 2)) != 21) {
      goto statement_320;
    }
  statement_210:
    lukfdi(cmn, 1 + fem::fint((2.f + parj(2)) * rlu(cmn, 0)), 0, kfln, kfdmp);
    lukfdi(cmn, kfln, 0, kflm, k(n + 2, 2));
    lukfdi(cmn, -kfln, -kflm, kfldmp, k(n + 3, 2));
    if (k(n + 2, 2) == 0 || k(n + 3, 2) == 0) {
      goto statement_210;
    }
  }
  p(n + 2, 5) = ulmass(cmn, k(n + 2, 2));
  p(n + 3, 5) = ulmass(cmn, k(n + 3, 2));
  if (p(n + 2, 5) + p(n + 3, 5) + parj(64) >= pecm && nsin == 1) {
    goto statement_320;
  }
  if (p(n + 2, 5) + p(n + 3, 5) + parj(64) >= pecm) {
    goto statement_260;
  }
  /// C
  /// C...Perform two-particle decay of jet system, if possible.
  /// Clin-5/2012:
  /// C      IF(PECM.GE.0.02d0*DPC(4)) THEN
  if (fem::dble(pecm) >= 0.02e0 * dpc(4)) {
    pa = fem::sqrt((fem::pow2(pecm) - fem::pow2((p(n + 2, 5) + p(n + 3, 5)))) *
                   (fem::pow2(pecm) - fem::pow2((p(n + 2, 5) - p(n + 3, 5))))) /
         (2.f * pecm);
    ue(3) = 2.f * rlu(cmn, 0) - 1.f;
    phi = paru(2) * rlu(cmn, 0);
    ue(1) = fem::sqrt(1.f - fem::pow2(ue(3))) * fem::cos(phi);
    ue(2) = fem::sqrt(1.f - fem::pow2(ue(3))) * fem::sin(phi);
    FEM_DO_SAFE(j, 1, 3) {
      p(n + 2, j) = pa * ue(j);
      p(n + 3, j) = -pa * ue(j);
    }
    p(n + 2, 4) = fem::sqrt(fem::pow2(pa) + fem::pow2(p(n + 2, 5)));
    p(n + 3, 4) = fem::sqrt(fem::pow2(pa) + fem::pow2(p(n + 3, 5)));
    ludbrb(n + 2, n + 3, 0.f, 0.f, dpc(1) / dpc(4), dpc(2) / dpc(4),
           dpc(3) / dpc(4));
  } else {
    np = 0;
    FEM_DO_SAFE(i, ic1, ic2) {
      if (k(i, 1) == 1 || k(i, 1) == 2) {
        np++;
      }
    }
    ha = p(ic1, 4) * p(ic2, 4) - p(ic1, 1) * p(ic2, 1) - p(ic1, 2) * p(ic2, 2) -
         p(ic1, 3) * p(ic2, 3);
    if (np >= 3 || ha <= 1.25f * p(ic1, 5) * p(ic2, 5)) {
      goto statement_260;
    }
    hd1 = 0.5f * (fem::pow2(p(n + 2, 5)) - fem::pow2(p(ic1, 5)));
    hd2 = 0.5f * (fem::pow2(p(n + 3, 5)) - fem::pow2(p(ic2, 5)));
    hr = fem::sqrt(fem::max(
             0.f, (fem::pow2((ha - hd1 - hd2)) -
                   fem::pow2((p(n + 2, 5) * p(n + 3, 5)))) /
                      (fem::pow2(ha) - fem::pow2((p(ic1, 5) * p(ic2, 5)))))) -
         1.f;
    hc = fem::pow2(p(ic1, 5)) + 2.f * ha + fem::pow2(p(ic2, 5));
    hk1 = ((fem::pow2(p(ic2, 5)) + ha) * hr + hd1 - hd2) / hc;
    hk2 = ((fem::pow2(p(ic1, 5)) + ha) * hr + hd2 - hd1) / hc;
    FEM_DO_SAFE(j, 1, 4) {
      p(n + 2, j) = (1.f + hk1) * p(ic1, j) - hk2 * p(ic2, j);
      p(n + 3, j) = (1.f + hk2) * p(ic2, j) - hk1 * p(ic1, j);
    }
  }
  FEM_DO_SAFE(j, 1, 4) {
    v(n + 1, j) = v(ic1, j);
    v(n + 2, j) = v(ic1, j);
    v(n + 3, j) = v(ic2, j);
  }
  v(n + 1, 5) = 0.f;
  v(n + 2, 5) = 0.f;
  v(n + 3, 5) = 0.f;
  n += 3;
  goto statement_300;
/// C
/// C...Else form one particle from the flavours available, if possible.
statement_260:
  k(n + 1, 5) = n + 2;
  if (fem::iabs(k(ic1, 2)) > 100 && fem::iabs(k(ic2, 2)) > 100) {
    goto statement_320;
  } else if (fem::iabs(k(ic1, 2)) != 21) {
    lukfdi(cmn, k(ic1, 2), k(ic2, 2), kfldmp, k(n + 2, 2));
  } else {
    kfln = 1 + fem::fint((2.f + parj(2)) * rlu(cmn, 0));
    lukfdi(cmn, kfln, -kfln, kfldmp, k(n + 2, 2));
  }
  if (k(n + 2, 2) == 0) {
    goto statement_260;
  }
  p(n + 2, 5) = ulmass(cmn, k(n + 2, 2));
  /// C
  /// C...Find parton/particle which combines to largest extra mass.
  ir = 0;
  ha = 0.f;
  FEM_DO_SAFE(mcomb, 1, 3) {
    if (ir != 0) {
      goto statement_280;
    }
    FEM_DO_SAFE(i, fem::max(1, ip), n) {
      if (k(i, 1) <= 0 || k(i, 1) > 10 ||
          (i >= ic1 && i <= ic2 && k(i, 1) >= 1 && k(i, 1) <= 2)) {
        goto statement_270;
      }
      if (mcomb == 1) {
        kci = lucomp(cmn, k(i, 2));
      }
      if (mcomb == 1 && kci == 0) {
        goto statement_270;
      }
      if (mcomb == 1 && kchg(kci, 2) == 0 && i <= ns) {
        goto statement_270;
      }
      if (mcomb == 2 && fem::iabs(k(i, 2)) > 10 && fem::iabs(k(i, 2)) <= 100) {
        goto statement_270;
      }
      hcr = fem::sngl(dpc(4)) * p(i, 4) - fem::sngl(dpc(1)) * p(i, 1) -
            fem::sngl(dpc(2)) * p(i, 2) - fem::sngl(dpc(3)) * p(i, 3);
      if (hcr > ha) {
        ir = i;
        ha = hcr;
      }
    statement_270:;
    }
  statement_280:;
  }
  /// C
  /// C...Shuffle energy and momentum to put new particle on mass shell.
  hb = fem::pow2(pecm) + ha;
  hc = fem::pow2(p(n + 2, 5)) + ha;
  hd = fem::pow2(p(ir, 5)) + ha;
  /// C******************CHANGES BY HIJING************
  hk2 = 0.0f;
  if (fem::pow2(ha) - fem::pow2((pecm * p(ir, 5))) == 0.0f || hb + hd == 0.0f) {
    goto statement_285;
  }
  /// C******************
  hk2 = 0.5f *
        (hb * fem::sqrt((fem::pow2((hb + hc)) -
                         4.f * (hb + hd) * fem::pow2(p(n + 2, 5))) /
                        (fem::pow2(ha) - fem::pow2((pecm * p(ir, 5))))) -
         (hb + hc)) /
        (hb + hd);
statement_285:
  hk1 = (0.5f * (fem::pow2(p(n + 2, 5)) - fem::pow2(pecm)) + hd * hk2) / hb;
  FEM_DO_SAFE(j, 1, 4) {
    p(n + 2, j) = (1.f + hk1) * fem::sngl(dpc(j)) - hk2 * p(ir, j);
    p(ir, j) = (1.f + hk2) * p(ir, j) - hk1 * fem::sngl(dpc(j));
    v(n + 1, j) = v(ic1, j);
    v(n + 2, j) = v(ic1, j);
  }
  v(n + 1, 5) = 0.f;
  v(n + 2, 5) = 0.f;
  n += 2;
/// C
/// C...Mark collapsed system and store daughter pointers. Iterate.
statement_300:
  FEM_DO_SAFE(i, ic1, ic2) {
    if ((k(i, 1) == 1 || k(i, 1) == 2) && kchg(lucomp(cmn, k(i, 2)), 2) != 0) {
      k(i, 1) += 10;
      if (mstu(16) != 2) {
        k(i, 4) = nsav + 1;
        k(i, 5) = nsav + 1;
      } else {
        k(i, 4) = nsav + 2;
        k(i, 5) = n;
      }
    }
  }
  if (n < mstu(4) - mstu(32) - 5) {
    goto statement_140;
  }
/// C
/// C...Check flavours and invariant masses in parton systems.
statement_320:
  np = 0;
  kfn = 0;
  kqs = 0;
  FEM_DO_SAFE(j, 1, 5) { dps(j) = 0e0; }
  FEM_DO_SAFE(i, fem::max(1, ip), n) {
    if (k(i, 1) <= 0 || k(i, 1) > 10) {
      goto statement_360;
    }
    kc = lucomp(cmn, k(i, 2));
    if (kc == 0) {
      goto statement_360;
    }
    kq = kchg(kc, 2) * fem::isign(1, k(i, 2));
    if (kq == 0) {
      goto statement_360;
    }
    np++;
    if (kq != 2) {
      kfn++;
      kqs += kq;
      mstj(93) = 1;
      dps(5) += fem::dble(ulmass(cmn, k(i, 2)));
    }
    FEM_DO_SAFE(j, 1, 4) { dps(j) += fem::dble(p(i, j)); }
    /// C
    /// Clin-4/12/01:
    /// C     np: # of partons, KFN: number of quarks and diquarks,
    /// C     KC=0 for color singlet system, -1 for quarks and anti-diquarks,
    /// C     1 for quarks and anti-diquarks, and 2 for gluons:
    if (k(i, 1) == 1) {
      /// Clin-4/12/01     end of color singlet system.
      if (np != 1 && (kfn == 1 || kfn >= 3 || kqs != 0)) {
        luerrm(cmn, 2, "(LUPREP:) unphysical flavour combination");
      }
      /// C
      /// Clin-4/16/01: 'jet system' should be defined as np.ne.2:
      /// C        IF(NP.NE.1.AND.DPS(4)**2-DPS(1)**2-DPS(2)**2-DPS(3)**2.LT.
      /// C     &  (0.9*PARJ(32)+DPS(5))**2) CALL LUERRM(3,
      /// C     &  '(LUPREP:) too small mass in jet system')
      if (np != 2 && fem::pow2(dps(4)) - fem::pow2(dps(1)) - fem::pow2(dps(2)) -
                             fem::pow2(dps(3)) <
                         fem::pow2((0.9e0 * fem::dble(parj(32)) + dps(5)))) {
        luerrm(cmn, 3, "(LUPREP:) too small mass in jet system");
        write(6, star), "DPS(1-5),KI1-5=", dps(1), dps(2), dps(3), dps(4),
            dps(5), "*", k(i, 1), k(i, 2), k(i, 3), k(i, 4), k(i, 5);
      }
      /// C
      np = 0;
      kfn = 0;
      kqs = 0;
      FEM_DO_SAFE(j, 1, 5) { dps(j) = 0e0; }
    }
  statement_360:;
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void luptdi(common& cmn, int const& kfl, float& px, float& py) {
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  ///
  /// C
  /// C...Purpose: to generate transverse momentum according to a Gaussian.
  /// C
  /// C...Generate p_T and azimuthal angle, gives p_x and p_y.
  int kfla = fem::iabs(kfl);
  float pt = parj(21) * fem::sqrt(-fem::log(fem::max(1e-10f, rlu(cmn, 0))));
  if (mstj(91) == 1) {
    pt = parj(22) * pt;
  }
  if (kfla == 0 && mstj(13) <= 0) {
    pt = 0.f;
  }
  float phi = paru(2) * rlu(cmn, 0);
  px = pt * fem::cos(phi);
  py = pt * fem::sin(phi);
  /// C
}

/// C
/// C*********************************************************************
/// C
void luzdis(common& cmn, int const& kfl1, int const& kfl2, float const& pr,
            float& z) {
  arr_cref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  ///
  int kfla = fem::int0;
  int kflb = fem::int0;
  int kflh = fem::int0;
  float fa = fem::float0;
  float fb = fem::float0;
  float fc = fem::float0;
  int mc = fem::int0;
  int ma = fem::int0;
  float zmax = fem::float0;
  int mmax = fem::int0;
  float zdiv = fem::float0;
  float fint = fem::float0;
  float zdivc = fem::float0;
  float fscb = fem::float0;
  float fpre = fem::float0;
  float fval = fem::float0;
  /// C
  /// C...Purpose: to generate the longitudinal splitting variable z.
  /// C
  /// C...Check if heavy flavour fragmentation.
  kfla = fem::iabs(kfl1);
  kflb = fem::iabs(kfl2);
  kflh = kfla;
  if (kfla >= 10) {
    kflh = fem::mod(kfla / 1000, 10);
  }
  /// C
  /// C...Lund symmetric scaling function: determine parameters of shape.
  if (mstj(11) == 1 || (mstj(11) == 3 && kflh <= 3)) {
    fa = parj(41);
    if (mstj(91) == 1) {
      fa = parj(43);
    }
    if (kflb >= 10) {
      fa += parj(45);
    }
    fb = parj(42) * pr;
    if (mstj(91) == 1) {
      fb = parj(44) * pr;
    }
    fc = 1.f;
    if (kfla >= 10) {
      fc = fc - parj(45);
    }
    if (kflb >= 10) {
      fc += parj(45);
    }
    mc = 1;
    if (fem::abs(fc - 1.f) > 0.01f) {
      mc = 2;
    }
    /// C
    /// C...Determine position of maximum. Special cases for a = 0 or a = c.
    if (fa < 0.02f) {
      ma = 1;
      zmax = 1.f;
      if (fc > fb) {
        zmax = fb / fc;
      }
    } else if (fem::abs(fc - fa) < 0.01f) {
      ma = 2;
      zmax = fb / (fb + fc);
    } else {
      ma = 3;
      zmax = 0.5f *
             (fb + fc - fem::sqrt(fem::pow2((fb - fc)) + 4.f * fa * fb)) /
             (fc - fa);
      if (zmax > 0.99f && fb > 100.f) {
        zmax = 1.f - fa / fb;
      }
    }
    /// C
    /// C...Subdivide z range if distribution very peaked near endpoint.
    mmax = 2;
    if (zmax < 0.1f) {
      mmax = 1;
      zdiv = 2.75f * zmax;
      if (mc == 1) {
        fint = 1.f - fem::log(zdiv);
      } else {
        zdivc = fem::pow(zdiv, (1.f - fc));
        fint = 1.f + (1.f - 1.f / zdivc) / (fc - 1.f);
      }
    } else if (zmax > 0.85f && fb > 1.f) {
      mmax = 3;
      fscb = fem::sqrt(4.f + fem::pow2((fc / fb)));
      zdiv = fscb - 1.f / zmax -
             (fc / fb) * fem::log(zmax * 0.5f * (fscb + fc / fb));
      if (ma >= 2) {
        zdiv += (fa / fb) * fem::log(1.f - zmax);
      }
      zdiv = fem::min(zmax, fem::max(0.f, zdiv));
      fint = 1.f + fb * (1.f - zdiv);
    }
  /// C
  /// C...Choice of z, preweighted for peaks at low or high z.
  statement_100:
    z = rlu(cmn, 0);
    fpre = 1.f;
    if (mmax == 1) {
      if (fint * rlu(cmn, 0) <= 1.f) {
        z = zdiv * z;
      } else if (mc == 1) {
        z = fem::pow(zdiv, z);
        fpre = zdiv / z;
      } else {
        z = 1.f / fem::pow((zdivc + z * (1.f - zdivc)), (1.f / (1.f - fc)));
        fpre = fem::pow((zdiv / z), fc);
      }
    } else if (mmax == 3) {
      if (fint * rlu(cmn, 0) <= 1.f) {
        z = zdiv + fem::log(z) / fb;
        fpre = fem::exp(fb * (z - zdiv));
      } else {
        z = zdiv + z * (1.f - zdiv);
      }
    }
    /// C
    /// C...Weighting according to correct formula.
    if (z <= fb / (50.f + fb) || z >= 1.f) {
      goto statement_100;
    }
    fval = fem::pow((zmax / z), fc) * fem::exp(fb * (1.f / zmax - 1.f / z));
    if (ma >= 2) {
      fval = fem::pow(((1.f - z) / (1.f - zmax)), fa) * fval;
    }
    if (fval < rlu(cmn, 0) * fpre) {
      goto statement_100;
    }
    /// C
    /// C...Generate z according to Field-Feynman, SLAC, (1-z)**c OR z**c.
  } else {
    fc = parj(50 + fem::max(1, kflh));
    if (mstj(91) == 1) {
      fc = parj(59);
    }
  statement_110:
    z = rlu(cmn, 0);
    if (fc >= 0.f && fc <= 1.f) {
      if (fc > rlu(cmn, 0)) {
        z = 1.f - fem::pow(z, (1.f / 3.f));
      }
    } else if (fc > -1.f) {
      if (-4.f * fc * z * fem::pow2((1.f - z)) <
          rlu(cmn, 0) * fem::pow2((fem::pow2((1.f - z)) - fc * z))) {
        goto statement_110;
      }
    } else {
      if (fc > 0.f) {
        z = 1.f - fem::pow(z, (1.f / fc));
      }
      if (fc < 0.f) {
        z = fem::pow(z, (-1.f / fc));
      }
    }
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void lustrf(common& cmn, int const& ip) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  int i = fem::int0;
  int j = fem::int0;
  arr_2d<5, 5, double> dp(fem::fill0);
  int nsav = fem::int0;
  int np = fem::int0;
  int kqsum = fem::int0;
  arr_1d<5, double> dps(fem::fill0);
  arr_1d<4, int> mju(fem::fill0);
  int kc = fem::int0;
  int kq = fem::int0;
  int ntryr = fem::int0;
  float paru12 = fem::float0;
  float paru13 = fem::float0;
  int nr = fem::int0;
  float pdrmin = fem::float0;
  int i1 = fem::int0;
  float pap = fem::float0;
  float pvp = fem::float0;
  float pdr = fem::float0;
  int ir = fem::int0;
  int nrs = fem::int0;
  int ntry = fem::int0;
  int jt = fem::int0;
  arr_1d<2, int> njs(fem::fill0);
  int js = fem::int0;
  int iu = fem::int0;
  arr_1d<3, int> iju(fem::fill0);
  arr_2d<5, 5, float> pju(fem::fill0);
  float t12 = fem::float0;
  float t13 = fem::float0;
  float t23 = fem::float0;
  float t11 = fem::float0;
  float t22 = fem::float0;
  float tsq = fem::float0;
  float t1f = fem::float0;
  float t2f = fem::float0;
  arr_1d<5, float> tju(fem::fill0);
  int ista = fem::int0;
  int ns = fem::int0;
  int is = fem::int0;
  int is1 = fem::int0;
  int is2 = fem::int0;
  double dhkc = fem::double0;
  double dhks = fem::double0;
  double dhk1 = fem::double0;
  double dhk2 = fem::double0;
  int in1 = fem::int0;
  int isav = fem::int0;
  int irankj = fem::int0;
  arr_1d<2, int> ie(fem::fill0);
  arr_1d<9, int> in(fem::fill0);
  int jq = fem::int0;
  arr_1d<3, int> kfl(fem::fill0);
  arr_1d<3, float> px(fem::fill0);
  arr_1d<3, float> py(fem::fill0);
  arr_1d<3, float> gam(fem::fill0);
  double dhc12 = fem::double0;
  double dhcx1 = fem::double0;
  double dhcx2 = fem::double0;
  double dhcxx = fem::double0;
  double dhcy1 = fem::double0;
  double dhcy2 = fem::double0;
  double dhcyx = fem::double0;
  double dhcyy = fem::double0;
  arr_1d<2, float> pr(fem::fill0);
  float z = fem::float0;
  float pxp = fem::float0;
  float pyp = fem::float0;
  arr_1d<4, double> dhg(fem::fill0);
  int in2 = fem::int0;
  arr_1d<4, double> dhm(fem::fill0);
  double dhc = fem::double0;
  double dhs1 = fem::double0;
  double dhs2 = fem::double0;
  double dhs3 = fem::double0;
  arr_1d<2, int> kfjh(fem::fill0);
  arr_1d<2, int> kfjs(fem::fill0);
  int kfls = fem::int0;
  arr_2d<4, 5, float> pjs(fem::fill0);
  int nb = fem::int0;
  float w2sum = fem::float0;
  float w2ran = fem::float0;
  arr_1d<2, int> irank(fem::fill0);
  arr_1d<3, float> pmq(fem::fill0);
  int kdump = fem::int0;
  float pr3 = fem::float0;
  float zr = fem::float0;
  int in3 = fem::int0;
  int jr = fem::int0;
  float wmin = fem::float0;
  float wrem2 = fem::float0;
  int kfl1a = fem::int0;
  int kfl2a = fem::int0;
  float pw12 = fem::float0;
  int kfldmp = fem::int0;
  double dhr1 = fem::double0;
  double dhr2 = fem::double0;
  float fd = fem::float0;
  float fa = fem::float0;
  float prev = fem::float0;
  float fb = fem::float0;
  int im = fem::int0;
  /// C...Purpose: to handle the fragmentation of an arbitrary colour singlet
  /// C...jet system according to the Lund string fragmentation model.
  /// C
  /// C...Function: four-product of two vectors.
  four(i, j) = p(i, 4) * p(j, 4) - p(i, 1) * p(j, 1) - p(i, 2) * p(j, 2) -
               p(i, 3) * p(j, 3);
  dfour(i, j) = dp(i, 4) * dp(j, 4) - dp(i, 1) * dp(j, 1) -
                dp(i, 2) * dp(j, 2) - dp(i, 3) * dp(j, 3);
  /// C
  /// C...Reset counters. Identify parton system.
  mstj(91) = 0;
  nsav = n;
  np = 0;
  kqsum = 0;
  FEM_DO_SAFE(j, 1, 5) { dps(j) = 0e0; }
  mju(1) = 0;
  mju(2) = 0;
  i = ip - 1;
statement_110:
  i++;
  if (i > fem::min(n, mstu(4) - mstu(32))) {
    luerrm(cmn, 12, "(LUSTRF:) failed to reconstruct jet system");
    if (mstu(21) >= 1) {
      return;
    }
  }
  if (k(i, 1) != 1 && k(i, 1) != 2 && k(i, 1) != 41) {
    goto statement_110;
  }
  kc = lucomp(cmn, k(i, 2));
  if (kc == 0) {
    goto statement_110;
  }
  kq = kchg(kc, 2) * fem::isign(1, k(i, 2));
  if (kq == 0) {
    goto statement_110;
  }
  if (n + 5 * np + 11 > mstu(4) - mstu(32) - 5) {
    luerrm(cmn, 11, "(LUSTRF:) no more memory left in LUJETS");
    if (mstu(21) >= 1) {
      return;
    }
  }
  /// C
  /// C...Take copy of partons to be considered. Check flavour sum.
  np++;
  FEM_DO_SAFE(j, 1, 5) {
    k(n + np, j) = k(i, j);
    p(n + np, j) = p(i, j);
    dps(j) += fem::dble(p(i, j));
  }
  k(n + np, 3) = i;
  if (fem::pow2(p(n + np, 4)) < fem::pow2(p(n + np, 1)) +
                                    fem::pow2(p(n + np, 2)) +
                                    fem::pow2(p(n + np, 3))) {
    p(n + np, 4) = fem::sqrt(fem::pow2(p(n + np, 1)) + fem::pow2(p(n + np, 2)) +
                             fem::pow2(p(n + np, 3)) + fem::pow2(p(n + np, 5)));
    dps(4) += fem::dble(fem::max(0.f, p(n + np, 4) - p(i, 4)));
  }
  if (kq != 2) {
    kqsum += kq;
  }
  if (k(i, 1) == 41) {
    kqsum += 2 * kq;
    if (kqsum == kq) {
      mju(1) = n + np;
    }
    if (kqsum != kq) {
      mju(2) = n + np;
    }
  }
  if (k(i, 1) == 2 || k(i, 1) == 41) {
    goto statement_110;
  }
  if (kqsum != 0) {
    luerrm(cmn, 12, "(LUSTRF:) unphysical flavour combination");
    if (mstu(21) >= 1) {
      return;
    }
  }
  /// C
  /// C...Boost copied system to CM frame (for better numerical precision).
  ludbrb(n + 1, n + np, 0.f, 0.f, -dps(1) / dps(4), -dps(2) / dps(4),
         -dps(3) / dps(4));
  /// C
  /// C...Search for very nearby partons that may be recombined.
  ntryr = 0;
  paru12 = paru(12);
  paru13 = paru(13);
  mju(3) = mju(1);
  mju(4) = mju(2);
  nr = np;
statement_130:
  if (nr >= 3) {
    pdrmin = 2.f * paru12;
    FEM_DO_SAFE(i, n + 1, n + nr) {
      if (i == n + nr && fem::iabs(k(n + 1, 2)) != 21) {
        goto statement_140;
      }
      i1 = i + 1;
      if (i == n + nr) {
        i1 = n + 1;
      }
      if (k(i, 1) == 41 || k(i1, 1) == 41) {
        goto statement_140;
      }
      if (mju(1) != 0 && i1 < mju(1) && fem::iabs(k(i1, 2)) != 21) {
        goto statement_140;
      }
      if (mju(2) != 0 && i > mju(2) && fem::iabs(k(i, 2)) != 21) {
        goto statement_140;
      }
      pap = fem::sqrt(
          (fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) + fem::pow2(p(i, 3))) *
          (fem::pow2(p(i1, 1)) + fem::pow2(p(i1, 2)) + fem::pow2(p(i1, 3))));
      pvp = p(i, 1) * p(i1, 1) + p(i, 2) * p(i1, 2) + p(i, 3) * p(i1, 3);
      pdr = 4.f * fem::pow2((pap - pvp)) /
            (fem::pow2(paru13) * pap + 2.f * (pap - pvp));
      if (pdr < pdrmin) {
        ir = i;
        pdrmin = pdr;
      }
    statement_140:;
    }
    /// C
    /// C...Recombine very nearby partons to avoid machine precision problems.
    if (pdrmin < paru12 && ir == n + nr) {
      FEM_DO_SAFE(j, 1, 4) { p(n + 1, j) += p(n + nr, j); }
      p(n + 1, 5) = fem::sqrt(
          fem::max(0.f, fem::pow2(p(n + 1, 4)) - fem::pow2(p(n + 1, 1)) -
                            fem::pow2(p(n + 1, 2)) - fem::pow2(p(n + 1, 3))));
      nr = nr - 1;
      goto statement_130;
    } else if (pdrmin < paru12) {
      FEM_DO_SAFE(j, 1, 4) { p(ir, j) += p(ir + 1, j); }
      p(ir, 5) = fem::sqrt(
          fem::max(0.f, fem::pow2(p(ir, 4)) - fem::pow2(p(ir, 1)) -
                            fem::pow2(p(ir, 2)) - fem::pow2(p(ir, 3))));
      FEM_DO_SAFE(i, ir + 1, n + nr - 1) {
        k(i, 2) = k(i + 1, 2);
        FEM_DO_SAFE(j, 1, 5) { p(i, j) = p(i + 1, j); }
      }
      if (ir == n + nr - 1) {
        k(ir, 2) = k(n + nr, 2);
      }
      nr = nr - 1;
      if (mju(1) > ir) {
        mju(1) = mju(1) - 1;
      }
      if (mju(2) > ir) {
        mju(2) = mju(2) - 1;
      }
      goto statement_130;
    }
  }
  ntryr++;
  /// C
  /// C...Reset particle counter. Skip ahead if no junctions are present;
  /// C...this is usually the case!
  nrs = fem::max(5 * nr + 11, np);
  ntry = 0;
statement_180:
  ntry++;
  if (ntry > 100 && ntryr <= 4) {
    paru12 = 4.f * paru12;
    paru13 = 2.f * paru13;
    goto statement_130;
  } else if (ntry > 100) {
    luerrm(cmn, 14, "(LUSTRF:) caught in infinite loop");
    if (mstu(21) >= 1) {
      return;
    }
  }
  i = n + nrs;
  if (mju(1) == 0 && mju(2) == 0) {
    goto statement_500;
  }
  FEM_DO_SAFE(jt, 1, 2) {
    njs(jt) = 0;
    if (mju(jt) == 0) {
      goto statement_490;
    }
    js = 3 - 2 * jt;
    /// C
    /// C...Find and sum up momentum on three sides of junction. Check flavours.
    FEM_DO_SAFE(iu, 1, 3) {
      iju(iu) = 0;
      FEM_DO_SAFE(j, 1, 5) { pju(iu, j) = 0.f; }
    }
    iu = 0;
    FEM_DOSTEP(i1, n + 1 + (jt - 1) * (nr - 1), n + nr + (jt - 1) * (1 - nr),
               js) {
      if (k(i1, 2) != 21 && iu <= 2) {
        iu++;
        iju(iu) = i1;
      }
      FEM_DO_SAFE(j, 1, 4) { pju(iu, j) += p(i1, j); }
    }
    FEM_DO_SAFE(iu, 1, 3) {
      pju(iu, 5) = fem::sqrt(fem::pow2(pju(iu, 1)) + fem::pow2(pju(iu, 2)) +
                             fem::pow2(pju(iu, 3)));
    }
    if (k(iju(3), 2) / 100 != 10 * k(iju(1), 2) + k(iju(2), 2) &&
        k(iju(3), 2) / 100 != 10 * k(iju(2), 2) + k(iju(1), 2)) {
      luerrm(cmn, 12, "(LUSTRF:) unphysical flavour combination");
      if (mstu(21) >= 1) {
        return;
      }
    }
    /// C
    /// C...Calculate (approximate) boost to rest frame of junction.
    t12 = (pju(1, 1) * pju(2, 1) + pju(1, 2) * pju(2, 2) +
           pju(1, 3) * pju(2, 3)) /
          (pju(1, 5) * pju(2, 5));
    t13 = (pju(1, 1) * pju(3, 1) + pju(1, 2) * pju(3, 2) +
           pju(1, 3) * pju(3, 3)) /
          (pju(1, 5) * pju(3, 5));
    t23 = (pju(2, 1) * pju(3, 1) + pju(2, 2) * pju(3, 2) +
           pju(2, 3) * pju(3, 3)) /
          (pju(2, 5) * pju(3, 5));
    t11 = fem::sqrt((2.f / 3.f) * (1.f - t12) * (1.f - t13) / (1.f - t23));
    t22 = fem::sqrt((2.f / 3.f) * (1.f - t12) * (1.f - t23) / (1.f - t13));
    tsq = fem::sqrt((2.f * t11 * t22 + t12 - 1.f) * (1.f + t12));
    t1f = (tsq - t22 * (1.f + t12)) / (1.f - fem::pow2(t12));
    t2f = (tsq - t11 * (1.f + t12)) / (1.f - fem::pow2(t12));
    FEM_DO_SAFE(j, 1, 3) {
      tju(j) = -(t1f * pju(1, j) / pju(1, 5) + t2f * pju(2, j) / pju(2, 5));
    }
    tju(4) = fem::sqrt(1.f + fem::pow2(tju(1)) + fem::pow2(tju(2)) +
                       fem::pow2(tju(3)));
    FEM_DO_SAFE(iu, 1, 3) {
      pju(iu, 5) = tju(4) * pju(iu, 4) - tju(1) * pju(iu, 1) -
                   tju(2) * pju(iu, 2) - tju(3) * pju(iu, 3);
    }
    /// C
    /// C...Put junction at rest if motion could give inconsistencies.
    if (pju(1, 5) + pju(2, 5) > pju(1, 4) + pju(2, 4)) {
      FEM_DO_SAFE(j, 1, 3) { tju(j) = 0.f; }
      tju(4) = 1.f;
      pju(1, 5) = pju(1, 4);
      pju(2, 5) = pju(2, 4);
      pju(3, 5) = pju(3, 4);
    }
    /// C
    /// C...Start preparing for fragmentation of two strings from junction.
    ista = i;
    FEM_DO_SAFE(iu, 1, 2) {
      ns = iju(iu + 1) - iju(iu);
      /// C
      /// C...Junction strings: find longitudinal string directions.
      FEM_DO_SAFE(is, 1, ns) {
        is1 = iju(iu) + is - 1;
        is2 = iju(iu) + is;
        FEM_DO_SAFE(j, 1, 5) {
          dp(1, j) = fem::dble(0.5f * p(is1, j));
          if (is == 1) {
            dp(1, j) = fem::dble(p(is1, j));
          }
          dp(2, j) = fem::dble(0.5f * p(is2, j));
          if (is == ns) {
            dp(2, j) = -fem::dble(pju(iu, j));
          }
        }
        if (is == ns) {
          dp(2, 4) = fem::dble(fem::sqrt(fem::pow2(pju(iu, 1)) +
                                         fem::pow2(pju(iu, 2)) +
                                         fem::pow2(pju(iu, 3))));
        }
        if (is == ns) {
          dp(2, 5) = 0e0;
        }
        dp(3, 5) = dfour(1, 1);
        dp(4, 5) = dfour(2, 2);
        dhkc = dfour(1, 2);
        if (dp(3, 5) + 2e0 * dhkc + dp(4, 5) <= 0e0) {
          dp(1, 4) = fem::sqrt(fem::pow2(dp(1, 1)) + fem::pow2(dp(1, 2)) +
                               fem::pow2(dp(1, 3)));
          dp(2, 4) = fem::sqrt(fem::pow2(dp(2, 1)) + fem::pow2(dp(2, 2)) +
                               fem::pow2(dp(2, 3)));
          dp(3, 5) = 0e0;
          dp(4, 5) = 0e0;
          dhkc = dfour(1, 2);
        }
        dhks = fem::sqrt(fem::pow2(dhkc) - dp(3, 5) * dp(4, 5));
        dhk1 = 0.5e0 * ((dp(4, 5) + dhkc) / dhks - 1e0);
        dhk2 = 0.5e0 * ((dp(3, 5) + dhkc) / dhks - 1e0);
        in1 = n + nr + 4 * is - 3;
        p(in1, 5) = fem::sngl(fem::sqrt(dp(3, 5) + 2e0 * dhkc + dp(4, 5)));
        FEM_DO_SAFE(j, 1, 4) {
          p(in1, j) = fem::sngl((1e0 + dhk1) * dp(1, j) - dhk2 * dp(2, j));
          p(in1 + 1, j) = fem::sngl((1e0 + dhk2) * dp(2, j) - dhk1 * dp(1, j));
        }
      }
      /// C
      /// C...Junction strings: initialize flavour, momentum and starting pos.
      isav = i;
    statement_270:
      ntry++;
      if (ntry > 100 && ntryr <= 4) {
        paru12 = 4.f * paru12;
        paru13 = 2.f * paru13;
        goto statement_130;
      } else if (ntry > 100) {
        luerrm(cmn, 14, "(LUSTRF:) caught in infinite loop");
        if (mstu(21) >= 1) {
          return;
        }
      }
      i = isav;
      irankj = 0;
      ie(1) = k(n + 1 + (jt / 2) * (np - 1), 3);
      in(4) = n + nr + 1;
      in(5) = in(4) + 1;
      in(6) = n + nr + 4 * ns + 1;
      FEM_DO_SAFE(jq, 1, 2) {
        FEM_DOSTEP(in1, n + nr + 2 + jq, n + nr + 4 * ns - 2 + jq, 4) {
          p(in1, 1) = 2 - jq;
          p(in1, 2) = jq - 1;
          p(in1, 3) = 1.f;
        }
      }
      kfl(1) = k(iju(iu), 2);
      px(1) = 0.f;
      py(1) = 0.f;
      gam(1) = 0.f;
      FEM_DO_SAFE(j, 1, 5) { pju(iu + 3, j) = 0.f; }
      /// C
      /// C...Junction strings: find initial transverse directions.
      FEM_DO_SAFE(j, 1, 4) {
        dp(1, j) = fem::dble(p(in(4), j));
        dp(2, j) = fem::dble(p(in(4) + 1, j));
        dp(3, j) = 0e0;
        dp(4, j) = 0e0;
      }
      dp(1, 4) = fem::sqrt(fem::pow2(dp(1, 1)) + fem::pow2(dp(1, 2)) +
                           fem::pow2(dp(1, 3)));
      dp(2, 4) = fem::sqrt(fem::pow2(dp(2, 1)) + fem::pow2(dp(2, 2)) +
                           fem::pow2(dp(2, 3)));
      dp(5, 1) = dp(1, 1) / dp(1, 4) - dp(2, 1) / dp(2, 4);
      dp(5, 2) = dp(1, 2) / dp(1, 4) - dp(2, 2) / dp(2, 4);
      dp(5, 3) = dp(1, 3) / dp(1, 4) - dp(2, 3) / dp(2, 4);
      if (fem::pow2(dp(5, 1)) <= fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
        dp(3, 1) = 1e0;
      }
      if (fem::pow2(dp(5, 1)) > fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
        dp(3, 3) = 1e0;
      }
      if (fem::pow2(dp(5, 2)) <= fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
        dp(4, 2) = 1e0;
      }
      if (fem::pow2(dp(5, 2)) > fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
        dp(4, 3) = 1e0;
      }
      dhc12 = dfour(1, 2);
      dhcx1 = dfour(3, 1) / dhc12;
      dhcx2 = dfour(3, 2) / dhc12;
      dhcxx = 1e0 / fem::sqrt(1e0 + 2e0 * dhcx1 * dhcx2 * dhc12);
      dhcy1 = dfour(4, 1) / dhc12;
      dhcy2 = dfour(4, 2) / dhc12;
      dhcyx = dhcxx * (dhcx1 * dhcy2 + dhcx2 * dhcy1) * dhc12;
      dhcyy =
          1e0 / fem::sqrt(1e0 + 2e0 * dhcy1 * dhcy2 * dhc12 - fem::pow2(dhcyx));
      FEM_DO_SAFE(j, 1, 4) {
        dp(3, j) = dhcxx * (dp(3, j) - dhcx2 * dp(1, j) - dhcx1 * dp(2, j));
        p(in(6), j) = fem::sngl(dp(3, j));
        p(in(6) + 1, j) =
            fem::sngl(dhcyy * (dp(4, j) - dhcy2 * dp(1, j) - dhcy1 * dp(2, j) -
                               dhcyx * dp(3, j)));
      }
    /// C
    /// C...Junction strings: produce new particle, origin.
    statement_320:
      i++;
      if (2 * i - nsav >= mstu(4) - mstu(32) - 5) {
        luerrm(cmn, 11, "(LUSTRF:) no more memory left in LUJETS");
        if (mstu(21) >= 1) {
          return;
        }
      }
      irankj++;
      k(i, 1) = 1;
      k(i, 3) = ie(1);
      k(i, 4) = 0;
      k(i, 5) = 0;
    /// C
    /// C...Junction strings: generate flavour, hadron, pT, z and Gamma.
    statement_330:
      lukfdi(cmn, kfl(1), 0, kfl(3), k(i, 2));
      if (k(i, 2) == 0) {
        goto statement_270;
      }
      if (mstj(12) >= 3 && irankj == 1 && fem::iabs(kfl(1)) <= 10 &&
          fem::iabs(kfl(3)) > 10) {
        if (rlu(cmn, 0) > parj(19)) {
          goto statement_330;
        }
      }
      p(i, 5) = ulmass(cmn, k(i, 2));
      luptdi(cmn, kfl(1), px(3), py(3));
      pr(1) = fem::pow2(p(i, 5)) + fem::pow2((px(1) + px(3))) +
              fem::pow2((py(1) + py(3)));
      luzdis(cmn, kfl(1), kfl(3), pr(1), z);
      gam(3) = (1.f - z) * (gam(1) + pr(1) / z);
      FEM_DO_SAFE(j, 1, 3) { in(j) = in(3 + j); }
      /// C
      /// C...Junction strings: stepping within or from 'low' string region
      /// easy.
      if (in(1) + 1 == in(2) &&
          z * p(in(1) + 2, 3) * p(in(2) + 2, 3) * fem::pow2(p(in(1), 5)) >=
              pr(1)) {
        p(in(1) + 2, 4) = z * p(in(1) + 2, 3);
        p(in(2) + 2, 4) = pr(1) / (p(in(1) + 2, 4) * fem::pow2(p(in(1), 5)));
        FEM_DO_SAFE(j, 1, 4) {
          p(i, j) =
              (px(1) + px(3)) * p(in(3), j) + (py(1) + py(3)) * p(in(3) + 1, j);
        }
        goto statement_420;
      } else if (in(1) + 1 == in(2)) {
        p(in(2) + 2, 4) = p(in(2) + 2, 3);
        p(in(2) + 2, 1) = 1.f;
        in(2) += 4;
        if (in(2) > n + nr + 4 * ns) {
          goto statement_270;
        }
        if (four(in(1), in(2)) <= 1e-2f) {
          p(in(1) + 2, 4) = p(in(1) + 2, 3);
          p(in(1) + 2, 1) = 0.f;
          in(1) += 4;
        }
      }
    /// C
    /// C...Junction strings: find new transverse directions.
    statement_360:
      if (in(1) > n + nr + 4 * ns || in(2) > n + nr + 4 * ns || in(1) > in(2)) {
        goto statement_270;
      }
      if (in(1) != in(4) || in(2) != in(5)) {
        FEM_DO_SAFE(j, 1, 4) {
          dp(1, j) = fem::dble(p(in(1), j));
          dp(2, j) = fem::dble(p(in(2), j));
          dp(3, j) = 0e0;
          dp(4, j) = 0e0;
        }
        dp(1, 4) = fem::sqrt(fem::pow2(dp(1, 1)) + fem::pow2(dp(1, 2)) +
                             fem::pow2(dp(1, 3)));
        dp(2, 4) = fem::sqrt(fem::pow2(dp(2, 1)) + fem::pow2(dp(2, 2)) +
                             fem::pow2(dp(2, 3)));
        dhc12 = dfour(1, 2);
        /// Clin-5/2012:
        /// C        IF(DHC12.LE.1E-2) THEN
        if (dhc12 <= 1e-2) {
          p(in(1) + 2, 4) = p(in(1) + 2, 3);
          p(in(1) + 2, 1) = 0.f;
          in(1) += 4;
          goto statement_360;
        }
        in(3) = n + nr + 4 * ns + 5;
        dp(5, 1) = dp(1, 1) / dp(1, 4) - dp(2, 1) / dp(2, 4);
        dp(5, 2) = dp(1, 2) / dp(1, 4) - dp(2, 2) / dp(2, 4);
        dp(5, 3) = dp(1, 3) / dp(1, 4) - dp(2, 3) / dp(2, 4);
        if (fem::pow2(dp(5, 1)) <= fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
          dp(3, 1) = 1e0;
        }
        if (fem::pow2(dp(5, 1)) > fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
          dp(3, 3) = 1e0;
        }
        if (fem::pow2(dp(5, 2)) <= fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
          dp(4, 2) = 1e0;
        }
        if (fem::pow2(dp(5, 2)) > fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
          dp(4, 3) = 1e0;
        }
        dhcx1 = dfour(3, 1) / dhc12;
        dhcx2 = dfour(3, 2) / dhc12;
        dhcxx = 1e0 / fem::sqrt(1e0 + 2e0 * dhcx1 * dhcx2 * dhc12);
        dhcy1 = dfour(4, 1) / dhc12;
        dhcy2 = dfour(4, 2) / dhc12;
        dhcyx = dhcxx * (dhcx1 * dhcy2 + dhcx2 * dhcy1) * dhc12;
        dhcyy = 1e0 /
                fem::sqrt(1e0 + 2e0 * dhcy1 * dhcy2 * dhc12 - fem::pow2(dhcyx));
        FEM_DO_SAFE(j, 1, 4) {
          dp(3, j) = dhcxx * (dp(3, j) - dhcx2 * dp(1, j) - dhcx1 * dp(2, j));
          p(in(3), j) = fem::sngl(dp(3, j));
          p(in(3) + 1, j) =
              fem::sngl(dhcyy * (dp(4, j) - dhcy2 * dp(1, j) -
                                 dhcy1 * dp(2, j) - dhcyx * dp(3, j)));
        }
        /// C...Express pT with respect to new axes, if sensible.
        pxp = -(px(3) * four(in(6), in(3)) + py(3) * four(in(6) + 1, in(3)));
        pyp = -(px(3) * four(in(6), in(3) + 1) +
                py(3) * four(in(6) + 1, in(3) + 1));
        if (fem::abs(fem::pow2(pxp) + fem::pow2(pyp) - fem::pow2(px(3)) -
                     fem::pow2(py(3))) < 0.01f) {
          px(3) = pxp;
          py(3) = pyp;
        }
      }
      /// C
      /// C...Junction strings: sum up known four-momentum, coefficients for m2.
      FEM_DO_SAFE(j, 1, 4) {
        dhg(j) = 0e0;
        p(i, j) = px(1) * p(in(6), j) + py(1) * p(in(6) + 1, j) +
                  px(3) * p(in(3), j) + py(3) * p(in(3) + 1, j);
        FEM_DOSTEP(in1, in(4), in(1) - 4, 4) {
          p(i, j) += p(in1 + 2, 3) * p(in1, j);
        }
        FEM_DOSTEP(in2, in(5), in(2) - 4, 4) {
          p(i, j) += p(in2 + 2, 3) * p(in2, j);
        }
      }
      dhm(1) = fem::dble(four(i, i));
      dhm(2) = fem::dble(2.f * four(i, in(1)));
      dhm(3) = fem::dble(2.f * four(i, in(2)));
      dhm(4) = fem::dble(2.f * four(in(1), in(2)));
      /// C
      /// C...Junction strings: find coefficients for Gamma expression.
      FEM_DOSTEP(in2, in(1) + 1, in(2), 4) {
        FEM_DOSTEP(in1, in(1), in2 - 1, 4) {
          dhc = fem::dble(2.f * four(in1, in2));
          dhg(1) += fem::dble(p(in1 + 2, 1) * p(in2 + 2, 1)) * dhc;
          if (in1 == in(1)) {
            dhg(2) = dhg(2) - fem::dble(p(in2 + 2, 1)) * dhc;
          }
          if (in2 == in(2)) {
            dhg(3) += fem::dble(p(in1 + 2, 1)) * dhc;
          }
          if (in1 == in(1) && in2 == in(2)) {
            dhg(4) = dhg(4) - dhc;
          }
        }
      }
      /// C
      /// C...Junction strings: solve (m2, Gamma) equation system for energies.
      dhs1 = dhm(3) * dhg(4) - dhm(4) * dhg(3);
      /// Clin-5/2012:
      /// C      IF(ABS(DHS1).LT.1E-4) GOTO 270
      if (fem::dabs(dhs1) < 1e-4) {
        goto statement_270;
      }
      dhs2 = dhm(4) * (fem::dble(gam(3)) - dhg(1)) - dhm(2) * dhg(3) -
             dhg(4) * (fem::pow2(fem::dble(p(i, 5))) - dhm(1)) +
             dhg(2) * dhm(3);
      dhs3 = dhm(2) * (fem::dble(gam(3)) - dhg(1)) -
             dhg(2) * (fem::pow2(fem::dble(p(i, 5))) - dhm(1));
      p(in(2) + 2, 4) =
          0.5f * fem::sngl(fem::sqrt(fem::max(
                               0e0, fem::pow2(dhs2) - 4e0 * dhs1 * dhs3)) /
                               fem::abs(dhs1) -
                           dhs2 / dhs1);
      if (dhm(2) + dhm(4) * fem::dble(p(in(2) + 2, 4)) <= 0e0) {
        goto statement_270;
      }
      p(in(1) + 2, 4) =
          (fem::pow2(p(i, 5)) - fem::sngl(dhm(1)) -
           fem::sngl(dhm(3)) * p(in(2) + 2, 4)) /
          (fem::sngl(dhm(2)) + fem::sngl(dhm(4)) * p(in(2) + 2, 4));
      /// C
      /// C...Junction strings: step to new region if necessary.
      if (p(in(2) + 2, 4) > p(in(2) + 2, 3)) {
        p(in(2) + 2, 4) = p(in(2) + 2, 3);
        p(in(2) + 2, 1) = 1.f;
        in(2) += 4;
        if (in(2) > n + nr + 4 * ns) {
          goto statement_270;
        }
        if (four(in(1), in(2)) <= 1e-2f) {
          p(in(1) + 2, 4) = p(in(1) + 2, 3);
          p(in(1) + 2, 1) = 0.f;
          in(1) += 4;
        }
        goto statement_360;
      } else if (p(in(1) + 2, 4) > p(in(1) + 2, 3)) {
        p(in(1) + 2, 4) = p(in(1) + 2, 3);
        p(in(1) + 2, 1) = 0.f;
        in(1) += js;
        goto statement_710;
      }
    /// C
    /// C...Junction strings: particle four-momentum, remainder, loop back.
    statement_420:
      FEM_DO_SAFE(j, 1, 4) {
        p(i, j) +=
            p(in(1) + 2, 4) * p(in(1), j) + p(in(2) + 2, 4) * p(in(2), j);
        pju(iu + 3, j) += p(i, j);
      }
      if (p(i, 4) <= 0.f) {
        goto statement_270;
      }
      pju(iu + 3, 5) = tju(4) * pju(iu + 3, 4) - tju(1) * pju(iu + 3, 1) -
                       tju(2) * pju(iu + 3, 2) - tju(3) * pju(iu + 3, 3);
      if (pju(iu + 3, 5) < pju(iu, 5)) {
        kfl(1) = -kfl(3);
        px(1) = -px(3);
        py(1) = -py(3);
        gam(1) = gam(3);
        if (in(3) != in(6)) {
          FEM_DO_SAFE(j, 1, 4) {
            p(in(6), j) = p(in(3), j);
            p(in(6) + 1, j) = p(in(3) + 1, j);
          }
        }
        FEM_DO_SAFE(jq, 1, 2) {
          in(3 + jq) = in(jq);
          p(in(jq) + 2, 3) = p(in(jq) + 2, 3) - p(in(jq) + 2, 4);
          p(in(jq) + 2, 1) = p(in(jq) + 2, 1) - (3 - 2 * jq) * p(in(jq) + 2, 4);
        }
        goto statement_320;
      }
      /// C
      /// C...Junction strings: save quantities left after each string.
      if (fem::iabs(kfl(1)) > 10) {
        goto statement_270;
      }
      i = i - 1;
      kfjh(iu) = kfl(1);
      FEM_DO_SAFE(j, 1, 4) { pju(iu + 3, j) = pju(iu + 3, j) - p(i + 1, j); }
    }
    /// C
    /// C...Junction strings: put together to new effective string endpoint.
    njs(jt) = i - ista;
    kfjs(jt) = k(k(mju(jt + 2), 3), 2);
    kfls =
        2 * fem::fint(rlu(cmn, 0) + 3.f * parj(4) / (1.f + 3.f * parj(4))) + 1;
    if (kfjh(1) == kfjh(2)) {
      kfls = 3;
    }
    if (ista != i) {
      kfjs(jt) = fem::isign(
          1000 * fem::max(fem::iabs(kfjh(1)), fem::iabs(kfjh(2))) +
              100 * fem::min(fem::iabs(kfjh(1)), fem::iabs(kfjh(2))) + kfls,
          kfjh(1));
    }
    FEM_DO_SAFE(j, 1, 4) {
      pjs(jt, j) = pju(1, j) + pju(2, j) + p(mju(jt), j);
      pjs(jt + 2, j) = pju(4, j) + pju(5, j);
    }
    pjs(jt, 5) = fem::sqrt(
        fem::max(0.f, fem::pow2(pjs(jt, 4)) - fem::pow2(pjs(jt, 1)) -
                          fem::pow2(pjs(jt, 2)) - fem::pow2(pjs(jt, 3))));
  statement_490:;
  }
/// C
/// C...Open versus closed strings. Choose breakup region for latter.
statement_500:
  if (mju(1) != 0 && mju(2) != 0) {
    ns = mju(2) - mju(1);
    nb = mju(1) - n;
  } else if (mju(1) != 0) {
    ns = n + nr - mju(1);
    nb = mju(1) - n;
  } else if (mju(2) != 0) {
    ns = mju(2) - n;
    nb = 1;
  } else if (fem::iabs(k(n + 1, 2)) != 21) {
    ns = nr - 1;
    nb = 1;
  } else {
    ns = nr + 1;
    w2sum = 0.f;
    FEM_DO_SAFE(is, 1, nr) {
      p(n + nr + is, 1) = 0.5f * four(n + is, n + is + 1 - nr * (is / nr));
      w2sum += p(n + nr + is, 1);
    }
    w2ran = rlu(cmn, 0) * w2sum;
    nb = 0;
  statement_520:
    nb++;
    w2sum = w2sum - p(n + nr + nb, 1);
    if (w2sum > w2ran && nb < nr) {
      goto statement_520;
    }
  }
  /// C
  /// C...Find longitudinal string directions (i.e. lightlike four-vectors).
  FEM_DO_SAFE(is, 1, ns) {
    is1 = n + is + nb - 1 - nr * ((is + nb - 2) / nr);
    is2 = n + is + nb - nr * ((is + nb - 1) / nr);
    FEM_DO_SAFE(j, 1, 5) {
      dp(1, j) = fem::dble(p(is1, j));
      if (fem::iabs(k(is1, 2)) == 21) {
        dp(1, j) = 0.5e0 * dp(1, j);
      }
      if (is1 == mju(1)) {
        dp(1, j) = fem::dble(pjs(1, j) - pjs(3, j));
      }
      dp(2, j) = fem::dble(p(is2, j));
      if (fem::iabs(k(is2, 2)) == 21) {
        dp(2, j) = 0.5e0 * dp(2, j);
      }
      if (is2 == mju(2)) {
        dp(2, j) = fem::dble(pjs(2, j) - pjs(4, j));
      }
    }
    dp(3, 5) = dfour(1, 1);
    dp(4, 5) = dfour(2, 2);
    dhkc = dfour(1, 2);
    if (dp(3, 5) + 2.e0 * dhkc + dp(4, 5) <= 0.e0) {
      dp(3, 5) = fem::pow2(dp(1, 5));
      dp(4, 5) = fem::pow2(dp(2, 5));
      dp(1, 4) = fem::sqrt(fem::pow2(dp(1, 1)) + fem::pow2(dp(1, 2)) +
                           fem::pow2(dp(1, 3)) + fem::pow2(dp(1, 5)));
      dp(2, 4) = fem::sqrt(fem::pow2(dp(2, 1)) + fem::pow2(dp(2, 2)) +
                           fem::pow2(dp(2, 3)) + fem::pow2(dp(2, 5)));
      dhkc = dfour(1, 2);
    }
    dhks = fem::sqrt(fem::pow2(dhkc) - dp(3, 5) * dp(4, 5));
    dhk1 = 0.5e0 * ((dp(4, 5) + dhkc) / dhks - 1.e0);
    dhk2 = 0.5e0 * ((dp(3, 5) + dhkc) / dhks - 1.e0);
    in1 = n + nr + 4 * is - 3;
    p(in1, 5) = fem::sqrt(fem::sngl(dp(3, 5) + 2.e0 * dhkc + dp(4, 5)));
    FEM_DO_SAFE(j, 1, 4) {
      p(in1, j) = fem::sngl((1.e0 + dhk1) * dp(1, j) - dhk2 * dp(2, j));
      p(in1 + 1, j) = fem::sngl((1.e0 + dhk2) * dp(2, j) - dhk1 * dp(1, j));
    }
  }
  /// C
  /// C...Begin initialization: sum up energy, set starting position.
  isav = i;
statement_550:
  ntry++;
  if (ntry > 100 && ntryr <= 4) {
    paru12 = 4.f * paru12;
    paru13 = 2.f * paru13;
    goto statement_130;
  } else if (ntry > 100) {
    luerrm(cmn, 14, "(LUSTRF:) caught in infinite loop");
    if (mstu(21) >= 1) {
      return;
    }
  }
  i = isav;
  FEM_DO_SAFE(j, 1, 4) {
    p(n + nrs, j) = 0.f;
    FEM_DO_SAFE(is, 1, nr) { p(n + nrs, j) += p(n + is, j); }
  }
  FEM_DO_SAFE(jt, 1, 2) {
    irank(jt) = 0;
    if (mju(jt) != 0) {
      irank(jt) = njs(jt);
    }
    if (ns > nr) {
      irank(jt) = 1;
    }
    ie(jt) = k(n + 1 + (jt / 2) * (np - 1), 3);
    in(3 * jt + 1) = n + nr + 1 + 4 * (jt / 2) * (ns - 1);
    in(3 * jt + 2) = in(3 * jt + 1) + 1;
    in(3 * jt + 3) = n + nr + 4 * ns + 2 * jt - 1;
    FEM_DOSTEP(in1, n + nr + 2 + jt, n + nr + 4 * ns - 2 + jt, 4) {
      p(in1, 1) = 2 - jt;
      p(in1, 2) = jt - 1;
      p(in1, 3) = 1.f;
    }
  }
  /// C
  /// C...Initialize flavour and pT variables for open string.
  if (ns < nr) {
    px(1) = 0.f;
    py(1) = 0.f;
    if (ns == 1 && mju(1) + mju(2) == 0) {
      luptdi(cmn, 0, px(1), py(1));
    }
    px(2) = -px(1);
    py(2) = -py(1);
    FEM_DO_SAFE(jt, 1, 2) {
      kfl(jt) = k(ie(jt), 2);
      if (mju(jt) != 0) {
        kfl(jt) = kfjs(jt);
      }
      mstj(93) = 1;
      pmq(jt) = ulmass(cmn, kfl(jt));
      gam(jt) = 0.f;
    }
    /// C
    /// C...Closed string: random initial breakup flavour, pT and vertex.
  } else {
    kfl(3) = fem::fint(1.f + (2.f + parj(2)) * rlu(cmn, 0)) *
             fem::pow((-1), fem::fint(rlu(cmn, 0) + 0.5f));
    lukfdi(cmn, kfl(3), 0, kfl(1), kdump);
    kfl(2) = -kfl(1);
    if (fem::iabs(kfl(1)) > 10 && rlu(cmn, 0) > 0.5f) {
      kfl(2) = -(kfl(1) + fem::isign(10000, kfl(1)));
    } else if (fem::iabs(kfl(1)) > 10) {
      kfl(1) = -(kfl(2) + fem::isign(10000, kfl(2)));
    }
    luptdi(cmn, kfl(1), px(1), py(1));
    px(2) = -px(1);
    py(2) = -py(1);
    pr3 = fem::min(25.f, 0.1f * fem::pow2(p(n + nr + 1, 5)));
  statement_590:
    luzdis(cmn, kfl(1), kfl(2), pr3, z);
    zr = pr3 / (z * fem::pow2(p(n + nr + 1, 5)));
    if (zr >= 1.f) {
      goto statement_590;
    }
    /// C
    FEM_DO_SAFE(jt, 1, 2) {
      mstj(93) = 1;
      pmq(jt) = ulmass(cmn, kfl(jt));
      gam(jt) = pr3 * (1.f - z) / z;
      in1 = n + nr + 3 + 4 * (jt / 2) * (ns - 1);
      p(in1, jt) = 1.f - z;
      p(in1, 3 - jt) = jt - 1;
      p(in1, 3) = (2 - jt) * (1.f - z) + (jt - 1) * z;
      p(in1 + 1, jt) = zr;
      p(in1 + 1, 3 - jt) = 2 - jt;
      p(in1 + 1, 3) = (2 - jt) * (1.f - zr) + (jt - 1) * zr;
    }
  }
  /// C
  /// C...Find initial transverse directions (i.e. spacelike four-vectors).
  FEM_DO_SAFE(jt, 1, 2) {
    if (jt == 1 || ns == nr - 1) {
      in1 = in(3 * jt + 1);
      in3 = in(3 * jt + 3);
      FEM_DO_SAFE(j, 1, 4) {
        dp(1, j) = fem::dble(p(in1, j));
        dp(2, j) = fem::dble(p(in1 + 1, j));
        dp(3, j) = 0.e0;
        dp(4, j) = 0.e0;
      }
      dp(1, 4) = fem::dsqrt(fem::pow2(dp(1, 1)) + fem::pow2(dp(1, 2)) +
                            fem::pow2(dp(1, 3)));
      dp(2, 4) = fem::dsqrt(fem::pow2(dp(2, 1)) + fem::pow2(dp(2, 2)) +
                            fem::pow2(dp(2, 3)));
      dp(5, 1) = dp(1, 1) / dp(1, 4) - dp(2, 1) / dp(2, 4);
      dp(5, 2) = dp(1, 2) / dp(1, 4) - dp(2, 2) / dp(2, 4);
      dp(5, 3) = dp(1, 3) / dp(1, 4) - dp(2, 3) / dp(2, 4);
      if (fem::pow2(dp(5, 1)) <= fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
        dp(3, 1) = 1.e0;
      }
      if (fem::pow2(dp(5, 1)) > fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
        dp(3, 3) = 1.e0;
      }
      if (fem::pow2(dp(5, 2)) <= fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
        dp(4, 2) = 1.e0;
      }
      if (fem::pow2(dp(5, 2)) > fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
        dp(4, 3) = 1.e0;
      }
      dhc12 = dfour(1, 2);
      dhcx1 = dfour(3, 1) / dhc12;
      dhcx2 = dfour(3, 2) / dhc12;
      dhcxx = 1e0 / fem::sqrt(1e0 + 2e0 * dhcx1 * dhcx2 * dhc12);
      dhcy1 = dfour(4, 1) / dhc12;
      dhcy2 = dfour(4, 2) / dhc12;
      dhcyx = dhcxx * (dhcx1 * dhcy2 + dhcx2 * dhcy1) * dhc12;
      dhcyy =
          1e0 / fem::sqrt(1e0 + 2e0 * dhcy1 * dhcy2 * dhc12 - fem::pow2(dhcyx));
      FEM_DO_SAFE(j, 1, 4) {
        dp(3, j) = dhcxx * (dp(3, j) - dhcx2 * dp(1, j) - dhcx1 * dp(2, j));
        p(in3, j) = fem::sngl(dp(3, j));
        p(in3 + 1, j) =
            fem::sngl(dhcyy * (dp(4, j) - dhcy2 * dp(1, j) - dhcy1 * dp(2, j) -
                               dhcyx * dp(3, j)));
      }
    } else {
      FEM_DO_SAFE(j, 1, 4) {
        p(in3 + 2, j) = p(in3, j);
        p(in3 + 3, j) = p(in3 + 1, j);
      }
    }
  }
  /// C
  /// C...Remove energy used up in junction string fragmentation.
  if (mju(1) + mju(2) > 0) {
    FEM_DO_SAFE(jt, 1, 2) {
      if (njs(jt) == 0) {
        goto statement_660;
      }
      FEM_DO_SAFE(j, 1, 4) { p(n + nrs, j) = p(n + nrs, j) - pjs(jt + 2, j); }
    statement_660:;
    }
  }
/// C
/// C...Produce new particle: side, origin.
statement_670:
  i++;
  if (2 * i - nsav >= mstu(4) - mstu(32) - 5) {
    luerrm(cmn, 11, "(LUSTRF:) no more memory left in LUJETS");
    if (mstu(21) >= 1) {
      return;
    }
  }
  jt = fem::fint(1.5f + rlu(cmn, 0));
  if (fem::iabs(kfl(3 - jt)) > 10) {
    jt = 3 - jt;
  }
  jr = 3 - jt;
  js = 3 - 2 * jt;
  irank(jt)++;
  k(i, 1) = 1;
  k(i, 3) = ie(jt);
  k(i, 4) = 0;
  k(i, 5) = 0;
/// C
/// C...Generate flavour, hadron and pT.
statement_680:
  lukfdi(cmn, kfl(jt), 0, kfl(3), k(i, 2));
  if (k(i, 2) == 0) {
    goto statement_550;
  }
  if (mstj(12) >= 3 && irank(jt) == 1 && fem::iabs(kfl(jt)) <= 10 &&
      fem::iabs(kfl(3)) > 10) {
    if (rlu(cmn, 0) > parj(19)) {
      goto statement_680;
    }
  }
  p(i, 5) = ulmass(cmn, k(i, 2));
  luptdi(cmn, kfl(jt), px(3), py(3));
  pr(jt) = fem::pow2(p(i, 5)) + fem::pow2((px(jt) + px(3))) +
           fem::pow2((py(jt) + py(3)));
  /// C
  /// C...Final hadrons for small invariant mass.
  mstj(93) = 1;
  pmq(3) = ulmass(cmn, kfl(3));
  wmin = parj(32 + mstj(11)) + pmq(1) + pmq(2) + parj(36) * pmq(3);
  if (fem::iabs(kfl(jt)) > 10 && fem::iabs(kfl(3)) > 10) {
    wmin = wmin - 0.5f * parj(36) * pmq(3);
  }
  wrem2 = four(n + nrs, n + nrs);
  if (wrem2 < 0.10f) {
    goto statement_550;
  }
  if (wrem2 <
      fem::pow2(fem::max(wmin * (1.f + (2.f * rlu(cmn, 0) - 1.f) * parj(37)),
                         parj(32) + pmq(1) + pmq(2)))) {
    goto statement_810;
  }
  /// C
  /// C...Choose z, which gives Gamma. Shift z for heavy flavours.
  luzdis(cmn, kfl(jt), kfl(3), pr(jt), z);
  /// C
  kfl1a = fem::iabs(kfl(1));
  kfl2a = fem::iabs(kfl(2));
  if (fem::max(fem::mod(kfl1a, 10), fem::mod(kfl1a / 1000, 10),
               fem::mod(kfl2a, 10), fem::mod(kfl2a / 1000, 10)) >= 4) {
    pr(jr) = fem::pow2((pmq(jr) + pmq(3))) + fem::pow2((px(jr) - px(3))) +
             fem::pow2((py(jr) - py(3)));
    pw12 = fem::sqrt(fem::max(
        0.f, fem::pow2((wrem2 - pr(1) - pr(2))) - 4.f * pr(1) * pr(2)));
    z = (wrem2 + pr(jt) - pr(jr) + pw12 * (2.f * z - 1.f)) / (2.f * wrem2);
    pr(jr) = fem::pow2((pmq(jr) + parj(32 + mstj(11)))) +
             fem::pow2((px(jr) - px(3))) + fem::pow2((py(jr) - py(3)));
    if ((1.f - z) * (wrem2 - pr(jt) / z) < pr(jr)) {
      goto statement_810;
    }
  }
  gam(3) = (1.f - z) * (gam(jt) + pr(jt) / z);
  FEM_DO_SAFE(j, 1, 3) { in(j) = in(3 * jt + j); }
  /// C
  /// C...Stepping within or from 'low' string region easy.
  if (in(1) + 1 == in(2) &&
      z * p(in(1) + 2, 3) * p(in(2) + 2, 3) * fem::pow2(p(in(1), 5)) >=
          pr(jt)) {
    p(in(jt) + 2, 4) = z * p(in(jt) + 2, 3);
    p(in(jr) + 2, 4) = pr(jt) / (p(in(jt) + 2, 4) * fem::pow2(p(in(1), 5)));
    FEM_DO_SAFE(j, 1, 4) {
      p(i, j) =
          (px(jt) + px(3)) * p(in(3), j) + (py(jt) + py(3)) * p(in(3) + 1, j);
    }
    goto statement_770;
  } else if (in(1) + 1 == in(2)) {
    p(in(jr) + 2, 4) = p(in(jr) + 2, 3);
    p(in(jr) + 2, jt) = 1.f;
    in(jr) += 4 * js;
    if (js * in(jr) > js * in(4 * jr)) {
      goto statement_550;
    }
    if (four(in(1), in(2)) <= 1e-2f) {
      p(in(jt) + 2, 4) = p(in(jt) + 2, 3);
      p(in(jt) + 2, jt) = 0.f;
      in(jt) += 4 * js;
    }
  }
/// C
/// C...Find new transverse directions (i.e. spacelike string vectors).
statement_710:
  if (js * in(1) > js * in(3 * jr + 1) || js * in(2) > js * in(3 * jr + 2) ||
      in(1) > in(2)) {
    goto statement_550;
  }
  if (in(1) != in(3 * jt + 1) || in(2) != in(3 * jt + 2)) {
    FEM_DO_SAFE(j, 1, 4) {
      dp(1, j) = fem::dble(p(in(1), j));
      dp(2, j) = fem::dble(p(in(2), j));
      dp(3, j) = 0.e0;
      dp(4, j) = 0.e0;
    }
    dp(1, 4) = fem::dsqrt(fem::pow2(dp(1, 1)) + fem::pow2(dp(1, 2)) +
                          fem::pow2(dp(1, 3)));
    dp(2, 4) = fem::dsqrt(fem::pow2(dp(2, 1)) + fem::pow2(dp(2, 2)) +
                          fem::pow2(dp(2, 3)));
    dhc12 = dfour(1, 2);
    /// Clin-5/2012:
    /// C        IF(DHC12.LE.1E-2) THEN
    if (dhc12 <= 1e-2) {
      p(in(jt) + 2, 4) = p(in(jt) + 2, 3);
      p(in(jt) + 2, jt) = 0.f;
      in(jt) += 4 * js;
      goto statement_710;
    }
    in(3) = n + nr + 4 * ns + 5;
    dp(5, 1) = dp(1, 1) / dp(1, 4) - dp(2, 1) / dp(2, 4);
    dp(5, 2) = dp(1, 2) / dp(1, 4) - dp(2, 2) / dp(2, 4);
    dp(5, 3) = dp(1, 3) / dp(1, 4) - dp(2, 3) / dp(2, 4);
    if (fem::pow2(dp(5, 1)) <= fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
      dp(3, 1) = 1.e0;
    }
    if (fem::pow2(dp(5, 1)) > fem::pow2(dp(5, 2)) + fem::pow2(dp(5, 3))) {
      dp(3, 3) = 1.e0;
    }
    if (fem::pow2(dp(5, 2)) <= fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
      dp(4, 2) = 1.e0;
    }
    if (fem::pow2(dp(5, 2)) > fem::pow2(dp(5, 1)) + fem::pow2(dp(5, 3))) {
      dp(4, 3) = 1.e0;
    }
    dhcx1 = dfour(3, 1) / dhc12;
    dhcx2 = dfour(3, 2) / dhc12;
    dhcxx = 1e0 / fem::sqrt(1e0 + 2e0 * dhcx1 * dhcx2 * dhc12);
    dhcy1 = dfour(4, 1) / dhc12;
    dhcy2 = dfour(4, 2) / dhc12;
    dhcyx = dhcxx * (dhcx1 * dhcy2 + dhcx2 * dhcy1) * dhc12;
    dhcyy =
        1e0 / fem::sqrt(1e0 + 2e0 * dhcy1 * dhcy2 * dhc12 - fem::pow2(dhcyx));
    FEM_DO_SAFE(j, 1, 4) {
      dp(3, j) = dhcxx * (dp(3, j) - dhcx2 * dp(1, j) - dhcx1 * dp(2, j));
      p(in(3), j) = fem::sngl(dp(3, j));
      p(in(3) + 1, j) =
          fem::sngl(dhcyy * (dp(4, j) - dhcy2 * dp(1, j) - dhcy1 * dp(2, j) -
                             dhcyx * dp(3, j)));
    }
    /// C...Express pT with respect to new axes, if sensible.
    pxp = -(px(3) * four(in(3 * jt + 3), in(3)) +
            py(3) * four(in(3 * jt + 3) + 1, in(3)));
    pyp = -(px(3) * four(in(3 * jt + 3), in(3) + 1) +
            py(3) * four(in(3 * jt + 3) + 1, in(3) + 1));
    if (fem::abs(fem::pow2(pxp) + fem::pow2(pyp) - fem::pow2(px(3)) -
                 fem::pow2(py(3))) < 0.01f) {
      px(3) = pxp;
      py(3) = pyp;
    }
  }
  /// C
  /// C...Sum up known four-momentum. Gives coefficients for m2 expression.
  FEM_DO_SAFE(j, 1, 4) {
    dhg(j) = 0.e0;
    p(i, j) = px(jt) * p(in(3 * jt + 3), j) +
              py(jt) * p(in(3 * jt + 3) + 1, j) + px(3) * p(in(3), j) +
              py(3) * p(in(3) + 1, j);
    FEM_DOSTEP(in1, in(3 * jt + 1), in(1) - 4 * js, 4 * js) {
      p(i, j) += p(in1 + 2, 3) * p(in1, j);
    }
    FEM_DOSTEP(in2, in(3 * jt + 2), in(2) - 4 * js, 4 * js) {
      p(i, j) += p(in2 + 2, 3) * p(in2, j);
    }
  }
  dhm(1) = fem::dble(four(i, i));
  dhm(2) = fem::dble(2.f * four(i, in(1)));
  dhm(3) = fem::dble(2.f * four(i, in(2)));
  dhm(4) = fem::dble(2.f * four(in(1), in(2)));
  /// C
  /// C...Find coefficients for Gamma expression.
  FEM_DOSTEP(in2, in(1) + 1, in(2), 4) {
    FEM_DOSTEP(in1, in(1), in2 - 1, 4) {
      dhc = fem::dble(2.f * four(in1, in2));
      dhg(1) += fem::dble(p(in1 + 2, jt) * p(in2 + 2, jt)) * dhc;
      if (in1 == in(1)) {
        dhg(2) = dhg(2) - fem::dble(fem::ffloat(js) * p(in2 + 2, jt)) * dhc;
      }
      if (in2 == in(2)) {
        dhg(3) += fem::dble(fem::ffloat(js) * p(in1 + 2, jt)) * dhc;
      }
      if (in1 == in(1) && in2 == in(2)) {
        dhg(4) = dhg(4) - dhc;
      }
    }
  }
  /// C
  /// C...Solve (m2, Gamma) equation system for energies taken.
  dhs1 = dhm(jr + 1) * dhg(4) - dhm(4) * dhg(jr + 1);
  /// Clin-5/2012:
  /// C      IF(ABS(DHS1).LT.1E-4) GOTO 550
  if (fem::dabs(dhs1) < 1e-4) {
    goto statement_550;
  }
  dhs2 = dhm(4) * (fem::dble(gam(3)) - dhg(1)) - dhm(jt + 1) * dhg(jr + 1) -
         dhg(4) * (fem::pow2(fem::dble(p(i, 5))) - dhm(1)) +
         dhg(jt + 1) * dhm(jr + 1);
  dhs3 = dhm(jt + 1) * (fem::dble(gam(3)) - dhg(1)) -
         dhg(jt + 1) * (fem::pow2(fem::dble(p(i, 5))) - dhm(1));
  p(in(jr) + 2, 4) =
      0.5f * fem::sngl((fem::sqrt(fem::max(
                           0e0, fem::pow2(dhs2) - 4.e0 * dhs1 * dhs3))) /
                           fem::abs(dhs1) -
                       dhs2 / dhs1);
  if (dhm(jt + 1) + dhm(4) * fem::dble(p(in(jr) + 2, 4)) <= 0.e0) {
    goto statement_550;
  }
  p(in(jt) + 2, 4) =
      (fem::pow2(p(i, 5)) - fem::sngl(dhm(1)) -
       fem::sngl(dhm(jr + 1)) * p(in(jr) + 2, 4)) /
      (fem::sngl(dhm(jt + 1)) + fem::sngl(dhm(4)) * p(in(jr) + 2, 4));
  /// C
  /// C...Step to new region if necessary.
  if (p(in(jr) + 2, 4) > p(in(jr) + 2, 3)) {
    p(in(jr) + 2, 4) = p(in(jr) + 2, 3);
    p(in(jr) + 2, jt) = 1.f;
    in(jr) += 4 * js;
    if (js * in(jr) > js * in(4 * jr)) {
      goto statement_550;
    }
    if (four(in(1), in(2)) <= 1e-2f) {
      p(in(jt) + 2, 4) = p(in(jt) + 2, 3);
      p(in(jt) + 2, jt) = 0.f;
      in(jt) += 4 * js;
    }
    goto statement_710;
  } else if (p(in(jt) + 2, 4) > p(in(jt) + 2, 3)) {
    p(in(jt) + 2, 4) = p(in(jt) + 2, 3);
    p(in(jt) + 2, jt) = 0.f;
    in(jt) += 4 * js;
    goto statement_710;
  }
/// C
/// C...Four-momentum of particle. Remaining quantities. Loop back.
statement_770:
  FEM_DO_SAFE(j, 1, 4) {
    p(i, j) += p(in(1) + 2, 4) * p(in(1), j) + p(in(2) + 2, 4) * p(in(2), j);
    p(n + nrs, j) = p(n + nrs, j) - p(i, j);
  }
  if (p(i, 4) <= 0.f) {
    goto statement_550;
  }
  kfl(jt) = -kfl(3);
  pmq(jt) = pmq(3);
  px(jt) = -px(3);
  py(jt) = -py(3);
  gam(jt) = gam(3);
  if (in(3) != in(3 * jt + 3)) {
    FEM_DO_SAFE(j, 1, 4) {
      p(in(3 * jt + 3), j) = p(in(3), j);
      p(in(3 * jt + 3) + 1, j) = p(in(3) + 1, j);
    }
  }
  FEM_DO_SAFE(jq, 1, 2) {
    in(3 * jt + jq) = in(jq);
    p(in(jq) + 2, 3) = p(in(jq) + 2, 3) - p(in(jq) + 2, 4);
    p(in(jq) + 2, jt) =
        p(in(jq) + 2, jt) - js * (3 - 2 * jq) * p(in(jq) + 2, 4);
  }
  goto statement_670;
/// C
/// C...Final hadron: side, flavour, hadron, mass.
statement_810:
  i++;
  k(i, 1) = 1;
  k(i, 3) = ie(jr);
  k(i, 4) = 0;
  k(i, 5) = 0;
  lukfdi(cmn, kfl(jr), -kfl(3), kfldmp, k(i, 2));
  if (k(i, 2) == 0) {
    goto statement_550;
  }
  p(i, 5) = ulmass(cmn, k(i, 2));
  pr(jr) = fem::pow2(p(i, 5)) + fem::pow2((px(jr) - px(3))) +
           fem::pow2((py(jr) - py(3)));
  /// C
  /// C...Final two hadrons: find common setup of four-vectors.
  jq = 1;
  if (p(in(4) + 2, 3) * p(in(5) + 2, 3) * four(in(4), in(5)) <
      p(in(7), 3) * p(in(8), 3) * four(in(7), in(8))) {
    jq = 2;
  }
  dhc12 = fem::dble(four(in(3 * jq + 1), in(3 * jq + 2)));
  dhr1 = fem::dble(four(n + nrs, in(3 * jq + 2))) / dhc12;
  dhr2 = fem::dble(four(n + nrs, in(3 * jq + 1))) / dhc12;
  if (in(4) != in(7) || in(5) != in(8)) {
    px(3 - jq) = -four(n + nrs, in(3 * jq + 3)) - px(jq);
    py(3 - jq) = -four(n + nrs, in(3 * jq + 3) + 1) - py(jq);
    pr(3 - jq) = fem::pow2(p(i + fem::pow2((jt + jq - 3)) - 1, 5)) +
                 fem::pow2((px(3 - jq) + (2 * jq - 3) * js * px(3))) +
                 fem::pow2((py(3 - jq) + (2 * jq - 3) * js * py(3)));
  }
  /// C
  /// C...Solve kinematics for final two hadrons, if possible.
  wrem2 += fem::pow2((px(1) + px(2))) + fem::pow2((py(1) + py(2)));
  fd = (fem::sqrt(pr(1)) + fem::sqrt(pr(2))) / fem::sqrt(wrem2);
  if (mju(1) + mju(2) != 0 && i == isav + 2 && fd >= 1.f) {
    goto statement_180;
  }
  if (fd >= 1.f) {
    goto statement_550;
  }
  fa = wrem2 + pr(jt) - pr(jr);
  if (mstj(11) == 2) {
    prev = 0.5f * fem::pow(fd, parj(37 + mstj(11)));
  }
  if (mstj(11) != 2) {
    prev = 0.5f * fem::exp(fem::max(-100.f, fem::log(fd) * parj(37 + mstj(11)) *
                                                fem::pow2((pr(1) + pr(2)))));
  }
  fb = fem::sign(fem::sqrt(fem::max(0.f, fem::pow2(fa) - 4.f * wrem2 * pr(jt))),
                 js * (rlu(cmn, 0) - prev));
  kfl1a = fem::iabs(kfl(1));
  kfl2a = fem::iabs(kfl(2));
  if (fem::max(fem::mod(kfl1a, 10), fem::mod(kfl1a / 1000, 10),
               fem::mod(kfl2a, 10), fem::mod(kfl2a / 1000, 10)) >= 6) {
    fb = fem::sign(
        fem::sqrt(fem::max(0.f, fem::pow2(fa) - 4.f * wrem2 * pr(jt))),
        fem::ffloat(js));
  }
  FEM_DO_SAFE(j, 1, 4) {
    p(i - 1, j) = (px(jt) + px(3)) * p(in(3 * jq + 3), j) +
                  (py(jt) + py(3)) * p(in(3 * jq + 3) + 1, j) +
                  0.5f *
                      (fem::sngl(dhr1) * (fa + fb) * p(in(3 * jq + 1), j) +
                       fem::sngl(dhr2) * (fa - fb) * p(in(3 * jq + 2), j)) /
                      wrem2;
    p(i, j) = p(n + nrs, j) - p(i - 1, j);
  }
  /// C
  /// C...Mark jets as fragmented and give daughter pointers.
  n = i - nrs + 1;
  FEM_DO_SAFE(i, nsav + 1, nsav + np) {
    im = k(i, 3);
    k(im, 1) += 10;
    if (mstu(16) != 2) {
      k(im, 4) = nsav + 1;
      k(im, 5) = nsav + 1;
    } else {
      k(im, 4) = nsav + 2;
      k(im, 5) = n;
    }
  }
  /// C
  /// C...Document string system. Move up particles.
  nsav++;
  k(nsav, 1) = 11;
  k(nsav, 2) = 92;
  k(nsav, 3) = ip;
  k(nsav, 4) = nsav + 1;
  k(nsav, 5) = n;
  FEM_DO_SAFE(j, 1, 4) {
    p(nsav, j) = fem::sngl(dps(j));
    v(nsav, j) = v(ip, j);
  }
  p(nsav, 5) = fem::sqrt(
      fem::sngl(fem::max(0e0, fem::pow2(dps(4)) - fem::pow2(dps(1)) -
                                  fem::pow2(dps(2)) - fem::pow2(dps(3)))));
  v(nsav, 5) = 0.f;
  FEM_DO_SAFE(i, nsav + 1, n) {
    /// C
    FEM_DO_SAFE(j, 1, 5) {
      k(i, j) = k(i + nrs - 1, j);
      p(i, j) = p(i + nrs - 1, j);
      v(i, j) = 0.f;
    }
  }
  /// C
  /// C...Order particles in rank along the chain. Update mother pointer.
  FEM_DO_SAFE(i, nsav + 1, n) {
    FEM_DO_SAFE(j, 1, 5) {
      k(i - nsav + n, j) = k(i, j);
      p(i - nsav + n, j) = p(i, j);
    }
  }
  i1 = nsav;
  FEM_DO_SAFE(i, n + 1, 2 * n - nsav) {
    if (k(i, 3) != ie(1)) {
      goto statement_880;
    }
    i1++;
    FEM_DO_SAFE(j, 1, 5) {
      k(i1, j) = k(i, j);
      p(i1, j) = p(i, j);
    }
    if (mstu(16) != 2) {
      k(i1, 3) = nsav;
    }
  statement_880:;
  }
  FEM_DOSTEP(i, 2 * n - nsav, n + 1, -1) {
    if (k(i, 3) == ie(1)) {
      goto statement_900;
    }
    i1++;
    FEM_DO_SAFE(j, 1, 5) {
      k(i1, j) = k(i, j);
      p(i1, j) = p(i, j);
    }
    if (mstu(16) != 2) {
      k(i1, 3) = nsav;
    }
  statement_900:;
  }
  /// C
  /// C...Boost back particle system. Set production vertices.
  ludbrb(nsav + 1, n, 0.f, 0.f, dps(1) / dps(4), dps(2) / dps(4),
         dps(3) / dps(4));
  FEM_DO_SAFE(i, nsav + 1, n) {
    /// C
    FEM_DO_SAFE(j, 1, 4) { v(i, j) = v(ip, j); }
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void luindf(common& cmn, int const& ip) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  int nsav = fem::int0;
  int njet = fem::int0;
  int kqsum = fem::int0;
  int j = fem::int0;
  arr_1d<5, double> dps(fem::fill0);
  int i = fem::int0;
  int kc = fem::int0;
  int kq = fem::int0;
  float pecm = fem::float0;
  arr_1d<3, int> nfi(fem::fill0);
  int kfa = fem::int0;
  int kfla = fem::int0;
  int kflb = fem::int0;
  int ntry = fem::int0;
  arr_1d<3, int> nfl(fem::fill0);
  arr_1d<3, int> ifet(fem::fill0);
  arr_1d<3, int> kflf(fem::fill0);
  int ip1 = fem::int0;
  int nsav1 = fem::int0;
  int kflh = fem::int0;
  arr_1d<2, int> kflo(fem::fill0);
  float wf = fem::float0;
  int nstr = fem::int0;
  arr_1d<2, float> pxo(fem::fill0);
  arr_1d<2, float> pyo(fem::fill0);
  arr_1d<2, float> wo(fem::fill0);
  int istr = fem::int0;
  int irank = fem::int0;
  int kfl1 = fem::int0;
  float px1 = fem::float0;
  float py1 = fem::float0;
  float w = fem::float0;
  int kfl2 = fem::int0;
  float px2 = fem::float0;
  float py2 = fem::float0;
  float pr = fem::float0;
  float z = fem::float0;
  float the = fem::float0;
  float phi = fem::float0;
  int kflc = fem::int0;
  int nreq = fem::int0;
  int nrem = fem::int0;
  int irem = fem::int0;
  float p2min = fem::float0;
  float p2 = fem::float0;
  int isgn = fem::int0;
  int nfet = fem::int0;
  int kflfc = fem::int0;
  int kfldmp = fem::int0;
  int kf = fem::int0;
  int npos = fem::int0;
  arr_1d<4, float> psi(fem::fill0);
  float pws = fem::float0;
  float pw = fem::float0;
  int ir1 = fem::int0;
  int ir2 = fem::int0;
  float pls = fem::float0;
  float pss = fem::float0;
  float pms = fem::float0;
  float pes = fem::float0;
  float pqs = fem::float0;
  int neco = fem::int0;
  float pfac = fem::float0;
  int i1 = fem::int0;
  /// C
  /// C...Purpose: to handle the fragmentation of a jet system (or a single
  /// C...jet) according to independent fragmentation models.
  /// C
  /// C...Reset counters. Identify parton system and take copy. Check flavour.
  nsav = n;
  njet = 0;
  kqsum = 0;
  FEM_DO_SAFE(j, 1, 5) { dps(j) = 0.e0; }
  i = ip - 1;
statement_110:
  i++;
  if (i > fem::min(n, mstu(4) - mstu(32))) {
    luerrm(cmn, 12, "(LUINDF:) failed to reconstruct jet system");
    if (mstu(21) >= 1) {
      return;
    }
  }
  if (k(i, 1) != 1 && k(i, 1) != 2) {
    goto statement_110;
  }
  kc = lucomp(cmn, k(i, 2));
  if (kc == 0) {
    goto statement_110;
  }
  kq = kchg(kc, 2) * fem::isign(1, k(i, 2));
  if (kq == 0) {
    goto statement_110;
  }
  njet++;
  if (kq != 2) {
    kqsum += kq;
  }
  FEM_DO_SAFE(j, 1, 5) {
    k(nsav + njet, j) = k(i, j);
    p(nsav + njet, j) = p(i, j);
    dps(j) += fem::dble(p(i, j));
  }
  k(nsav + njet, 3) = i;
  if (k(i, 1) == 2 || (mstj(3) <= 5 && n > i && k(i + 1, 1) == 2)) {
    goto statement_110;
  }
  if (njet != 1 && kqsum != 0) {
    luerrm(cmn, 12, "(LUINDF:) unphysical flavour combination");
    if (mstu(21) >= 1) {
      return;
    }
  }
  /// C
  /// C...Boost copied system to CM frame. Find CM energy and sum flavours.
  if (njet != 1) {
    ludbrb(nsav + 1, nsav + njet, 0.f, 0.f, -dps(1) / dps(4), -dps(2) / dps(4),
           -dps(3) / dps(4));
  }
  pecm = 0.f;
  FEM_DO_SAFE(j, 1, 3) { nfi(j) = 0; }
  FEM_DO_SAFE(i, nsav + 1, nsav + njet) {
    pecm += p(i, 4);
    kfa = fem::iabs(k(i, 2));
    if (kfa <= 3) {
      nfi(kfa) += fem::isign(1, k(i, 2));
    } else if (kfa > 1000) {
      kfla = fem::mod(kfa / 1000, 10);
      kflb = fem::mod(kfa / 100, 10);
      if (kfla <= 3) {
        nfi(kfla) += fem::isign(1, k(i, 2));
      }
      if (kflb <= 3) {
        nfi(kflb) += fem::isign(1, k(i, 2));
      }
    }
  }
  /// C
  /// C...Loop over attempts made. Reset counters.
  ntry = 0;
statement_150:
  ntry++;
  n = nsav + njet;
  if (ntry > 200) {
    luerrm(cmn, 14, "(LUINDF:) caught in infinite loop");
    if (mstu(21) >= 1) {
      return;
    }
  }
  FEM_DO_SAFE(j, 1, 3) {
    nfl(j) = nfi(j);
    ifet(j) = 0;
    kflf(j) = 0;
  }
  /// C
  /// C...Loop over jets to be fragmented.
  FEM_DO_SAFE(ip1, nsav + 1, nsav + njet) {
    mstj(91) = 0;
    nsav1 = n;
    /// C
    /// C...Initial flavour and momentum values. Jet along +z axis.
    kflh = fem::iabs(k(ip1, 2));
    if (kflh > 10) {
      kflh = fem::mod(kflh / 1000, 10);
    }
    kflo(2) = 0;
    wf = p(ip1, 4) + fem::sqrt(fem::pow2(p(ip1, 1)) + fem::pow2(p(ip1, 2)) +
                               fem::pow2(p(ip1, 3)));
  /// C
  /// C...Initial values for quark or diquark jet.
  statement_170:
    if (fem::iabs(k(ip1, 2)) != 21) {
      nstr = 1;
      kflo(1) = k(ip1, 2);
      luptdi(cmn, 0, pxo(1), pyo(1));
      wo(1) = wf;
      /// C
      /// C...Initial values for gluon treated like random quark jet.
    } else if (mstj(2) <= 2) {
      nstr = 1;
      if (mstj(2) == 2) {
        mstj(91) = 1;
      }
      kflo(1) = fem::fint(1.f + (2.f + parj(2)) * rlu(cmn, 0)) *
                fem::pow((-1), fem::fint(rlu(cmn, 0) + 0.5f));
      luptdi(cmn, 0, pxo(1), pyo(1));
      wo(1) = wf;
      /// C
      /// C...Initial values for gluon treated like quark-antiquark jet pair,
      /// C...sharing energy according to Altarelli-Parisi splitting function.
    } else {
      nstr = 2;
      if (mstj(2) == 4) {
        mstj(91) = 1;
      }
      kflo(1) = fem::fint(1.f + (2.f + parj(2)) * rlu(cmn, 0)) *
                fem::pow((-1), fem::fint(rlu(cmn, 0) + 0.5f));
      kflo(2) = -kflo(1);
      luptdi(cmn, 0, pxo(1), pyo(1));
      pxo(2) = -pxo(1);
      pyo(2) = -pyo(1);
      wo(1) = wf * fem::pow(rlu(cmn, 0), (1.f / 3.f));
      wo(2) = wf - wo(1);
    }
    /// C
    /// C...Initial values for rank, flavour, pT and W+.
    FEM_DO_SAFE(istr, 1, nstr) {
    statement_180:
      i = n;
      irank = 0;
      kfl1 = kflo(istr);
      px1 = pxo(istr);
      py1 = pyo(istr);
      w = wo(istr);
    /// C
    /// C...New hadron. Generate flavour and hadron species.
    statement_190:
      i++;
      if (i >= mstu(4) - mstu(32) - njet - 5) {
        luerrm(cmn, 11, "(LUINDF:) no more memory left in LUJETS");
        if (mstu(21) >= 1) {
          return;
        }
      }
      irank++;
      k(i, 1) = 1;
      k(i, 3) = ip1;
      k(i, 4) = 0;
      k(i, 5) = 0;
    statement_200:
      lukfdi(cmn, kfl1, 0, kfl2, k(i, 2));
      if (k(i, 2) == 0) {
        goto statement_180;
      }
      if (mstj(12) >= 3 && irank == 1 && fem::iabs(kfl1) <= 10 &&
          fem::iabs(kfl2) > 10) {
        if (rlu(cmn, 0) > parj(19)) {
          goto statement_200;
        }
      }
      /// C
      /// C...Find hadron mass. Generate four-momentum.
      p(i, 5) = ulmass(cmn, k(i, 2));
      luptdi(cmn, kfl1, px2, py2);
      p(i, 1) = px1 + px2;
      p(i, 2) = py1 + py2;
      pr = fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
      luzdis(cmn, kfl1, kfl2, pr, z);
      p(i, 3) = 0.5f * (z * w - pr / (z * w));
      p(i, 4) = 0.5f * (z * w + pr / (z * w));
      if (mstj(3) >= 1 && irank == 1 && kflh >= 4 && p(i, 3) <= 0.001f) {
        if (w >= p(i, 5) + 0.5f * parj(32)) {
          goto statement_180;
        }
        p(i, 3) = 0.0001f;
        p(i, 4) = fem::sqrt(pr);
        z = p(i, 4) / w;
      }
      /// C
      /// C...Remaining flavour and momentum.
      kfl1 = -kfl2;
      px1 = -px2;
      py1 = -py2;
      w = (1.f - z) * w;
      FEM_DO_SAFE(j, 1, 5) { v(i, j) = 0.f; }
      /// C
      /// C...Check if pL acceptable. Go back for new hadron if enough energy.
      if (mstj(3) >= 0 && p(i, 3) < 0.f) {
        i = i - 1;
      }
      if (w > parj(31)) {
        goto statement_190;
      }
      n = i;
    }
    if (fem::mod(mstj(3), 5) == 4 && n == nsav1) {
      wf += 0.1f * parj(32);
    }
    if (fem::mod(mstj(3), 5) == 4 && n == nsav1) {
      goto statement_170;
    }
    /// C
    /// C...Rotate jet to new direction.
    the = ulangl(cmn, p(ip1, 3),
                 fem::sqrt(fem::pow2(p(ip1, 1)) + fem::pow2(p(ip1, 2))));
    phi = ulangl(cmn, p(ip1, 1), p(ip1, 2));
    ludbrb(nsav1 + 1, n, the, phi, 0e0, 0e0, 0e0);
    k(k(ip1, 3), 4) = nsav1 + 1;
    k(k(ip1, 3), 5) = n;
    /// C
    /// C...End of jet generation loop. Skip conservation in some cases.
  }
  if (njet == 1 || mstj(3) <= 0) {
    goto statement_470;
  }
  if (fem::mod(mstj(3), 5) != 0 && n - nsav - njet < 2) {
    goto statement_150;
  }
  /// C
  /// C...Subtract off produced hadron flavours, finished if zero.
  FEM_DO_SAFE(i, nsav + njet + 1, n) {
    kfa = fem::iabs(k(i, 2));
    kfla = fem::mod(kfa / 1000, 10);
    kflb = fem::mod(kfa / 100, 10);
    kflc = fem::mod(kfa / 10, 10);
    if (kfla == 0) {
      if (kflb <= 3) {
        nfl(kflb) = nfl(kflb) - fem::isign(1, k(i, 2)) * fem::pow((-1), kflb);
      }
      if (kflc <= 3) {
        nfl(kflc) += fem::isign(1, k(i, 2)) * fem::pow((-1), kflb);
      }
    } else {
      if (kfla <= 3) {
        nfl(kfla) = nfl(kfla) - fem::isign(1, k(i, 2));
      }
      if (kflb <= 3) {
        nfl(kflb) = nfl(kflb) - fem::isign(1, k(i, 2));
      }
      if (kflc <= 3) {
        nfl(kflc) = nfl(kflc) - fem::isign(1, k(i, 2));
      }
    }
  }
  nreq = (fem::iabs(nfl(1)) + fem::iabs(nfl(2)) + fem::iabs(nfl(3)) -
          fem::iabs(nfl(1) + nfl(2) + nfl(3))) /
             2 +
         fem::iabs(nfl(1) + nfl(2) + nfl(3)) / 3;
  if (nreq == 0) {
    goto statement_320;
  }
  /// C
  /// C...Take away flavour of low-momentum particles until enough freedom.
  nrem = 0;
statement_250:
  irem = 0;
  p2min = fem::pow2(pecm);
  FEM_DO_SAFE(i, nsav + njet + 1, n) {
    p2 = fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) + fem::pow2(p(i, 3));
    if (k(i, 1) == 1 && p2 < p2min) {
      irem = i;
    }
    if (k(i, 1) == 1 && p2 < p2min) {
      p2min = p2;
    }
  }
  if (irem == 0) {
    goto statement_150;
  }
  k(irem, 1) = 7;
  kfa = fem::iabs(k(irem, 2));
  kfla = fem::mod(kfa / 1000, 10);
  kflb = fem::mod(kfa / 100, 10);
  kflc = fem::mod(kfa / 10, 10);
  if (kfla >= 4 || kflb >= 4) {
    k(irem, 1) = 8;
  }
  if (k(irem, 1) == 8) {
    goto statement_250;
  }
  if (kfla == 0) {
    isgn = fem::isign(1, k(irem, 2)) * fem::pow((-1), kflb);
    if (kflb <= 3) {
      nfl(kflb) += isgn;
    }
    if (kflc <= 3) {
      nfl(kflc) = nfl(kflc) - isgn;
    }
  } else {
    if (kfla <= 3) {
      nfl(kfla) += fem::isign(1, k(irem, 2));
    }
    if (kflb <= 3) {
      nfl(kflb) += fem::isign(1, k(irem, 2));
    }
    if (kflc <= 3) {
      nfl(kflc) += fem::isign(1, k(irem, 2));
    }
  }
  nrem++;
  nreq = (fem::iabs(nfl(1)) + fem::iabs(nfl(2)) + fem::iabs(nfl(3)) -
          fem::iabs(nfl(1) + nfl(2) + nfl(3))) /
             2 +
         fem::iabs(nfl(1) + nfl(2) + nfl(3)) / 3;
  if (nreq > nrem) {
    goto statement_250;
  }
  FEM_DO_SAFE(i, nsav + njet + 1, n) {
    if (k(i, 1) == 8) {
      k(i, 1) = 1;
    }
  }
/// C
/// C...Find combination of existing and new flavours for hadron.
statement_280:
  nfet = 2;
  if (nfl(1) + nfl(2) + nfl(3) != 0) {
    nfet = 3;
  }
  if (nreq < nrem) {
    nfet = 1;
  }
  if (fem::iabs(nfl(1)) + fem::iabs(nfl(2)) + fem::iabs(nfl(3)) == 0) {
    nfet = 0;
  }
  FEM_DO_SAFE(j, 1, nfet) {
    ifet(j) =
        1 +
        fem::fint((fem::iabs(nfl(1)) + fem::iabs(nfl(2)) + fem::iabs(nfl(3))) *
                  rlu(cmn, 0));
    kflf(j) = fem::isign(1, nfl(1));
    if (ifet(j) > fem::iabs(nfl(1))) {
      kflf(j) = fem::isign(2, nfl(2));
    }
    if (ifet(j) > fem::iabs(nfl(1)) + fem::iabs(nfl(2))) {
      kflf(j) = fem::isign(3, nfl(3));
    }
  }
  if (nfet == 2 && (ifet(1) == ifet(2) || kflf(1) * kflf(2) > 0)) {
    goto statement_280;
  }
  if (nfet == 3 &&
      (ifet(1) == ifet(2) || ifet(1) == ifet(3) || ifet(2) == ifet(3) ||
       kflf(1) * kflf(2) < 0 || kflf(1) * kflf(3) < 0 ||
       kflf(1) * (nfl(1) + nfl(2) + nfl(3)) < 0)) {
    goto statement_280;
  }
  if (nfet == 0) {
    kflf(1) = 1 + fem::fint((2.f + parj(2)) * rlu(cmn, 0));
  }
  if (nfet == 0) {
    kflf(2) = -kflf(1);
  }
  if (nfet == 1) {
    kflf(2) =
        fem::isign(1 + fem::fint((2.f + parj(2)) * rlu(cmn, 0)), -kflf(1));
  }
  if (nfet <= 2) {
    kflf(3) = 0;
  }
  if (kflf(3) != 0) {
    kflfc = fem::isign(
        1000 * fem::max(fem::iabs(kflf(1)), fem::iabs(kflf(3))) +
            100 * fem::min(fem::iabs(kflf(1)), fem::iabs(kflf(3))) + 1,
        kflf(1));
    if (kflf(1) == kflf(3) || (1.f + 3.f * parj(4)) * rlu(cmn, 0) > 1.f) {
      kflfc += fem::isign(2, kflfc);
    }
  } else {
    kflfc = kflf(1);
  }
  lukfdi(cmn, kflfc, kflf(2), kfldmp, kf);
  if (kf == 0) {
    goto statement_280;
  }
  FEM_DO_SAFE(j, 1, fem::max(2, nfet)) {
    nfl(fem::iabs(kflf(j))) = nfl(fem::iabs(kflf(j))) - fem::isign(1, kflf(j));
  }
  /// C
  /// C...Store hadron at random among free positions.
  npos = fem::min(1 + fem::fint(rlu(cmn, 0) * nrem), nrem);
  FEM_DO_SAFE(i, nsav + njet + 1, n) {
    if (k(i, 1) == 7) {
      npos = npos - 1;
    }
    if (k(i, 1) == 1 || npos != 0) {
      goto statement_310;
    }
    k(i, 1) = 1;
    k(i, 2) = kf;
    p(i, 5) = ulmass(cmn, k(i, 2));
    p(i, 4) = fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                        fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
  statement_310:;
  }
  nrem = nrem - 1;
  nreq = (fem::iabs(nfl(1)) + fem::iabs(nfl(2)) + fem::iabs(nfl(3)) -
          fem::iabs(nfl(1) + nfl(2) + nfl(3))) /
             2 +
         fem::iabs(nfl(1) + nfl(2) + nfl(3)) / 3;
  if (nrem > 0) {
    goto statement_280;
  }
/// C
/// C...Compensate for missing momentum in global scheme (3 options).
statement_320:
  if (fem::mod(mstj(3), 5) != 0 && fem::mod(mstj(3), 5) != 4) {
    FEM_DO_SAFE(j, 1, 3) {
      psi(j) = 0.f;
      FEM_DO_SAFE(i, nsav + njet + 1, n) { psi(j) += p(i, j); }
    }
    psi(4) = fem::pow2(psi(1)) + fem::pow2(psi(2)) + fem::pow2(psi(3));
    pws = 0.f;
    FEM_DO_SAFE(i, nsav + njet + 1, n) {
      if (fem::mod(mstj(3), 5) == 1) {
        pws += p(i, 4);
      }
      if (fem::mod(mstj(3), 5) == 2) {
        pws += fem::sqrt(fem::pow2(p(i, 5)) +
                         fem::pow2((psi(1) * p(i, 1) + psi(2) * p(i, 2) +
                                    psi(3) * p(i, 3))) /
                             psi(4));
      }
      if (fem::mod(mstj(3), 5) == 3) {
        pws += 1.f;
      }
    }
    FEM_DO_SAFE(i, nsav + njet + 1, n) {
      if (fem::mod(mstj(3), 5) == 1) {
        pw = p(i, 4);
      }
      if (fem::mod(mstj(3), 5) == 2) {
        pw = fem::sqrt(fem::pow2(p(i, 5)) +
                       fem::pow2((psi(1) * p(i, 1) + psi(2) * p(i, 2) +
                                  psi(3) * p(i, 3))) /
                           psi(4));
      }
      if (fem::mod(mstj(3), 5) == 3) {
        pw = 1.f;
      }
      FEM_DO_SAFE(j, 1, 3) { p(i, j) = p(i, j) - psi(j) * pw / pws; }
      p(i, 4) = fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                          fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
    }
    /// C
    /// C...Compensate for missing momentum withing each jet separately.
  } else if (fem::mod(mstj(3), 5) == 4) {
    FEM_DO_SAFE(i, n + 1, n + njet) {
      k(i, 1) = 0;
      FEM_DO_SAFE(j, 1, 5) { p(i, j) = 0.f; }
    }
    FEM_DO_SAFE(i, nsav + njet + 1, n) {
      ir1 = k(i, 3);
      ir2 = n + ir1 - nsav;
      k(ir2, 1)++;
      pls =
          (p(i, 1) * p(ir1, 1) + p(i, 2) * p(ir1, 2) + p(i, 3) * p(ir1, 3)) /
          (fem::pow2(p(ir1, 1)) + fem::pow2(p(ir1, 2)) + fem::pow2(p(ir1, 3)));
      FEM_DO_SAFE(j, 1, 3) { p(ir2, j) += p(i, j) - pls * p(ir1, j); }
      p(ir2, 4) += p(i, 4);
      p(ir2, 5) += pls;
    }
    pss = 0.f;
    FEM_DO_SAFE(i, n + 1, n + njet) {
      if (k(i, 1) != 0) {
        pss += p(i, 4) / (pecm * (0.8f * p(i, 5) + 0.2f));
      }
    }
    FEM_DO_SAFE(i, nsav + njet + 1, n) {
      ir1 = k(i, 3);
      ir2 = n + ir1 - nsav;
      pls =
          (p(i, 1) * p(ir1, 1) + p(i, 2) * p(ir1, 2) + p(i, 3) * p(ir1, 3)) /
          (fem::pow2(p(ir1, 1)) + fem::pow2(p(ir1, 2)) + fem::pow2(p(ir1, 3)));
      FEM_DO_SAFE(j, 1, 3) {
        p(i, j) = p(i, j) - p(ir2, j) / k(ir2, 1) +
                  (1.f / (p(ir2, 5) * pss) - 1.f) * pls * p(ir1, j);
      }
      p(i, 4) = fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                          fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
    }
  }
  /// C
  /// C...Scale momenta for energy conservation.
  if (fem::mod(mstj(3), 5) != 0) {
    pms = 0.f;
    pes = 0.f;
    pqs = 0.f;
    FEM_DO_SAFE(i, nsav + njet + 1, n) {
      pms += p(i, 5);
      pes += p(i, 4);
      pqs += fem::pow2(p(i, 5)) / p(i, 4);
    }
    if (pms >= pecm) {
      goto statement_150;
    }
    neco = 0;
  statement_440:
    neco++;
    pfac = (pecm - pqs) / (pes - pqs);
    pes = 0.f;
    pqs = 0.f;
    FEM_DO_SAFE(i, nsav + njet + 1, n) {
      FEM_DO_SAFE(j, 1, 3) { p(i, j) = pfac * p(i, j); }
      p(i, 4) = fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                          fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
      pes += p(i, 4);
      pqs += fem::pow2(p(i, 5)) / p(i, 4);
    }
    if (neco < 10 && fem::abs(pecm - pes) > 2e-6f * pecm) {
      goto statement_440;
    }
  }
/// C
/// C...Origin of produced particles and parton daughter pointers.
statement_470:
  FEM_DO_SAFE(i, nsav + njet + 1, n) {
    if (mstu(16) != 2) {
      k(i, 3) = nsav + 1;
    }
    if (mstu(16) == 2) {
      k(i, 3) = k(k(i, 3), 3);
    }
  }
  FEM_DO_SAFE(i, nsav + 1, nsav + njet) {
    i1 = k(i, 3);
    k(i1, 1) += 10;
    if (mstu(16) != 2) {
      k(i1, 4) = nsav + 1;
      k(i1, 5) = nsav + 1;
    } else {
      k(i1, 4) = k(i1, 4) - njet + 1;
      k(i1, 5) = k(i1, 5) - njet + 1;
      if (k(i1, 5) < k(i1, 4)) {
        k(i1, 4) = 0;
        k(i1, 5) = 0;
      }
    }
  }
  /// C
  /// C...Document independent fragmentation system. Remove copy of jets.
  nsav++;
  k(nsav, 1) = 11;
  k(nsav, 2) = 93;
  k(nsav, 3) = ip;
  k(nsav, 4) = nsav + 1;
  k(nsav, 5) = n - njet + 1;
  FEM_DO_SAFE(j, 1, 4) {
    p(nsav, j) = fem::sngl(dps(j));
    v(nsav, j) = v(ip, j);
  }
  p(nsav, 5) = fem::sqrt(
      fem::sngl(fem::max(0e0, fem::pow2(dps(4)) - fem::pow2(dps(1)) -
                                  fem::pow2(dps(2)) - fem::pow2(dps(3)))));
  v(nsav, 5) = 0.f;
  FEM_DO_SAFE(i, nsav + njet, n) {
    FEM_DO_SAFE(j, 1, 5) {
      k(i - njet + 1, j) = k(i, j);
      p(i - njet + 1, j) = p(i, j);
      v(i - njet + 1, j) = v(i, j);
    }
  }
  n = n - njet + 1;
  /// C
  /// C...Boost back particle system. Set production vertices.
  if (njet != 1) {
    ludbrb(nsav + 1, n, 0.f, 0.f, dps(1) / dps(4), dps(2) / dps(4),
           dps(3) / dps(4));
  }
  FEM_DO_SAFE(i, nsav + 1, n) {
    FEM_DO_SAFE(j, 1, 4) { v(i, j) = v(ip, j); }
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void lushow(common& cmn, int const& ip1, int const& ip2, float const& qmax) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  arr_2d<5, 40, float> pmth(fem::fill0);
  float pmqth1 = fem::float0;
  float pmqth2 = fem::float0;
  int identifier_if = fem::int0;
  float pt2min = fem::float0;
  float alams = fem::float0;
  float alfm = fem::float0;
  int m3jc = fem::int0;
  int npa = fem::int0;
  arr_1d<4, int> ipa(fem::fill0);
  int i = fem::int0;
  int irej = fem::int0;
  int j = fem::int0;
  arr_1d<5, float> ps(fem::fill0);
  float pm = fem::float0;
  arr_1d<4, int> kfla(fem::fill0);
  arr_1d<4, float> pma(fem::fill0);
  int ns = fem::int0;
  int nep = fem::int0;
  int im = fem::int0;
  int kflm = fem::int0;
  int igm = fem::int0;
  int iau = fem::int0;
  int ip = fem::int0;
  arr_1d<4, int> kfld(fem::fill0);
  arr_1d<4, int> itry(fem::fill0);
  arr_1d<4, int> isl(fem::fill0);
  arr_1d<4, int> isi(fem::fill0);
  int islm = fem::int0;
  float pem = fem::float0;
  arr_1d<4, float> pmsd(fem::fill0);
  int inum = fem::int0;
  float rmax = fem::float0;
  float rpm = fem::float0;
  arr_1d<4, int> iep(fem::fill0);
  arr_1d<4, int> kfl(fem::fill0);
  float z = fem::float0;
  float pmed = fem::float0;
  float zc = fem::float0;
  float zce = fem::float0;
  float fbr = fem::float0;
  float fbre = fem::float0;
  float pms = fem::float0;
  float pm2 = fem::float0;
  float b0 = fem::float0;
  float pmsqcd = fem::float0;
  int mce = fem::int0;
  float pmsqed = fem::float0;
  int kflb = fem::int0;
  float pmq = fem::float0;
  float pmq0 = fem::float0;
  int kflgd1 = fem::int0;
  int kflgd2 = fem::int0;
  float ped = fem::float0;
  float pmqth3 = fem::float0;
  float pmq1 = fem::float0;
  float pmq2 = fem::float0;
  float zd = fem::float0;
  float zh = fem::float0;
  float zl = fem::float0;
  float zu = fem::float0;
  float x1 = fem::float0;
  float x2 = fem::float0;
  float x3 = fem::float0;
  int ki1 = fem::int0;
  int ki2 = fem::int0;
  float qf1 = fem::float0;
  float qf2 = fem::float0;
  float wshow = fem::float0;
  float wme = fem::float0;
  int maom = fem::int0;
  float zm = fem::float0;
  float the2id = fem::float0;
  int iaom = fem::int0;
  float the2im = fem::float0;
  float pa1s = fem::float0;
  float pa2s = fem::float0;
  float pa3s = fem::float0;
  float pts = fem::float0;
  int i1 = fem::int0;
  int kflda = fem::int0;
  int i2 = fem::int0;
  float pml = fem::float0;
  float zdr1 = fem::float0;
  float zdr2 = fem::float0;
  int mazip = fem::int0;
  int mazic = fem::int0;
  float ped1 = fem::float0;
  float pzm = fem::float0;
  float pmls = fem::float0;
  float pt = fem::float0;
  float hazip = fem::float0;
  float zau = fem::float0;
  float hazic = fem::float0;
  float zs = fem::float0;
  float zgm = fem::float0;
  float phi = fem::float0;
  float bex = fem::float0;
  float bey = fem::float0;
  float bez = fem::float0;
  float ga = fem::float0;
  float gabep = fem::float0;
  float the = fem::float0;
  arr_1d<4, double> dp(fem::fill0);
  double dbp = fem::double0;
  double dgabp = fem::double0;
  arr_2d<5, 4, double> dpt(fem::fill0);
  double dpma = fem::double0;
  double dpmd = fem::double0;
  double dpmm = fem::double0;
  float cad = fem::float0;
  int iim = fem::int0;
  int id1 = fem::int0;
  int id2 = fem::int0;
  float chi = fem::float0;
  double dbex = fem::double0;
  double dbey = fem::double0;
  double dbez = fem::double0;
  /// C
  /// C...Purpose: to generate timelike parton showers from given partons.
  /// C
  /// C...Initialization of cutoff masses etc.
  if (mstj(41) <= 0 || (mstj(41) == 1 && qmax <= parj(82)) ||
      qmax <= fem::min(parj(82), parj(83)) || mstj(41) >= 3) {
    return;
  }
  pmth(1, 21) = ulmass(cmn, 21);
  pmth(2, 21) = fem::sqrt(fem::pow2(pmth(1, 21)) + 0.25f * fem::pow2(parj(82)));
  pmth(3, 21) = 2.f * pmth(2, 21);
  pmth(4, 21) = pmth(3, 21);
  pmth(5, 21) = pmth(3, 21);
  pmth(1, 22) = ulmass(cmn, 22);
  pmth(2, 22) = fem::sqrt(fem::pow2(pmth(1, 22)) + 0.25f * fem::pow2(parj(83)));
  pmth(3, 22) = 2.f * pmth(2, 22);
  pmth(4, 22) = pmth(3, 22);
  pmth(5, 22) = pmth(3, 22);
  pmqth1 = parj(82);
  if (mstj(41) == 2) {
    pmqth1 = fem::min(parj(82), parj(83));
  }
  pmqth2 = pmth(2, 21);
  if (mstj(41) == 2) {
    pmqth2 = fem::min(pmth(2, 21), pmth(2, 22));
  }
  FEM_DO_SAFE(identifier_if, 1, 8) {
    pmth(1, identifier_if) = ulmass(cmn, identifier_if);
    pmth(2, identifier_if) = fem::sqrt(fem::pow2(pmth(1, identifier_if)) +
                                       0.25f * fem::pow2(pmqth1));
    pmth(3, identifier_if) = pmth(2, identifier_if) + pmqth2;
    pmth(4, identifier_if) = fem::sqrt(fem::pow2(pmth(1, identifier_if)) +
                                       0.25f * fem::pow2(parj(82))) +
                             pmth(2, 21);
    pmth(5, identifier_if) = fem::sqrt(fem::pow2(pmth(1, identifier_if)) +
                                       0.25f * fem::pow2(parj(83))) +
                             pmth(2, 22);
  }
  pt2min = fem::pow2(fem::max(0.5f * parj(82), 1.1f * parj(81)));
  alams = fem::pow2(parj(81));
  alfm = fem::log(pt2min / alams);
  /// C
  /// C...Store positions of shower initiating partons.
  m3jc = 0;
  if (ip1 > 0 && ip1 <= fem::min(n, mstu(4) - mstu(32)) && ip2 == 0) {
    npa = 1;
    ipa(1) = ip1;
  } else if (fem::min(ip1, ip2) > 0 &&
             fem::max(ip1, ip2) <= fem::min(n, mstu(4) - mstu(32))) {
    npa = 2;
    ipa(1) = ip1;
    ipa(2) = ip2;
  } else if (ip1 > 0 && ip1 <= fem::min(n, mstu(4) - mstu(32)) && ip2 < 0 &&
             ip2 >= -3) {
    npa = fem::iabs(ip2);
    FEM_DO_SAFE(i, 1, npa) { ipa(i) = ip1 + i - 1; }
  } else {
    luerrm(cmn, 12, "(LUSHOW:) failed to reconstruct showering system");
    if (mstu(21) >= 1) {
      return;
    }
  }
  /// C
  /// C...Check on phase space available for emission.
  irej = 0;
  FEM_DO_SAFE(j, 1, 5) { ps(j) = 0.f; }
  pm = 0.f;
  FEM_DO_SAFE(i, 1, npa) {
    kfla(i) = fem::iabs(k(ipa(i), 2));
    pma(i) = p(ipa(i), 5);
    if (kfla(i) != 0 && (kfla(i) <= 8 || kfla(i) == 21)) {
      pma(i) = pmth(3, kfla(i));
    }
    pm += pma(i);
    if (kfla(i) == 0 || (kfla(i) > 8 && kfla(i) != 21) || pma(i) > qmax) {
      irej++;
    }
    FEM_DO_SAFE(j, 1, 4) { ps(j) += p(ipa(i), j); }
  }
  if (irej == npa) {
    return;
  }
  ps(5) = fem::sqrt(fem::max(0.f, fem::pow2(ps(4)) - fem::pow2(ps(1)) -
                                      fem::pow2(ps(2)) - fem::pow2(ps(3))));
  if (npa == 1) {
    ps(5) = ps(4);
  }
  if (ps(5) <= pm + pmqth1) {
    return;
  }
  if (npa == 2 && mstj(47) >= 1) {
    if (kfla(1) >= 1 && kfla(1) <= 8 && kfla(2) >= 1 && kfla(2) <= 8) {
      m3jc = 1;
    }
    if (mstj(47) >= 2) {
      m3jc = 1;
    }
  }
  /// C
  /// C...Define imagined single initiator of shower for parton system.
  ns = n;
  if (n > mstu(4) - mstu(32) - 5) {
    luerrm(cmn, 11, "(LUSHOW:) no more memory left in LUJETS");
    if (mstu(21) >= 1) {
      return;
    }
  }
  if (npa >= 2) {
    k(n + 1, 1) = 11;
    k(n + 1, 2) = 21;
    k(n + 1, 3) = 0;
    k(n + 1, 4) = 0;
    k(n + 1, 5) = 0;
    p(n + 1, 1) = 0.f;
    p(n + 1, 2) = 0.f;
    p(n + 1, 3) = 0.f;
    p(n + 1, 4) = ps(5);
    p(n + 1, 5) = ps(5);
    v(n + 1, 5) = fem::pow2(ps(5));
    n++;
  }
  /// C
  /// C...Loop over partons that may branch.
  nep = npa;
  im = ns;
  if (npa == 1) {
    im = ns - 1;
  }
statement_140:
  im++;
  if (n > ns) {
    if (im > n) {
      goto statement_380;
    }
    kflm = fem::iabs(k(im, 2));
    if (kflm == 0 || (kflm > 8 && kflm != 21)) {
      goto statement_140;
    }
    if (p(im, 5) < pmth(2, kflm)) {
      goto statement_140;
    }
    igm = k(im, 3);
  } else {
    igm = -1;
  }
  if (n + nep > mstu(4) - mstu(32) - 5) {
    luerrm(cmn, 11, "(LUSHOW:) no more memory left in LUJETS");
    if (mstu(21) >= 1) {
      return;
    }
  }
  /// C
  /// C...Position of aunt (sister to branching parton).
  /// C...Origin and flavour of daughters.
  iau = 0;
  if (igm > 0) {
    if (k(im - 1, 3) == igm) {
      iau = im - 1;
    }
    if (n >= im + 1 && k(im + 1, 3) == igm) {
      iau = im + 1;
    }
  }
  if (igm >= 0) {
    k(im, 4) = n + 1;
    FEM_DO_SAFE(i, 1, nep) { k(n + i, 3) = im; }
  } else {
    k(n + 1, 3) = ipa(1);
  }
  if (igm <= 0) {
    FEM_DO_SAFE(i, 1, nep) { k(n + i, 2) = k(ipa(i), 2); }
  } else if (kflm != 21) {
    k(n + 1, 2) = k(im, 2);
    k(n + 2, 2) = k(im, 5);
  } else if (k(im, 5) == 21) {
    k(n + 1, 2) = 21;
    k(n + 2, 2) = 21;
  } else {
    k(n + 1, 2) = k(im, 5);
    k(n + 2, 2) = -k(im, 5);
  }
  /// C
  /// C...Reset flags on daughers and tries made.
  FEM_DO_SAFE(ip, 1, nep) {
    k(n + ip, 1) = 3;
    k(n + ip, 4) = 0;
    k(n + ip, 5) = 0;
    kfld(ip) = fem::iabs(k(n + ip, 2));
    itry(ip) = 0;
    isl(ip) = 0;
    isi(ip) = 0;
    if (kfld(ip) > 0 && (kfld(ip) <= 8 || kfld(ip) == 21)) {
      isi(ip) = 1;
    }
  }
  islm = 0;
  /// C
  /// C...Maximum virtuality of daughters.
  if (igm <= 0) {
    FEM_DO_SAFE(i, 1, npa) {
      if (npa >= 3) {
        p(n + i, 4) = (ps(4) * p(ipa(i), 4) - ps(1) * p(ipa(i), 1) -
                       ps(2) * p(ipa(i), 2) - ps(3) * p(ipa(i), 3)) /
                      ps(5);
      }
      p(n + i, 5) = fem::min(qmax, ps(5));
      if (npa >= 3) {
        p(n + i, 5) = fem::min(p(n + i, 5), p(n + i, 4));
      }
      if (isi(i) == 0) {
        p(n + i, 5) = p(ipa(i), 5);
      }
    }
  } else {
    if (mstj(43) <= 2) {
      pem = v(im, 2);
    }
    if (mstj(43) >= 3) {
      pem = p(im, 4);
    }
    p(n + 1, 5) = fem::min(p(im, 5), v(im, 1) * pem);
    p(n + 2, 5) = fem::min(p(im, 5), (1.f - v(im, 1)) * pem);
    if (k(n + 2, 2) == 22) {
      p(n + 2, 5) = pmth(1, 22);
    }
  }
  FEM_DO_SAFE(i, 1, nep) {
    pmsd(i) = p(n + i, 5);
    if (isi(i) == 1) {
      if (p(n + i, 5) <= pmth(3, kfld(i))) {
        p(n + i, 5) = pmth(1, kfld(i));
      }
    }
    v(n + i, 5) = fem::pow2(p(n + i, 5));
  }
/// C
/// C...Choose one of the daughters for evolution.
statement_200:
  inum = 0;
  if (nep == 1) {
    inum = 1;
  }
  FEM_DO_SAFE(i, 1, nep) {
    if (inum == 0 && isl(i) == 1) {
      inum = i;
    }
  }
  FEM_DO_SAFE(i, 1, nep) {
    if (inum == 0 && itry(i) == 0 && isi(i) == 1) {
      if (p(n + i, 5) >= pmth(2, kfld(i))) {
        inum = i;
      }
    }
  }
  if (inum == 0) {
    rmax = 0.f;
    FEM_DO_SAFE(i, 1, nep) {
      if (isi(i) == 1 && pmsd(i) >= pmqth2) {
        rpm = p(n + i, 5) / pmsd(i);
        if (rpm > rmax && p(n + i, 5) >= pmth(2, kfld(i))) {
          rmax = rpm;
          inum = i;
        }
      }
    }
  }
  /// C
  /// C...Store information on choice of evolving daughter.
  inum = fem::max(1, inum);
  iep(1) = n + inum;
  FEM_DO_SAFE(i, 2, nep) {
    iep(i) = iep(i - 1) + 1;
    if (iep(i) > n + nep) {
      iep(i) = n + 1;
    }
  }
  FEM_DO_SAFE(i, 1, nep) { kfl(i) = fem::iabs(k(iep(i), 2)); }
  itry(inum)++;
  if (itry(inum) > 200) {
    luerrm(cmn, 14, "(LUSHOW:) caught in infinite loop");
    if (mstu(21) >= 1) {
      return;
    }
  }
  z = 0.5f;
  if (kfl(1) == 0 || (kfl(1) > 8 && kfl(1) != 21)) {
    goto statement_300;
  }
  if (p(iep(1), 5) < pmth(2, kfl(1))) {
    goto statement_300;
  }
  /// C
  /// C...Calculate allowed z range.
  if (nep == 1) {
    pmed = ps(4);
  } else if (igm == 0 || mstj(43) <= 2) {
    pmed = p(im, 5);
  } else {
    if (inum == 1) {
      pmed = v(im, 1) * pem;
    }
    if (inum == 2) {
      pmed = (1.f - v(im, 1)) * pem;
    }
  }
  if (fem::mod(mstj(43), 2) == 1) {
    zc = pmth(2, 21) / pmed;
    zce = pmth(2, 22) / pmed;
  } else {
    zc = 0.5f * (1.f - fem::sqrt(fem::max(
                           0.f, 1.f - fem::pow2((2.f * pmth(2, 21) / pmed)))));
    if (zc < 1e-4f) {
      zc = fem::pow2((pmth(2, 21) / pmed));
    }
    zce = 0.5f * (1.f - fem::sqrt(fem::max(
                            0.f, 1.f - fem::pow2((2.f * pmth(2, 22) / pmed)))));
    if (zce < 1e-4f) {
      zce = fem::pow2((pmth(2, 22) / pmed));
    }
  }
  zc = fem::min(zc, 0.491f);
  zce = fem::min(zce, 0.491f);
  if ((mstj(41) == 1 && zc > 0.49f) ||
      (mstj(41) == 2 && fem::min(zc, zce) > 0.49f)) {
    p(iep(1), 5) = pmth(1, kfl(1));
    v(iep(1), 5) = fem::pow2(p(iep(1), 5));
    goto statement_300;
  }
  /// C
  /// C...Integral of Altarelli-Parisi z kernel for QCD.
  if (mstj(49) == 0 && kfl(1) == 21) {
    fbr = 6.f * fem::log((1.f - zc) / zc) + mstj(45) * (0.5f - zc);
  } else if (mstj(49) == 0) {
    fbr = (8.f / 3.f) * fem::log((1.f - zc) / zc);
    /// C
    /// C...Integral of Altarelli-Parisi z kernel for scalar gluon.
  } else if (mstj(49) == 1 && kfl(1) == 21) {
    fbr = (parj(87) + mstj(45) * parj(88)) * (1.f - 2.f * zc);
  } else if (mstj(49) == 1) {
    fbr = (1.f - 2.f * zc) / 3.f;
    if (igm == 0 && m3jc == 1) {
      fbr = 4.f * fbr;
    }
    /// C
    /// C...Integral of Altarelli-Parisi z kernel for Abelian vector gluon.
  } else if (kfl(1) == 21) {
    fbr = 6.f * mstj(45) * (0.5f - zc);
  } else {
    fbr = 2.f * fem::log((1.f - zc) / zc);
  }
  /// C
  /// C...Integral of Altarelli-Parisi kernel for photon emission.
  if (mstj(41) == 2 && kfl(1) >= 1 && kfl(1) <= 8) {
    fbre =
        fem::pow2((kchg(kfl(1), 1) / 3.f)) * 2.f * fem::log((1.f - zce) / zce);
  }
/// C
/// C...Inner veto algorithm starts. Find maximum mass for evolution.
statement_260:
  pms = v(iep(1), 5);
  if (igm >= 0) {
    pm2 = 0.f;
    FEM_DO_SAFE(i, 2, nep) {
      pm = p(iep(i), 5);
      if (kfl(i) > 0 && (kfl(i) <= 8 || kfl(i) == 21)) {
        pm = pmth(2, kfl(i));
      }
      pm2 += pm;
    }
    pms = fem::min(pms, fem::pow2((p(im, 5) - pm2)));
  }
  /// C
  /// C...Select mass for daughter in QCD evolution.
  b0 = 27.f / 6.f;
  FEM_DO_SAFE(identifier_if, 4, mstj(45)) {
    if (pms > 4.f * fem::pow2(pmth(2, identifier_if))) {
      b0 = (33.f - 2.f * identifier_if) / 6.f;
    }
  }
  if (mstj(44) <= 0) {
    pmsqcd = pms * fem::exp(fem::max(-100.f, fem::log(rlu(cmn, 0)) * paru(2) /
                                                 (paru(111) * fbr)));
  } else if (mstj(44) == 1) {
    pmsqcd =
        4.f * alams *
        fem::pow((0.25f * pms / alams), (fem::pow(rlu(cmn, 0), (b0 / fbr))));
  } else {
    pmsqcd = pms * fem::pow(rlu(cmn, 0), (alfm * b0 / fbr));
  }
  if (zc > 0.49f || pmsqcd <= fem::pow2(pmth(4, kfl(1)))) {
    pmsqcd = fem::pow2(pmth(2, kfl(1)));
  }
  v(iep(1), 5) = pmsqcd;
  mce = 1;
  /// C
  /// C...Select mass for daughter in QED evolution.
  if (mstj(41) == 2 && kfl(1) >= 1 && kfl(1) <= 8) {
    pmsqed = pms * fem::exp(fem::max(-100.f, fem::log(rlu(cmn, 0)) * paru(2) /
                                                 (paru(101) * fbre)));
    if (zce > 0.49f || pmsqed <= fem::pow2(pmth(5, kfl(1)))) {
      pmsqed = fem::pow2(pmth(2, kfl(1)));
    }
    if (pmsqed > pmsqcd) {
      v(iep(1), 5) = pmsqed;
      mce = 2;
    }
  }
  /// C
  /// C...Check whether daughter mass below cutoff.
  p(iep(1), 5) = fem::sqrt(v(iep(1), 5));
  if (p(iep(1), 5) <= pmth(3, kfl(1))) {
    p(iep(1), 5) = pmth(1, kfl(1));
    v(iep(1), 5) = fem::pow2(p(iep(1), 5));
    goto statement_300;
  }
  /// C
  /// C...Select z value of branching: q -> qgamma.
  if (mce == 2) {
    z = 1.f - (1.f - zce) * fem::pow((zce / (1.f - zce)), rlu(cmn, 0));
    if (1.f + fem::pow2(z) < 2.f * rlu(cmn, 0)) {
      goto statement_260;
    }
    k(iep(1), 5) = 22;
    /// C
    /// C...Select z value of branching: q -> qg, g -> gg, g -> qqbar.
  } else if (mstj(49) != 1 && kfl(1) != 21) {
    z = 1.f - (1.f - zc) * fem::pow((zc / (1.f - zc)), rlu(cmn, 0));
    if (1.f + fem::pow2(z) < 2.f * rlu(cmn, 0)) {
      goto statement_260;
    }
    k(iep(1), 5) = 21;
  } else if (mstj(49) == 0 && mstj(45) * (0.5f - zc) < rlu(cmn, 0) * fbr) {
    z = (1.f - zc) * fem::pow((zc / (1.f - zc)), rlu(cmn, 0));
    if (rlu(cmn, 0) > 0.5f) {
      z = 1.f - z;
    }
    if (fem::pow2((1.f - z * (1.f - z))) < rlu(cmn, 0)) {
      goto statement_260;
    }
    k(iep(1), 5) = 21;
  } else if (mstj(49) != 1) {
    z = zc + (1.f - 2.f * zc) * rlu(cmn, 0);
    if (fem::pow2(z) + fem::pow2((1.f - z)) < rlu(cmn, 0)) {
      goto statement_260;
    }
    kflb = 1 + fem::fint(mstj(45) * rlu(cmn, 0));
    pmq = 4.f * fem::pow2(pmth(2, kflb)) / v(iep(1), 5);
    if (pmq >= 1.f) {
      goto statement_260;
    }
    pmq0 = 4.f * fem::pow2(pmth(2, 21)) / v(iep(1), 5);
    if (fem::mod(mstj(43), 2) == 0 &&
        (1.f + 0.5f * pmq) * fem::sqrt(1.f - pmq) <
            rlu(cmn, 0) * (1.f + 0.5f * pmq0) * fem::sqrt(1.f - pmq0)) {
      goto statement_260;
    }
    k(iep(1), 5) = kflb;
    /// C
    /// C...Ditto for scalar gluon model.
  } else if (kfl(1) != 21) {
    z = 1.f - fem::sqrt(fem::pow2(zc) + rlu(cmn, 0) * (1.f - 2.f * zc));
    k(iep(1), 5) = 21;
  } else if (rlu(cmn, 0) * (parj(87) + mstj(45) * parj(88)) <= parj(87)) {
    z = zc + (1.f - 2.f * zc) * rlu(cmn, 0);
    k(iep(1), 5) = 21;
  } else {
    z = zc + (1.f - 2.f * zc) * rlu(cmn, 0);
    kflb = 1 + fem::fint(mstj(45) * rlu(cmn, 0));
    pmq = 4.f * fem::pow2(pmth(2, kflb)) / v(iep(1), 5);
    if (pmq >= 1.f) {
      goto statement_260;
    }
    k(iep(1), 5) = kflb;
  }
  if (mce == 1 && mstj(44) >= 2) {
    if (z * (1.f - z) * v(iep(1), 5) < pt2min) {
      goto statement_260;
    }
    if (alfm / fem::log(v(iep(1), 5) * z * (1.f - z) / alams) < rlu(cmn, 0)) {
      goto statement_260;
    }
  }
  /// C
  /// C...Check if z consistent with chosen m.
  if (kfl(1) == 21) {
    kflgd1 = fem::iabs(k(iep(1), 5));
    kflgd2 = kflgd1;
  } else {
    kflgd1 = kfl(1);
    kflgd2 = fem::iabs(k(iep(1), 5));
  }
  if (nep == 1) {
    ped = ps(4);
  } else if (nep >= 3) {
    ped = p(iep(1), 4);
  } else if (igm == 0 || mstj(43) <= 2) {
    ped = 0.5f * (v(im, 5) + v(iep(1), 5) - fem::pow2(pm2)) / p(im, 5);
  } else {
    if (iep(1) == n + 1) {
      ped = v(im, 1) * pem;
    }
    if (iep(1) == n + 2) {
      ped = (1.f - v(im, 1)) * pem;
    }
  }
  if (fem::mod(mstj(43), 2) == 1) {
    pmqth3 = 0.5f * parj(82);
    if (kflgd2 == 22) {
      pmqth3 = 0.5f * parj(83);
    }
    pmq1 = (fem::pow2(pmth(1, kflgd1)) + fem::pow2(pmqth3)) / v(iep(1), 5);
    pmq2 = (fem::pow2(pmth(1, kflgd2)) + fem::pow2(pmqth3)) / v(iep(1), 5);
    zd = fem::sqrt(fem::max(
        0.f, (1.f - v(iep(1), 5) / fem::pow2(ped)) *
                 (fem::pow2((1.f - pmq1 - pmq2)) - 4.f * pmq1 * pmq2)));
    zh = 1.f + pmq1 - pmq2;
  } else {
    zd = fem::sqrt(fem::max(0.f, 1.f - v(iep(1), 5) / fem::pow2(ped)));
    zh = 1.f;
  }
  zl = 0.5f * (zh - zd);
  zu = 0.5f * (zh + zd);
  if (z < zl || z > zu) {
    goto statement_260;
  }
  if (kfl(1) == 21) {
    v(iep(1), 3) =
        fem::log(zu * (1.f - zl) / fem::max(1e-20f, zl * (1.f - zu)));
  }
  if (kfl(1) != 21) {
    v(iep(1), 3) = fem::log((1.f - zl) / fem::max(1e-10f, 1.f - zu));
  }
  /// C
  /// C...Three-jet matrix element correction.
  if (igm == 0 && m3jc == 1) {
    x1 = z * (1.f + v(iep(1), 5) / v(ns + 1, 5));
    x2 = 1.f - v(iep(1), 5) / v(ns + 1, 5);
    x3 = (1.f - x1) + (1.f - x2);
    if (mce == 2) {
      ki1 = k(ipa(inum), 2);
      ki2 = k(ipa(3 - inum), 2);
      qf1 = kchg(fem::iabs(ki1), 1) * fem::isign(1, ki1) / 3.f;
      qf2 = kchg(fem::iabs(ki2), 1) * fem::isign(1, ki2) / 3.f;
      wshow = fem::pow2(qf1) * (1.f - x1) / x3 *
                  (1.f + fem::pow2((x1 / (2.f - x2)))) +
              fem::pow2(qf2) * (1.f - x2) / x3 *
                  (1.f + fem::pow2((x2 / (2.f - x1))));
      wme = fem::pow2((qf1 * (1.f - x1) / x3 - qf2 * (1.f - x2) / x3)) *
            (fem::pow2(x1) + fem::pow2(x2));
    } else if (mstj(49) != 1) {
      wshow = 1.f + (1.f - x1) / x3 * fem::pow2((x1 / (2.f - x2))) +
              (1.f - x2) / x3 * fem::pow2((x2 / (2.f - x1)));
      wme = fem::pow2(x1) + fem::pow2(x2);
    } else {
      wshow = 4.f * x3 *
              ((1.f - x1) / fem::pow2((2.f - x2)) +
               (1.f - x2) / fem::pow2((2.f - x1)));
      wme = fem::pow2(x3);
    }
    if (wme < rlu(cmn, 0) * wshow) {
      goto statement_260;
    }
    /// C
    /// C...Impose angular ordering by rejection of nonordered emission.
  } else if (mce == 1 && igm > 0 && mstj(42) >= 2) {
    maom = 1;
    zm = v(im, 1);
    if (iep(1) == n + 2) {
      zm = 1.f - v(im, 1);
    }
    the2id = z * (1.f - z) * fem::pow2((zm * p(im, 4))) / v(iep(1), 5);
    iaom = im;
  statement_290:
    if (k(iaom, 5) == 22) {
      iaom = k(iaom, 3);
      if (k(iaom, 3) <= ns) {
        maom = 0;
      }
      if (maom == 1) {
        goto statement_290;
      }
    }
    if (maom == 1) {
      the2im =
          v(iaom, 1) * (1.f - v(iaom, 1)) * fem::pow2(p(iaom, 4)) / v(iaom, 5);
      if (the2id < the2im) {
        goto statement_260;
      }
    }
  }
  /// C
  /// C...Impose user-defined maximum angle at first branching.
  if (mstj(48) == 1) {
    if (nep == 1 && im == ns) {
      the2id = z * (1.f - z) * fem::pow2(ps(4)) / v(iep(1), 5);
      if (the2id < 1.f / fem::pow2(parj(85))) {
        goto statement_260;
      }
    } else if (nep == 2 && iep(1) == ns + 2) {
      the2id = z * (1.f - z) * fem::pow2((0.5f * p(im, 4))) / v(iep(1), 5);
      if (the2id < 1.f / fem::pow2(parj(85))) {
        goto statement_260;
      }
    } else if (nep == 2 && iep(1) == ns + 3) {
      the2id = z * (1.f - z) * fem::pow2((0.5f * p(im, 4))) / v(iep(1), 5);
      if (the2id < 1.f / fem::pow2(parj(86))) {
        goto statement_260;
      }
    }
  }
/// C
/// C...End of inner veto algorithm. Check if only one leg evolved so far.
statement_300:
  v(iep(1), 1) = z;
  isl(1) = 0;
  isl(2) = 0;
  if (nep == 1) {
    goto statement_330;
  }
  if (nep == 2 && p(iep(1), 5) + p(iep(2), 5) >= p(im, 5)) {
    goto statement_200;
  }
  FEM_DO_SAFE(i, 1, nep) {
    if (itry(i) == 0 && kfld(i) > 0 && (kfld(i) <= 8 || kfld(i) == 21)) {
      if (p(n + i, 5) >= pmth(2, kfld(i))) {
        goto statement_200;
      }
    }
  }
  /// C
  /// C...Check if chosen multiplet m1,m2,z1,z2 is physical.
  if (nep == 3) {
    pa1s = (p(n + 1, 4) + p(n + 1, 5)) * (p(n + 1, 4) - p(n + 1, 5));
    pa2s = (p(n + 2, 4) + p(n + 2, 5)) * (p(n + 2, 4) - p(n + 2, 5));
    pa3s = (p(n + 3, 4) + p(n + 3, 5)) * (p(n + 3, 4) - p(n + 3, 5));
    pts = 0.25f *
          (2.f * pa1s * pa2s + 2.f * pa1s * pa3s + 2.f * pa2s * pa3s -
           fem::pow2(pa1s) - fem::pow2(pa2s) - fem::pow2(pa3s)) /
          pa1s;
    if (pts <= 0.f) {
      goto statement_200;
    }
  } else if (igm == 0 || mstj(43) <= 2 || fem::mod(mstj(43), 2) == 0) {
    FEM_DO_SAFE(i1, n + 1, n + 2) {
      kflda = fem::iabs(k(i1, 2));
      if (kflda == 0 || (kflda > 8 && kflda != 21)) {
        goto statement_320;
      }
      if (p(i1, 5) < pmth(2, kflda)) {
        goto statement_320;
      }
      if (kflda == 21) {
        kflgd1 = fem::iabs(k(i1, 5));
        kflgd2 = kflgd1;
      } else {
        kflgd1 = kflda;
        kflgd2 = fem::iabs(k(i1, 5));
      }
      i2 = 2 * n + 3 - i1;
      if (igm == 0 || mstj(43) <= 2) {
        ped = 0.5f * (v(im, 5) + v(i1, 5) - v(i2, 5)) / p(im, 5);
      } else {
        if (i1 == n + 1) {
          zm = v(im, 1);
        }
        if (i1 == n + 2) {
          zm = 1.f - v(im, 1);
        }
        pml = fem::sqrt(fem::pow2((v(im, 5) - v(n + 1, 5) - v(n + 2, 5))) -
                        4.f * v(n + 1, 5) * v(n + 2, 5));
        ped = pem * (0.5f * (v(im, 5) - pml + v(i1, 5) - v(i2, 5)) + pml * zm) /
              v(im, 5);
      }
      if (fem::mod(mstj(43), 2) == 1) {
        pmqth3 = 0.5f * parj(82);
        if (kflgd2 == 22) {
          pmqth3 = 0.5f * parj(83);
        }
        pmq1 = (fem::pow2(pmth(1, kflgd1)) + fem::pow2(pmqth3)) / v(i1, 5);
        pmq2 = (fem::pow2(pmth(1, kflgd2)) + fem::pow2(pmqth3)) / v(i1, 5);
        zd = fem::sqrt(fem::max(
            0.f, (1.f - v(i1, 5) / fem::pow2(ped)) *
                     (fem::pow2((1.f - pmq1 - pmq2)) - 4.f * pmq1 * pmq2)));
        zh = 1.f + pmq1 - pmq2;
      } else {
        zd = fem::sqrt(fem::max(0.f, 1.f - v(i1, 5) / fem::pow2(ped)));
        zh = 1.f;
      }
      zl = 0.5f * (zh - zd);
      zu = 0.5f * (zh + zd);
      if (i1 == n + 1 && (v(i1, 1) < zl || v(i1, 1) > zu)) {
        isl(1) = 1;
      }
      if (i1 == n + 2 && (v(i1, 1) < zl || v(i1, 1) > zu)) {
        isl(2) = 1;
      }
      if (kflda == 21) {
        v(i1, 4) =
            fem::log(zu * (1.f - zl) / fem::max(1e-20f, zl * (1.f - zu)));
      }
      if (kflda != 21) {
        v(i1, 4) = fem::log((1.f - zl) / fem::max(1e-10f, 1.f - zu));
      }
    statement_320:;
    }
    if (isl(1) == 1 && isl(2) == 1 && islm != 0) {
      isl(3 - islm) = 0;
      islm = 3 - islm;
    } else if (isl(1) == 1 && isl(2) == 1) {
      zdr1 = fem::max(0.f, v(n + 1, 3) / v(n + 1, 4) - 1.f);
      zdr2 = fem::max(0.f, v(n + 2, 3) / v(n + 2, 4) - 1.f);
      if (zdr2 > rlu(cmn, 0) * (zdr1 + zdr2)) {
        isl(1) = 0;
      }
      if (isl(1) == 1) {
        isl(2) = 0;
      }
      if (isl(1) == 0) {
        islm = 1;
      }
      if (isl(2) == 0) {
        islm = 2;
      }
    }
    if (isl(1) == 1 || isl(2) == 1) {
      goto statement_200;
    }
  }
  if (igm > 0 && fem::mod(mstj(43), 2) == 1 &&
      (p(n + 1, 5) >= pmth(2, kfld(1)) || p(n + 2, 5) >= pmth(2, kfld(2)))) {
    pmq1 = v(n + 1, 5) / v(im, 5);
    pmq2 = v(n + 2, 5) / v(im, 5);
    zd = fem::sqrt(fem::max(
        0.f, (1.f - v(im, 5) / fem::pow2(pem)) *
                 (fem::pow2((1.f - pmq1 - pmq2)) - 4.f * pmq1 * pmq2)));
    zh = 1.f + pmq1 - pmq2;
    zl = 0.5f * (zh - zd);
    zu = 0.5f * (zh + zd);
    if (v(im, 1) < zl || v(im, 1) > zu) {
      goto statement_200;
    }
  }
/// C
/// C...Accepted branch. Construct four-momentum for initial partons.
statement_330:
  mazip = 0;
  mazic = 0;
  if (nep == 1) {
    p(n + 1, 1) = 0.f;
    p(n + 1, 2) = 0.f;
    p(n + 1, 3) = fem::sqrt(fem::max(
        0.f, (p(ipa(1), 4) + p(n + 1, 5)) * (p(ipa(1), 4) - p(n + 1, 5))));
    p(n + 1, 4) = p(ipa(1), 4);
    v(n + 1, 2) = p(n + 1, 4);
  } else if (igm == 0 && nep == 2) {
    ped1 = 0.5f * (v(im, 5) + v(n + 1, 5) - v(n + 2, 5)) / p(im, 5);
    p(n + 1, 1) = 0.f;
    p(n + 1, 2) = 0.f;
    p(n + 1, 3) =
        fem::sqrt(fem::max(0.f, (ped1 + p(n + 1, 5)) * (ped1 - p(n + 1, 5))));
    p(n + 1, 4) = ped1;
    p(n + 2, 1) = 0.f;
    p(n + 2, 2) = 0.f;
    p(n + 2, 3) = -p(n + 1, 3);
    p(n + 2, 4) = p(im, 5) - ped1;
    v(n + 1, 2) = p(n + 1, 4);
    v(n + 2, 2) = p(n + 2, 4);
  } else if (nep == 3) {
    p(n + 1, 1) = 0.f;
    p(n + 1, 2) = 0.f;
    p(n + 1, 3) = fem::sqrt(fem::max(0.f, pa1s));
    p(n + 2, 1) = fem::sqrt(pts);
    p(n + 2, 2) = 0.f;
    p(n + 2, 3) = 0.5f * (pa3s - pa2s - pa1s) / p(n + 1, 3);
    p(n + 3, 1) = -p(n + 2, 1);
    p(n + 3, 2) = 0.f;
    p(n + 3, 3) = -(p(n + 1, 3) + p(n + 2, 3));
    v(n + 1, 2) = p(n + 1, 4);
    v(n + 2, 2) = p(n + 2, 4);
    v(n + 3, 2) = p(n + 3, 4);
    /// C
    /// C...Construct transverse momentum for ordinary branching in shower.
  } else {
    zm = v(im, 1);
    pzm = fem::sqrt(fem::max(0.f, (pem + p(im, 5)) * (pem - p(im, 5))));
    pmls = fem::pow2((v(im, 5) - v(n + 1, 5) - v(n + 2, 5))) -
           4.f * v(n + 1, 5) * v(n + 2, 5);
    if (pzm <= 0.f) {
      pts = 0.f;
    } else if (fem::mod(mstj(43), 2) == 1) {
      pts = (fem::pow2(pem) * (zm * (1.f - zm) * v(im, 5) -
                               (1.f - zm) * v(n + 1, 5) - zm * v(n + 2, 5)) -
             0.25f * pmls) /
            fem::pow2(pzm);
    } else {
      pts = pmls * (zm * (1.f - zm) * fem::pow2(pem) / v(im, 5) - 0.25f) /
            fem::pow2(pzm);
    }
    pt = fem::sqrt(fem::max(0.f, pts));
    /// C
    /// C...Find coefficient of azimuthal asymmetry due to gluon polarization.
    hazip = 0.f;
    if (mstj(49) != 1 && fem::mod(mstj(46), 2) == 1 && k(im, 2) == 21 &&
        iau != 0) {
      if (k(igm, 3) != 0) {
        mazip = 1;
      }
      zau = v(igm, 1);
      if (iau == im + 1) {
        zau = 1.f - v(igm, 1);
      }
      if (mazip == 0) {
        zau = 0.f;
      }
      if (k(igm, 2) != 21) {
        hazip = 2.f * zau / (1.f + fem::pow2(zau));
      } else {
        hazip = fem::pow2((zau / (1.f - zau * (1.f - zau))));
      }
      if (k(n + 1, 2) != 21) {
        hazip =
            hazip * (-2.f * zm * (1.f - zm)) / (1.f - 2.f * zm * (1.f - zm));
      } else {
        hazip = hazip * fem::pow2((zm * (1.f - zm) / (1.f - zm * (1.f - zm))));
      }
    }
    /// C
    /// C...Find coefficient of azimuthal asymmetry due to soft gluon
    /// C...interference.
    hazic = 0.f;
    if (mstj(46) >= 2 && (k(n + 1, 2) == 21 || k(n + 2, 2) == 21) && iau != 0) {
      if (k(igm, 3) != 0) {
        mazic = n + 1;
      }
      if (k(igm, 3) != 0 && k(n + 1, 2) != 21) {
        mazic = n + 2;
      }
      if (k(igm, 3) != 0 && k(n + 1, 2) == 21 && k(n + 2, 2) == 21 &&
          zm > 0.5f) {
        mazic = n + 2;
      }
      if (k(iau, 2) == 22) {
        mazic = 0;
      }
      zs = zm;
      if (mazic == n + 2) {
        zs = 1.f - zm;
      }
      zgm = v(igm, 1);
      if (iau == im - 1) {
        zgm = 1.f - v(igm, 1);
      }
      if (mazic == 0) {
        zgm = 1.f;
      }
      hazic = (p(im, 5) / p(igm, 5)) *
              fem::sqrt((1.f - zs) * (1.f - zgm) / (zs * zgm));
      hazic = fem::min(0.95f, hazic);
    }
  }
/// C
/// C...Construct kinematics for ordinary branching in shower.
statement_340:
  if (nep == 2 && igm > 0) {
    if (fem::mod(mstj(43), 2) == 1) {
      p(n + 1, 4) = pem * v(im, 1);
    } else {
      p(n + 1, 4) =
          pem *
          (0.5f * (v(im, 5) - fem::sqrt(pmls) + v(n + 1, 5) - v(n + 2, 5)) +
           fem::sqrt(pmls) * zm) /
          v(im, 5);
    }
    phi = paru(2) * rlu(cmn, 0);
    p(n + 1, 1) = pt * fem::cos(phi);
    p(n + 1, 2) = pt * fem::sin(phi);
    if (pzm > 0.f) {
      p(n + 1, 3) =
          0.5f *
          (v(n + 2, 5) - v(n + 1, 5) - v(im, 5) + 2.f * pem * p(n + 1, 4)) /
          pzm;
    } else {
      p(n + 1, 3) = 0.f;
    }
    p(n + 2, 1) = -p(n + 1, 1);
    p(n + 2, 2) = -p(n + 1, 2);
    p(n + 2, 3) = pzm - p(n + 1, 3);
    p(n + 2, 4) = pem - p(n + 1, 4);
    if (mstj(43) <= 2) {
      v(n + 1, 2) = (pem * p(n + 1, 4) - pzm * p(n + 1, 3)) / p(im, 5);
      v(n + 2, 2) = (pem * p(n + 2, 4) - pzm * p(n + 2, 3)) / p(im, 5);
    }
  }
  /// C
  /// C...Rotate and boost daughters.
  if (igm > 0) {
    if (mstj(43) <= 2) {
      bex = p(igm, 1) / p(igm, 4);
      bey = p(igm, 2) / p(igm, 4);
      bez = p(igm, 3) / p(igm, 4);
      ga = p(igm, 4) / p(igm, 5);
      gabep = ga * (ga * (bex * p(im, 1) + bey * p(im, 2) + bez * p(im, 3)) /
                        (1.f + ga) -
                    p(im, 4));
    } else {
      bex = 0.f;
      bey = 0.f;
      bez = 0.f;
      ga = 1.f;
      gabep = 0.f;
    }
    the = ulangl(cmn, p(im, 3) + gabep * bez,
                 fem::sqrt(fem::pow2((p(im, 1) + gabep * bex)) +
                           fem::pow2((p(im, 2) + gabep * bey))));
    phi = ulangl(cmn, p(im, 1) + gabep * bex, p(im, 2) + gabep * bey);
    FEM_DO_SAFE(i, n + 1, n + 2) {
      dp(1) = fem::dble(fem::cos(the) * fem::cos(phi) * p(i, 1) -
                        fem::sin(phi) * p(i, 2) +
                        fem::sin(the) * fem::cos(phi) * p(i, 3));
      dp(2) = fem::dble(fem::cos(the) * fem::sin(phi) * p(i, 1) +
                        fem::cos(phi) * p(i, 2) +
                        fem::sin(the) * fem::sin(phi) * p(i, 3));
      dp(3) = fem::dble(-fem::sin(the) * p(i, 1) + fem::cos(the) * p(i, 3));
      dp(4) = fem::dble(p(i, 4));
      dbp = fem::dble(bex) * dp(1) + fem::dble(bey) * dp(2) +
            fem::dble(bez) * dp(3);
      dgabp =
          fem::dble(ga) * (fem::dble(ga) * dbp / (1e0 + fem::dble(ga)) + dp(4));
      p(i, 1) = fem::sngl(dp(1) + dgabp * fem::dble(bex));
      p(i, 2) = fem::sngl(dp(2) + dgabp * fem::dble(bey));
      p(i, 3) = fem::sngl(dp(3) + dgabp * fem::dble(bez));
      p(i, 4) = ga * fem::sngl(dp(4) + dbp);
    }
  }
  /// C
  /// C...Weight with azimuthal distribution, if required.
  if (mazip != 0 || mazic != 0) {
    FEM_DO_SAFE(j, 1, 3) {
      dpt(1, j) = fem::dble(p(im, j));
      dpt(2, j) = fem::dble(p(iau, j));
      dpt(3, j) = fem::dble(p(n + 1, j));
    }
    dpma =
        dpt(1, 1) * dpt(2, 1) + dpt(1, 2) * dpt(2, 2) + dpt(1, 3) * dpt(2, 3);
    dpmd =
        dpt(1, 1) * dpt(3, 1) + dpt(1, 2) * dpt(3, 2) + dpt(1, 3) * dpt(3, 3);
    dpmm = fem::pow2(dpt(1, 1)) + fem::pow2(dpt(1, 2)) + fem::pow2(dpt(1, 3));
    FEM_DO_SAFE(j, 1, 3) {
      dpt(4, j) = dpt(2, j) - dpma * dpt(1, j) / dpmm;
      dpt(5, j) = dpt(3, j) - dpmd * dpt(1, j) / dpmm;
    }
    dpt(4, 4) = fem::dsqrt(fem::pow2(dpt(4, 1)) + fem::pow2(dpt(4, 2)) +
                           fem::pow2(dpt(4, 3)));
    dpt(5, 4) = fem::dsqrt(fem::pow2(dpt(5, 1)) + fem::pow2(dpt(5, 2)) +
                           fem::pow2(dpt(5, 3)));
    /// Clin-5/2012:
    /// C        IF(MIN(DPT(4,4),DPT(5,4)).GT.0.1*PARJ(82)) THEN
    if (fem::sngl(fem::min(dpt(4, 4), dpt(5, 4))) > (0.1f * parj(82))) {
      cad = fem::sngl((dpt(4, 1) * dpt(5, 1) + dpt(4, 2) * dpt(5, 2) +
                       dpt(4, 3) * dpt(5, 3)) /
                      (dpt(4, 4) * dpt(5, 4)));
      if (mazip != 0) {
        if (1.f + hazip * (2.f * fem::pow2(cad) - 1.f) <
            rlu(cmn, 0) * (1.f + fem::abs(hazip))) {
          goto statement_340;
        }
      }
      if (mazic != 0) {
        if (mazic == n + 2) {
          cad = -cad;
        }
        if ((1.f - hazic) * (1.f - hazic * cad) /
                (1.f + fem::pow2(hazic) - 2.f * hazic * cad) <
            rlu(cmn, 0)) {
          goto statement_340;
        }
      }
    }
  }
  /// C
  /// C...Continue loop over partons that may branch, until none left.
  if (igm >= 0) {
    k(im, 1) = 14;
  }
  n += nep;
  nep = 2;
  if (n > mstu(4) - mstu(32) - 5) {
    luerrm(cmn, 11, "(LUSHOW:) no more memory left in LUJETS");
    if (mstu(21) >= 1) {
      n = ns;
    }
    if (mstu(21) >= 1) {
      return;
    }
  }
  goto statement_140;
/// C
/// C...Set information on imagined shower initiator.
statement_380:
  if (npa >= 2) {
    k(ns + 1, 1) = 11;
    k(ns + 1, 2) = 94;
    k(ns + 1, 3) = ip1;
    if (ip2 > 0 && ip2 < ip1) {
      k(ns + 1, 3) = ip2;
    }
    k(ns + 1, 4) = ns + 2;
    k(ns + 1, 5) = ns + 1 + npa;
    iim = 1;
  } else {
    iim = 0;
  }
  /// C
  /// C...Reconstruct string drawing information.
  FEM_DO_SAFE(i, ns + 1 + iim, n) {
    if (k(i, 1) <= 10 && k(i, 2) == 22) {
      k(i, 1) = 1;
    } else if (k(i, 1) <= 10) {
      k(i, 4) = mstu(5) * (k(i, 4) / mstu(5));
      k(i, 5) = mstu(5) * (k(i, 5) / mstu(5));
    } else if (k(fem::mod(k(i, 4), mstu(5)) + 1, 2) != 22) {
      id1 = fem::mod(k(i, 4), mstu(5));
      if (k(i, 2) >= 1 && k(i, 2) <= 8) {
        id1 = fem::mod(k(i, 4), mstu(5)) + 1;
      }
      id2 = 2 * fem::mod(k(i, 4), mstu(5)) + 1 - id1;
      k(i, 4) = mstu(5) * (k(i, 4) / mstu(5)) + id1;
      k(i, 5) = mstu(5) * (k(i, 5) / mstu(5)) + id2;
      k(id1, 4) += mstu(5) * i;
      k(id1, 5) += mstu(5) * id2;
      k(id2, 4) += mstu(5) * id1;
      k(id2, 5) += mstu(5) * i;
    } else {
      id1 = fem::mod(k(i, 4), mstu(5));
      id2 = id1 + 1;
      k(i, 4) = mstu(5) * (k(i, 4) / mstu(5)) + id1;
      k(i, 5) = mstu(5) * (k(i, 5) / mstu(5)) + id1;
      k(id1, 4) += mstu(5) * i;
      k(id1, 5) += mstu(5) * i;
      k(id2, 4) = 0;
      k(id2, 5) = 0;
    }
  }
  /// C
  /// C...Transformation from CM frame.
  if (npa >= 2) {
    bex = ps(1) / ps(4);
    bey = ps(2) / ps(4);
    bez = ps(3) / ps(4);
    ga = ps(4) / ps(5);
    gabep =
        ga *
        (ga * (bex * p(ipa(1), 1) + bey * p(ipa(1), 2) + bez * p(ipa(1), 3)) /
             (1.f + ga) -
         p(ipa(1), 4));
  } else {
    bex = 0.f;
    bey = 0.f;
    bez = 0.f;
    gabep = 0.f;
  }
  the = ulangl(cmn, p(ipa(1), 3) + gabep * bez,
               fem::sqrt(fem::pow2((p(ipa(1), 1) + gabep * bex)) +
                         fem::pow2((p(ipa(1), 2) + gabep * bey))));
  phi = ulangl(cmn, p(ipa(1), 1) + gabep * bex, p(ipa(1), 2) + gabep * bey);
  if (npa == 3) {
    chi = ulangl(
        cmn,
        fem::cos(the) * fem::cos(phi) * (p(ipa(2), 1) + gabep * bex) +
            fem::cos(the) * fem::sin(phi) * (p(ipa(2), 2) + gabep * bey) -
            fem::sin(the) * (p(ipa(2), 3) + gabep * bez),
        -fem::sin(phi) * (p(ipa(2), 1) + gabep * bex) +
            fem::cos(phi) * (p(ipa(2), 2) + gabep * bey));
    ludbrb(ns + 1, n, 0.f, chi, 0e0, 0e0, 0e0);
  }
  dbex = fem::dble(bex);
  dbey = fem::dble(bey);
  dbez = fem::dble(bez);
  ludbrb(ns + 1, n, the, phi, dbex, dbey, dbez);
  /// C
  /// C...Decay vertex of shower.
  FEM_DO_SAFE(i, ns + 1, n) {
    FEM_DO_SAFE(j, 1, 5) { v(i, j) = v(ip1, j); }
  }
  /// C
  /// C...Delete trivial shower, else connect initiators.
  if (n == ns + npa + iim) {
    n = ns;
  } else {
    FEM_DO_SAFE(ip, 1, npa) {
      k(ipa(ip), 1) = 14;
      k(ipa(ip), 4) += ns + iim + ip;
      k(ipa(ip), 5) += ns + iim + ip;
      k(ns + iim + ip, 3) = ipa(ip);
      if (iim == 1 && mstu(16) != 2) {
        k(ns + iim + ip, 3) = ns + 1;
      }
      k(ns + iim + ip, 4) += mstu(5) * ipa(ip);
      k(ns + iim + ip, 5) += mstu(5) * ipa(ip);
    }
  }
  /// C
}

struct luboei_save {
  arr<int> kfbe;

  luboei_save() : kfbe(dimension(9), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void luboei(common& cmn, int const& nsav) {
  FEM_CMN_SVE(luboei);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  ///
  arr_ref<int> kfbe(sve.kfbe, dimension(9));
  if (is_called_first_time) {
    static const int values[] = {211, -211, 111, 321, -321, 130, 310, 221, 331};
    fem::data_of_type<int>(FEM_VALUES_AND_SIZE), kfbe;
  }
  int j = fem::int0;
  arr_1d<4, double> dps(fem::fill0);
  int i = fem::int0;
  float pecm = fem::float0;
  arr_1d<10, int> nbe(dim1(0, 9), fem::fill0);
  int ibe = fem::int0;
  float pmhq = fem::float0;
  float qdel = fem::float0;
  int nbin = fem::int0;
  float beex = fem::float0;
  float bert = fem::float0;
  int ibin = fem::int0;
  float qbin = fem::float0;
  arr_1d<100, float> bei(fem::fill0);
  int i1m = fem::int0;
  int i1 = fem::int0;
  int i2m = fem::int0;
  int i2 = fem::int0;
  float q2old = fem::float0;
  float qold = fem::float0;
  float qmov = fem::float0;
  float rbin = fem::float0;
  float rinp = fem::float0;
  float q2new = fem::float0;
  float hc1 = fem::float0;
  float hc2 = fem::float0;
  float ha = fem::float0;
  float pd = fem::float0;
  int im = fem::int0;
  float pes = fem::float0;
  float pqs = fem::float0;
  float fac = fem::float0;
  /// C
  /// C...Purpose: to modify event so as to approximately take into account
  /// C...Bose-Einstein effects according to a simple phenomenological
  /// C...parametrization.
  /// C
  /// C...Boost event to overall CM frame. Calculate CM energy.
  if ((mstj(51) != 1 && mstj(51) != 2) || n - nsav <= 1) {
    return;
  }
  FEM_DO_SAFE(j, 1, 4) { dps(j) = 0.e0; }
  FEM_DO_SAFE(i, 1, n) {
    if (k(i, 1) <= 0 || k(i, 1) > 10) {
      goto statement_120;
    }
    FEM_DO_SAFE(j, 1, 4) { dps(j) += fem::dble(p(i, j)); }
  statement_120:;
  }
  ludbrb(0, 0, 0.f, 0.f, -dps(1) / dps(4), -dps(2) / dps(4), -dps(3) / dps(4));
  pecm = 0.f;
  FEM_DO_SAFE(i, 1, n) {
    if (k(i, 1) >= 1 && k(i, 1) <= 10) {
      pecm += p(i, 4);
    }
  }
  /// C
  /// C...Reserve copy of particles by species at end of record.
  nbe(0) = n + mstu(3);
  FEM_DO_SAFE(ibe, 1, fem::min(9, mstj(51))) {
    nbe(ibe) = nbe(ibe - 1);
    FEM_DO_SAFE(i, nsav + 1, n) {
      if (k(i, 2) != kfbe(ibe)) {
        goto statement_150;
      }
      if (k(i, 1) <= 0 || k(i, 1) > 10) {
        goto statement_150;
      }
      if (nbe(ibe) >= mstu(4) - mstu(32) - 5) {
        luerrm(cmn, 11, "(LUBOEI:) no more memory left in LUJETS");
        return;
      }
      nbe(ibe)++;
      k(nbe(ibe), 1) = i;
      FEM_DO_SAFE(j, 1, 3) { p(nbe(ibe), j) = 0.f; }
    statement_150:;
    }
  }
  /// C
  /// C...Tabulate integral for subsequent momentum shift.
  FEM_DO_SAFE(ibe, 1, fem::min(9, mstj(51))) {
    if (ibe != 1 && ibe != 4 && ibe <= 7) {
      goto statement_180;
    }
    if (ibe == 1 &&
        fem::max(nbe(1) - nbe(0), nbe(2) - nbe(1), nbe(3) - nbe(2)) <= 1) {
      goto statement_180;
    }
    if (ibe == 4 && fem::max(nbe(4) - nbe(3), nbe(5) - nbe(4), nbe(6) - nbe(5),
                             nbe(7) - nbe(6)) <= 1) {
      goto statement_180;
    }
    if (ibe >= 8 && nbe(ibe) - nbe(ibe - 1) <= 1) {
      goto statement_180;
    }
    if (ibe == 1) {
      pmhq = 2.f * ulmass(cmn, 211);
    }
    if (ibe == 4) {
      pmhq = 2.f * ulmass(cmn, 321);
    }
    if (ibe == 8) {
      pmhq = 2.f * ulmass(cmn, 221);
    }
    if (ibe == 9) {
      pmhq = 2.f * ulmass(cmn, 331);
    }
    qdel = 0.1f * fem::min(pmhq, parj(93));
    if (mstj(51) == 1) {
      nbin = fem::min(100, fem::nint(9.f * parj(93) / qdel));
      beex = fem::exp(0.5f * qdel / parj(93));
      bert = fem::exp(-qdel / parj(93));
    } else {
      nbin = fem::min(100, fem::nint(3.f * parj(93) / qdel));
    }
    FEM_DO_SAFE(ibin, 1, nbin) {
      qbin = qdel * (ibin - 0.5f);
      bei(ibin) = qdel * (fem::pow2(qbin) + fem::pow2(qdel) / 12.f) /
                  fem::sqrt(fem::pow2(qbin) + fem::pow2(pmhq));
      if (mstj(51) == 1) {
        beex = beex * bert;
        bei(ibin) = bei(ibin) * beex;
      } else {
        bei(ibin) = bei(ibin) * fem::exp(-fem::pow2((qbin / parj(93))));
      }
      if (ibin >= 2) {
        bei(ibin) += bei(ibin - 1);
      }
    }
  /// C
  /// C...Loop through particle pairs and find old relative momentum.
  statement_180:
    FEM_DO_SAFE(i1m, nbe(ibe - 1) + 1, nbe(ibe) - 1) {
      i1 = k(i1m, 1);
      FEM_DO_SAFE(i2m, i1m + 1, nbe(ibe)) {
        i2 = k(i2m, 1);
        q2old = fem::max(0.f, fem::pow2((p(i1, 4) + p(i2, 4))) -
                                  fem::pow2((p(i1, 1) + p(i2, 1))) -
                                  fem::pow2((p(i1, 2) + p(i2, 2))) -
                                  fem::pow2((p(i1, 3) + p(i2, 3))) -
                                  fem::pow2((p(i1, 5) + p(i2, 5))));
        qold = fem::sqrt(q2old);
        /// C
        /// C...Calculate new relative momentum.
        if (qold < 0.5f * qdel) {
          qmov = qold / 3.f;
        } else if (qold < (nbin - 0.1f) * qdel) {
          rbin = qold / qdel;
          ibin = fem::fint(rbin);
          rinp =
              (fem::pow3(rbin) - fem::pow3(ibin)) / (3 * ibin * (ibin + 1) + 1);
          qmov = (bei(ibin) + rinp * (bei(ibin + 1) - bei(ibin))) *
                 fem::sqrt(q2old + fem::pow2(pmhq)) / q2old;
        } else {
          qmov = bei(nbin) * fem::sqrt(q2old + fem::pow2(pmhq)) / q2old;
        }
        q2new = q2old *
                fem::pow((qold / (qold + 3.f * parj(92) * qmov)), (2.f / 3.f));
        /// C
        /// C...Calculate and save shift to be performed on three-momenta.
        hc1 = fem::pow2((p(i1, 4) + p(i2, 4))) - (q2old - q2new);
        hc2 = (q2old - q2new) * fem::pow2((p(i1, 4) - p(i2, 4)));
        ha = 0.5f * (1.f - fem::sqrt(hc1 * q2new / (hc1 * q2old - hc2)));
        FEM_DO_SAFE(j, 1, 3) {
          pd = ha * (p(i2, j) - p(i1, j));
          p(i1m, j) += pd;
          p(i2m, j) = p(i2m, j) - pd;
        }
      }
    }
  }
  /// C
  /// C...Shift momenta and recalculate energies.
  FEM_DO_SAFE(im, nbe(0) + 1, nbe(fem::min(9, mstj(51)))) {
    i = k(im, 1);
    FEM_DO_SAFE(j, 1, 3) { p(i, j) += p(im, j); }
    p(i, 4) = fem::sqrt(fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) +
                        fem::pow2(p(i, 2)) + fem::pow2(p(i, 3)));
  }
  /// C
  /// C...Rescale all momenta for energy conservation.
  pes = 0.f;
  pqs = 0.f;
  FEM_DO_SAFE(i, 1, n) {
    if (k(i, 1) <= 0 || k(i, 1) > 10) {
      goto statement_240;
    }
    pes += p(i, 4);
    pqs += fem::pow2(p(i, 5)) / p(i, 4);
  statement_240:;
  }
  fac = (pecm - pqs) / (pes - pqs);
  FEM_DO_SAFE(i, 1, n) {
    if (k(i, 1) <= 0 || k(i, 1) > 10) {
      goto statement_260;
    }
    FEM_DO_SAFE(j, 1, 3) { p(i, j) = fac * p(i, j); }
    p(i, 4) = fem::sqrt(fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) +
                        fem::pow2(p(i, 2)) + fem::pow2(p(i, 3)));
  statement_260:;
  }
  /// C
  /// C...Boost back to correct reference frame.
  ludbrb(0, 0, 0.f, 0.f, dps(1) / dps(4), dps(2) / dps(4), dps(3) / dps(4));
  /// C
}

/// C
/// C*********************************************************************
/// C
void luexec(common& cmn) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_cref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  ///
  int mcons = fem::int0;
  int nsav = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  arr_2d<2, 6, float> ps(fem::fill0);
  int mbe = fem::int0;
  int ip = fem::int0;
  int kc = fem::int0;
  int ip1 = fem::int0;
  float qmax = fem::float0;
  float pip5 = fem::float0;
  int mfrag = fem::int0;
  float pdev = fem::float0;
  /// C
  /// C...Purpose: to administrate the fragmentation and decay chain.
  /// C
  /// C...Initialize and reset.
  mstu(24) = 0;
  if (mstu(12) >= 1) {
    lulist(cmn, 0);
  }
  mstu(31)++;
  mstu(1) = 0;
  mstu(2) = 0;
  mstu(3) = 0;
  mcons = 1;
  /// C
  /// C...Sum up momentum, energy and charge for starting entries.
  nsav = n;
  FEM_DO_SAFE(i, 1, 2) {
    FEM_DO_SAFE(j, 1, 6) { ps(i, j) = 0.f; }
  }
  FEM_DO_SAFE(i, 1, n) {
    if (k(i, 1) <= 0 || k(i, 1) > 10) {
      goto statement_120;
    }
    FEM_DO_SAFE(j, 1, 4) { ps(1, j) += p(i, j); }
    ps(1, 6) += luchge(cmn, k(i, 2));
  statement_120:;
  }
  paru(21) = ps(1, 4);
  /// C
  /// C...Prepare system for subsequent fragmentation/decay.
  luprep(cmn, 0);
  /// C
  /// C...Loop through jet fragmentation and particle decays.
  mbe = 0;
statement_130:
  mbe++;
  ip = 0;
statement_140:
  ip++;
  kc = 0;
  if (k(ip, 1) > 0 && k(ip, 1) <= 10) {
    kc = lucomp(cmn, k(ip, 2));
  }
  if (kc == 0) {
    /// C
    /// C...Particle decay if unstable and allowed. Save long-lived particle
    /// C...decays until second pass after Bose-Einstein effects.
  } else if (kchg(kc, 2) == 0) {
    /// Clin-4/2008 break up compound IF statements:
    /// C        IF(MSTJ(21).GE.1.AND.MDCY(KC,1).GE.1.AND.(MSTJ(51).LE.0.OR.MBE.
    /// C     &  EQ.2.OR.PMAS(KC,2).GE.PARJ(91).OR.IABS(K(IP,2)).EQ.311))
    /// C     &  CALL LUDECY(IP)
    if (mstj(21) >= 1 && mdcy(kc, 1) >= 1) {
      if (mstj(51) <= 0 || mbe == 2 || pmas(kc, 2) >= parj(91) ||
          fem::iabs(k(ip, 2)) == 311) {
        ludecy(cmn, ip);
      }
    }
    /// C
    /// C...Decay products may develop a shower.
    if (mstj(92) > 0) {
      ip1 = mstj(92);
      qmax =
          fem::sqrt(fem::max(0.f, fem::pow2((p(ip1, 4) + p(ip1 + 1, 4))) -
                                      fem::pow2((p(ip1, 1) + p(ip1 + 1, 1))) -
                                      fem::pow2((p(ip1, 2) + p(ip1 + 1, 2))) -
                                      fem::pow2((p(ip1, 3) + p(ip1 + 1, 3)))));
      lushow(cmn, ip1, ip1 + 1, qmax);
      luprep(cmn, ip1);
      mstj(92) = 0;
    } else if (mstj(92) < 0) {
      ip1 = -mstj(92);
      /// Clin-8/19/02 avoid actual argument in common blocks of LUSHOW:
      /// C          CALL LUSHOW(IP1,-3,P(IP,5))
      pip5 = p(ip, 5);
      lushow(cmn, ip1, -3, pip5);
      luprep(cmn, ip1);
      mstj(92) = 0;
    }
    /// C
    /// C...Jet fragmentation: string or independent fragmentation.
  } else if (k(ip, 1) == 1 || k(ip, 1) == 2) {
    mfrag = mstj(1);
    if (mfrag >= 1 && k(ip, 1) == 1) {
      mfrag = 2;
    }
    if (mstj(21) >= 2 && k(ip, 1) == 2 && n > ip) {
      if (k(ip + 1, 1) == 1 && k(ip + 1, 3) == k(ip, 3) && k(ip, 3) > 0 &&
          k(ip, 3) < ip) {
        if (kchg(lucomp(cmn, k(k(ip, 3), 2)), 2) == 0) {
          mfrag = fem::min(1, mfrag);
        }
      }
    }
    if (mfrag == 1) {
      lustrf(cmn, ip);
    }
    if (mfrag == 2) {
      luindf(cmn, ip);
    }
    if (mfrag == 2 && k(ip, 1) == 1) {
      mcons = 0;
    }
    if (mfrag == 2 && (mstj(3) <= 0 || fem::mod(mstj(3), 5) == 0)) {
      mcons = 0;
    }
  }
  /// C
  /// C...Loop back if enough space left in LUJETS and no error abort.
  if (mstu(24) != 0 && mstu(21) >= 2) {
  } else if (ip < n && n < mstu(4) - 20 - mstu(32)) {
    goto statement_140;
  } else if (ip < n) {
    luerrm(cmn, 11, "(LUEXEC:) no more memory left in LUJETS");
  }
  /// C
  /// C...Include simple Bose-Einstein effect parametrization if desired.
  if (mbe == 1 && mstj(51) >= 1) {
    luboei(cmn, nsav);
    goto statement_130;
  }
  /// C
  /// C...Check that momentum, energy and charge were conserved.
  FEM_DO_SAFE(i, 1, n) {
    if (k(i, 1) <= 0 || k(i, 1) > 10) {
      goto statement_160;
    }
    FEM_DO_SAFE(j, 1, 4) { ps(2, j) += p(i, j); }
    ps(2, 6) += luchge(cmn, k(i, 2));
  statement_160:;
  }
  pdev = (fem::abs(ps(2, 1) - ps(1, 1)) + fem::abs(ps(2, 2) - ps(1, 2)) +
          fem::abs(ps(2, 3) - ps(1, 3)) + fem::abs(ps(2, 4) - ps(1, 4))) /
         (1.f + fem::abs(ps(2, 4)) + fem::abs(ps(1, 4)));
  if (mcons == 1 && pdev > paru(11)) {
    luerrm(cmn, 15, "(LUEXEC:) four-momentum was not conserved");
  }
  /// C      IF(MCONS.EQ.1.AND.PDEV.GT.PARU(11)) then
  /// C         CALL LUERRM(15,
  /// C     &'(LUEXEC:) four-momentum was not conserved')
  /// C         write(6,*) 'PS1,2=',PS(1,1),PS(1,2),PS(1,3),PS(1,4),
  /// C     1        '*',PS(2,1),PS(2,2),PS(2,3),PS(2,4)
  /// C      endif
  /// C
  if (mcons == 1 && fem::abs(ps(2, 6) - ps(1, 6)) > 0.1f) {
    luerrm(cmn, 15, "(LUEXEC:) charge was not conserved");
  }
  /// C
}

/// C
/// C*********************************************************************
/// C THIS SUBROUTINE IS ONLY FOR THE USE OF HIJING TO ROTATE OR BOOST
/// C        THE FOUR MOMENTUM ONLY
/// C*********************************************************************
/// C
void hirobo(common& cmn, float const& the, float const& phi, float const& bex,
            float const& bey, float const& bez) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  ///
  int imin = fem::int0;
  int imax = fem::int0;
  double dbx = fem::double0;
  double dby = fem::double0;
  double dbz = fem::double0;
  arr_2d<3, 3, float> rot(fem::fill0);
  int i = fem::int0;
  int j = fem::int0;
  arr_1d<3, float> pr(fem::fill0);
  double db = fem::double0;
  double dga = fem::double0;
  arr_1d<4, double> dp(fem::fill0);
  double dbp = fem::double0;
  double dgabp = fem::double0;
  /// C
  /// C...Purpose: to perform rotations and boosts.
  /// C
  /// C...Find range of rotation/boost. Convert boost to double precision.
  imin = 1;
  if (mstu(1) > 0) {
    imin = mstu(1);
  }
  imax = n;
  if (mstu(2) > 0) {
    imax = mstu(2);
  }
  dbx = fem::dble(bex);
  dby = fem::dble(bey);
  dbz = fem::dble(bez);
  /// C
  /// C...Check range of rotation/boost.
  if (imin > mstu(4) || imax > mstu(4)) {
    luerrm(cmn, 11, "(LUROBO:) range outside LUJETS memory");
    return;
  }
  /// C
  /// C...Rotate, typically from z axis to direction (theta,phi).
  /// Clin-5/2012:
  /// C      IF(THE**2+PHI**2.GT.1E-20) THEN
  if ((fem::pow2(the) + fem::pow2(phi)) > 1e-20f) {
    rot(1, 1) = fem::cos(the) * fem::cos(phi);
    rot(1, 2) = -fem::sin(phi);
    rot(1, 3) = fem::sin(the) * fem::cos(phi);
    rot(2, 1) = fem::cos(the) * fem::sin(phi);
    rot(2, 2) = fem::cos(phi);
    rot(2, 3) = fem::sin(the) * fem::sin(phi);
    rot(3, 1) = -fem::sin(the);
    rot(3, 2) = 0.f;
    rot(3, 3) = fem::cos(the);
    FEM_DO_SAFE(i, imin, imax) {
      if (k(i, 1) <= 0) {
        goto statement_130;
      }
      FEM_DO_SAFE(j, 1, 3) { pr(j) = p(i, j); }
      FEM_DO_SAFE(j, 1, 3) {
        p(i, j) = rot(j, 1) * pr(1) + rot(j, 2) * pr(2) + rot(j, 3) * pr(3);
      }
    statement_130:;
    }
  }
  /// C
  /// C...Boost, typically from rest to momentum/energy=beta.
  /// Clin-5/2012:
  /// C      IF(DBX**2+DBY**2+DBZ**2.GT.1E-20) THEN
  if ((fem::pow2(dbx) + fem::pow2(dby) + fem::pow2(dbz)) > 1e-20) {
    db = fem::sqrt(fem::pow2(dbx) + fem::pow2(dby) + fem::pow2(dbz));
    if (db > 0.99999999e0) {
      /// C...Rescale boost vector if too close to unity.
      luerrm(cmn, 3, "(LUROBO:) boost vector too large");
      dbx = dbx * (0.99999999e0 / db);
      dby = dby * (0.99999999e0 / db);
      dbz = dbz * (0.99999999e0 / db);
      db = 0.99999999e0;
    }
    dga = 1e0 / fem::sqrt(1e0 - fem::pow2(db));
    FEM_DO_SAFE(i, imin, imax) {
      if (k(i, 1) <= 0) {
        goto statement_150;
      }
      FEM_DO_SAFE(j, 1, 4) { dp(j) = fem::dble(p(i, j)); }
      dbp = dbx * dp(1) + dby * dp(2) + dbz * dp(3);
      dgabp = dga * (dga * dbp / (1e0 + dga) + dp(4));
      p(i, 1) = fem::sngl(dp(1) + dgabp * dbx);
      p(i, 2) = fem::sngl(dp(2) + dgabp * dby);
      p(i, 3) = fem::sngl(dp(3) + dgabp * dbz);
      p(i, 4) = fem::sngl(dga * (dp(4) + dbp));
    statement_150:;
    }
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void luedit(common& cmn, int const& medit) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  int imax = fem::int0;
  int i1 = fem::int0;
  int i = fem::int0;
  int kc = fem::int0;
  int j = fem::int0;
  int id = fem::int0;
  int im = fem::int0;
  int kcm = fem::int0;
  int kcd = fem::int0;
  int kh = fem::int0;
  int is = fem::int0;
  arr_1d<2, int> ns(fem::fill0);
  arr_1d<2, float> pts(fem::fill0);
  arr_1d<2, float> pls(fem::fill0);
  /// C
  /// C...Purpose: to perform global manipulations on the event record,
  /// C...in particular to exclude unstable or undetectable partons/particles.
  /// C
  /// C...Remove unwanted partons/particles.
  if ((medit >= 0 && medit <= 3) || medit == 5) {
    imax = n;
    if (mstu(2) > 0) {
      imax = mstu(2);
    }
    i1 = fem::max(1, mstu(1)) - 1;
    FEM_DO_SAFE(i, fem::max(1, mstu(1)), imax) {
      if (k(i, 1) == 0 || k(i, 1) > 20) {
        goto statement_110;
      }
      if (medit == 1) {
        if (k(i, 1) > 10) {
          goto statement_110;
        }
      } else if (medit == 2) {
        if (k(i, 1) > 10) {
          goto statement_110;
        }
        kc = lucomp(cmn, k(i, 2));
        if (kc == 0 || kc == 12 || kc == 14 || kc == 16 || kc == 18) {
          goto statement_110;
        }
      } else if (medit == 3) {
        if (k(i, 1) > 10) {
          goto statement_110;
        }
        kc = lucomp(cmn, k(i, 2));
        if (kc == 0) {
          goto statement_110;
        }
        if (kchg(kc, 2) == 0 && luchge(cmn, k(i, 2)) == 0) {
          goto statement_110;
        }
      } else if (medit == 5) {
        if (k(i, 1) == 13 || k(i, 1) == 14) {
          goto statement_110;
        }
        kc = lucomp(cmn, k(i, 2));
        if (kc == 0) {
          goto statement_110;
        }
        if (k(i, 1) >= 11 && kchg(kc, 2) == 0) {
          goto statement_110;
        }
      }
      /// C
      /// C...Pack remaining partons/particles. Origin no longer known.
      i1++;
      FEM_DO_SAFE(j, 1, 5) {
        k(i1, j) = k(i, j);
        p(i1, j) = p(i, j);
        v(i1, j) = v(i, j);
      }
      k(i1, 3) = 0;
    statement_110:;
    }
    n = i1;
    /// C
    /// C...Selective removal of class of entries. New position of retained.
  } else if (medit >= 11 && medit <= 15) {
    i1 = 0;
    FEM_DO_SAFE(i, 1, n) {
      k(i, 3) = fem::mod(k(i, 3), mstu(5));
      if (medit == 11 && k(i, 1) < 0) {
        goto statement_120;
      }
      if (medit == 12 && k(i, 1) == 0) {
        goto statement_120;
      }
      if (medit == 13 && (k(i, 1) == 11 || k(i, 1) == 12 || k(i, 1) == 15) &&
          k(i, 2) != 94) {
        goto statement_120;
      }
      if (medit == 14 && (k(i, 1) == 13 || k(i, 1) == 14 || k(i, 2) == 94)) {
        goto statement_120;
      }
      if (medit == 15 && k(i, 1) >= 21) {
        goto statement_120;
      }
      i1++;
      k(i, 3) += mstu(5) * i1;
    statement_120:;
    }
    /// C
    /// C...Find new event history information and replace old.
    FEM_DO_SAFE(i, 1, n) {
      if (k(i, 1) <= 0 || k(i, 1) > 20 || k(i, 3) / mstu(5) == 0) {
        goto statement_140;
      }
      id = i;
    statement_130:
      im = fem::mod(k(id, 3), mstu(5));
      if (medit == 13 && im > 0 && im <= n) {
        if ((k(im, 1) == 11 || k(im, 1) == 12 || k(im, 1) == 15) &&
            k(im, 2) != 94) {
          id = im;
          goto statement_130;
        }
      } else if (medit == 14 && im > 0 && im <= n) {
        if (k(im, 1) == 13 || k(im, 1) == 14 || k(im, 2) == 94) {
          id = im;
          goto statement_130;
        }
      }
      k(i, 3) = mstu(5) * (k(i, 3) / mstu(5));
      if (im != 0) {
        k(i, 3) += k(im, 3) / mstu(5);
      }
      if (k(i, 1) != 3 && k(i, 1) != 13 && k(i, 1) != 14) {
        if (k(i, 4) > 0 && k(i, 4) <= mstu(4)) {
          k(i, 4) = k(k(i, 4), 3) / mstu(5);
        }
        if (k(i, 5) > 0 && k(i, 5) <= mstu(4)) {
          k(i, 5) = k(k(i, 5), 3) / mstu(5);
        }
      } else {
        kcm = fem::mod(k(i, 4) / mstu(5), mstu(5));
        if (kcm > 0 && kcm <= mstu(4)) {
          kcm = k(kcm, 3) / mstu(5);
        }
        kcd = fem::mod(k(i, 4), mstu(5));
        if (kcd > 0 && kcd <= mstu(4)) {
          kcd = k(kcd, 3) / mstu(5);
        }
        k(i, 4) = fem::pow2(mstu(5)) * (k(i, 4) / fem::pow2(mstu(5))) +
                  mstu(5) * kcm + kcd;
        kcm = fem::mod(k(i, 5) / mstu(5), mstu(5));
        if (kcm > 0 && kcm <= mstu(4)) {
          kcm = k(kcm, 3) / mstu(5);
        }
        kcd = fem::mod(k(i, 5), mstu(5));
        if (kcd > 0 && kcd <= mstu(4)) {
          kcd = k(kcd, 3) / mstu(5);
        }
        k(i, 5) = fem::pow2(mstu(5)) * (k(i, 5) / fem::pow2(mstu(5))) +
                  mstu(5) * kcm + kcd;
      }
    statement_140:;
    }
    /// C
    /// C...Pack remaining entries.
    i1 = 0;
    FEM_DO_SAFE(i, 1, n) {
      if (k(i, 3) / mstu(5) == 0) {
        goto statement_160;
      }
      i1++;
      FEM_DO_SAFE(j, 1, 5) {
        k(i1, j) = k(i, j);
        p(i1, j) = p(i, j);
        v(i1, j) = v(i, j);
      }
      k(i1, 3) = fem::mod(k(i1, 3), mstu(5));
    statement_160:;
    }
    n = i1;
    /// C
    /// C...Save top entries at bottom of LUJETS commonblock.
  } else if (medit == 21) {
    if (2 * n >= mstu(4)) {
      luerrm(cmn, 11, "(LUEDIT:) no more memory left in LUJETS");
      return;
    }
    FEM_DO_SAFE(i, 1, n) {
      FEM_DO_SAFE(j, 1, 5) {
        k(mstu(4) - i, j) = k(i, j);
        p(mstu(4) - i, j) = p(i, j);
        v(mstu(4) - i, j) = v(i, j);
      }
    }
    mstu(32) = n;
    /// C
    /// C...Restore bottom entries of commonblock LUJETS to top.
  } else if (medit == 22) {
    FEM_DO_SAFE(i, 1, mstu(32)) {
      FEM_DO_SAFE(j, 1, 5) {
        k(i, j) = k(mstu(4) - i, j);
        p(i, j) = p(mstu(4) - i, j);
        v(i, j) = v(mstu(4) - i, j);
      }
    }
    n = mstu(32);
    /// C
    /// C...Mark primary entries at top of commonblock LUJETS as untreated.
  } else if (medit == 23) {
    i1 = 0;
    FEM_DO_SAFE(i, 1, n) {
      kh = k(i, 3);
      if (kh >= 1) {
        if (k(kh, 1) > 20) {
          kh = 0;
        }
      }
      if (kh != 0) {
        goto statement_200;
      }
      i1++;
      if (k(i, 1) > 10 && k(i, 1) <= 20) {
        k(i, 1) = k(i, 1) - 10;
      }
    }
  statement_200:
    n = i1;
    /// C
    /// C...Place largest axis along z axis and second largest in xy plane.
  } else if (medit == 31 || medit == 32) {
    ludbrb(1, n + mstu(3), 0.f, -ulangl(cmn, p(mstu(61), 1), p(mstu(61), 2)),
           0e0, 0e0, 0e0);
    ludbrb(1, n + mstu(3), -ulangl(cmn, p(mstu(61), 3), p(mstu(61), 1)), 0.f,
           0e0, 0e0, 0e0);
    ludbrb(1, n + mstu(3), 0.f,
           -ulangl(cmn, p(mstu(61) + 1, 1), p(mstu(61) + 1, 2)), 0e0, 0e0, 0e0);
    if (medit == 31) {
      return;
    }
    /// C
    /// C...Rotate to put slim jet along +z axis.
    FEM_DO_SAFE(is, 1, 2) {
      ns(is) = 0;
      pts(is) = 0.f;
      pls(is) = 0.f;
    }
    FEM_DO_SAFE(i, 1, n) {
      if (k(i, 1) <= 0 || k(i, 1) > 10) {
        goto statement_220;
      }
      if (mstu(41) >= 2) {
        kc = lucomp(cmn, k(i, 2));
        if (kc == 0 || kc == 12 || kc == 14 || kc == 16 || kc == 18) {
          goto statement_220;
        }
        if (mstu(41) >= 3 && kchg(kc, 2) == 0 && luchge(cmn, k(i, 2)) == 0) {
          goto statement_220;
        }
      }
      is = fem::fint(2.f - fem::sign(0.5f, p(i, 3)));
      ns(is)++;
      pts(is) += fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)));
    statement_220:;
    }
    if (ns(1) * fem::pow2(pts(2)) < ns(2) * fem::pow2(pts(1))) {
      ludbrb(1, n + mstu(3), paru(1), 0.f, 0e0, 0e0, 0e0);
    }
    /// C
    /// C...Rotate to put second largest jet into -z,+x quadrant.
    FEM_DO_SAFE(i, 1, n) {
      if (p(i, 3) >= 0.f) {
        goto statement_230;
      }
      if (k(i, 1) <= 0 || k(i, 1) > 10) {
        goto statement_230;
      }
      if (mstu(41) >= 2) {
        kc = lucomp(cmn, k(i, 2));
        if (kc == 0 || kc == 12 || kc == 14 || kc == 16 || kc == 18) {
          goto statement_230;
        }
        if (mstu(41) >= 3 && kchg(kc, 2) == 0 && luchge(cmn, k(i, 2)) == 0) {
          goto statement_230;
        }
      }
      is = fem::fint(2.f - fem::sign(0.5f, p(i, 1)));
      pls(is) = pls(is) - p(i, 3);
    statement_230:;
    }
    if (pls(2) > pls(1)) {
      ludbrb(1, n + mstu(3), 0.f, paru(1), 0e0, 0e0, 0e0);
    }
  }
  /// C
}

struct hijfrg_save {
  fem::variant_bindings hstrng_bindings;
  float am1;
  float am2;
  float amt;
  float amt1;
  float amt2;
  float btz;
  float hdat20;
  float hpr150;
  int i;
  int i0;
  int iex;
  int ii;
  int isg;
  int j;
  int jetot;
  int jj;
  int kf1;
  int kf2;
  int kk1;
  float pb1;
  float pb2;
  float pb3;
  float pecm;
  float pmax1;
  float pmax2;
  float pmax3;
  float pq11;
  float pq12;
  float pq21;
  float pq22;
  float pzcm;

  hijfrg_save()
      : am1(fem::float0),
        am2(fem::float0),
        amt(fem::float0),
        amt1(fem::float0),
        amt2(fem::float0),
        btz(fem::float0),
        hdat20(fem::float0),
        hpr150(fem::float0),
        i(fem::int0),
        i0(fem::int0),
        iex(fem::int0),
        ii(fem::int0),
        isg(fem::int0),
        j(fem::int0),
        jetot(fem::int0),
        jj(fem::int0),
        kf1(fem::int0),
        kf2(fem::int0),
        kk1(fem::int0),
        pb1(fem::float0),
        pb2(fem::float0),
        pb3(fem::float0),
        pecm(fem::float0),
        pmax1(fem::float0),
        pmax2(fem::float0),
        pmax3(fem::float0),
        pq11(fem::float0),
        pq12(fem::float0),
        pq21(fem::float0),
        pq22(fem::float0),
        pzcm(fem::float0) {}
};

void hijfrg(common& cmn, int const& jtp, int const& ntp, int& ierror) {
  FEM_CMN_SVE(hijfrg);
  common_write write(cmn);
  arr_ref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_ref<float> hidat(cmn.hidat, dimension(10));
  arr_cref<int> npj(cmn.npj, dimension(300));
  arr_cref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_cref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_cref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_cref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_cref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_cref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_cref<int> ntj(cmn.ntj, dimension(300));
  arr_cref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_cref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_cref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_cref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_cref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_cref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  const int maxstr = 150001;
  arr_cref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_cref<int, 2> k1sg(cmn.k1sg, dimension(maxstr, 100));
  arr_cref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_cref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_cref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_cref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_cref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_cref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  int& nseed = cmn.nseed;
  int& isoft = cmn.isoft;
  int& isflag = cmn.isflag;
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  float& am1 = sve.am1;
  float& am2 = sve.am2;
  float& amt = sve.amt;
  float& amt1 = sve.amt1;
  float& amt2 = sve.amt2;
  float& btz = sve.btz;
  float& hdat20 = sve.hdat20;
  float& hpr150 = sve.hpr150;
  int& i = sve.i;
  int& i0 = sve.i0;
  int& iex = sve.iex;
  int& ii = sve.ii;
  int& isg = sve.isg;
  int& j = sve.j;
  int& jetot = sve.jetot;
  int& jj = sve.jj;
  int& kf1 = sve.kf1;
  int& kf2 = sve.kf2;
  int& kk1 = sve.kk1;
  float& pb1 = sve.pb1;
  float& pb2 = sve.pb2;
  float& pb3 = sve.pb3;
  float& pecm = sve.pecm;
  float& pmax1 = sve.pmax1;
  float& pmax2 = sve.pmax2;
  float& pmax3 = sve.pmax3;
  float& pq11 = sve.pq11;
  float& pq12 = sve.pq12;
  float& pq21 = sve.pq21;
  float& pq22 = sve.pq22;
  float& pzcm = sve.pzcm;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_cref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_cref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  /// C        NTP=1, fragment proj string, NTP=2, targ string,
  /// C       NTP=3, independent
  /// C        strings from jets.  JTP is the line number of the string
  /// C*******Fragment all leadng strings of proj and targ**************
  /// C        IHNT2(1)=atomic #, IHNT2(2)=proton #(=-1 if anti-proton)  *
  /// C******************************************************************
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HIJDAT/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// C
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /LUDAT1/
  /// Cc      SAVE /RNDF77/
  /// Clin-4/11/01 soft:
  /// Cc      SAVE /anim/
  /// C
  /// Cbz3/12/99
  /// C.....set up fragmentation function according to the number of collisions
  /// C.....a wounded nucleon has suffered
  /// C        IF (NTP .EQ. 1) THEN
  /// C           NCOLL = NFP(JTP, 11)
  /// C        ELSE IF (NTP .EQ. 2) THEN
  /// C           NCOLL = NFT(JTP, 11)
  /// C        ELSE IF (NTP .EQ. 3) THEN
  /// C           NCOLL = (NFP(IASG(JTP,1), 11) + NFT(IASG(JTP,2), 11)) / 2
  /// C        END IF
  /// C        IF (NCOLL .LE. 1) THEN
  /// C           PARJ(5) = 0.5
  /// C        ELSE IF (NCOLL .EQ. 2) THEN
  /// C           PARJ(5) = 0.75
  /// C        ELSE IF (NCOLL .EQ. 3) THEN
  /// C           PARJ(5) = 1.17
  /// C        ELSE IF (NCOLL .EQ. 4) THEN
  /// C           PARJ(5) = 2.0
  /// C        ELSE IF (NCOLL .EQ. 5) THEN
  /// C           PARJ(5) = 4.5
  /// C        ELSE IF (NCOLL .GE. 6) THEN
  /// C           PARJ(5) = 49.5
  /// C        END IF
  /// C        PARJ(5) = 0.5
  /// Cbz3/12/99 end
  /// C
  ierror = 0;
  luedit(cmn, 0);
  n = 0;
  /// C                        ********initialize the document lines
  if (ntp == 3) {
    isg = jtp;
    n = njsg(isg);
    FEM_DO_SAFE(i, 1, njsg(isg)) {
      k(i, 1) = k1sg(isg, i);
      k(i, 2) = k2sg(isg, i);
      p(i, 1) = pxsg(isg, i);
      p(i, 2) = pysg(isg, i);
      p(i, 3) = pzsg(isg, i);
      p(i, 4) = pesg(isg, i);
      p(i, 5) = pmsg(isg, i);
    }
    /// C
    /// C                IF(IHPR2(1).GT.0) CALL ATTRAD(IERROR)
    /// C                IF(IERROR.NE.0) RETURN
    /// C                CALL LULIST(1)
    if (isoft != 2 || isflag != 0) {
      luexec(cmn);
    }
    return;
  }
  /// C
  if (ntp == 2) {
    goto statement_200;
  }
  if (jtp > ihnt2(1)) {
    return;
  }
  if (nfp(jtp, 5) != 3 && nfp(jtp, 3) != 0 && npj(jtp) == 0 &&
      nfp(jtp, 10) == 0) {
    goto statement_1000;
  }
  if (nfp(jtp, 15) == -1) {
    kf1 = nfp(jtp, 2);
    kf2 = nfp(jtp, 1);
    pq21 = pp(jtp, 6);
    pq22 = pp(jtp, 7);
    pq11 = pp(jtp, 8);
    pq12 = pp(jtp, 9);
    am1 = pp(jtp, 15);
    am2 = pp(jtp, 14);
  } else {
    kf1 = nfp(jtp, 1);
    kf2 = nfp(jtp, 2);
    pq21 = pp(jtp, 8);
    pq22 = pp(jtp, 9);
    pq11 = pp(jtp, 6);
    pq12 = pp(jtp, 7);
    am1 = pp(jtp, 14);
    am2 = pp(jtp, 15);
  }
  /// C
  /// C        ********for NFP(JTP,15)=-1 NFP(JTP,1) IS IN -Z DIRECTION
  pb1 = pq11 + pq21;
  pb2 = pq12 + pq22;
  pb3 = pp(jtp, 3);
  pecm = pp(jtp, 5);
  btz = pb3 / pp(jtp, 4);
  if ((fem::abs(pb1 - pp(jtp, 1)) > 0.01f ||
       fem::abs(pb2 - pp(jtp, 2)) > 0.01f) &&
      ihpr2(10) != 0) {
    write(6, star), "  Pt of Q and QQ do not sum to the total", jtp, ntp, pq11,
        pq21, pb1, "*", pq12, pq22, pb2, "*", pp(jtp, 1), pp(jtp, 2);
  }
  goto statement_300;
/// C
statement_200:
  if (jtp > ihnt2(3)) {
    return;
  }
  if (nft(jtp, 5) != 3 && nft(jtp, 3) != 0 && ntj(jtp) == 0 &&
      nft(jtp, 10) == 0) {
    goto statement_1200;
  }
  if (nft(jtp, 15) == 1) {
    kf1 = nft(jtp, 1);
    kf2 = nft(jtp, 2);
    pq11 = pt(jtp, 6);
    pq12 = pt(jtp, 7);
    pq21 = pt(jtp, 8);
    pq22 = pt(jtp, 9);
    am1 = pt(jtp, 14);
    am2 = pt(jtp, 15);
  } else {
    kf1 = nft(jtp, 2);
    kf2 = nft(jtp, 1);
    pq11 = pt(jtp, 8);
    pq12 = pt(jtp, 9);
    pq21 = pt(jtp, 6);
    pq22 = pt(jtp, 7);
    am1 = pt(jtp, 15);
    am2 = pt(jtp, 14);
  }
  /// C        ********for NFT(JTP,15)=1 NFT(JTP,1) IS IN +Z DIRECTION
  pb1 = pq11 + pq21;
  pb2 = pq12 + pq22;
  pb3 = pt(jtp, 3);
  pecm = pt(jtp, 5);
  btz = pb3 / pt(jtp, 4);
  /// C
  if ((fem::abs(pb1 - pt(jtp, 1)) > 0.01f ||
       fem::abs(pb2 - pt(jtp, 2)) > 0.01f) &&
      ihpr2(10) != 0) {
    write(6, star), "  Pt of Q and QQ do not sum to the total", jtp, ntp, pq11,
        pq21, pb1, "*", pq12, pq22, pb2, "*", pt(jtp, 1), pt(jtp, 2);
  }
statement_300:
  if (pecm < hipr1(1)) {
    ierror = 1;
    if (ihpr2(10) == 0) {
      return;
    }
    write(6, star), " ECM=", pecm, " energy of the string is too small";
    /// Clin:
    write(6, star), "JTP,NTP,pq=", jtp, ntp, pq11, pq12, pq21, pq22;
    return;
  }
  amt = fem::pow2(pecm) + fem::pow2(pb1) + fem::pow2(pb2);
  amt1 = fem::pow2(am1) + fem::pow2(pq11) + fem::pow2(pq12);
  amt2 = fem::pow2(am2) + fem::pow2(pq21) + fem::pow2(pq22);
  pzcm = fem::sqrt(fem::abs(fem::pow2(amt) + fem::pow2(amt1) + fem::pow2(amt2) -
                            2.0f * amt * amt1 - 2.0f * amt * amt2 -
                            2.0f * amt1 * amt2)) /
         2.0f / fem::sqrt(amt);
  /// C                *******PZ of end-partons in c.m. frame of the string
  k(1, 1) = 2;
  k(1, 2) = kf1;
  p(1, 1) = pq11;
  p(1, 2) = pq12;
  p(1, 3) = pzcm;
  p(1, 4) = fem::sqrt(amt1 + fem::pow2(pzcm));
  p(1, 5) = am1;
  k(2, 1) = 1;
  k(2, 2) = kf2;
  p(2, 1) = pq21;
  p(2, 2) = pq22;
  p(2, 3) = -pzcm;
  p(2, 4) = fem::sqrt(amt2 + fem::pow2(pzcm));
  p(2, 5) = am2;
  n = 2;
  /// C*****
  hirobo(cmn, 0.0f, 0.0f, 0.0f, 0.0f, btz);
  jetot = 0;
  if ((fem::pow2(pq21) + fem::pow2(pq22)) >
      (fem::pow2(pq11) + fem::pow2(pq12))) {
    pmax1 = p(2, 1);
    pmax2 = p(2, 2);
    pmax3 = p(2, 3);
  } else {
    pmax1 = p(1, 1);
    pmax2 = p(1, 2);
    pmax3 = p(1, 3);
  }
  if (ntp == 1) {
    pp(jtp, 10) = pmax1;
    pp(jtp, 11) = pmax2;
    pp(jtp, 12) = pmax3;
  } else if (ntp == 2) {
    pt(jtp, 10) = pmax1;
    pt(jtp, 11) = pmax2;
    pt(jtp, 12) = pmax3;
  }
  /// C*******************attach produced jets to the leadng partons****
  if (ntp == 1 && npj(jtp) != 0) {
    jetot = npj(jtp);
    /// C                IF(NPJ(JTP).GE.2) CALL HIJSRT(JTP,1)
    /// C                        ********sort jets in order of y
    iex = 0;
    if ((fem::abs(kf1) > 1000 && kf1 < 0) ||
        (fem::abs(kf1) < 1000 && kf1 > 0)) {
      iex = 1;
    }
    FEM_DOSTEP(i, n, 2, -1) {
      FEM_DO_SAFE(j, 1, 5) {
        ii = npj(jtp) + i;
        k(ii, j) = k(i, j);
        p(ii, j) = p(i, j);
        v(ii, j) = v(i, j);
      }
    }
    /// C
    FEM_DO_SAFE(i, 1, npj(jtp)) {
      FEM_DO_SAFE(j, 1, 5) {
        k(i + 1, j) = 0;
        v(i + 1, j) = 0;
      }
      i0 = i;
      /// Clin-4/12/01:                        IF(IEX.EQ.1) I0=NPJ(JTP)-I+1
      if (iex == 1 && (isoft != 2 || isflag != 0)) {
        i0 = npj(jtp) - i + 1;
      }
      /// C                                ********reverse the order of jets
      kk1 = kfpj(jtp, i0);
      k(i + 1, 1) = 2;
      k(i + 1, 2) = kk1;
      if (kk1 != 21 && kk1 != 0) {
        k(i + 1, 1) =
            1 + (fem::abs(kk1) + (2 * iex - 1) * kk1) / 2 / fem::abs(kk1);
      }
      p(i + 1, 1) = pjpx(jtp, i0);
      p(i + 1, 2) = pjpy(jtp, i0);
      p(i + 1, 3) = pjpz(jtp, i0);
      p(i + 1, 4) = pjpe(jtp, i0);
      p(i + 1, 5) = pjpm(jtp, i0);
    }
    n += npj(jtp);
  } else if (ntp == 2 && ntj(jtp) != 0) {
    jetot = ntj(jtp);
    /// C                IF(NTJ(JTP).GE.2)  CALL HIJSRT(JTP,2)
    /// C                        ********sort jets in order of y
    iex = 1;
    if ((fem::abs(kf2) > 1000 && kf2 < 0) ||
        (fem::abs(kf2) < 1000 && kf2 > 0)) {
      iex = 0;
    }
    FEM_DOSTEP(i, n, 2, -1) {
      FEM_DO_SAFE(j, 1, 5) {
        ii = ntj(jtp) + i;
        k(ii, j) = k(i, j);
        p(ii, j) = p(i, j);
        v(ii, j) = v(i, j);
      }
    }
    FEM_DO_SAFE(i, 1, ntj(jtp)) {
      FEM_DO_SAFE(j, 1, 5) {
        k(i + 1, j) = 0;
        v(i + 1, j) = 0;
      }
      i0 = i;
      /// Clin-4/12/01:                        IF(IEX.EQ.1) I0=NTJ(JTP)-I+1
      if (iex == 1 && (isoft != 2 || isflag != 0)) {
        i0 = ntj(jtp) - i + 1;
      }
      /// C                                ********reverse the order of jets
      kk1 = kftj(jtp, i0);
      k(i + 1, 1) = 2;
      k(i + 1, 2) = kk1;
      if (kk1 != 21 && kk1 != 0) {
        k(i + 1, 1) =
            1 + (fem::abs(kk1) + (2 * iex - 1) * kk1) / 2 / fem::abs(kk1);
      }
      p(i + 1, 1) = pjtx(jtp, i0);
      p(i + 1, 2) = pjty(jtp, i0);
      p(i + 1, 3) = pjtz(jtp, i0);
      p(i + 1, 4) = pjte(jtp, i0);
      p(i + 1, 5) = pjtm(jtp, i0);
    }
    n += ntj(jtp);
  }
  if (ihpr2(1) > 0 && ranart(nseed) <= hidat(3)) {
    hdat20 = hidat(2);
    hpr150 = hipr1(5);
    if (ihpr2(8) == 0 && ihpr2(3) == 0 && ihpr2(9) == 0) {
      hidat(2) = 2.0f;
    }
    if (hint1(1) >= 1000.0f && jetot == 0) {
      hidat(2) = 3.0f;
      hipr1(5) = 5.0f;
    }
    attrad(cmn, ierror);
    hidat(2) = hdat20;
    hipr1(5) = hpr150;
  } else if (jetot == 0 && ihpr2(1) > 0 && hint1(1) >= 1000.0f &&
             ranart(nseed) <= 0.8f) {
    hdat20 = hidat(2);
    hpr150 = hipr1(5);
    hidat(2) = 3.0f;
    hipr1(5) = 5.0f;
    if (ihpr2(8) == 0 && ihpr2(3) == 0 && ihpr2(9) == 0) {
      hidat(2) = 2.0f;
    }
    attrad(cmn, ierror);
    hidat(2) = hdat20;
    hipr1(5) = hpr150;
  }
  if (ierror != 0) {
    return;
  }
  /// C                ******** conduct soft radiations
  /// C****************************
  /// C
  /// Clin-4/11/01 soft:
  /// C        CALL LUEXEC
  if (isoft != 2 || isflag != 0) {
    luexec(cmn);
  }
  /// C
  return;
/// C
statement_1000:
  n = 1;
  k(1, 1) = 1;
  k(1, 2) = nfp(jtp, 3);
  FEM_DO_SAFE(jj, 1, 5) { p(1, jj) = pp(jtp, jj); }
  /// C                        ********proj remain as a nucleon or delta
  /// Clin-4/11/01 soft:
  /// C        CALL LUEXEC
  if (isoft != 2 || isflag != 0) {
    luexec(cmn);
  }
  /// C
  /// C        call lulist(1)
  return;
/// C
statement_1200:
  n = 1;
  k(1, 1) = 1;
  k(1, 2) = nft(jtp, 3);
  FEM_DO_SAFE(jj, 1, 5) { p(1, jj) = pt(jtp, jj); }
  /// C                        ********targ remain as a nucleon or delta
  /// Clin-4/11/01 soft:
  /// C        CALL LUEXEC
  if (isoft != 2 || isflag != 0) {
    luexec(cmn);
  }
  /// C
  /// C        call lulist(1)
}

struct pyovly_save {
  int imax;
  arr<float> wti;
  float wts;

  pyovly_save()
      : imax(fem::int0), wti(dim1(0, 100), fem::fill0), wts(fem::float0) {}
};

/// C
/// C*********************************************************************
/// C
void pyovly(common& cmn, int const& movly) {
  FEM_CMN_SVE(pyovly);
  common_write write(cmn);
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  ///
  int& imax = sve.imax;
  arr_ref<float> wti(sve.wti, dim1(0, 100));
  float& wts = sve.wts;
  float xnave = fem::float0;
  float wtn = fem::float0;
  int i = fem::int0;
  float wtr = fem::float0;
  static const char* format_1000 =
      "(1x,'Warning: requested average number of events per bunch',"
      "'crossing too large, ',1p,e12.4)";
  /// C
  /// C...Initializes multiplicity distribution and selects mutliplicity
  /// C...of overlayed events, i.e. several events occuring at the same
  /// C...beam crossing.
  /// C
  /// C...Sum of allowed cross-sections for overlayed events.
  if (movly == 1) {
    vint(131) = vint(106);
    if (mstp(132) >= 2) {
      vint(131) += vint(104);
    }
    if (mstp(132) >= 3) {
      vint(131) += vint(103);
    }
    if (mstp(132) >= 4) {
      vint(131) += vint(102);
    }
    /// C
    /// C...Initialize multiplicity distribution for unbiased events.
    if (mstp(133) == 1) {
      xnave = vint(131) * parp(131);
      if (xnave > 40.f) {
        write(mstu(11), format_1000), xnave;
      }
      wti(0) = fem::exp(-fem::min(50.f, xnave));
      wts = 0.f;
      wtn = 0.f;
      FEM_DO_SAFE(i, 1, 100) {
        wti(i) = wti(i - 1) * xnave / i;
        if (i - 2.5f > xnave && wti(i) < 1e-6f) {
          goto statement_110;
        }
        wts += wti(i);
        wtn += wti(i) * i;
        imax = i;
      }
    statement_110:
      vint(132) = xnave;
      vint(133) = wtn / wts;
      vint(134) = wts;
      /// C
      /// C...Initialize mutiplicity distribution for biased events.
    } else if (mstp(133) == 2) {
      xnave = vint(131) * parp(131);
      if (xnave > 40.f) {
        write(mstu(11), format_1000), xnave;
      }
      wti(1) = fem::exp(-fem::min(50.f, xnave)) * xnave;
      wts = wti(1);
      wtn = wti(1);
      FEM_DO_SAFE(i, 2, 100) {
        wti(i) = wti(i - 1) * xnave / (i - 1);
        if (i - 2.5f > xnave && wti(i) < 1e-6f) {
          goto statement_130;
        }
        wts += wti(i);
        wtn += wti(i) * i;
        imax = i;
      }
    statement_130:
      vint(132) = xnave;
      vint(133) = wtn / wts;
      vint(134) = wts;
    }
    /// C
    /// C...Pick multiplicity of overlayed events.
  } else {
    if (mstp(133) == 0) {
      mint(81) = fem::max(1, mstp(134));
    } else {
      wtr = wts * rlu(cmn, 0);
      FEM_DO_SAFE(i, 1, imax) {
        mint(81) = i;
        wtr = wtr - wti(i);
        if (wtr <= 0.f) {
          goto statement_150;
        }
      }
    statement_150:;
    }
  }
  /// C
  /// C...Format statement for error message.
  /// C
}

/// C
/// C***********************************************************************
/// C
void pyklim(common& cmn, int const& ilim) {
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_cref<float> ckin(cmn.ckin, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  ///
  int isub = fem::int0;
  float sqm3 = fem::float0;
  float sqm4 = fem::float0;
  float tau = fem::float0;
  float rm3 = fem::float0;
  float rm4 = fem::float0;
  float be34 = fem::float0;
  float pthmin = fem::float0;
  float yst = fem::float0;
  float cth = fem::float0;
  float taup = fem::float0;
  float x1 = fem::float0;
  float x2 = fem::float0;
  float xf = fem::float0;
  float pth = fem::float0;
  float y3 = fem::float0;
  float y4 = fem::float0;
  float ylarge = fem::float0;
  float ysmall = fem::float0;
  float etalar = fem::float0;
  float etasma = fem::float0;
  float sth = fem::float0;
  float expet3 = fem::float0;
  float expet4 = fem::float0;
  float eta3 = fem::float0;
  float eta4 = fem::float0;
  float cts3 = fem::float0;
  float cts4 = fem::float0;
  float ctslar = fem::float0;
  float ctssma = fem::float0;
  float taumn0 = fem::float0;
  float taumx0 = fem::float0;
  float taumn1 = fem::float0;
  float taumx1 = fem::float0;
  float tm3 = fem::float0;
  float tm4 = fem::float0;
  float ydcosh = fem::float0;
  float taumn2 = fem::float0;
  float taumx2 = fem::float0;
  float cth2mn = fem::float0;
  float cth2mx = fem::float0;
  float taumn3 = fem::float0;
  float taumx3 = fem::float0;
  float taumn4 = fem::float0;
  float taumx4 = fem::float0;
  float taumn5 = fem::float0;
  float taumx5 = fem::float0;
  float taurt = fem::float0;
  float ystmn0 = fem::float0;
  float ystmx0 = fem::float0;
  float ystmn1 = fem::float0;
  float ystmx1 = fem::float0;
  float ystmn2 = fem::float0;
  float ystmx2 = fem::float0;
  float ystmn3 = fem::float0;
  float ystmx3 = fem::float0;
  float yepmn4 = fem::float0;
  float ystmn4 = fem::float0;
  float yepmx4 = fem::float0;
  float ystmx4 = fem::float0;
  float yepsmn = fem::float0;
  float yepsmx = fem::float0;
  float ydifmn = fem::float0;
  float ydifmx = fem::float0;
  float ystmn5 = fem::float0;
  float ystmx5 = fem::float0;
  float cthlim = fem::float0;
  float rzmn = fem::float0;
  float rzmx = fem::float0;
  float yex3mx = fem::float0;
  float yex4mx = fem::float0;
  float yex3mn = fem::float0;
  float yex4mn = fem::float0;
  float ystmn6 = fem::float0;
  float ystmx6 = fem::float0;
  float ctnmn0 = fem::float0;
  float ctnmx0 = fem::float0;
  float ctpmn0 = fem::float0;
  float ctpmx0 = fem::float0;
  float ctnmn1 = fem::float0;
  float ctnmx1 = fem::float0;
  float ctpmn1 = fem::float0;
  float ctpmx1 = fem::float0;
  float ctnmn2 = fem::float0;
  float ctpmx2 = fem::float0;
  float ctnmx2 = fem::float0;
  float ctpmn2 = fem::float0;
  float ctnmn3 = fem::float0;
  float ctnmx3 = fem::float0;
  float ctpmn3 = fem::float0;
  float ctpmx3 = fem::float0;
  float tapmn0 = fem::float0;
  float tapmx0 = fem::float0;
  float tapmn1 = fem::float0;
  float tapmx1 = fem::float0;
  float st2eff = fem::float0;
  /// C
  /// C...Checks generated variables against pre-set kinematical limits;
  /// C...also calculates limits on variables used in generation.
  /// C
  /// C...Common kinematical expressions.
  isub = mint(1);
  if (isub == 96) {
    goto statement_110;
  }
  sqm3 = vint(63);
  sqm4 = vint(64);
  if (ilim != 1) {
    tau = vint(21);
    rm3 = sqm3 / (tau * vint(2));
    rm4 = sqm4 / (tau * vint(2));
    be34 = fem::sqrt(fem::pow2((1.f - rm3 - rm4)) - 4.f * rm3 * rm4);
  }
  pthmin = ckin(3);
  if (fem::min(sqm3, sqm4) < fem::pow2(ckin(6))) {
    pthmin = fem::max(ckin(3), ckin(5));
  }
  if (ilim == 0) {
    /// C...Check generated values of tau, y*, cos(theta-hat), and tau' against
    /// C...pre-set kinematical limits.
    yst = vint(22);
    cth = vint(23);
    taup = vint(26);
    if (iset(isub) <= 2) {
      x1 = fem::sqrt(tau) * fem::exp(yst);
      x2 = fem::sqrt(tau) * fem::exp(-yst);
    } else {
      x1 = fem::sqrt(taup) * fem::exp(yst);
      x2 = fem::sqrt(taup) * fem::exp(-yst);
    }
    xf = x1 - x2;
    if (tau * vint(2) < fem::pow2(ckin(1))) {
      mint(51) = 1;
    }
    if (ckin(2) >= 0.f && tau * vint(2) > fem::pow2(ckin(2))) {
      mint(51) = 1;
    }
    if (x1 < ckin(21) || x1 > ckin(22)) {
      mint(51) = 1;
    }
    if (x2 < ckin(23) || x2 > ckin(24)) {
      mint(51) = 1;
    }
    if (xf < ckin(25) || xf > ckin(26)) {
      mint(51) = 1;
    }
    if (yst < ckin(7) || yst > ckin(8)) {
      mint(51) = 1;
    }
    if (iset(isub) == 2 || iset(isub) == 4) {
      pth = 0.5f * be34 * fem::sqrt(tau * vint(2) * (1.f - fem::pow2(cth)));
      y3 = yst + 0.5f * fem::log((1.f + rm3 - rm4 + be34 * cth) /
                                 (1.f + rm3 - rm4 - be34 * cth));
      y4 = yst + 0.5f * fem::log((1.f + rm4 - rm3 - be34 * cth) /
                                 (1.f + rm4 - rm3 + be34 * cth));
      ylarge = fem::max(y3, y4);
      ysmall = fem::min(y3, y4);
      etalar = 10.f;
      etasma = -10.f;
      sth = fem::sqrt(1.f - fem::pow2(cth));
      if (sth < 1.e-6f) {
        goto statement_100;
      }
      expet3 =
          ((1.f + rm3 - rm4) * fem::sinh(yst) + be34 * fem::cosh(yst) * cth +
           fem::sqrt(fem::pow2(((1.f + rm3 - rm4) * fem::cosh(yst) +
                                be34 * fem::sinh(yst) * cth)) -
                     4.f * rm3)) /
          (be34 * sth);
      expet4 =
          ((1.f - rm3 + rm4) * fem::sinh(yst) - be34 * fem::cosh(yst) * cth +
           fem::sqrt(fem::pow2(((1.f - rm3 + rm4) * fem::cosh(yst) -
                                be34 * fem::sinh(yst) * cth)) -
                     4.f * rm4)) /
          (be34 * sth);
      eta3 = fem::log(fem::min(1.e10f, fem::max(1.e-10f, expet3)));
      eta4 = fem::log(fem::min(1.e10f, fem::max(1.e-10f, expet4)));
      etalar = fem::max(eta3, eta4);
      etasma = fem::min(eta3, eta4);
    statement_100:
      cts3 =
          ((1.f + rm3 - rm4) * fem::sinh(yst) + be34 * fem::cosh(yst) * cth) /
          fem::sqrt(fem::pow2(((1.f + rm3 - rm4) * fem::cosh(yst) +
                               be34 * fem::sinh(yst) * cth)) -
                    4.f * rm3);
      cts4 =
          ((1.f - rm3 + rm4) * fem::sinh(yst) - be34 * fem::cosh(yst) * cth) /
          fem::sqrt(fem::pow2(((1.f - rm3 + rm4) * fem::cosh(yst) -
                               be34 * fem::sinh(yst) * cth)) -
                    4.f * rm4);
      ctslar = fem::max(cts3, cts4);
      ctssma = fem::min(cts3, cts4);
      if (pth < pthmin) {
        mint(51) = 1;
      }
      if (ckin(4) >= 0.f && pth > ckin(4)) {
        mint(51) = 1;
      }
      if (ylarge < ckin(9) || ylarge > ckin(10)) {
        mint(51) = 1;
      }
      if (ysmall < ckin(11) || ysmall > ckin(12)) {
        mint(51) = 1;
      }
      if (etalar < ckin(13) || etalar > ckin(14)) {
        mint(51) = 1;
      }
      if (etasma < ckin(15) || etasma > ckin(16)) {
        mint(51) = 1;
      }
      if (ctslar < ckin(17) || ctslar > ckin(18)) {
        mint(51) = 1;
      }
      if (ctssma < ckin(19) || ctssma > ckin(20)) {
        mint(51) = 1;
      }
      if (cth < ckin(27) || cth > ckin(28)) {
        mint(51) = 1;
      }
    }
    if (iset(isub) == 3 || iset(isub) == 4) {
      if (taup * vint(2) < fem::pow2(ckin(31))) {
        mint(51) = 1;
      }
      if (ckin(32) >= 0.f && taup * vint(2) > fem::pow2(ckin(32))) {
        mint(51) = 1;
      }
    }
    /// C
  } else if (ilim == 1) {
    /// C...Calculate limits on tau
    /// C...0) due to definition
    taumn0 = 0.f;
    taumx0 = 1.f;
    /// C...1) due to limits on subsystem mass
    taumn1 = fem::pow2(ckin(1)) / vint(2);
    taumx1 = 1.f;
    if (ckin(2) >= 0.f) {
      taumx1 = fem::pow2(ckin(2)) / vint(2);
    }
    /// C...2) due to limits on pT-hat (and non-overlapping rapidity intervals)
    tm3 = fem::sqrt(sqm3 + fem::pow2(pthmin));
    tm4 = fem::sqrt(sqm4 + fem::pow2(pthmin));
    ydcosh = 1.f;
    if (ckin(9) > ckin(12)) {
      ydcosh = fem::cosh(ckin(9) - ckin(12));
    }
    taumn2 =
        (fem::pow2(tm3) + 2.f * tm3 * tm4 * ydcosh + fem::pow2(tm4)) / vint(2);
    taumx2 = 1.f;
    /// C...3) due to limits on pT-hat and cos(theta-hat)
    cth2mn = fem::min(fem::pow2(ckin(27)), fem::pow2(ckin(28)));
    cth2mx = fem::max(fem::pow2(ckin(27)), fem::pow2(ckin(28)));
    taumn3 = 0.f;
    if (ckin(27) * ckin(28) > 0.f) {
      taumn3 =
          fem::pow2((fem::sqrt(sqm3 + fem::pow2(pthmin) / (1.f - cth2mn)) +
                     fem::sqrt(sqm4 + fem::pow2(pthmin) / (1.f - cth2mn)))) /
          vint(2);
    }
    taumx3 = 1.f;
    if (ckin(4) >= 0.f && cth2mx < 1.f) {
      taumx3 =
          fem::pow2((fem::sqrt(sqm3 + fem::pow2(ckin(4)) / (1.f - cth2mx)) +
                     fem::sqrt(sqm4 + fem::pow2(ckin(4)) / (1.f - cth2mx)))) /
          vint(2);
    }
    /// C...4) due to limits on x1 and x2
    taumn4 = ckin(21) * ckin(23);
    taumx4 = ckin(22) * ckin(24);
    /// C...5) due to limits on xF
    taumn5 = 0.f;
    taumx5 = fem::max(1.f - ckin(25), 1.f + ckin(26));
    vint(11) = fem::max(taumn0, taumn1, taumn2, taumn3, taumn4, taumn5);
    vint(31) = fem::min(taumx0, taumx1, taumx2, taumx3, taumx4, taumx5);
    if (mint(43) == 1 && (iset(isub) == 1 || iset(isub) == 2)) {
      vint(11) = 0.99999f;
      vint(31) = 1.00001f;
    }
    if (vint(31) <= vint(11)) {
      mint(51) = 1;
    }
    /// C
  } else if (ilim == 2) {
    /// C...Calculate limits on y*
    if (iset(isub) == 3 || iset(isub) == 4) {
      tau = vint(26);
    }
    taurt = fem::sqrt(tau);
    /// C...0) due to kinematics
    ystmn0 = fem::log(taurt);
    ystmx0 = -ystmn0;
    /// C...1) due to explicit limits
    ystmn1 = ckin(7);
    ystmx1 = ckin(8);
    /// C...2) due to limits on x1
    ystmn2 = fem::log(fem::max(tau, ckin(21)) / taurt);
    ystmx2 = fem::log(fem::max(tau, ckin(22)) / taurt);
    /// C...3) due to limits on x2
    ystmn3 = -fem::log(fem::max(tau, ckin(24)) / taurt);
    ystmx3 = -fem::log(fem::max(tau, ckin(23)) / taurt);
    /// C...4) due to limits on xF
    yepmn4 = 0.5f * fem::abs(ckin(25)) / taurt;
    ystmn4 = fem::sign(fem::log(fem::sqrt(1.f + fem::pow2(yepmn4)) + yepmn4),
                       ckin(25));
    yepmx4 = 0.5f * fem::abs(ckin(26)) / taurt;
    ystmx4 = fem::sign(fem::log(fem::sqrt(1.f + fem::pow2(yepmx4)) + yepmx4),
                       ckin(26));
    /// C...5) due to simultaneous limits on y-large and y-small
    yepsmn = (rm3 - rm4) * fem::sinh(ckin(9) - ckin(11));
    yepsmx = (rm3 - rm4) * fem::sinh(ckin(10) - ckin(12));
    ydifmn = fem::abs(fem::log(fem::sqrt(1.f + fem::pow2(yepsmn)) - yepsmn));
    ydifmx = fem::abs(fem::log(fem::sqrt(1.f + fem::pow2(yepsmx)) - yepsmx));
    ystmn5 = 0.5f * (ckin(9) + ckin(11) - ydifmn);
    ystmx5 = 0.5f * (ckin(10) + ckin(12) + ydifmx);
    /// C...6) due to simultaneous limits on cos(theta-hat) and y-large or
    /// C...   y-small
    cthlim = fem::sqrt(1.f - 4.f * fem::pow2(pthmin) / (be34 * tau * vint(2)));
    rzmn = be34 * fem::max(ckin(27), -cthlim);
    rzmx = be34 * fem::min(ckin(28), cthlim);
    yex3mx =
        (1.f + rm3 - rm4 + rzmx) / fem::max(1e-10f, 1.f + rm3 - rm4 - rzmx);
    yex4mx =
        (1.f + rm4 - rm3 - rzmn) / fem::max(1e-10f, 1.f + rm4 - rm3 + rzmn);
    yex3mn =
        fem::max(1e-10f, 1.f + rm3 - rm4 + rzmn) / (1.f + rm3 - rm4 - rzmn);
    yex4mn =
        fem::max(1e-10f, 1.f + rm4 - rm3 - rzmx) / (1.f + rm4 - rm3 + rzmx);
    ystmn6 = ckin(9) - 0.5f * fem::log(fem::max(yex3mx, yex4mx));
    ystmx6 = ckin(12) - 0.5f * fem::log(fem::min(yex3mn, yex4mn));
    vint(12) = fem::max(ystmn0, ystmn1, ystmn2, ystmn3, ystmn4, ystmn5, ystmn6);
    vint(32) = fem::min(ystmx0, ystmx1, ystmx2, ystmx3, ystmx4, ystmx5, ystmx6);
    if (mint(43) == 1) {
      vint(12) = -0.00001f;
      vint(32) = 0.00001f;
    } else if (mint(43) == 2) {
      vint(12) = 0.99999f * ystmx0;
      vint(32) = 1.00001f * ystmx0;
    } else if (mint(43) == 3) {
      vint(12) = -1.00001f * ystmx0;
      vint(32) = -0.99999f * ystmx0;
    }
    if (vint(32) <= vint(12)) {
      mint(51) = 1;
    }
    /// C
  } else if (ilim == 3) {
    /// C...Calculate limits on cos(theta-hat)
    yst = vint(22);
    /// C...0) due to definition
    ctnmn0 = -1.f;
    ctnmx0 = 0.f;
    ctpmn0 = 0.f;
    ctpmx0 = 1.f;
    /// C...1) due to explicit limits
    ctnmn1 = fem::min(0.f, ckin(27));
    ctnmx1 = fem::min(0.f, ckin(28));
    ctpmn1 = fem::max(0.f, ckin(27));
    ctpmx1 = fem::max(0.f, ckin(28));
    /// C...2) due to limits on pT-hat
    ctnmn2 = -fem::sqrt(1.f - 4.f * fem::pow2(pthmin) /
                                  (fem::pow2(be34) * tau * vint(2)));
    ctpmx2 = -ctnmn2;
    ctnmx2 = 0.f;
    ctpmn2 = 0.f;
    if (ckin(4) >= 0.f) {
      ctnmx2 = -fem::sqrt(fem::max(
          0.f,
          1.f - 4.f * fem::pow2(ckin(4)) / (fem::pow2(be34) * tau * vint(2))));
      ctpmn2 = -ctnmx2;
    }
    /// C...3) due to limits on y-large and y-small
    ctnmn3 = fem::min(
        0.f, fem::max((1.f + rm3 - rm4) / be34 * fem::tanh(ckin(11) - yst),
                      -(1.f - rm3 + rm4) / be34 * fem::tanh(ckin(10) - yst)));
    ctnmx3 = fem::min(0.f, (1.f + rm3 - rm4) / be34 * fem::tanh(ckin(12) - yst),
                      -(1.f - rm3 + rm4) / be34 * fem::tanh(ckin(9) - yst));
    ctpmn3 = fem::max(0.f, (1.f + rm3 - rm4) / be34 * fem::tanh(ckin(9) - yst),
                      -(1.f - rm3 + rm4) / be34 * fem::tanh(ckin(12) - yst));
    ctpmx3 = fem::max(
        0.f, fem::min((1.f + rm3 - rm4) / be34 * fem::tanh(ckin(10) - yst),
                      -(1.f - rm3 + rm4) / be34 * fem::tanh(ckin(11) - yst)));
    vint(13) = fem::max(ctnmn0, ctnmn1, ctnmn2, ctnmn3);
    vint(33) = fem::min(ctnmx0, ctnmx1, ctnmx2, ctnmx3);
    vint(14) = fem::max(ctpmn0, ctpmn1, ctpmn2, ctpmn3);
    vint(34) = fem::min(ctpmx0, ctpmx1, ctpmx2, ctpmx3);
    if (vint(33) <= vint(13) && vint(34) <= vint(14)) {
      mint(51) = 1;
    }
    /// C
  } else if (ilim == 4) {
    /// C...Calculate limits on tau'
    /// C...0) due to kinematics
    tapmn0 = tau;
    tapmx0 = 1.f;
    /// C...1) due to explicit limits
    tapmn1 = fem::pow2(ckin(31)) / vint(2);
    tapmx1 = 1.f;
    if (ckin(32) >= 0.f) {
      tapmx1 = fem::pow2(ckin(32)) / vint(2);
    }
    vint(16) = fem::max(tapmn0, tapmn1);
    vint(36) = fem::min(tapmx0, tapmx1);
    if (mint(43) == 1) {
      vint(16) = 0.99999f;
      vint(36) = 1.00001f;
    }
    if (vint(36) <= vint(16)) {
      mint(51) = 1;
    }
    /// C
  }
  return;
/// C
/// C...Special case for low-pT and multiple interactions:
/// C...effective kinematical limits for tau, y*, cos(theta-hat).
statement_110:
  if (ilim == 0) {
  } else if (ilim == 1) {
    if (mstp(82) <= 1) {
      vint(11) = 4.f * fem::pow2(parp(81)) / vint(2);
    }
    if (mstp(82) >= 2) {
      vint(11) = fem::pow2(parp(82)) / vint(2);
    }
    vint(31) = 1.f;
  } else if (ilim == 2) {
    vint(12) = 0.5f * fem::log(vint(21));
    vint(32) = -vint(12);
  } else if (ilim == 3) {
    if (mstp(82) <= 1) {
      st2eff = 4.f * fem::pow2(parp(81)) / (vint(21) * vint(2));
    }
    if (mstp(82) >= 2) {
      st2eff = 0.01f * fem::pow2(parp(82)) / (vint(21) * vint(2));
    }
    vint(13) = -fem::sqrt(fem::max(0.f, 1.f - st2eff));
    vint(33) = 0.f;
    vint(14) = 0.f;
    vint(34) = -vint(13);
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void pykmap(common& cmn, int const& ivar, int const& mvar, float const& vvar) {
  /// COMMON pyint1
  arr_cref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  /// COMMON pyint2
  arr_cref<int> iset(cmn.iset, dimension(200));
  ///
  /// C
  /// C...Maps a uniform distribution into a distribution of a kinematical
  /// C...variable according to one of the possibilities allowed. It is
  /// C...assumed that kinematical limits have been set by a PYKLIM call.
  /// C
  /// C...Convert VVAR to tau variable.
  int isub = mint(1);
  float taumin = fem::float0;
  float taumax = fem::float0;
  float taure = fem::float0;
  float gamre = fem::float0;
  float tau = fem::float0;
  float ratgen = fem::float0;
  float aupp = fem::float0;
  float alow = fem::float0;
  float ystmin = fem::float0;
  float ystmax = fem::float0;
  float yst = fem::float0;
  float rm34 = fem::float0;
  float rsqm = fem::float0;
  float ctnmin = fem::float0;
  float ctnmax = fem::float0;
  float ctpmin = fem::float0;
  float ctpmax = fem::float0;
  float aneg = fem::float0;
  float apos = fem::float0;
  float vctn = fem::float0;
  float cth = fem::float0;
  float vctp = fem::float0;
  float rmnmin = fem::float0;
  float rmnmax = fem::float0;
  float rmpmin = fem::float0;
  float rmpmax = fem::float0;
  float taupmn = fem::float0;
  float taupmx = fem::float0;
  float taup = fem::float0;
  if (ivar == 1) {
    taumin = vint(11);
    taumax = vint(31);
    if (mvar == 3 || mvar == 4) {
      taure = vint(73);
      gamre = vint(74);
    } else if (mvar == 5 || mvar == 6) {
      taure = vint(75);
      gamre = vint(76);
    }
    if (mint(43) == 1 && (iset(isub) == 1 || iset(isub) == 2)) {
      tau = 1.f;
    } else if (mvar == 1) {
      tau = taumin * fem::pow((taumax / taumin), vvar);
    } else if (mvar == 2) {
      tau = taumax * taumin / (taumin + (taumax - taumin) * vvar);
    } else if (mvar == 3 || mvar == 5) {
      ratgen = (taure + taumax) / (taure + taumin) * taumin / taumax;
      tau =
          taure * taumin / ((taure + taumin) * fem::pow(ratgen, vvar) - taumin);
    } else {
      aupp = fem::atan((taumax - taure) / gamre);
      alow = fem::atan((taumin - taure) / gamre);
      tau = taure + gamre * fem::tan(alow + (aupp - alow) * vvar);
    }
    vint(21) = fem::min(taumax, fem::max(taumin, tau));
    /// C
    /// C...Convert VVAR to y* variable.
  } else if (ivar == 2) {
    ystmin = vint(12);
    ystmax = vint(32);
    if (mint(43) == 1) {
      yst = 0.f;
    } else if (mint(43) == 2) {
      if (iset(isub) <= 2) {
        yst = -0.5f * fem::log(vint(21));
      }
      if (iset(isub) >= 3) {
        yst = -0.5f * fem::log(vint(26));
      }
    } else if (mint(43) == 3) {
      if (iset(isub) <= 2) {
        yst = 0.5f * fem::log(vint(21));
      }
      if (iset(isub) >= 3) {
        yst = 0.5f * fem::log(vint(26));
      }
    } else if (mvar == 1) {
      yst = ystmin + (ystmax - ystmin) * fem::sqrt(vvar);
    } else if (mvar == 2) {
      yst = ystmax - (ystmax - ystmin) * fem::sqrt(1.f - vvar);
    } else {
      aupp = fem::atan(fem::exp(ystmax));
      alow = fem::atan(fem::exp(ystmin));
      yst = fem::log(fem::tan(alow + (aupp - alow) * vvar));
    }
    vint(22) = fem::min(ystmax, fem::max(ystmin, yst));
    /// C
    /// C...Convert VVAR to cos(theta-hat) variable.
  } else if (ivar == 3) {
    rm34 = 2.f * vint(63) * vint(64) / fem::pow2((vint(21) * vint(2)));
    rsqm = 1.f + rm34;
    if (2.f * fem::pow2(vint(71)) / (vint(21) * vint(2)) < 0.0001f) {
      rm34 = fem::max(rm34, 2.f * fem::pow2(vint(71)) / (vint(21) * vint(2)));
    }
    ctnmin = vint(13);
    ctnmax = vint(33);
    ctpmin = vint(14);
    ctpmax = vint(34);
    if (mvar == 1) {
      aneg = ctnmax - ctnmin;
      apos = ctpmax - ctpmin;
      if (aneg > 0.f && vvar * (aneg + apos) <= aneg) {
        vctn = vvar * (aneg + apos) / aneg;
        cth = ctnmin + (ctnmax - ctnmin) * vctn;
      } else {
        vctp = (vvar * (aneg + apos) - aneg) / apos;
        cth = ctpmin + (ctpmax - ctpmin) * vctp;
      }
    } else if (mvar == 2) {
      rmnmin = fem::max(rm34, rsqm - ctnmin);
      rmnmax = fem::max(rm34, rsqm - ctnmax);
      rmpmin = fem::max(rm34, rsqm - ctpmin);
      rmpmax = fem::max(rm34, rsqm - ctpmax);
      aneg = fem::log(rmnmin / rmnmax);
      apos = fem::log(rmpmin / rmpmax);
      if (aneg > 0.f && vvar * (aneg + apos) <= aneg) {
        vctn = vvar * (aneg + apos) / aneg;
        cth = rsqm - rmnmin * fem::pow((rmnmax / rmnmin), vctn);
      } else {
        vctp = (vvar * (aneg + apos) - aneg) / apos;
        cth = rsqm - rmpmin * fem::pow((rmpmax / rmpmin), vctp);
      }
    } else if (mvar == 3) {
      rmnmin = fem::max(rm34, rsqm + ctnmin);
      rmnmax = fem::max(rm34, rsqm + ctnmax);
      rmpmin = fem::max(rm34, rsqm + ctpmin);
      rmpmax = fem::max(rm34, rsqm + ctpmax);
      aneg = fem::log(rmnmax / rmnmin);
      apos = fem::log(rmpmax / rmpmin);
      if (aneg > 0.f && vvar * (aneg + apos) <= aneg) {
        vctn = vvar * (aneg + apos) / aneg;
        cth = rmnmin * fem::pow((rmnmax / rmnmin), vctn) - rsqm;
      } else {
        vctp = (vvar * (aneg + apos) - aneg) / apos;
        cth = rmpmin * fem::pow((rmpmax / rmpmin), vctp) - rsqm;
      }
    } else if (mvar == 4) {
      rmnmin = fem::max(rm34, rsqm - ctnmin);
      rmnmax = fem::max(rm34, rsqm - ctnmax);
      rmpmin = fem::max(rm34, rsqm - ctpmin);
      rmpmax = fem::max(rm34, rsqm - ctpmax);
      aneg = 1.f / rmnmax - 1.f / rmnmin;
      apos = 1.f / rmpmax - 1.f / rmpmin;
      if (aneg > 0.f && vvar * (aneg + apos) <= aneg) {
        vctn = vvar * (aneg + apos) / aneg;
        cth = rsqm - 1.f / (1.f / rmnmin + aneg * vctn);
      } else {
        vctp = (vvar * (aneg + apos) - aneg) / apos;
        cth = rsqm - 1.f / (1.f / rmpmin + apos * vctp);
      }
    } else if (mvar == 5) {
      rmnmin = fem::max(rm34, rsqm + ctnmin);
      rmnmax = fem::max(rm34, rsqm + ctnmax);
      rmpmin = fem::max(rm34, rsqm + ctpmin);
      rmpmax = fem::max(rm34, rsqm + ctpmax);
      aneg = 1.f / rmnmin - 1.f / rmnmax;
      apos = 1.f / rmpmin - 1.f / rmpmax;
      if (aneg > 0.f && vvar * (aneg + apos) <= aneg) {
        vctn = vvar * (aneg + apos) / aneg;
        cth = 1.f / (1.f / rmnmin - aneg * vctn) - rsqm;
      } else {
        vctp = (vvar * (aneg + apos) - aneg) / apos;
        cth = 1.f / (1.f / rmpmin - apos * vctp) - rsqm;
      }
    }
    if (cth < 0.f) {
      cth = fem::min(ctnmax, fem::max(ctnmin, cth));
    }
    if (cth > 0.f) {
      cth = fem::min(ctpmax, fem::max(ctpmin, cth));
    }
    vint(23) = cth;
    /// C
    /// C...Convert VVAR to tau' variable.
  } else if (ivar == 4) {
    tau = vint(11);
    taupmn = vint(16);
    taupmx = vint(36);
    if (mint(43) == 1) {
      taup = 1.f;
    } else if (mvar == 1) {
      taup = taupmn * fem::pow((taupmx / taupmn), vvar);
    } else {
      aupp = fem::pow4((1.f - tau / taupmx));
      alow = fem::pow4((1.f - tau / taupmn));
      taup = tau / (1.f - fem::pow((alow + (aupp - alow) * vvar), 0.25f));
    }
    vint(26) = fem::min(taupmx, fem::max(taupmn, taup));
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
float ulalps(common& cmn, float const& q2) {
  float return_value = fem::float0;
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<float> paru(cmn.paru, dimension(200));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  ///
  float q2eff = fem::float0;
  int nf = fem::int0;
  float alam2 = fem::float0;
  float q2thr = fem::float0;
  float b0 = fem::float0;
  float algq = fem::float0;
  float b1 = fem::float0;
  /// C
  /// C...Purpose: to give the value of alpha_strong.
  /// C
  /// C...Constant alpha_strong trivial.
  if (mstu(111) <= 0) {
    return_value = paru(111);
    mstu(118) = mstu(112);
    paru(117) = 0.f;
    paru(118) = paru(111);
    return return_value;
  }
  /// C
  /// C...Find effective Q2, number of flavours and Lambda.
  q2eff = q2;
  if (mstu(115) >= 2) {
    q2eff = fem::max(q2, paru(114));
  }
  nf = mstu(112);
  alam2 = fem::pow2(paru(112));
statement_100:
  if (nf > fem::max(2, mstu(113))) {
    q2thr = paru(113) * fem::pow2(pmas(nf, 1));
    if (q2eff < q2thr) {
      nf = nf - 1;
      alam2 = alam2 * fem::pow((q2thr / alam2), (2.f / (33.f - 2.f * nf)));
      goto statement_100;
    }
  }
statement_110:
  if (nf < fem::min(8, mstu(114))) {
    q2thr = paru(113) * fem::pow2(pmas(nf + 1, 1));
    if (q2eff > q2thr) {
      nf++;
      alam2 = alam2 * fem::pow((alam2 / q2thr), (2.f / (33.f - 2.f * nf)));
      goto statement_110;
    }
  }
  if (mstu(115) == 1) {
    q2eff += alam2;
  }
  paru(117) = fem::sqrt(alam2);
  /// C
  /// C...Evaluate first or second order alpha_strong.
  b0 = (33.f - 2.f * nf) / 6.f;
  algq = fem::log(q2eff / alam2);
  if (mstu(111) == 1) {
    return_value = paru(2) / (b0 * algq);
  } else {
    b1 = (153.f - 19.f * nf) / 6.f;
    return_value = paru(2) / (b0 * algq) *
                   (1.f - b1 * fem::log(algq) / (fem::pow2(b0) * algq));
  }
  mstu(118) = nf;
  paru(118) = return_value;
  /// C
  return return_value;
}

/// C
/// C*********************************************************************
/// C
void pywidt(common& cmn, int const& kflr, float const& rmas,
            arr_ref<float> wdtp, arr_ref<float, 2> wdte) {
  wdtp(dim1(0, 40));
  wdte(dim1(0, 40).dim2(0, 5));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<float, 2> vckm(cmn.vckm, dimension(4, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_cref<int, 2> kfdp(cmn.kfdp, dimension(2000, 5));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<float, 2> wids(cmn.wids, dim1(21, 40).dim2(3));
  ///
  int kfla = fem::int0;
  float sqm = fem::float0;
  float as = fem::float0;
  float aem = fem::float0;
  float xw = fem::float0;
  float radc = fem::float0;
  int i = fem::int0;
  int j = fem::int0;
  int idc = fem::int0;
  float rm1 = fem::float0;
  float rm2 = fem::float0;
  float wid2 = fem::float0;
  float ei = fem::float0;
  float ai = fem::float0;
  float vi = fem::float0;
  float sqmz = fem::float0;
  float gzmz = fem::float0;
  float ggi = fem::float0;
  float gzi = fem::float0;
  float zzi = fem::float0;
  float ef = fem::float0;
  float af = fem::float0;
  float vf = fem::float0;
  float ggf = fem::float0;
  float gzf = fem::float0;
  float zzf = fem::float0;
  float cf = fem::float0;
  float etare = fem::float0;
  float etaim = fem::float0;
  float eps = fem::float0;
  float root = fem::float0;
  float rln = fem::float0;
  float phire = fem::float0;
  float phiim = fem::float0;
  float eta2 = fem::float0;
  float ej = fem::float0;
  int jl = fem::int0;
  float aj = fem::float0;
  float vj = fem::float0;
  float epsp = fem::float0;
  float psire = fem::float0;
  float psiim = fem::float0;
  float phirep = fem::float0;
  float phiimp = fem::float0;
  float psirep = fem::float0;
  float psiimp = fem::float0;
  float fxyre = fem::float0;
  float fxyim = fem::float0;
  float f1re = fem::float0;
  float f1im = fem::float0;
  float api = fem::float0;
  float vpi = fem::float0;
  float sqmzp = fem::float0;
  float gzpmzp = fem::float0;
  float gzpi = fem::float0;
  float zzpi = fem::float0;
  float zpzpi = fem::float0;
  float apf = fem::float0;
  float vpf = fem::float0;
  float gzpf = fem::float0;
  float zzpf = fem::float0;
  float zpzpf = fem::float0;
  /// C
  /// C...Calculates full and partial widths of resonances.
  /// C
  /// C...Some common constants.
  kfla = fem::iabs(kflr);
  sqm = fem::pow2(rmas);
  as = ulalps(cmn, sqm);
  aem = paru(101);
  xw = paru(102);
  radc = 1.f + as / paru(1);
  /// C
  /// C...Reset width information.
  FEM_DO_SAFE(i, 0, 40) {
    wdtp(i) = 0.f;
    FEM_DO_SAFE(j, 0, 5) { wdte(i, j) = 0.f; }
  }
  /// C
  if (kfla == 21) {
    /// C...QCD:
    FEM_DO_SAFE(i, 1, mdcy(21, 3)) {
      idc = i + mdcy(21, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_110;
      }
      if (i <= 8) {
        /// C...QCD -> q + qb
        wdtp(i) = (1.f + 2.f * rm1) * fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        wid2 = 1.f;
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
      }
    statement_110:;
    }
    /// C
  } else if (kfla == 23) {
    /// C...Z0:
    if (mint(61) == 1) {
      ei = kchg(fem::iabs(mint(15)), 1) / 3.f;
      ai = fem::sign(1.f, ei);
      vi = ai - 4.f * ei * xw;
      sqmz = fem::pow2(pmas(23, 1));
      gzmz = pmas(23, 2) * pmas(23, 1);
      ggi = fem::pow2(ei);
      gzi = ei * vi / (8.f * xw * (1.f - xw)) * sqm * (sqm - sqmz) /
            (fem::pow2((sqm - sqmz)) + fem::pow2(gzmz));
      zzi = (fem::pow2(vi) + fem::pow2(ai)) /
            fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sqm) /
            (fem::pow2((sqm - sqmz)) + fem::pow2(gzmz));
      if (mstp(43) == 1) {
        /// C...Only gamma* production included
        gzi = 0.f;
        zzi = 0.f;
      } else if (mstp(43) == 2) {
        /// C...Only Z0 production included
        ggi = 0.f;
        gzi = 0.f;
      }
    } else if (mint(61) == 2) {
      vint(111) = 0.f;
      vint(112) = 0.f;
      vint(114) = 0.f;
    }
    FEM_DO_SAFE(i, 1, mdcy(23, 3)) {
      idc = i + mdcy(23, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_120;
      }
      if (i <= 8) {
        /// C...Z0 -> q + qb
        ef = kchg(i, 1) / 3.f;
        af = fem::sign(1.f, ef + 0.1f);
        vf = af - 4.f * ef * xw;
        if (mint(61) == 0) {
          wdtp(i) = 3.f *
                    (fem::pow2(vf) * (1.f + 2.f * rm1) +
                     fem::pow2(af) * (1.f - 4.f * rm1)) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        } else if (mint(61) == 1) {
          wdtp(i) =
              3.f *
              ((ggi * fem::pow2(ef) + gzi * ef * vf + zzi * fem::pow2(vf)) *
                   (1.f + 2.f * rm1) +
               zzi * fem::pow2(af) * (1.f - 4.f * rm1)) *
              fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        } else if (mint(61) == 2) {
          ggf = 3.f * fem::pow2(ef) * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          gzf = 3.f * ef * vf * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          zzf = 3.f *
                (fem::pow2(vf) * (1.f + 2.f * rm1) +
                 fem::pow2(af) * (1.f - 4.f * rm1)) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        }
        wid2 = 1.f;
      } else if (i <= 16) {
        /// C...Z0 -> l+ + l-, nu + nub
        ef = kchg(i + 2, 1) / 3.f;
        af = fem::sign(1.f, ef + 0.1f);
        vf = af - 4.f * ef * xw;
        wdtp(i) = (fem::pow2(vf) * (1.f + 2.f * rm1) +
                   fem::pow2(af) * (1.f - 4.f * rm1)) *
                  fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        if (mint(61) == 0) {
          wdtp(i) = (fem::pow2(vf) * (1.f + 2.f * rm1) +
                     fem::pow2(af) * (1.f - 4.f * rm1)) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        } else if (mint(61) == 1) {
          wdtp(i) =
              ((ggi * fem::pow2(ef) + gzi * ef * vf + zzi * fem::pow2(vf)) *
                   (1.f + 2.f * rm1) +
               zzi * fem::pow2(af) * (1.f - 4.f * rm1)) *
              fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        } else if (mint(61) == 2) {
          ggf = fem::pow2(ef) * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          gzf = ef * vf * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          zzf = (fem::pow2(vf) * (1.f + 2.f * rm1) +
                 fem::pow2(af) * (1.f - 4.f * rm1)) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        }
        wid2 = 1.f;
      } else {
        /// C...Z0 -> H+ + H-
        cf = 2.f * (1.f - 2.f * xw);
        if (mint(61) == 0) {
          wdtp(i) = 0.25f * fem::pow2(cf) * (1.f - 4.f * rm1) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        } else if (mint(61) == 1) {
          wdtp(i) = 0.25f * (ggi + gzi * cf + zzi * fem::pow2(cf)) *
                    (1.f - 4.f * rm1) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        } else if (mint(61) == 2) {
          ggf = 0.25f * (1.f - 4.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          gzf = 0.25f * cf * (1.f - 4.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          zzf = 0.25f * fem::pow2(cf) * (1.f - 4.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        }
        wid2 = wids(37, 1);
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
        /// Clin-4/2008 modified a la pythia6115.f to avoid undefined values
        /// (GGF,GZF,ZZF): C          VINT(111)=VINT(111)+GGF*WID2 C
        /// VINT(112)=VINT(112)+GZF*WID2 C          VINT(114)=VINT(114)+ZZF*WID2
        if (mint(61) == 2) {
          vint(111) += ggf * wid2;
          vint(112) += gzf * wid2;
          vint(114) += zzf * wid2;
        }
        /// Clin-4/2008-end
      }
    statement_120:;
    }
    if (mstp(43) == 1) {
      /// C...Only gamma* production included
      vint(112) = 0.f;
      vint(114) = 0.f;
    } else if (mstp(43) == 2) {
      /// C...Only Z0 production included
      vint(111) = 0.f;
      vint(112) = 0.f;
    }
    /// C
  } else if (kfla == 24) {
    /// C...W+/-:
    FEM_DO_SAFE(i, 1, mdcy(24, 3)) {
      idc = i + mdcy(24, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_130;
      }
      if (i <= 16) {
        /// C...W+/- -> q + qb'
        wdtp(i) = 3.f * (2.f - rm1 - rm2 - fem::pow2((rm1 - rm2))) *
                  fem::sqrt(fem::max(
                      0.f, fem::pow2((1.f - rm1 - rm2)) - 4.f * rm1 * rm2)) *
                  vckm((i - 1) / 4 + 1, fem::mod(i - 1, 4) + 1) * radc;
        wid2 = 1.f;
      } else {
        /// C...W+/- -> l+/- + nu
        wdtp(i) = (2.f - rm1 - rm2 - fem::pow2((rm1 - rm2))) *
                  fem::sqrt(fem::max(
                      0.f, fem::pow2((1.f - rm1 - rm2)) - 4.f * rm1 * rm2));
        wid2 = 1.f;
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
      }
    statement_130:;
    }
    /// C
  } else if (kfla == 25) {
    /// C...H0:
    FEM_DO_SAFE(i, 1, mdcy(25, 3)) {
      idc = i + mdcy(25, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_170;
      }
      if (i <= 8) {
        /// C...H0 -> q + qb
        wdtp(i) = 3.f * rm1 * (1.f - 4.f * rm1) *
                  fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        wid2 = 1.f;
      } else if (i <= 12) {
        /// C...H0 -> l+ + l-
        wdtp(i) =
            rm1 * (1.f - 4.f * rm1) * fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        wid2 = 1.f;
      } else if (i == 13) {
        /// C...H0 -> g + g; quark loop contribution only
        etare = 0.f;
        etaim = 0.f;
        FEM_DO_SAFE(j, 1, 2 * mstp(1)) {
          eps = fem::pow2((2.f * pmas(j, 1) / rmas));
          if (eps <= 1.f) {
            if (eps > 1.e-4f) {
              root = fem::sqrt(1.f - eps);
              rln = fem::log((1.f + root) / (1.f - root));
            } else {
              rln = fem::log(4.f / eps - 2.f);
            }
            phire = 0.25f * (fem::pow2(rln) - fem::pow2(paru(1)));
            phiim = 0.5f * paru(1) * rln;
          } else {
            phire = -fem::pow2((fem::asin(1.f / fem::sqrt(eps))));
            phiim = 0.f;
          }
          etare += 0.5f * eps * (1.f + (eps - 1.f) * phire);
          etaim += 0.5f * eps * (eps - 1.f) * phiim;
        }
        eta2 = fem::pow2(etare) + fem::pow2(etaim);
        wdtp(i) = fem::pow2((as / paru(1))) * eta2;
        wid2 = 1.f;
      } else if (i == 14) {
        /// C...H0 -> gamma + gamma; quark, charged lepton and W loop
        /// contributions
        etare = 0.f;
        etaim = 0.f;
        FEM_DO_SAFE(j, 1, 3 * mstp(1) + 1) {
          if (j <= 2 * mstp(1)) {
            ej = kchg(j, 1) / 3.f;
            eps = fem::pow2((2.f * pmas(j, 1) / rmas));
          } else if (j <= 3 * mstp(1)) {
            jl = 2 * (j - 2 * mstp(1)) - 1;
            ej = kchg(10 + jl, 1) / 3.f;
            eps = fem::pow2((2.f * pmas(10 + jl, 1) / rmas));
          } else {
            eps = fem::pow2((2.f * pmas(24, 1) / rmas));
          }
          if (eps <= 1.f) {
            if (eps > 1.e-4f) {
              root = fem::sqrt(1.f - eps);
              rln = fem::log((1.f + root) / (1.f - root));
            } else {
              rln = fem::log(4.f / eps - 2.f);
            }
            phire = 0.25f * (fem::pow2(rln) - fem::pow2(paru(1)));
            phiim = 0.5f * paru(1) * rln;
          } else {
            phire = -fem::pow2((fem::asin(1.f / fem::sqrt(eps))));
            phiim = 0.f;
          }
          if (j <= 2 * mstp(1)) {
            etare +=
                0.5f * 3.f * fem::pow2(ej) * eps * (1.f + (eps - 1.f) * phire);
            etaim += 0.5f * 3.f * fem::pow2(ej) * eps * (eps - 1.f) * phiim;
          } else if (j <= 3 * mstp(1)) {
            etare += 0.5f * fem::pow2(ej) * eps * (1.f + (eps - 1.f) * phire);
            etaim += 0.5f * fem::pow2(ej) * eps * (eps - 1.f) * phiim;
          } else {
            etare = etare - 0.5f - 0.75f * eps * (1.f + (eps - 2.f) * phire);
            etaim += 0.75f * eps * (eps - 2.f) * phiim;
          }
        }
        eta2 = fem::pow2(etare) + fem::pow2(etaim);
        wdtp(i) = fem::pow2((aem / paru(1))) * 0.5f * eta2;
        wid2 = 1.f;
      } else if (i == 15) {
        /// C...H0 -> gamma + Z0; quark, charged lepton and W loop contributions
        etare = 0.f;
        etaim = 0.f;
        FEM_DO_SAFE(j, 1, 3 * mstp(1) + 1) {
          if (j <= 2 * mstp(1)) {
            ej = kchg(j, 1) / 3.f;
            aj = fem::sign(1.f, ej + 0.1f);
            vj = aj - 4.f * ej * xw;
            eps = fem::pow2((2.f * pmas(j, 1) / rmas));
            epsp = fem::pow2((2.f * pmas(j, 1) / pmas(23, 1)));
          } else if (j <= 3 * mstp(1)) {
            jl = 2 * (j - 2 * mstp(1)) - 1;
            ej = kchg(10 + jl, 1) / 3.f;
            aj = fem::sign(1.f, ej + 0.1f);
            vj = ai - 4.f * ej * xw;
            eps = fem::pow2((2.f * pmas(10 + jl, 1) / rmas));
            epsp = fem::pow2((2.f * pmas(10 + jl, 1) / pmas(23, 1)));
          } else {
            eps = fem::pow2((2.f * pmas(24, 1) / rmas));
            epsp = fem::pow2((2.f * pmas(24, 1) / pmas(23, 1)));
          }
          if (eps <= 1.f) {
            root = fem::sqrt(1.f - eps);
            if (eps > 1.e-4f) {
              rln = fem::log((1.f + root) / (1.f - root));
            } else {
              rln = fem::log(4.f / eps - 2.f);
            }
            phire = 0.25f * (fem::pow2(rln) - fem::pow2(paru(1)));
            phiim = 0.5f * paru(1) * rln;
            psire = -(1.f + 0.5f * root * rln);
            psiim = 0.5f * paru(1) * root;
          } else {
            phire = -fem::pow2((fem::asin(1.f / fem::sqrt(eps))));
            phiim = 0.f;
            psire =
                -(1.f + fem::sqrt(eps - 1.f) * fem::asin(1.f / fem::sqrt(eps)));
            psiim = 0.f;
          }
          if (epsp <= 1.f) {
            root = fem::sqrt(1.f - epsp);
            if (epsp > 1.e-4f) {
              rln = fem::log((1.f + root) / (1.f - root));
            } else {
              rln = fem::log(4.f / epsp - 2.f);
            }
            phirep = 0.25f * (fem::pow2(rln) - fem::pow2(paru(1)));
            phiimp = 0.5f * paru(1) * rln;
            psirep = -(1.f + 0.5f * root * rln);
            psiimp = 0.5f * paru(1) * root;
          } else {
            phirep = -fem::pow2((fem::asin(1.f / fem::sqrt(epsp))));
            phiimp = 0.f;
            psirep = -(1.f + fem::sqrt(epsp - 1.f) *
                                 fem::asin(1.f / fem::sqrt(epsp)));
            psiimp = 0.f;
          }
          fxyre = eps * epsp / (8.f * (eps - epsp)) *
                  (1.f - eps * epsp / (eps - epsp) * (phire - phirep) +
                   2.f * eps / (eps - epsp) * (psire - psirep));
          fxyim = eps * epsp / (8.f * (eps - epsp)) *
                  (-eps * epsp / (eps - epsp) * (phiim - phiimp) +
                   2.f * eps / (eps - epsp) * (psiim - psiimp));
          f1re = eps * epsp / (2.f * (eps - epsp)) * (phire - phirep);
          f1im = eps * epsp / (2.f * (eps - epsp)) * (phiim - phiimp);
          if (j <= 2 * mstp(1)) {
            etare = etare - 3.f * ej * vj * (fxyre - 0.25f * f1re);
            etaim = etaim - 3.f * ej * vj * (fxyim - 0.25f * f1im);
          } else if (j <= 3 * mstp(1)) {
            etare = etare - ej * vj * (fxyre - 0.25f * f1re);
            etaim = etaim - ej * vj * (fxyim - 0.25f * f1im);
          } else {
            etare = etare - fem::sqrt(1.f - xw) *
                                (((1.f + 2.f / eps) * xw / fem::sqrt(1.f - xw) -
                                  (5.f + 2.f / eps)) *
                                     fxyre +
                                 (3.f - xw / fem::sqrt(1.f - xw)) * f1re);
            etaim = etaim - fem::sqrt(1.f - xw) *
                                (((1.f + 2.f / eps) * xw / fem::sqrt(1.f - xw) -
                                  (5.f + 2.f / eps)) *
                                     fxyim +
                                 (3.f - xw / fem::sqrt(1.f - xw)) * f1im);
          }
        }
        eta2 = fem::pow2(etare) + fem::pow2(etaim);
        wdtp(i) = fem::pow2((aem / paru(1))) *
                  fem::pow3((1.f - fem::pow2((pmas(23, 1) / rmas)))) / xw *
                  eta2;
        wid2 = wids(23, 2);
      } else {
        /// C...H0 -> Z0 + Z0, W+ + W-
        wdtp(i) = (1.f - 4.f * rm1 + 12.f * fem::pow2(rm1)) *
                  fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) / (2.f * (18 - i));
        wid2 = wids(7 + i, 1);
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
      }
    statement_170:;
    }
    /// C
  } else if (kfla == 32) {
    /// C...Z'0:
    if (mint(61) == 1) {
      ei = kchg(fem::iabs(mint(15)), 1) / 3.f;
      ai = fem::sign(1.f, ei);
      vi = ai - 4.f * ei * xw;
      sqmz = fem::pow2(pmas(23, 1));
      gzmz = pmas(23, 2) * pmas(23, 1);
      api = fem::sign(1.f, ei);
      vpi = api - 4.f * ei * xw;
      sqmzp = fem::pow2(pmas(32, 1));
      gzpmzp = pmas(32, 2) * pmas(32, 1);
      ggi = fem::pow2(ei);
      gzi = ei * vi / (8.f * xw * (1.f - xw)) * sqm * (sqm - sqmz) /
            (fem::pow2((sqm - sqmz)) + fem::pow2(gzmz));
      gzpi = ei * vpi / (8.f * xw * (1.f - xw)) * sqm * (sqm - sqmzp) /
             (fem::pow2((sqm - sqmzp)) + fem::pow2(gzpmzp));
      zzi = (fem::pow2(vi) + fem::pow2(ai)) /
            fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sqm) /
            (fem::pow2((sqm - sqmz)) + fem::pow2(gzmz));
      zzpi = 2.f * (vi * vpi + ai * api) / fem::pow2((16.f * xw * (1.f - xw))) *
             fem::pow2(sqm) * ((sqm - sqmz) * (sqm - sqmzp) + gzmz * gzpmzp) /
             ((fem::pow2((sqm - sqmz)) + fem::pow2(gzmz)) *
              (fem::pow2((sqm - sqmzp)) + fem::pow2(gzpmzp)));
      zpzpi = (fem::pow2(vpi) + fem::pow2(api)) /
              fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sqm) /
              (fem::pow2((sqm - sqmzp)) + fem::pow2(gzpmzp));
      if (mstp(44) == 1) {
        /// C...Only gamma* production included
        gzi = 0.f;
        gzpi = 0.f;
        zzi = 0.f;
        zzpi = 0.f;
        zpzpi = 0.f;
      } else if (mstp(44) == 2) {
        /// C...Only Z0 production included
        ggi = 0.f;
        gzi = 0.f;
        gzpi = 0.f;
        zzpi = 0.f;
        zpzpi = 0.f;
      } else if (mstp(44) == 3) {
        /// C...Only Z'0 production included
        ggi = 0.f;
        gzi = 0.f;
        gzpi = 0.f;
        zzi = 0.f;
        zzpi = 0.f;
      } else if (mstp(44) == 4) {
        /// C...Only gamma*/Z0 production included
        gzpi = 0.f;
        zzpi = 0.f;
        zpzpi = 0.f;
      } else if (mstp(44) == 5) {
        /// C...Only gamma*/Z'0 production included
        gzi = 0.f;
        zzi = 0.f;
        zzpi = 0.f;
      } else if (mstp(44) == 6) {
        /// C...Only Z0/Z'0 production included
        ggi = 0.f;
        gzi = 0.f;
        gzpi = 0.f;
      }
    } else if (mint(61) == 2) {
      vint(111) = 0.f;
      vint(112) = 0.f;
      vint(113) = 0.f;
      vint(114) = 0.f;
      vint(115) = 0.f;
      vint(116) = 0.f;
    }
    FEM_DO_SAFE(i, 1, mdcy(32, 3)) {
      idc = i + mdcy(32, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_180;
      }
      if (i <= 8) {
        /// C...Z'0 -> q + qb
        ef = kchg(i, 1) / 3.f;
        af = fem::sign(1.f, ef + 0.1f);
        vf = af - 4.f * ef * xw;
        apf = fem::sign(1.f, ef + 0.1f);
        vpf = apf - 4.f * ef * xw;
        if (mint(61) == 0) {
          wdtp(i) = 3.f *
                    (fem::pow2(vpf) * (1.f + 2.f * rm1) +
                     fem::pow2(apf) * (1.f - 4.f * rm1)) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        } else if (mint(61) == 1) {
          wdtp(i) = 3.f *
                    ((ggi * fem::pow2(ef) + gzi * ef * vf + gzpi * ef * vpf +
                      zzi * fem::pow2(vf) + zzpi * vf * vpf +
                      zpzpi * fem::pow2(vpf)) *
                         (1.f + 2.f * rm1) +
                     (zzi * fem::pow2(af) + zzpi * af * apf +
                      zpzpi * fem::pow2(apf)) *
                         (1.f - 4.f * rm1)) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        } else if (mint(61) == 2) {
          ggf = 3.f * fem::pow2(ef) * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          gzf = 3.f * ef * vf * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          gzpf = 3.f * ef * vpf * (1.f + 2.f * rm1) *
                 fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          zzf = 3.f *
                (fem::pow2(vf) * (1.f + 2.f * rm1) +
                 fem::pow2(af) * (1.f - 4.f * rm1)) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          zzpf = 3.f *
                 (vf * vpf * (1.f + 2.f * rm1) + af * apf * (1.f - 4.f * rm1)) *
                 fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
          zpzpf = 3.f *
                  (fem::pow2(vpf) * (1.f + 2.f * rm1) +
                   fem::pow2(apf) * (1.f - 4.f * rm1)) *
                  fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1)) * radc;
        }
        wid2 = 1.f;
      } else {
        /// C...Z'0 -> l+ + l-, nu + nub
        ef = kchg(i + 2, 1) / 3.f;
        af = fem::sign(1.f, ef + 0.1f);
        vf = af - 4.f * ef * xw;
        /// Clin-4/2008 modified above a la pythia6115.f to avoid undefined
        /// variable API: C          APF=SIGN(1.,EF+0.1) C VPF=API-4.*EF*XW
        if (i <= 10) {
          vpf = paru(127 - 2 * fem::mod(i, 2));
          apf = paru(128 - 2 * fem::mod(i, 2));
        } else if (i <= 12) {
          vpf = parj(186 - 2 * fem::mod(i, 2));
          apf = parj(187 - 2 * fem::mod(i, 2));
        } else {
          vpf = parj(194 - 2 * fem::mod(i, 2));
          apf = parj(195 - 2 * fem::mod(i, 2));
        }
        /// Clin-4/2008-end
        if (mint(61) == 0) {
          wdtp(i) = (fem::pow2(vpf) * (1.f + 2.f * rm1) +
                     fem::pow2(apf) * (1.f - 4.f * rm1)) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        } else if (mint(61) == 1) {
          wdtp(i) = ((ggi * fem::pow2(ef) + gzi * ef * vf + gzpi * ef * vpf +
                      zzi * fem::pow2(vf) + zzpi * vf * vpf +
                      zpzpi * fem::pow2(vpf)) *
                         (1.f + 2.f * rm1) +
                     (zzi * fem::pow2(af) + zzpi * af * apf +
                      zpzpi * fem::pow2(apf)) *
                         (1.f - 4.f * rm1)) *
                    fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        } else if (mint(61) == 2) {
          ggf = fem::pow2(ef) * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          gzf = ef * vf * (1.f + 2.f * rm1) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          gzpf = ef * vpf * (1.f + 2.f * rm1) *
                 fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          zzf = (fem::pow2(vf) * (1.f + 2.f * rm1) +
                 fem::pow2(af) * (1.f - 4.f * rm1)) *
                fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          zzpf = (vf * vpf * (1.f + 2.f * rm1) + af * apf * (1.f - 4.f * rm1)) *
                 fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
          zpzpf = (fem::pow2(vpf) * (1.f + 2.f * rm1) +
                   fem::pow2(apf) * (1.f - 4.f * rm1)) *
                  fem::sqrt(fem::max(0.f, 1.f - 4.f * rm1));
        }
        wid2 = 1.f;
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
        /// Clin-4/2008:
        /// C          VINT(111)=VINT(111)+GGF
        /// C          VINT(112)=VINT(112)+GZF
        /// C          VINT(113)=VINT(113)+GZPF
        /// C          VINT(114)=VINT(114)+ZZF
        /// C          VINT(115)=VINT(115)+ZZPF
        /// C          VINT(116)=VINT(116)+ZPZPF
        if (mint(61) == 2) {
          vint(111) += ggf;
          vint(112) += gzf;
          vint(113) += gzpf;
          vint(114) += zzf;
          vint(115) += zzpf;
          vint(116) += zpzpf;
        }
        /// Clin-4/2008-end
      }
    statement_180:;
    }
    if (mstp(44) == 1) {
      /// C...Only gamma* production included
      vint(112) = 0.f;
      vint(113) = 0.f;
      vint(114) = 0.f;
      vint(115) = 0.f;
      vint(116) = 0.f;
    } else if (mstp(44) == 2) {
      /// C...Only Z0 production included
      vint(111) = 0.f;
      vint(112) = 0.f;
      vint(113) = 0.f;
      vint(115) = 0.f;
      vint(116) = 0.f;
    } else if (mstp(44) == 3) {
      /// C...Only Z'0 production included
      vint(111) = 0.f;
      vint(112) = 0.f;
      vint(113) = 0.f;
      vint(114) = 0.f;
      vint(115) = 0.f;
    } else if (mstp(44) == 4) {
      /// C...Only gamma*/Z0 production included
      vint(113) = 0.f;
      vint(115) = 0.f;
      vint(116) = 0.f;
    } else if (mstp(44) == 5) {
      /// C...Only gamma*/Z'0 production included
      vint(112) = 0.f;
      vint(114) = 0.f;
      vint(115) = 0.f;
    } else if (mstp(44) == 6) {
      /// C...Only Z0/Z'0 production included
      vint(111) = 0.f;
      vint(112) = 0.f;
      vint(113) = 0.f;
    }
    /// C
  } else if (kfla == 37) {
    /// C...H+/-:
    FEM_DO_SAFE(i, 1, mdcy(37, 3)) {
      idc = i + mdcy(37, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_190;
      }
      if (i <= 4) {
        /// C...H+/- -> q + qb'
        wdtp(i) = 3.f *
                  ((rm1 * paru(121) + rm2 / paru(121)) * (1.f - rm1 - rm2) -
                   4.f * rm1 * rm2) *
                  fem::sqrt(fem::max(
                      0.f, fem::pow2((1.f - rm1 - rm2)) - 4.f * rm1 * rm2)) *
                  radc;
        wid2 = 1.f;
      } else {
        /// C...H+/- -> l+/- + nu
        wdtp(i) = ((rm1 * paru(121) + rm2 / paru(121)) * (1.f - rm1 - rm2) -
                   4.f * rm1 * rm2) *
                  fem::sqrt(fem::max(
                      0.f, fem::pow2((1.f - rm1 - rm2)) - 4.f * rm1 * rm2));
        wid2 = 1.f;
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
      }
    statement_190:;
    }
    /// C
  } else if (kfla == 40) {
    /// C...R:
    FEM_DO_SAFE(i, 1, mdcy(40, 3)) {
      idc = i + mdcy(40, 2) - 1;
      rm1 = fem::pow2((pmas(fem::iabs(kfdp(idc, 1)), 1) / rmas));
      rm2 = fem::pow2((pmas(fem::iabs(kfdp(idc, 2)), 1) / rmas));
      if (fem::sqrt(rm1) + fem::sqrt(rm2) > 1.f || mdme(idc, 1) < 0) {
        goto statement_200;
      }
      if (i <= 4) {
        /// C...R -> q + qb'
        wdtp(i) = 3.f * radc;
        wid2 = 1.f;
      } else {
        /// C...R -> l+ + l'-
        wdtp(i) = 1.f;
        wid2 = 1.f;
      }
      wdtp(0) += wdtp(i);
      if (mdme(idc, 1) > 0) {
        wdte(i, mdme(idc, 1)) = wdtp(i) * wid2;
        wdte(0, mdme(idc, 1)) += wdte(i, mdme(idc, 1));
        wdte(i, 0) = wdte(i, mdme(idc, 1));
        wdte(0, 0) += wdte(i, 0);
      }
    statement_200:;
    }
    /// C
  }
  mint(61) = 0;
  /// C
}

struct pygamm_save {
  arr<float> b;

  pygamm_save() : b(dimension(8), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
float pygamm(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pygamm);
  /// SAVE
  arr_ref<float> b(sve.b, dimension(8));
  ///
  if (is_called_first_time) {
    static const float values[] = {-0.57719165f, 0.98820589f,  -0.89705694f,
                                   0.91820686f,  -0.75670408f, 0.48219939f,
                                   -0.19352782f, 0.03586834f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), b;
  }
  /// C
  /// C...Gives ordinary Gamma function Gamma(x) for positive, real arguments;
  /// C...see M. Abramowitz, I. A. Stegun: Handbook of Mathematical Functions
  /// C...(Dover, 1965) 6.1.36.
  /// Clin      DATA B/-0.577191652,0.988205891,-0.897056937,0.918206857,
  /// Clin     &-0.756704078,0.482199394,-0.193527818,0.035868343/
  /// C
  int nx = fem::fint(x);
  float dx = x - nx;
  /// C
  return_value = 1.f;
  int i = fem::int0;
  FEM_DO_SAFE(i, 1, 8) { return_value += b(i) * fem::pow(dx, i); }
  int ix = fem::int0;
  if (x < 1.f) {
    return_value = return_value / x;
  } else {
    FEM_DO_SAFE(ix, 1, nx - 1) { return_value = (x - ix) * return_value; }
  }
  /// C
  return return_value;
}

struct pystfe_save {
  arr<fem::str<5> > chdflm;
  fem::str<40> header;
  int init;

  pystfe_save()
      : chdflm(dimension(9), fem::fill0), header(fem::char0), init(fem::int0) {}
};

/// C
/// C*********************************************************************
/// C
void pystfe(common& cmn, int const& /* kf */, float const& x, float const& q2,
            arr_ref<float> xpq) {
  FEM_CMN_SVE(pystfe);
  xpq(dim1(-6, 6));
  /// COMMON ludat2
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  /// COMMON pypars
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  ///
  /// SAVE
  int& init = sve.init;
  ///
  str_arr_ref<1> chdflm(sve.chdflm, dimension(9));
  if (is_called_first_time) {
    {
      static const char* values[] = {"UPVAL", "DOVAL", "GLUON",
                                     "QBAR ", "UBAR ", "SBAR ",
                                     "CBAR ", "BBAR ", "TBAR "};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chdflm;
    }
    sve.header = "Tung evolution package has been invoked";
    init = 0;
  }
  /// C
  /// C...This is a dummy routine, where the user can introduce an interface
  /// C...to his own external structure function parametrization.
  /// C...Arguments in:
  /// C...KF : 2212 for p, 211 for pi+; isospin conjugation for n and charge
  /// C...    conjugation for pbar, nbar or pi- is performed by PYSTFU.
  /// C...X : x value.
  /// C...Q2 : Q^2 value.
  /// C...Arguments out:
  /// C...XPQ(-6:6) : x * f(x,Q2), with index according to KF code,
  /// C...    except that gluon is placed in 0. Thus XPQ(0) = xg,
  /// C...    XPQ(1) = xd, XPQ(-1) = xdbar, XPQ(2) = xu, XPQ(-2) = xubar,
  /// C...    XPQ(3) = xs, XPQ(-3) = xsbar, XPQ(4) = xc, XPQ(-4) = xcbar,
  /// C...    XPQ(5) = xb, XPQ(-5) = xbbar, XPQ(6) = xt, XPQ(-6) = xtbar.
  /// C...
  /// C...One such interface, to the Diemos, Ferroni, Longo, Martinelli
  /// C...proton structure functions, already comes with the package. What
  /// C...the user needs here is external files with the three routines
  /// C...FXG160, FXG260 and FXG360 of the authors above, plus the
  /// C...interpolation routine FINT, which is part of the CERN library
  /// C...KERNLIB package. To avoid problems with unresolved external
  /// C...references, the external calls are commented in the current
  /// C...version. To enable this option, remove the C* at the beginning
  /// C...of the relevant lines.
  /// C...
  /// C...Alternatively, the routine can be used as an interface to the
  /// C...structure function evolution program of Tung. This can be achieved
  /// C...by removing C* at the beginning of some of the lines below.
  /// C
  /// C...Proton structure functions from Diemoz, Ferroni, Longo, Martinelli.
  /// C...Allowed variable range 10 GeV2 < Q2 < 1E8 GeV2, 5E-5 < x < .95.
  float xdflm = fem::float0;
  float q2dflm = fem::float0;
  int j = fem::int0;
  arr_1d<9, float> xfdflm(fem::fill0);
  float cxs = fem::float0;
  int i1 = fem::int0;
  int ihdrn = fem::int0;
  int nu = fem::int0;
  int i2 = fem::int0;
  int i3 = fem::int0;
  float alam = fem::float0;
  float tpms = fem::float0;
  float qini = fem::float0;
  float qmax = fem::float0;
  float xmin = fem::float0;
  float q = fem::float0;
  int i = fem::int0;
  float fixq = fem::float0;
  float xps = fem::float0;
  if (mstp(51) >= 11 && mstp(51) <= 13 && mstp(52) <= 1) {
    xdflm = fem::max(0.51e-4f, x);
    q2dflm = fem::max(10.f, fem::min(1e8f, q2));
    if (mstp(52) == 0) {
      q2dflm = 10.f;
    }
    FEM_DO_SAFE(j, 1, 9) {
      if (mstp(52) == 1 && j == 9) {
        q2dflm = q2dflm * fem::pow2((40.f / pmas(6, 1)));
        q2dflm = fem::max(10.f, fem::min(1e8f, q2));
      }
      xfdflm(j) = 0.f;
      /// C...Remove C* on following three lines to enable the DFLM options.
      /// C*      IF(MSTP(51).EQ.11) CALL
      /// FXG160(XDFLM,Q2DFLM,CHDFLM(J),XFDFLM(J)) C*      IF(MSTP(51).EQ.12)
      /// CALL FXG260(XDFLM,Q2DFLM,CHDFLM(J),XFDFLM(J)) C* IF(MSTP(51).EQ.13)
      /// CALL FXG360(XDFLM,Q2DFLM,CHDFLM(J),XFDFLM(J))
    }
    if (x < 0.51e-4f && fem::abs(parp(51) - 1.f) > 0.01f) {
      cxs = fem::pow((0.51e-4f / x), (parp(51) - 1.f));
      FEM_DO_SAFE(j, 1, 7) { xfdflm(j) = xfdflm(j) * cxs; }
    }
    xpq(0) = xfdflm(3);
    xpq(1) = xfdflm(2) + xfdflm(5);
    xpq(2) = xfdflm(1) + xfdflm(5);
    xpq(3) = xfdflm(6);
    xpq(4) = xfdflm(7);
    xpq(5) = xfdflm(8);
    xpq(6) = xfdflm(9);
    xpq(-1) = xfdflm(5);
    xpq(-2) = xfdflm(5);
    xpq(-3) = xfdflm(6);
    xpq(-4) = xfdflm(7);
    xpq(-5) = xfdflm(8);
    xpq(-6) = xfdflm(9);
    /// C
    /// C...Proton structure function evolution from Wu-Ki Tung: parton
    /// C...distribution functions incorporating heavy quark mass effects.
    /// C...Allowed variable range: PARP(52) < Q < PARP(53); PARP(54) < x < 1.
  } else {
    if (init == 0) {
      i1 = 0;
      if (mstp(52) == 4) {
        i1 = 1;
      }
      ihdrn = 1;
      nu = mstp(53);
      i2 = mstp(51);
      if (mstp(51) >= 11) {
        i2 = mstp(51) - 3;
      }
      i3 = 0;
      if (mstp(52) == 3) {
        i3 = 1;
      }
      /// C
      /// C...Convert to Lambda in CWZ scheme (approximately linear relation).
      alam = 0.75f * parp(1);
      tpms = pmas(6, 1);
      qini = parp(52);
      qmax = parp(53);
      xmin = parp(54);
      /// C
      /// C...Initialize evolution (perform calculation or read results from
      /// C...file).
      /// C...Remove C* on following two lines to enable Tung initialization.
      /// C*        CALL PDFSET(I1,IHDRN,ALAM,TPMS,QINI,QMAX,XMIN,NU,HEADER,
      /// C*   &    I2,I3,IRET,IRR)
      init = 1;
    }
    /// C
    /// C...Put into output array.
    q = fem::sqrt(q2);
    FEM_DO_SAFE(i, -6, 6) {
      fixq = 0.f;
      /// C...Remove C* on following line to enable structure function call.
      /// C*      FIXQ=MAX(0.,PDF(10,1,I,X,Q,IR))
      xpq(i) = x * fixq;
    }
    /// C
    /// C...Change order of u and d quarks from Tung to PYTHIA convention.
    xps = xpq(1);
    xpq(1) = xpq(2);
    xpq(2) = xps;
    xps = xpq(-1);
    xpq(-1) = xpq(-2);
    xpq(-2) = xps;
  }
  /// C
}

struct pystfu_save {
  arr<float, 4> cdo;
  arr<float, 5> cehlq;
  arr<float, 4> cow;
  arr<int, 2> nehlq;

  pystfu_save()
      : cdo(dimension(3, 6, 5, 2), fem::fill0),
        cehlq(dimension(6, 6, 2, 8, 2), fem::fill0),
        cow(dimension(3, 5, 4, 2), fem::fill0),
        nehlq(dimension(8, 2), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void pystfu(common& cmn, int const& kf, float const& x, float const& q2,
            arr_ref<float> xpq, int const& jbt) {
  FEM_CMN_SVE(pystfu);
  xpq(dim1(-6, 6));
  common_write write(cmn);
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  ///
  arr_ref<float, 4> cdo(sve.cdo, dimension(3, 6, 5, 2));
  arr_ref<float, 5> cehlq(sve.cehlq, dimension(6, 6, 2, 8, 2));
  arr_ref<float, 4> cow(sve.cow, dimension(3, 5, 4, 2));
  arr_ref<int, 2> nehlq(sve.nehlq, dimension(8, 2));
  int ix = fem::int0;
  int it = fem::int0;
  int nx = fem::int0;
  int ip = fem::int0;
  int is = fem::int0;
  if (is_called_first_time) {
    {
      static const int values[] = {3, 4, 7, 5, 7, 7, 7, 7,
                                   3, 4, 7, 6, 7, 7, 7, 7};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), nehlq;
    }
    {
      static const float values[] = {
          7.677e-01f,  -2.087e-01f, -3.303e-01f, -2.517e-02f, -1.570e-02f,
          -1.000e-04f, -5.326e-01f, -2.661e-01f, 3.201e-01f,  1.192e-01f,
          2.434e-02f,  7.620e-03f,  2.162e-01f,  1.881e-01f,  -8.375e-02f,
          -6.515e-02f, -1.743e-02f, -5.040e-03f, -9.211e-02f, -9.952e-02f,
          1.373e-02f,  2.506e-02f,  8.770e-03f,  2.550e-03f,  3.670e-02f,
          4.409e-02f,  9.600e-04f,  -7.960e-03f, -3.420e-03f, -1.050e-03f,
          -1.549e-02f, -2.026e-02f, -3.060e-03f, 2.220e-03f,  1.240e-03f,
          4.100e-04f,  2.395e-01f,  2.905e-01f,  9.778e-02f,  2.149e-02f,
          3.440e-03f,  5.000e-04f,  1.751e-02f,  -6.090e-03f, -2.687e-02f,
          -1.916e-02f, -7.970e-03f, -2.750e-03f, -5.760e-03f, -5.040e-03f,
          1.080e-03f,  2.490e-03f,  1.530e-03f,  7.500e-04f,  1.740e-03f,
          1.960e-03f,  3.000e-04f,  -3.400e-04f, -2.900e-04f, -1.800e-04f,
          -5.300e-04f, -6.400e-04f, -1.700e-04f, 4.000e-05f,  6.000e-05f,
          4.000e-05f,  1.700e-04f,  2.200e-04f,  8.000e-05f,  1.000e-05f,
          -1.000e-05f, -1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 1, 1); }
        }
      }
    }
    {
      static const float values[] = {
          7.237e-01f,  -2.189e-01f, -2.995e-01f, -1.909e-02f, -1.477e-02f,
          2.500e-04f,  -5.314e-01f, -2.425e-01f, 3.283e-01f,  1.119e-01f,
          2.223e-02f,  7.070e-03f,  2.289e-01f,  1.890e-01f,  -9.859e-02f,
          -6.900e-02f, -1.747e-02f, -5.080e-03f, -1.041e-01f, -1.084e-01f,
          2.108e-02f,  2.975e-02f,  9.830e-03f,  2.830e-03f,  4.394e-02f,
          5.116e-02f,  -1.410e-03f, -1.055e-02f, -4.230e-03f, -1.270e-03f,
          -1.991e-02f, -2.539e-02f, -2.780e-03f, 3.430e-03f,  1.720e-03f,
          5.500e-04f,  2.410e-01f,  2.884e-01f,  9.369e-02f,  1.900e-02f,
          2.530e-03f,  2.400e-04f,  1.765e-02f,  -9.220e-03f, -3.037e-02f,
          -2.085e-02f, -8.440e-03f, -2.810e-03f, -6.450e-03f, -5.260e-03f,
          1.720e-03f,  3.110e-03f,  1.830e-03f,  8.700e-04f,  2.120e-03f,
          2.320e-03f,  2.600e-04f,  -4.900e-04f, -3.900e-04f, -2.300e-04f,
          -6.900e-04f, -8.200e-04f, -2.000e-04f, 7.000e-05f,  9.000e-05f,
          6.000e-05f,  2.400e-04f,  3.100e-04f,  1.100e-04f,  0.000e+00f,
          -2.000e-05f, -2.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 1, 2); }
        }
      }
    }
    {
      static const float values[] = {
          3.813e-01f,  -8.090e-02f, -1.634e-01f, -2.185e-02f, -8.430e-03f,
          -6.200e-04f, -2.948e-01f, -1.435e-01f, 1.665e-01f,  6.638e-02f,
          1.473e-02f,  4.080e-03f,  1.252e-01f,  1.042e-01f,  -4.722e-02f,
          -3.683e-02f, -1.038e-02f, -2.860e-03f, -5.478e-02f, -5.678e-02f,
          8.900e-03f,  1.484e-02f,  5.340e-03f,  1.520e-03f,  2.220e-02f,
          2.567e-02f,  -3.000e-05f, -4.970e-03f, -2.160e-03f, -6.500e-04f,
          -9.530e-03f, -1.204e-02f, -1.510e-03f, 1.510e-03f,  8.300e-04f,
          2.700e-04f,  1.261e-01f,  1.354e-01f,  3.958e-02f,  8.240e-03f,
          1.660e-03f,  4.500e-04f,  3.890e-03f,  -1.159e-02f, -1.625e-02f,
          -9.610e-03f, -3.710e-03f, -1.260e-03f, -1.910e-03f, -5.600e-04f,
          1.590e-03f,  1.590e-03f,  8.400e-04f,  3.900e-04f,  6.400e-04f,
          4.900e-04f,  -1.500e-04f, -2.900e-04f, -1.800e-04f, -1.000e-04f,
          -2.000e-04f, -1.900e-04f, 0.000e+00f,  6.000e-05f,  4.000e-05f,
          3.000e-05f,  7.000e-05f,  8.000e-05f,  2.000e-05f,  -1.000e-05f,
          -1.000e-05f, -1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 2, 1); }
        }
      }
    }
    {
      static const float values[] = {
          3.578e-01f,  -8.622e-02f, -1.480e-01f, -1.840e-02f, -7.820e-03f,
          -4.500e-04f, -2.925e-01f, -1.304e-01f, 1.696e-01f,  6.243e-02f,
          1.353e-02f,  3.750e-03f,  1.318e-01f,  1.041e-01f,  -5.486e-02f,
          -3.872e-02f, -1.038e-02f, -2.850e-03f, -6.162e-02f, -6.143e-02f,
          1.303e-02f,  1.740e-02f,  5.940e-03f,  1.670e-03f,  2.643e-02f,
          2.957e-02f,  -1.490e-03f, -6.450e-03f, -2.630e-03f, -7.700e-04f,
          -1.218e-02f, -1.497e-02f, -1.260e-03f, 2.240e-03f,  1.120e-03f,
          3.500e-04f,  1.263e-01f,  1.334e-01f,  3.732e-02f,  7.070e-03f,
          1.260e-03f,  3.400e-04f,  3.660e-03f,  -1.357e-02f, -1.795e-02f,
          -1.031e-02f, -3.880e-03f, -1.280e-03f, -2.100e-03f, -3.600e-04f,
          2.050e-03f,  1.920e-03f,  9.800e-04f,  4.400e-04f,  7.700e-04f,
          5.400e-04f,  -2.400e-04f, -3.900e-04f, -2.400e-04f, -1.300e-04f,
          -2.600e-04f, -2.300e-04f, 2.000e-05f,  9.000e-05f,  6.000e-05f,
          4.000e-05f,  9.000e-05f,  1.000e-04f,  2.000e-05f,  -2.000e-05f,
          -2.000e-05f, -1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 2, 2); }
        }
      }
    }
    {
      static const float values[] = {
          6.870e-02f,  -6.861e-02f, 2.973e-02f,  -5.400e-03f, 3.780e-03f,
          -9.700e-04f, -1.802e-02f, 1.400e-04f,  6.490e-03f,  -8.540e-03f,
          1.220e-03f,  -1.750e-03f, -4.650e-03f, 1.480e-03f,  -5.930e-03f,
          6.000e-04f,  -1.030e-03f, -8.000e-05f, 6.440e-03f,  2.570e-03f,
          2.830e-03f,  1.150e-03f,  7.100e-04f,  3.300e-04f,  -3.930e-03f,
          -2.540e-03f, -1.160e-03f, -7.700e-04f, -3.600e-04f, -1.900e-04f,
          2.340e-03f,  1.930e-03f,  5.300e-04f,  3.700e-04f,  1.600e-04f,
          9.000e-05f,  1.014e+00f,  -1.106e+00f, 3.374e-01f,  -7.444e-02f,
          8.850e-03f,  -8.700e-04f, 9.233e-01f,  -1.285e+00f, 4.475e-01f,
          -9.786e-02f, 1.419e-02f,  -1.120e-03f, 4.888e-02f,  -1.271e-01f,
          8.606e-02f,  -2.608e-02f, 4.780e-03f,  -6.000e-04f, -2.691e-02f,
          4.887e-02f,  -1.771e-02f, 1.620e-03f,  2.500e-04f,  -6.000e-05f,
          7.040e-03f,  -1.113e-02f, 1.590e-03f,  7.000e-04f,  -2.000e-04f,
          0.000e+00f,  -1.710e-03f, 2.290e-03f,  3.800e-04f,  -3.500e-04f,
          4.000e-05f,  1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 3, 1); }
        }
      }
    }
    {
      static const float values[] = {
          1.008e-01f,  -7.100e-02f, 1.973e-02f,  -5.710e-03f, 2.930e-03f,
          -9.900e-04f, -5.271e-02f, -1.823e-02f, 1.792e-02f,  -6.580e-03f,
          1.750e-03f,  -1.550e-03f, 1.220e-02f,  1.763e-02f,  -8.690e-03f,
          -8.800e-04f, -1.160e-03f, -2.100e-04f, -1.190e-03f, -7.180e-03f,
          2.360e-03f,  1.890e-03f,  7.700e-04f,  4.100e-04f,  -9.100e-04f,
          2.040e-03f,  -3.100e-04f, -1.050e-03f, -4.000e-04f, -2.400e-04f,
          1.190e-03f,  -1.700e-04f, -2.000e-04f, 4.200e-04f,  1.700e-04f,
          1.000e-04f,  1.081e+00f,  -1.189e+00f, 3.868e-01f,  -8.617e-02f,
          1.115e-02f,  -1.180e-03f, 9.917e-01f,  -1.396e+00f, 4.998e-01f,
          -1.159e-01f, 1.674e-02f,  -1.720e-03f, 5.099e-02f,  -1.338e-01f,
          9.173e-02f,  -2.885e-02f, 5.890e-03f,  -6.500e-04f, -3.178e-02f,
          5.703e-02f,  -2.070e-02f, 2.440e-03f,  1.100e-04f,  -9.000e-05f,
          8.970e-03f,  -1.392e-02f, 2.050e-03f,  6.500e-04f,  -2.300e-04f,
          2.000e-05f,  -2.340e-03f, 3.010e-03f,  5.000e-04f,  -3.900e-04f,
          6.000e-05f,  1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 3, 2); }
        }
      }
    }
    {
      static const float values[] = {
          9.482e-01f,  -9.578e-01f, 1.009e-01f,  -1.051e-01f, 3.456e-02f,
          -3.054e-02f, -9.627e-01f, 5.379e-01f,  3.368e-01f,  -9.525e-02f,
          1.488e-02f,  -2.051e-02f, 4.300e-01f,  -8.306e-02f, -3.372e-01f,
          4.902e-02f,  -9.160e-03f, 1.041e-02f,  -1.925e-01f, -1.790e-02f,
          2.183e-01f,  7.490e-03f,  4.140e-03f,  -1.860e-03f, 8.183e-02f,
          1.926e-02f,  -1.072e-01f, -1.944e-02f, -2.770e-03f, -5.200e-04f,
          -3.884e-02f, -1.234e-02f, 5.410e-02f,  1.879e-02f,  3.350e-03f,
          1.040e-03f,  2.948e+01f,  -3.902e+01f, 1.464e+01f,  -3.335e+00f,
          5.054e-01f,  -5.915e-02f, 2.559e+01f,  -3.955e+01f, 1.661e+01f,
          -4.299e+00f, 6.904e-01f,  -8.243e-02f, -1.663e+00f, 1.176e+00f,
          1.118e+00f,  -7.099e-01f, 1.948e-01f,  -2.404e-02f, -2.168e-01f,
          8.170e-01f,  -7.169e-01f, 1.851e-01f,  -1.924e-02f, -3.250e-03f,
          2.088e-01f,  -4.355e-01f, 2.239e-01f,  -2.446e-02f, -3.620e-03f,
          1.910e-03f,  -9.097e-02f, 1.601e-01f,  -5.681e-02f, -2.500e-03f,
          2.580e-03f,  -4.700e-04f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 4, 1); }
        }
      }
    }
    {
      static const float values[] = {
          2.367e+00f,  4.453e-01f,  3.660e-01f,  9.467e-02f,  1.341e-01f,
          1.661e-02f,  -3.170e+00f, -1.795e+00f, 3.313e-02f,  -2.874e-01f,
          -9.827e-02f, -7.119e-02f, 1.823e+00f,  1.457e+00f,  -2.465e-01f,
          3.739e-02f,  6.090e-03f,  1.814e-02f,  -1.033e+00f, -9.827e-01f,
          2.136e-01f,  1.169e-01f,  5.001e-02f,  1.684e-02f,  5.133e-01f,
          5.259e-01f,  -1.173e-01f, -1.139e-01f, -4.988e-02f, -2.021e-02f,
          -2.881e-01f, -3.145e-01f, 5.667e-02f,  9.161e-02f,  4.568e-02f,
          1.951e-02f,  3.036e+01f,  -4.062e+01f, 1.578e+01f,  -3.699e+00f,
          6.020e-01f,  -7.031e-02f, 2.700e+01f,  -4.167e+01f, 1.770e+01f,
          -4.804e+00f, 7.862e-01f,  -1.060e-01f, -1.909e+00f, 1.357e+00f,
          1.127e+00f,  -7.181e-01f, 2.232e-01f,  -2.481e-02f, -2.488e-01f,
          9.781e-01f,  -8.127e-01f, 2.094e-01f,  -2.997e-02f, -4.710e-03f,
          2.506e-01f,  -5.427e-01f, 2.672e-01f,  -3.103e-02f, -1.800e-03f,
          2.870e-03f,  -1.128e-01f, 2.087e-01f,  -6.972e-02f, -2.480e-03f,
          2.630e-03f,  -8.400e-04f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 4, 2); }
        }
      }
    }
    {
      static const float values[] = {
          4.968e-02f,  -4.173e-02f, 2.102e-02f,  -3.270e-03f, 3.240e-03f,
          -6.700e-04f, -6.150e-03f, -1.294e-02f, 6.740e-03f,  -6.890e-03f,
          9.000e-04f,  -1.510e-03f, -8.580e-03f, 5.050e-03f,  -4.900e-03f,
          -1.600e-04f, -9.400e-04f, -1.500e-04f, 7.840e-03f,  1.510e-03f,
          2.220e-03f,  1.400e-03f,  7.000e-04f,  3.500e-04f,  -4.410e-03f,
          -2.220e-03f, -8.900e-04f, -8.500e-04f, -3.600e-04f, -2.000e-04f,
          2.520e-03f,  1.840e-03f,  4.100e-04f,  3.900e-04f,  1.600e-04f,
          9.000e-05f,  9.235e-01f,  -1.085e+00f, 3.464e-01f,  -7.210e-02f,
          9.140e-03f,  -9.100e-04f, 9.315e-01f,  -1.274e+00f, 4.512e-01f,
          -9.775e-02f, 1.380e-02f,  -1.310e-03f, 4.739e-02f,  -1.296e-01f,
          8.482e-02f,  -2.642e-02f, 4.760e-03f,  -5.700e-04f, -2.653e-02f,
          4.953e-02f,  -1.735e-02f, 1.750e-03f,  2.800e-04f,  -6.000e-05f,
          6.940e-03f,  -1.132e-02f, 1.480e-03f,  6.500e-04f,  -2.100e-04f,
          0.000e+00f,  -1.680e-03f, 2.340e-03f,  4.200e-04f,  -3.400e-04f,
          5.000e-05f,  1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 5, 1); }
        }
      }
    }
    {
      static const float values[] = {
          6.478e-02f,  -4.537e-02f, 1.643e-02f,  -3.490e-03f, 2.710e-03f,
          -6.700e-04f, -2.223e-02f, -2.126e-02f, 1.247e-02f,  -6.290e-03f,
          1.120e-03f,  -1.440e-03f, -1.340e-03f, 1.362e-02f,  -6.130e-03f,
          -7.900e-04f, -9.000e-04f, -2.000e-04f, 5.080e-03f,  -3.610e-03f,
          1.700e-03f,  1.830e-03f,  6.800e-04f,  4.000e-04f,  -3.580e-03f,
          6.000e-05f,  -2.600e-04f, -1.050e-03f, -3.800e-04f, -2.300e-04f,
          2.420e-03f,  9.300e-04f,  -1.000e-04f, 4.500e-04f,  1.700e-04f,
          1.100e-04f,  9.868e-01f,  -1.171e+00f, 3.940e-01f,  -8.459e-02f,
          1.124e-02f,  -1.250e-03f, 1.001e+00f,  -1.383e+00f, 5.044e-01f,
          -1.152e-01f, 1.658e-02f,  -1.830e-03f, 4.928e-02f,  -1.368e-01f,
          9.021e-02f,  -2.935e-02f, 5.800e-03f,  -6.600e-04f, -3.133e-02f,
          5.785e-02f,  -2.023e-02f, 2.630e-03f,  1.600e-04f,  -8.000e-05f,
          8.840e-03f,  -1.416e-02f, 1.900e-03f,  5.800e-04f,  -2.500e-04f,
          1.000e-05f,  -2.300e-03f, 3.080e-03f,  5.500e-04f,  -3.700e-04f,
          7.000e-05f,  1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 5, 2); }
        }
      }
    }
    {
      static const float values[] = {
          9.270e-03f,  -1.817e-02f, 9.590e-03f,  -6.390e-03f, 1.690e-03f,
          -1.540e-03f, 5.710e-03f,  -1.188e-02f, 6.090e-03f,  -4.650e-03f,
          1.240e-03f,  -1.310e-03f, -3.960e-03f, 7.100e-03f,  -3.590e-03f,
          1.840e-03f,  -3.900e-04f, 3.400e-04f,  1.120e-03f,  -1.960e-03f,
          1.120e-03f,  -4.800e-04f, 1.000e-04f,  -4.000e-05f, 4.000e-05f,
          -3.000e-05f, -1.800e-04f, 9.000e-05f,  -5.000e-05f, -2.000e-05f,
          -4.200e-04f, 7.300e-04f,  -1.600e-04f, 5.000e-05f,  5.000e-05f,
          5.000e-05f,  8.098e-01f,  -1.042e+00f, 3.398e-01f,  -6.824e-02f,
          8.760e-03f,  -9.000e-04f, 8.961e-01f,  -1.217e+00f, 4.339e-01f,
          -9.287e-02f, 1.304e-02f,  -1.290e-03f, 3.058e-02f,  -1.040e-01f,
          7.604e-02f,  -2.415e-02f, 4.600e-03f,  -5.000e-04f, -2.451e-02f,
          4.432e-02f,  -1.651e-02f, 1.430e-03f,  1.200e-04f,  -1.000e-04f,
          1.122e-02f,  -1.457e-02f, 2.680e-03f,  5.800e-04f,  -1.200e-04f,
          3.000e-05f,  -7.730e-03f, 7.330e-03f,  -7.600e-04f, -2.400e-04f,
          1.000e-05f,  0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 6, 1); }
        }
      }
    }
    {
      static const float values[] = {
          9.980e-03f,  -1.945e-02f, 1.055e-02f,  -6.870e-03f, 1.860e-03f,
          -1.560e-03f, 5.700e-03f,  -1.203e-02f, 6.250e-03f,  -4.860e-03f,
          1.310e-03f,  -1.370e-03f, -4.490e-03f, 7.990e-03f,  -4.170e-03f,
          2.050e-03f,  -4.400e-04f, 3.300e-04f,  1.470e-03f,  -2.480e-03f,
          1.460e-03f,  -5.700e-04f, 1.200e-04f,  -1.000e-05f, -9.000e-05f,
          1.500e-04f,  -3.200e-04f, 1.200e-04f,  -6.000e-05f, -4.000e-05f,
          -4.200e-04f, 7.600e-04f,  -1.400e-04f, 4.000e-05f,  7.000e-05f,
          5.000e-05f,  8.698e-01f,  -1.131e+00f, 3.836e-01f,  -8.111e-02f,
          1.048e-02f,  -1.300e-03f, 9.626e-01f,  -1.321e+00f, 4.854e-01f,
          -1.091e-01f, 1.583e-02f,  -1.700e-03f, 3.057e-02f,  -1.088e-01f,
          8.022e-02f,  -2.676e-02f, 5.590e-03f,  -5.600e-04f, -2.845e-02f,
          5.164e-02f,  -1.918e-02f, 2.210e-03f,  -4.000e-05f, -1.500e-04f,
          1.311e-02f,  -1.751e-02f, 3.310e-03f,  5.100e-04f,  -1.200e-04f,
          5.000e-05f,  -8.590e-03f, 8.380e-03f,  -9.200e-04f, -2.600e-04f,
          1.000e-05f,  -1.000e-05f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 6, 2); }
        }
      }
    }
    {
      static const float values[] = {
          9.010e-03f,  -1.401e-02f, 7.150e-03f,  -4.130e-03f, 1.260e-03f,
          -1.040e-03f, 6.280e-03f,  -9.320e-03f, 4.780e-03f,  -2.890e-03f,
          9.100e-04f,  -8.200e-04f, -2.930e-03f, 4.090e-03f,  -1.890e-03f,
          7.600e-04f,  -2.300e-04f, 1.400e-04f,  3.900e-04f,  -1.200e-03f,
          4.400e-04f,  -2.500e-04f, 2.000e-05f,  -2.000e-05f, 2.600e-04f,
          1.400e-04f,  -8.000e-05f, 1.000e-04f,  1.000e-05f,  1.000e-05f,
          -2.600e-04f, 3.200e-04f,  1.000e-05f,  -1.000e-05f, 1.000e-05f,
          -1.000e-05f, 8.029e-01f,  -1.075e+00f, 3.792e-01f,  -7.843e-02f,
          1.007e-02f,  -1.090e-03f, 7.903e-01f,  -1.099e+00f, 4.153e-01f,
          -9.301e-02f, 1.317e-02f,  -1.410e-03f, -1.704e-02f, -1.130e-02f,
          2.882e-02f,  -1.341e-02f, 3.040e-03f,  -3.600e-04f, -7.200e-04f,
          7.230e-03f,  -5.160e-03f, 1.080e-03f,  -5.000e-05f, -4.000e-05f,
          3.050e-03f,  -4.610e-03f, 1.660e-03f,  -1.300e-04f, -1.000e-05f,
          1.000e-05f,  -4.360e-03f, 5.230e-03f,  -1.610e-03f, 2.000e-04f,
          -2.000e-05f, 0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 7, 1); }
        }
      }
    }
    {
      static const float values[] = {
          8.980e-03f,  -1.459e-02f, 7.510e-03f,  -4.410e-03f, 1.310e-03f,
          -1.070e-03f, 5.970e-03f,  -9.440e-03f, 4.800e-03f,  -3.020e-03f,
          9.100e-04f,  -8.500e-04f, -3.050e-03f, 4.440e-03f,  -2.100e-03f,
          8.500e-04f,  -2.400e-04f, 1.400e-04f,  5.300e-04f,  -1.300e-03f,
          5.600e-04f,  -2.700e-04f, 3.000e-05f,  -2.000e-05f, 2.000e-04f,
          1.400e-04f,  -1.100e-04f, 1.000e-04f,  0.000e+00f,  0.000e+00f,
          -2.600e-04f, 3.200e-04f,  0.000e+00f,  -3.000e-05f, 1.000e-05f,
          -1.000e-05f, 8.672e-01f,  -1.174e+00f, 4.265e-01f,  -9.252e-02f,
          1.244e-02f,  -1.460e-03f, 8.500e-01f,  -1.194e+00f, 4.630e-01f,
          -1.083e-01f, 1.614e-02f,  -1.830e-03f, -2.241e-02f, -5.630e-03f,
          2.815e-02f,  -1.425e-02f, 3.520e-03f,  -4.300e-04f, -7.300e-04f,
          8.030e-03f,  -5.780e-03f, 1.380e-03f,  -1.300e-04f, -4.000e-05f,
          3.460e-03f,  -5.380e-03f, 1.960e-03f,  -2.100e-04f, 1.000e-05f,
          1.000e-05f,  -4.850e-03f, 5.950e-03f,  -1.890e-03f, 2.600e-04f,
          -3.000e-05f, 0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 7, 2); }
        }
      }
    }
    {
      static const float values[] = {
          4.410e-03f,  -7.480e-03f, 3.770e-03f,  -2.580e-03f, 7.300e-04f,
          -7.100e-04f, 3.840e-03f,  -6.050e-03f, 3.030e-03f,  -2.030e-03f,
          5.800e-04f,  -5.900e-04f, -8.800e-04f, 1.660e-03f,  -7.500e-04f,
          4.700e-04f,  -1.000e-04f, 1.000e-04f,  -8.000e-05f, -1.500e-04f,
          1.200e-04f,  -9.000e-05f, 3.000e-05f,  0.000e+00f,  1.300e-04f,
          -2.200e-04f, -2.000e-05f, -2.000e-05f, -2.000e-05f, -2.000e-05f,
          -7.000e-05f, 1.900e-04f,  -4.000e-05f, 2.000e-05f,  0.000e+00f,
          0.000e+00f,  6.623e-01f,  -9.248e-01f, 3.519e-01f,  -7.930e-02f,
          1.110e-02f,  -1.180e-03f, 6.380e-01f,  -9.062e-01f, 3.582e-01f,
          -8.479e-02f, 1.265e-02f,  -1.390e-03f, -2.581e-02f, 2.125e-02f,
          4.190e-03f,  -4.980e-03f, 1.490e-03f,  -2.100e-04f, 7.100e-04f,
          5.300e-04f,  -1.270e-03f, 3.900e-04f,  -5.000e-05f, -1.000e-05f,
          3.850e-03f,  -5.060e-03f, 1.860e-03f,  -3.500e-04f, 4.000e-05f,
          0.000e+00f,  -3.530e-03f, 4.460e-03f,  -1.500e-03f, 2.700e-04f,
          -3.000e-05f, 0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 8, 1); }
        }
      }
    }
    {
      static const float values[] = {
          4.260e-03f,  -7.530e-03f, 3.830e-03f,  -2.680e-03f, 7.600e-04f,
          -7.300e-04f, 3.640e-03f,  -6.050e-03f, 3.030e-03f,  -2.090e-03f,
          5.900e-04f,  -6.000e-04f, -9.200e-04f, 1.710e-03f,  -8.200e-04f,
          5.000e-04f,  -1.200e-04f, 1.000e-04f,  -5.000e-05f, -1.600e-04f,
          1.300e-04f,  -9.000e-05f, 3.000e-05f,  0.000e+00f,  1.300e-04f,
          -2.100e-04f, -1.000e-05f, -2.000e-05f, -2.000e-05f, -1.000e-05f,
          -8.000e-05f, 1.800e-04f,  -5.000e-05f, 2.000e-05f,  0.000e+00f,
          0.000e+00f,  7.146e-01f,  -1.007e+00f, 3.932e-01f,  -9.246e-02f,
          1.366e-02f,  -1.540e-03f, 6.856e-01f,  -9.828e-01f, 3.977e-01f,
          -9.795e-02f, 1.540e-02f,  -1.790e-03f, -3.053e-02f, 2.758e-02f,
          2.150e-03f,  -4.880e-03f, 1.640e-03f,  -2.500e-04f, 9.200e-04f,
          4.200e-04f,  -1.340e-03f, 4.600e-04f,  -8.000e-05f, -1.000e-05f,
          4.230e-03f,  -5.660e-03f, 2.140e-03f,  -4.300e-04f, 6.000e-05f,
          0.000e+00f,  -3.890e-03f, 5.000e-03f,  -1.740e-03f, 3.300e-04f,
          -4.000e-05f, 0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(nx, 1, 2) {
        FEM_DO_SAFE(it, 1, 6) {
          FEM_DO_SAFE(ix, 1, 6) { data, cehlq(ix, it, nx, 8, 2); }
        }
      }
    }
    {
      static const float values[] = {
          4.190e-01f, 3.460e+00f, 4.400e+00f,  0.000e+00f,  0.000e+00f,
          0.000e+00f, 4.000e-03f, 7.240e-01f,  -4.860e+00f, 0.000e+00f,
          0.000e+00f, 0.000e+00f, -7.000e-03f, -6.600e-02f, 1.330e+00f,
          0.000e+00f, 0.000e+00f, 0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 1, 1); }
      }
    }
    {
      static const float values[] = {
          3.740e-01f, 3.330e+00f, 6.030e+00f, 0.000e+00f,  0.000e+00f,
          0.000e+00f, 1.400e-02f, 7.530e-01f, -6.220e+00f, 0.000e+00f,
          0.000e+00f, 0.000e+00f, 0.000e+00f, -7.600e-02f, 1.560e+00f,
          0.000e+00f, 0.000e+00f, 0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 1, 2); }
      }
    }
    {
      static const float values[] = {
          7.630e-01f, 4.000e+00f,  0.000e+00f, 0.000e+00f,  0.000e+00f,
          0.000e+00f, -2.370e-01f, 6.270e-01f, -4.210e-01f, 0.000e+00f,
          0.000e+00f, 0.000e+00f,  2.600e-02f, -1.900e-02f, 3.300e-02f,
          0.000e+00f, 0.000e+00f,  0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 2, 1); }
      }
    }
    {
      static const float values[] = {
          7.610e-01f, 3.830e+00f,  0.000e+00f, 0.000e+00f,  0.000e+00f,
          0.000e+00f, -2.320e-01f, 6.270e-01f, -4.180e-01f, 0.000e+00f,
          0.000e+00f, 0.000e+00f,  2.300e-02f, -1.900e-02f, 3.600e-02f,
          0.000e+00f, 0.000e+00f,  0.000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 2, 2); }
      }
    }
    {
      static const float values[] = {
          1.265e+00f,  0.000e+00f,  8.050e+00f,  0.000e+00f,  0.000e+00f,
          0.000e+00f,  -1.132e+00f, -3.720e-01f, 1.590e+00f,  6.310e+00f,
          -1.050e+01f, 1.470e+01f,  2.930e-01f,  -2.900e-02f, -1.530e-01f,
          -2.730e-01f, -3.170e+00f, 9.800e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 3, 1); }
      }
    }
    {
      static const float values[] = {
          1.670e+00f,  0.000e+00f,  9.150e+00f,  0.000e+00f,  0.000e+00f,
          0.000e+00f,  -1.920e+00f, -2.730e-01f, 5.300e-01f,  1.570e+01f,
          -1.010e+02f, 2.230e+02f,  5.820e-01f,  -1.640e-01f, -7.630e-01f,
          -2.830e+00f, 4.470e+01f,  -1.170e+02f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 3, 2); }
      }
    }
    {
      static const float values[] = {
          0.000e+00f, -3.600e-02f, 6.350e+00f,  0.000e+00f,  0.000e+00f,
          0.000e+00f, 1.350e-01f,  -2.220e-01f, 3.260e+00f,  -3.030e+00f,
          1.740e+01f, -1.790e+01f, -7.500e-02f, -5.800e-02f, -9.090e-01f,
          1.500e+00f, -1.130e+01f, 1.560e+01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 4, 1); }
      }
    }
    {
      static const float values[] = {
          0.000e+00f, -1.200e-01f, 3.510e+00f,  0.000e+00f,  0.000e+00f,
          0.000e+00f, 6.700e-02f,  -2.330e-01f, 3.660e+00f,  -4.740e-01f,
          9.500e+00f, -1.660e+01f, -3.100e-02f, -2.300e-02f, -4.530e-01f,
          3.580e-01f, -5.430e+00f, 1.550e+01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 4, 2); }
      }
    }
    {
      static const float values[] = {
          1.560e+00f,  0.000e+00f,  6.000e+00f,  9.000e+00f, 0.000e+00f,
          0.000e+00f,  -1.710e+00f, -9.490e-01f, 1.440e+00f, -7.190e+00f,
          -1.650e+01f, 1.530e+01f,  6.380e-01f,  3.250e-01f, -1.050e+00f,
          2.550e-01f,  1.090e+01f,  -1.010e+01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 5, 1); }
      }
    }
    {
      static const float values[] = {
          8.790e-01f,  0.000e+00f,  4.000e+00f,  9.000e+00f, 0.000e+00f,
          0.000e+00f,  -9.710e-01f, -1.160e+00f, 1.230e+00f, -5.640e+00f,
          -7.540e+00f, -5.960e-01f, 4.340e-01f,  4.760e-01f, -2.540e-01f,
          -8.170e-01f, 5.500e+00f,  1.260e-01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 6) { data, cdo(ip, is, 5, 2); }
      }
    }
    {
      static const float values[] = {
          4.0000e-01f,  7.0000e-01f, 0.0000e+00f, 0.0000e+00f, 0.0000e+00f,
          -6.2120e-02f, 6.4780e-01f, 0.0000e+00f, 0.0000e+00f, 0.0000e+00f,
          -7.1090e-03f, 1.3350e-02f, 0.0000e+00f, 0.0000e+00f, 0.0000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 1, 1); }
      }
    }
    {
      static const float values[] = {
          4.0000e-01f,  6.2800e-01f, 0.0000e+00f, 0.0000e+00f, 0.0000e+00f,
          -5.9090e-02f, 6.4360e-01f, 0.0000e+00f, 0.0000e+00f, 0.0000e+00f,
          -6.5240e-03f, 1.4510e-02f, 0.0000e+00f, 0.0000e+00f, 0.0000e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 1, 2); }
      }
    }
    {
      static const float values[] = {
          8.8800e-01f,  0.0000e+00f,  3.1100e+00f,  6.0000e+00f,  0.0000e+00f,
          -1.8020e+00f, -1.5760e+00f, -1.3170e-01f, 2.8010e+00f,  -1.7280e+01f,
          1.8120e+00f,  1.2000e+00f,  5.0680e-01f,  -1.2160e+01f, 2.0490e+01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 2, 1); }
      }
    }
    {
      static const float values[] = {
          7.9400e-01f,  0.0000e+00f,  2.8900e+00f,  6.0000e+00f,  0.0000e+00f,
          -9.1440e-01f, -1.2370e+00f, 5.9660e-01f,  -3.6710e+00f, -8.1910e+00f,
          5.9660e-01f,  6.5820e-01f,  -2.5500e-01f, -2.3040e+00f, 7.7580e+00f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 2, 2); }
      }
    }
    {
      static const float values[] = {
          9.0000e-01f,  0.0000e+00f,  5.0000e+00f, 0.0000e+00f,  0.0000e+00f,
          -2.4280e-01f, -2.1200e-01f, 8.6730e-01f, 1.2660e+00f,  2.3820e+00f,
          1.3860e-01f,  3.6710e-03f,  4.7470e-02f, -2.2150e+00f, 3.4820e-01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 3, 1); }
      }
    }
    {
      static const float values[] = {
          9.0000e-01f,  0.0000e+00f,  5.0000e+00f,  0.0000e+00f,  0.0000e+00f,
          -1.4170e-01f, -1.6970e-01f, -2.4740e+00f, -2.5340e+00f, 5.6210e-01f,
          -1.7400e-01f, -9.6230e-02f, 1.5750e+00f,  1.3780e+00f,  -2.7010e-01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 3, 2); }
      }
    }
    {
      static const float values[] = {
          0.0000e+00f,  -2.2120e-02f, 2.8940e+00f,  0.0000e+00f,  0.0000e+00f,
          7.9280e-02f,  -3.7850e-01f, 9.4330e+00f,  5.2480e+00f,  8.3880e+00f,
          -6.1340e-02f, -1.0880e-01f, -1.0852e+01f, -7.1870e+00f, -1.1610e+01f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 4, 1); }
      }
    }
    {
      static const float values[] = {
          0.0000e+00f,  -8.8200e-02f, 1.9240e+00f, 0.0000e+00f,  0.0000e+00f,
          6.2290e-02f,  -2.8920e-01f, 2.4240e-01f, -4.4630e+00f, -8.3670e-01f,
          -4.0990e-02f, -1.0820e-01f, 2.0360e+00f, 5.2090e+00f,  -4.8400e-02f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(ip, 1, 3) {
        FEM_DO_SAFE(is, 1, 5) { data, cow(ip, is, 4, 2); }
      }
    }
  }
  float alam = fem::float0;
  int kfl = fem::int0;
  int kfa = fem::int0;
  int kfe = fem::int0;
  int nset = fem::int0;
  float tmin = fem::float0;
  float tmax = fem::float0;
  float t = fem::float0;
  float vt = fem::float0;
  float vx = fem::float0;
  float cxs = fem::float0;
  arr_1d<6, float> tx(fem::fill0);
  arr_1d<6, float> tt(fem::fill0);
  float xqsum = fem::float0;
  arr_1d<6, float> xq(fem::fill0);
  float sd = fem::float0;
  arr_1d<6, float> ts(fem::fill0);
  float eulbt1 = fem::float0;
  float eulbt2 = fem::float0;
  float xps = fem::float0;
  float atnm = fem::float0;
  float bbr2 = fem::float0;
  float abx = fem::float0;
  float apx = fem::float0;
  float aax = fem::float0;
  float rrx = fem::float0;
  static const char* format_1200 =
      "(' Error: bad value of parameter MSTP(51) in PYSTFU,',' MSTP(51) =',i5)";
  /// C
  /// C                        *******JBT specifies beam or target of the
  /// particle C...Gives proton and pi+ parton structure functions according to
  /// a few C...different parametrizations. Note that what is coded is x times
  /// the C...probability distribution, i.e. xq(x,Q2) etc. C ********COMMON
  /// BLOCK FROM HIJING
  /// C
  /// C...The following data lines are coefficients needed in the
  /// C...Eichten, Hinchliffe, Lane, Quigg proton structure function
  /// C...parametrizations, see below.
  /// C...Powers of 1-x in different cases.
  /// C...Expansion coefficients for up valence quark distribution.
  /// C...Expansion coefficients for down valence quark distribution.
  /// C...Expansion coefficients for up and down sea quark distributions.
  /// C...Expansion coefficients for gluon distribution.
  /// C...Expansion coefficients for strange sea quark distribution.
  /// C...Expansion coefficients for charm sea quark distribution.
  /// C...Expansion coefficients for bottom sea quark distribution.
  /// C...Expansion coefficients for top sea quark distribution.
  /// C
  /// C...The following data lines are coefficients needed in the
  /// C...Duke, Owens proton structure function parametrizations, see below.
  /// C...Expansion coefficients for (up+down) valence quark distribution.
  /// C...Expansion coefficients for down valence quark distribution.
  /// C...Expansion coefficients for (up+down+strange) sea quark distribution.
  /// C...Expansion coefficients for charm sea quark distribution.
  /// C...Expansion coefficients for gluon distribution.
  /// C
  /// C...The following data lines are coefficients needed in the
  /// C...Owens pion structure function parametrizations, see below.
  /// C...Expansion coefficients for up and down valence quark distributions.
  /// C...Expansion coefficients for gluon distribution.
  /// C...Expansion coefficients for (up+down+strange) quark sea distribution.
  /// C...Expansion coefficients for charm quark sea distribution.
  /// C
  /// C...Euler's beta function, requires ordinary Gamma function
  /// Clin-10/25/02 get rid of argument usage mismatch in PYGAMM():
  /// C      EULBT(X,Y)=PYGAMM(X)*PYGAMM(Y)/PYGAMM(X+Y)
  /// C
  /// C...Reset structure functions, check x and hadron flavour.
  alam = 0.f;
  FEM_DO_SAFE(kfl, -6, 6) { xpq(kfl) = 0.f; }
  if (x < 0.f || x > 1.f) {
    write(mstu(11), "(' Error: x value outside physical range, x =',1p,e12.3)"),
        x;
    return;
  }
  kfa = fem::iabs(kf);
  if (kfa != 211 && kfa != 2212 && kfa != 2112) {
    write(
        mstu(11),
        "(' Error: illegal particle code for structure function,',' KF =',i5)"),
        kf;
    return;
  }
  /// C
  /// C...Call user-supplied structure function. Select proton/neutron/pion.
  if (mstp(51) == 0 || mstp(52) >= 2) {
    kfe = kfa;
    if (kfa == 2112) {
      kfe = 2212;
    }
    pystfe(cmn, kfe, x, q2, xpq);
    goto statement_230;
  }
  if (kfa == 211) {
    goto statement_200;
  }
  /// C
  if (mstp(51) == 1 || mstp(51) == 2) {
    /// C...Proton structure functions from Eichten, Hinchliffe, Lane, Quigg.
    /// C...Allowed variable range: 5 GeV2 < Q2 < 1E8 GeV2; 1E-4 < x < 1
    /// C
    /// C...Determine set, Lamdba and x and t expansion variables.
    nset = mstp(51);
    if (nset == 1) {
      alam = 0.2f;
    }
    if (nset == 2) {
      alam = 0.29f;
    }
    tmin = fem::log(5.f / fem::pow2(alam));
    tmax = fem::log(1e8f / fem::pow2(alam));
    if (mstp(52) == 0) {
      t = tmin;
    } else {
      t = fem::log(q2 / fem::pow2(alam));
    }
    vt = fem::max(-1.f, fem::min(1.f, (2.f * t - tmax - tmin) / (tmax - tmin)));
    nx = 1;
    if (x <= 0.1f) {
      nx = 2;
    }
    if (nx == 1) {
      vx = (2.f * x - 1.1f) / 0.9f;
    }
    if (nx == 2) {
      vx = fem::max(-1.f, (2.f * fem::log(x) + 11.51293f) / 6.90776f);
    }
    cxs = 1.f;
    if (x < 1e-4f && fem::abs(parp(51) - 1.f) > 0.01f) {
      cxs = fem::pow((1e-4f / x), (parp(51) - 1.f));
    }
    /// C
    /// C...Chebyshev polynomials for x and t expansion.
    tx(1) = 1.f;
    tx(2) = vx;
    tx(3) = 2.f * fem::pow2(vx) - 1.f;
    tx(4) = 4.f * fem::pow3(vx) - 3.f * vx;
    tx(5) = 8.f * fem::pow4(vx) - 8.f * fem::pow2(vx) + 1.f;
    tx(6) = 16.f * fem::pow(vx, 5) - 20.f * fem::pow3(vx) + 5.f * vx;
    tt(1) = 1.f;
    tt(2) = vt;
    tt(3) = 2.f * fem::pow2(vt) - 1.f;
    tt(4) = 4.f * fem::pow3(vt) - 3.f * vt;
    tt(5) = 8.f * fem::pow4(vt) - 8.f * fem::pow2(vt) + 1.f;
    tt(6) = 16.f * fem::pow(vt, 5) - 20.f * fem::pow3(vt) + 5.f * vt;
    /// C
    /// C...Calculate structure functions.
    FEM_DO_SAFE(kfl, 1, 6) {
      xqsum = 0.f;
      FEM_DO_SAFE(it, 1, 6) {
        FEM_DO_SAFE(ix, 1, 6) {
          xqsum += cehlq(ix, it, nx, kfl, nset) * tx(ix) * tt(it);
        }
      }
      xq(kfl) = xqsum * fem::pow((1.f - x), nehlq(kfl, nset)) * cxs;
    }
    /// C
    /// C...Put into output array.
    xpq(0) = xq(4);
    xpq(1) = xq(2) + xq(3);
    xpq(2) = xq(1) + xq(3);
    xpq(3) = xq(5);
    xpq(4) = xq(6);
    xpq(-1) = xq(3);
    xpq(-2) = xq(3);
    xpq(-3) = xq(5);
    xpq(-4) = xq(6);
    /// C
    /// C...Special expansion for bottom (thresh effects).
    if (mstp(54) >= 5) {
      if (nset == 1) {
        tmin = 8.1905f;
      }
      if (nset == 2) {
        tmin = 7.4474f;
      }
      if (t <= tmin) {
        goto statement_140;
      }
      vt = fem::max(-1.f,
                    fem::min(1.f, (2.f * t - tmax - tmin) / (tmax - tmin)));
      tt(1) = 1.f;
      tt(2) = vt;
      tt(3) = 2.f * fem::pow2(vt) - 1.f;
      tt(4) = 4.f * fem::pow3(vt) - 3.f * vt;
      tt(5) = 8.f * fem::pow4(vt) - 8.f * fem::pow2(vt) + 1.f;
      tt(6) = 16.f * fem::pow(vt, 5) - 20.f * fem::pow3(vt) + 5.f * vt;
      xqsum = 0.f;
      FEM_DO_SAFE(it, 1, 6) {
        FEM_DO_SAFE(ix, 1, 6) {
          xqsum += cehlq(ix, it, nx, 7, nset) * tx(ix) * tt(it);
        }
      }
      xpq(5) = xqsum * fem::pow((1.f - x), nehlq(7, nset));
      xpq(-5) = xpq(5);
    statement_140:;
    }
    /// C
    /// C...Special expansion for top (thresh effects).
    if (mstp(54) >= 6) {
      if (nset == 1) {
        tmin = 11.5528f;
      }
      if (nset == 2) {
        tmin = 10.8097f;
      }
      tmin += 2.f * fem::log(pmas(6, 1) / 30.f);
      tmax += 2.f * fem::log(pmas(6, 1) / 30.f);
      if (t <= tmin) {
        goto statement_160;
      }
      vt = fem::max(-1.f,
                    fem::min(1.f, (2.f * t - tmax - tmin) / (tmax - tmin)));
      tt(1) = 1.f;
      tt(2) = vt;
      tt(3) = 2.f * fem::pow2(vt) - 1.f;
      tt(4) = 4.f * fem::pow3(vt) - 3.f * vt;
      tt(5) = 8.f * fem::pow4(vt) - 8.f * fem::pow2(vt) + 1.f;
      tt(6) = 16.f * fem::pow(vt, 5) - 20.f * fem::pow3(vt) + 5.f * vt;
      xqsum = 0.f;
      FEM_DO_SAFE(it, 1, 6) {
        FEM_DO_SAFE(ix, 1, 6) {
          xqsum += cehlq(ix, it, nx, 8, nset) * tx(ix) * tt(it);
        }
      }
      xpq(6) = xqsum * fem::pow((1.f - x), nehlq(8, nset));
      xpq(-6) = xpq(6);
    statement_160:;
    }
    /// C
  } else if (mstp(51) == 3 || mstp(51) == 4) {
    /// C...Proton structure functions from Duke, Owens.
    /// C...Allowed variable range: 4 GeV2 < Q2 < approx 1E6 GeV2.
    /// C
    /// C...Determine set, Lambda and s expansion parameter.
    nset = mstp(51) - 2;
    if (nset == 1) {
      alam = 0.2f;
    }
    if (nset == 2) {
      alam = 0.4f;
    }
    if (mstp(52) <= 0) {
      sd = 0.f;
    } else {
      sd = fem::log(fem::log(fem::max(q2, 4.f) / fem::pow2(alam)) /
                    fem::log(4.f / fem::pow2(alam)));
    }
    /// C
    /// C...Calculate structure functions.
    FEM_DO_SAFE(kfl, 1, 5) {
      FEM_DO_SAFE(is, 1, 6) {
        ts(is) = cdo(1, is, kfl, nset) + cdo(2, is, kfl, nset) * sd +
                 cdo(3, is, kfl, nset) * fem::pow2(sd);
      }
      if (kfl <= 2) {
        /// C
        /// Clin-10/25/02 evaluate EULBT(TS(1),TS(2)+1.):
        /// C          XQ(KFL)=X**TS(1)*(1.-X)**TS(2)*(1.+TS(3)*X)/(EULBT(TS(1),
        /// C     &    TS(2)+1.)*(1.+TS(3)*TS(1)/(TS(1)+TS(2)+1.)))
        eulbt1 = pygamm(cmn, ts(1)) * pygamm(cmn, ts(2) + 1.f) /
                 pygamm(cmn, ts(1) + ts(2) + 1.f);
        xq(kfl) = fem::pow(x, ts(1)) * fem::pow((1.f - x), ts(2)) *
                  (1.f + ts(3) * x) /
                  (eulbt1 * (1.f + ts(3) * ts(1) / (ts(1) + ts(2) + 1.f)));
      } else {
        xq(kfl) =
            ts(1) * fem::pow(x, ts(2)) * fem::pow((1.f - x), ts(3)) *
            (1.f + ts(4) * x + ts(5) * fem::pow2(x) + ts(6) * fem::pow3(x));
      }
      /// C
    }
    /// C
    /// C...Put into output arrays.
    xpq(0) = xq(5);
    xpq(1) = xq(2) + xq(3) / 6.f;
    xpq(2) = 3.f * xq(1) - xq(2) + xq(3) / 6.f;
    xpq(3) = xq(3) / 6.f;
    xpq(4) = xq(4);
    xpq(-1) = xq(3) / 6.f;
    xpq(-2) = xq(3) / 6.f;
    xpq(-3) = xq(3) / 6.f;
    xpq(-4) = xq(4);
    /// C
    /// C...Proton structure functions from Diemoz, Ferroni, Longo, Martinelli.
    /// C...These are accessed via PYSTFE since the files needed may not always
    /// C...available.
  } else if (mstp(51) >= 11 && mstp(51) <= 13) {
    pystfe(cmn, 2212, x, q2, xpq);
    /// C
    /// C...Unknown proton parametrization.
  } else {
    write(mstu(11), format_1200), mstp(51);
  }
  goto statement_230;
/// C
statement_200:
  if ((mstp(51) >= 1 && mstp(51) <= 4) || (mstp(51) >= 11 && mstp(51) <= 13)) {
    /// C...Pion structure functions from Owens.
    /// C...Allowed variable range: 4 GeV2 < Q2 < approx 2000 GeV2.
    /// C
    /// C...Determine set, Lambda and s expansion variable.
    nset = 1;
    if (mstp(51) == 2 || mstp(51) == 4 || mstp(51) == 13) {
      nset = 2;
    }
    if (nset == 1) {
      alam = 0.2f;
    }
    if (nset == 2) {
      alam = 0.4f;
    }
    if (mstp(52) <= 0) {
      sd = 0.f;
    } else {
      sd = fem::log(fem::log(fem::max(q2, 4.f) / fem::pow2(alam)) /
                    fem::log(4.f / fem::pow2(alam)));
    }
    /// C
    /// C...Calculate structure functions.
    FEM_DO_SAFE(kfl, 1, 4) {
      FEM_DO_SAFE(is, 1, 5) {
        ts(is) = cow(1, is, kfl, nset) + cow(2, is, kfl, nset) * sd +
                 cow(3, is, kfl, nset) * fem::pow2(sd);
      }
      if (kfl == 1) {
        /// C
        /// Clin-10/25/02 get rid of argument usage mismatch in PYGAMM():
        /// C          XQ(KFL)=X**TS(1)*(1.-X)**TS(2)/EULBT(TS(1),TS(2)+1.)
        eulbt2 = pygamm(cmn, ts(1)) * pygamm(cmn, ts(2) + 1.f) /
                 pygamm(cmn, ts(1) + ts(2) + 1.f);
        xq(kfl) = fem::pow(x, ts(1)) * fem::pow((1.f - x), ts(2)) / eulbt2;
      } else {
        xq(kfl) = ts(1) * fem::pow(x, ts(2)) * fem::pow((1.f - x), ts(3)) *
                  (1.f + ts(4) * x + ts(5) * fem::pow2(x));
      }
    }
    /// C
    /// C...Put into output arrays.
    xpq(0) = xq(2);
    xpq(1) = xq(3) / 6.f;
    xpq(2) = xq(1) + xq(3) / 6.f;
    xpq(3) = xq(3) / 6.f;
    xpq(4) = xq(4);
    xpq(-1) = xq(1) + xq(3) / 6.f;
    xpq(-2) = xq(3) / 6.f;
    xpq(-3) = xq(3) / 6.f;
    xpq(-4) = xq(4);
    /// C
    /// C...Unknown pion parametrization.
  } else {
    write(mstu(11), format_1200), mstp(51);
  }
/// C
/// C...Isospin conjugation for neutron, charge conjugation for antipart.
statement_230:
  if (kfa == 2112) {
    xps = xpq(1);
    xpq(1) = xpq(2);
    xpq(2) = xps;
    xps = xpq(-1);
    xpq(-1) = xpq(-2);
    xpq(-2) = xps;
  }
  if (kf < 0) {
    FEM_DO_SAFE(kfl, 1, 4) {
      xps = xpq(kfl);
      xpq(kfl) = xpq(-kfl);
      xpq(-kfl) = xps;
    }
  }
  /// C
  /// C...Check positivity and reset above maximum allowed flavour.
  FEM_DO_SAFE(kfl, -6, 6) {
    xpq(kfl) = fem::max(0.f, xpq(kfl));
    if (fem::iabs(kfl) > mstp(54)) {
      xpq(kfl) = 0.f;
    }
  }
  /// C
  /// C...consider nuclear effect on the structure function
  if ((jbt != 1 && jbt != 2) || ihpr2(6) == 0 || ihnt2(16) == 1) {
    goto statement_400;
  }
  atnm = ihnt2(2 * jbt - 1);
  if (atnm <= 1.0f) {
    goto statement_400;
  }
  if (jbt == 1) {
    bbr2 = (fem::pow2(yp(1, ihnt2(11))) + fem::pow2(yp(2, ihnt2(11)))) / 1.44f /
           fem::pow(atnm, 0.66666f);
  } else if (jbt == 2) {
    bbr2 = (fem::pow2(yt(1, ihnt2(12))) + fem::pow2(yt(2, ihnt2(12)))) / 1.44f /
           fem::pow(atnm, 0.66666f);
  }
  bbr2 = fem::min(1.0f, bbr2);
  abx = (fem::pow(atnm, 0.33333333f) - 1.0f);
  apx = hipr1(6) * 4.0f / 3.0f * abx * fem::sqrt(1.0f - bbr2);
  aax = 1.192f * fem::pow(fem::alog(atnm), 0.1666666f);
  rrx = aax * (fem::pow3(x) - 1.2f * fem::pow2(x) + 0.21f * x) + 1.0f -
        (apx - 1.079f * abx * fem::sqrt(x) / fem::alog(atnm + 1.0f)) *
            fem::exp(-fem::pow(x, 2.0f) / 0.01f);
  FEM_DO_SAFE(kfl, -6, 6) { xpq(kfl) = xpq(kfl) * rrx; }
/// C                        ********consider the nuclear effect on the
/// structure C                                function which also depends on
/// the impact C                                parameter of the nuclear
/// reaction
/// C
statement_400:;
  /// C...Formats for error printouts.
  /// C
}

/// C
/// C***********************************************************************
/// C
float pyw1au(common& cmn, float const& eps, int const& ireim) {
  float return_value = fem::float0;
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  ///
  /// C
  /// C...Calculates real and imaginary parts of the auxiliary function W1;
  /// C...see R. K. Ellis, I. Hinchliffe, M. Soldate and J. J. van der Bij,
  /// C...FERMILAB-Pub-87/100-T, LBL-23504, June, 1987
  /// C
  /// Clin-8/2014:
  /// C      ASINH(X)=LOG(X+SQRT(X**2+1.))
  float x = fem::float0;
  acosh(x) = fem::log(x + fem::sqrt(fem::pow2(x) - 1.f));
  /// C
  float w1re = fem::float0;
  float w1im = fem::float0;
  if (eps < 0.f) {
    w1re = 2.f * fem::sqrt(1.f - eps) * asinh(fem::sqrt(-1.f / eps));
    w1im = 0.f;
  } else if (eps < 1.f) {
    w1re = 2.f * fem::sqrt(1.f - eps) * acosh(fem::sqrt(1.f / eps));
    w1im = -paru(1) * fem::sqrt(1.f - eps);
  } else {
    w1re = 2.f * fem::sqrt(eps - 1.f) * fem::asin(fem::sqrt(1.f / eps));
    w1im = 0.f;
  }
  /// C
  if (ireim == 1) {
    return_value = w1re;
  }
  if (ireim == 2) {
    return_value = w1im;
  }
  /// C
  return return_value;
}

/// C
/// C***********************************************************************
/// C
float pyw2au(common& cmn, float const& eps, int const& ireim) {
  float return_value = fem::float0;
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  ///
  /// C
  /// C...Calculates real and imaginary parts of the auxiliary function W2;
  /// C...see R. K. Ellis, I. Hinchliffe, M. Soldate and J. J. van der Bij,
  /// C...FERMILAB-Pub-87/100-T, LBL-23504, June, 1987
  /// C
  /// Clin-8/2014:
  /// C      ASINH(X)=LOG(X+SQRT(X**2+1.))
  float x = fem::float0;
  acosh(x) = fem::log(x + fem::sqrt(fem::pow2(x) - 1.f));
  /// C
  float w2re = fem::float0;
  float w2im = fem::float0;
  if (eps < 0.f) {
    w2re = 4.f * fem::pow2((asinh(fem::sqrt(-1.f / eps))));
    w2im = 0.f;
  } else if (eps < 1.f) {
    w2re = 4.f * fem::pow2((acosh(fem::sqrt(1.f / eps)))) - fem::pow2(paru(1));
    w2im = -4.f * paru(1) * acosh(fem::sqrt(1.f / eps));
  } else {
    w2re = -4.f * fem::pow2((fem::asin(fem::sqrt(1.f / eps))));
    w2im = 0.f;
  }
  /// C
  if (ireim == 1) {
    return_value = w2re;
  }
  if (ireim == 2) {
    return_value = w2im;
  }
  /// C
  return return_value;
}

struct pyspen_save {
  arr<float> b;

  pyspen_save() : b(dim1(0, 14), fem::fill0) {}
};

/// C
/// C***********************************************************************
/// C
float pyspen(common& cmn, float const& xrein, float const& ximin,
             int const& ireim) {
  float return_value = fem::float0;
  FEM_CMN_SVE(pyspen);
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  ///
  /// SAVE
  arr_ref<float> b(sve.b, dim1(0, 14));
  ///
  if (is_called_first_time) {
    static const float values[] = {
        1.000000e+00f,  -5.000000e-01f, 1.666667e-01f, 0.000000e+00f,
        -3.333333e-02f, 0.000000e+00f,  2.380952e-02f, 0.000000e+00f,
        -3.333333e-02f, 0.000000e+00f,  7.575757e-02f, 0.000000e+00f,
        -2.531135e-01f, 0.000000e+00f,  1.166667e+00f};
    fem::data_of_type<float>(FEM_VALUES_AND_SIZE), b;
  }
  /// C
  /// C...Calculates real and imaginary part of Spence function; see
  /// C...G. 't Hooft and M. Veltman, Nucl. Phys. B153 (1979) 365.
  /// C
  float xre = xrein;
  float xim = ximin;
  if (fem::abs(1.f - xre) < 1.e-6f && fem::abs(xim) < 1.e-6f) {
    if (ireim == 1) {
      return_value = fem::pow2(paru(1)) / 6.f;
    }
    if (ireim == 2) {
      return_value = 0.f;
    }
    return return_value;
  }
  /// C
  float xmod = fem::sqrt(fem::pow2(xre) + fem::pow2(xim));
  if (xmod < 1.e-6f) {
    if (ireim == 1) {
      return_value = 0.f;
    }
    if (ireim == 2) {
      return_value = 0.f;
    }
    return return_value;
  }
  /// C
  float xarg = fem::sign(fem::acos(xre / xmod), xim);
  float sp0re = 0.f;
  float sp0im = 0.f;
  float sgn = 1.f;
  float algxre = fem::float0;
  float algxim = fem::float0;
  if (xmod > 1.f) {
    algxre = fem::log(xmod);
    algxim = xarg - fem::sign(paru(1), xarg);
    sp0re = -fem::pow2(paru(1)) / 6.f -
            (fem::pow2(algxre) - fem::pow2(algxim)) / 2.f;
    sp0im = -algxre * algxim;
    sgn = -1.f;
    xmod = 1.f / xmod;
    xarg = -xarg;
    xre = xmod * fem::cos(xarg);
    xim = xmod * fem::sin(xarg);
  }
  float algyre = fem::float0;
  float algyim = fem::float0;
  if (xre > 0.5f) {
    algxre = fem::log(xmod);
    algxim = xarg;
    xre = 1.f - xre;
    xim = -xim;
    xmod = fem::sqrt(fem::pow2(xre) + fem::pow2(xim));
    xarg = fem::sign(fem::acos(xre / xmod), xim);
    algyre = fem::log(xmod);
    algyim = xarg;
    sp0re +=
        sgn * (fem::pow2(paru(1)) / 6.f - (algxre * algyre - algxim * algyim));
    sp0im = sp0im - sgn * (algxre * algyim + algxim * algyre);
    sgn = -sgn;
  }
  /// C
  xre = 1.f - xre;
  xim = -xim;
  xmod = fem::sqrt(fem::pow2(xre) + fem::pow2(xim));
  xarg = fem::sign(fem::acos(xre / xmod), xim);
  float zre = -fem::log(xmod);
  float zim = -xarg;
  /// C
  float spre = 0.f;
  float spim = 0.f;
  float savere = 1.f;
  float saveim = 0.f;
  int i = fem::int0;
  float termre = fem::float0;
  float termim = fem::float0;
  FEM_DO_SAFE(i, 0, 14) {
    termre = (savere * zre - saveim * zim) / fem::ffloat(i + 1);
    termim = (savere * zim + saveim * zre) / fem::ffloat(i + 1);
    savere = termre;
    saveim = termim;
    spre += b(i) * termre;
    spim += b(i) * termim;
  }
  /// C
  if (ireim == 1) {
    return_value = sp0re + sgn * spre;
  }
  if (ireim == 2) {
    return_value = sp0im + sgn * spim;
  }
  /// C
  return return_value;
}

/// C
/// C***********************************************************************
/// C
float pyi3au(common& cmn, float const& be, float const& eps, int const& ireim) {
  float return_value = fem::float0;
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  ///
  /// C
  /// C...Calculates real and imaginary parts of the auxiliary function I3;
  /// C...see R. K. Ellis, I. Hinchliffe, M. Soldate and J. J. van der Bij,
  /// C...FERMILAB-Pub-87/100-T, LBL-23504, June, 1987
  /// C
  float ga = fem::float0;
  if (eps < 1.f) {
    ga = 0.5f * (1.f + fem::sqrt(1.f - eps));
  }
  /// C
  float f3re = fem::float0;
  float f3im = fem::float0;
  float rsq = fem::float0;
  float rcthe = fem::float0;
  float rsthe = fem::float0;
  float rcphi = fem::float0;
  float rsphi = fem::float0;
  float r = fem::float0;
  float the = fem::float0;
  float phi = fem::float0;
  if (eps < 0.f) {
    f3re = pyspen(cmn, (ga - 1.f) / (ga + be - 1.f), 0.f, 1) -
           pyspen(cmn, ga / (ga + be - 1.f), 0.f, 1) +
           pyspen(cmn, (be - ga) / be, 0.f, 1) -
           pyspen(cmn, (be - ga) / (be - 1.f), 0.f, 1) +
           (fem::pow2(fem::log(be)) - fem::pow2(fem::log(be - 1.f))) / 2.f +
           fem::log(ga) * fem::log((ga + be - 1.f) / be) +
           fem::log(ga - 1.f) * fem::log((be - 1.f) / (ga + be - 1.f));
    f3im = 0.f;
  } else if (eps < 1.f) {
    f3re = pyspen(cmn, (ga - 1.f) / (ga + be - 1.f), 0.f, 1) -
           pyspen(cmn, ga / (ga + be - 1.f), 0.f, 1) +
           pyspen(cmn, ga / (ga - be), 0.f, 1) -
           pyspen(cmn, (ga - 1.f) / (ga - be), 0.f, 1) +
           fem::log(ga / (1.f - ga)) * fem::log((ga + be - 1.f) / (be - ga));
    f3im = -paru(1) * fem::log((ga + be - 1.f) / (be - ga));
  } else {
    rsq = eps / (eps - 1.f + fem::pow2((2.f * be - 1.f)));
    rcthe = rsq * (1.f - 2.f * be / eps);
    rsthe = fem::sqrt(rsq - fem::pow2(rcthe));
    rcphi = rsq * (1.f + 2.f * (be - 1.f) / eps);
    rsphi = fem::sqrt(rsq - fem::pow2(rcphi));
    r = fem::sqrt(rsq);
    the = fem::acos(rcthe / r);
    phi = fem::acos(rcphi / r);
    f3re = pyspen(cmn, rcthe, rsthe, 1) + pyspen(cmn, rcthe, -rsthe, 1) -
           pyspen(cmn, rcphi, rsphi, 1) - pyspen(cmn, rcphi, -rsphi, 1) +
           (phi - the) * (phi + the - paru(1));
    f3im = pyspen(cmn, rcthe, rsthe, 2) + pyspen(cmn, rcthe, -rsthe, 2) -
           pyspen(cmn, rcphi, rsphi, 2) - pyspen(cmn, rcphi, -rsphi, 2);
  }
  /// C
  if (ireim == 1) {
    return_value = 2.f / (2.f * be - 1.f) * f3re;
  }
  if (ireim == 2) {
    return_value = 2.f / (2.f * be - 1.f) * f3im;
  }
  /// C
  return return_value;
}

/// C
/// C***********************************************************************
/// C
void pysigh(common& cmn, int& nchn, float& sigs) {
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<float, 2> vckm(cmn.vckm, dimension(4, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> kfin(cmn.kfin, dim1(2).dim2(-40, 40));
  arr_cref<float> ckin(cmn.ckin, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<float> pari(cmn.pari, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_cref<int, 2> kfpr(cmn.kfpr, dimension(200, 2));
  arr_cref<float, 2> coef(cmn.coef, dimension(200, 20));
  arr_ref<float, 2> xsfx(cmn.xsfx, dim1(2).dim2(-40, 40));
  arr_ref<int, 2> isig(cmn.isig, dimension(1000, 3));
  arr_ref<float> sigh(cmn.sigh, dimension(1000));
  arr_cref<float, 2> wids(cmn.wids, dim1(21, 40).dim2(3));
  arr_cref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  int isub = fem::int0;
  float taumin = fem::float0;
  float ystmin = fem::float0;
  float ctnmin = fem::float0;
  float ctpmin = fem::float0;
  float xt2min = fem::float0;
  float taupmn = fem::float0;
  float tau = fem::float0;
  float yst = fem::float0;
  float cth = fem::float0;
  float xt2 = fem::float0;
  float taup = fem::float0;
  float taumax = fem::float0;
  float ystmax = fem::float0;
  float ctnmax = fem::float0;
  float ctpmax = fem::float0;
  float xt2max = fem::float0;
  float taupmx = fem::float0;
  arr_1d<2, float> x(fem::fill0);
  float sh = fem::float0;
  float sqm3 = fem::float0;
  float sqm4 = fem::float0;
  float rm3 = fem::float0;
  float rm4 = fem::float0;
  float be34 = fem::float0;
  float rpts = fem::float0;
  float be34l = fem::float0;
  float rm34 = fem::float0;
  float rsqm = fem::float0;
  float rthm = fem::float0;
  float th = fem::float0;
  float uh = fem::float0;
  float sqpth = fem::float0;
  float sh2 = fem::float0;
  float th2 = fem::float0;
  float uh2 = fem::float0;
  float q2 = fem::float0;
  float q2sf = fem::float0;
  int i = fem::int0;
  float xsf = fem::float0;
  arr_1d<13, float> xpq(dim1(-6, 6), fem::fill0);
  int kfl = fem::int0;
  float as = fem::float0;
  float fack = fem::float0;
  float faca = fem::float0;
  float q2as = fem::float0;
  float radc = fem::float0;
  int j = fem::int0;
  arr_2d<2, 81, int> kfac(dim1(2).dim2(-40, 40), fem::fill0);
  int min1 = fem::int0;
  int max1 = fem::int0;
  int min2 = fem::int0;
  int max2 = fem::int0;
  int mina = fem::int0;
  int maxa = fem::int0;
  float sqmz = fem::float0;
  float gmmz = fem::float0;
  float sqmw = fem::float0;
  float gmmw = fem::float0;
  float sqmh = fem::float0;
  float gmmh = fem::float0;
  float sqmzp = fem::float0;
  float gmmzp = fem::float0;
  float sqmhc = fem::float0;
  float gmmhc = fem::float0;
  float sqmr = fem::float0;
  float gmmr = fem::float0;
  float aem = fem::float0;
  float xw = fem::float0;
  float comfac = fem::float0;
  float atau0 = fem::float0;
  float atau1 = fem::float0;
  float h1 = fem::float0;
  float taur1 = fem::float0;
  float gamr1 = fem::float0;
  float atau2 = fem::float0;
  float atau3 = fem::float0;
  float taur2 = fem::float0;
  float gamr2 = fem::float0;
  float atau4 = fem::float0;
  float atau5 = fem::float0;
  float ayst0 = fem::float0;
  float ayst1 = fem::float0;
  float ayst2 = fem::float0;
  float ayst3 = fem::float0;
  float h2 = fem::float0;
  float acth0 = fem::float0;
  float acth1 = fem::float0;
  float acth2 = fem::float0;
  float acth3 = fem::float0;
  float acth4 = fem::float0;
  float h3 = fem::float0;
  float ataup0 = fem::float0;
  float ataup1 = fem::float0;
  float h4 = fem::float0;
  float fzw = fem::float0;
  arr_1d<41, float> wdtp(dim1(0, 40), fem::fill0);
  arr_2d<41, 6, float> wdte(dim1(0, 40).dim2(0, 5), fem::fill0);
  float facz = fem::float0;
  float ei = fem::float0;
  float ai = fem::float0;
  float vi = fem::float0;
  float facf = fem::float0;
  float facw = fem::float0;
  int ia = fem::int0;
  int ja = fem::int0;
  int kchw = fem::int0;
  float fach = fem::float0;
  float rmq = fem::float0;
  float ej = fem::float0;
  float aj = fem::float0;
  float vj = fem::float0;
  float facqq1 = fem::float0;
  float facqqb = fem::float0;
  float facqq2 = fem::float0;
  float facgg1 = fem::float0;
  float facgg2 = fem::float0;
  float facgg = fem::float0;
  float faczg = fem::float0;
  float facwg = fem::float0;
  float fckm = fem::float0;
  float facgz = fem::float0;
  float facgw = fem::float0;
  float faczz = fem::float0;
  float faczw = fem::float0;
  float thuh = fem::float0;
  float visav = fem::float0;
  float aisav = fem::float0;
  float fachz = fem::float0;
  float facww = fem::float0;
  float dsigww = fem::float0;
  float fachw = fem::float0;
  float facqg1 = fem::float0;
  float facqg2 = fem::float0;
  int isde = fem::int0;
  float fgq = fem::float0;
  float facgq = fem::float0;
  float fzq = fem::float0;
  float faczq = fem::float0;
  float facwq = fem::float0;
  float facgg3 = fem::float0;
  float be2 = fem::float0;
  float shang = fem::float0;
  float ashre = fem::float0;
  float ashim = fem::float0;
  float thang = fem::float0;
  float athre = fem::float0;
  float athim = fem::float0;
  float uhang = fem::float0;
  float auhre = fem::float0;
  float auhim = fem::float0;
  float avi = fem::float0;
  float avj = fem::float0;
  float cth2 = fem::float0;
  float atwre = fem::float0;
  float atwim = fem::float0;
  float auwre = fem::float0;
  float auwim = fem::float0;
  float a4re = fem::float0;
  float a4im = fem::float0;
  float ep1 = fem::float0;
  float ep2 = fem::float0;
  float aswre = fem::float0;
  float aswim = fem::float0;
  float be4 = fem::float0;
  float cth3 = fem::float0;
  float sgzang = fem::float0;
  float asgre = fem::float0;
  float asgim = fem::float0;
  float aszre = fem::float0;
  float aszim = fem::float0;
  float tgzang = fem::float0;
  float atgre = fem::float0;
  float atgim = fem::float0;
  float atzre = fem::float0;
  float atzim = fem::float0;
  float alssg = fem::float0;
  int mst115 = fem::int0;
  float q2bn = fem::float0;
  float xrepu = fem::float0;
  float frepu = fem::float0;
  float xattr = fem::float0;
  float fattr = fem::float0;
  float fatre = fem::float0;
  float etare = fem::float0;
  float etaim = fem::float0;
  float eps = fem::float0;
  float root = fem::float0;
  float rln = fem::float0;
  float phire = fem::float0;
  float phiim = fem::float0;
  float eta2 = fem::float0;
  float a5stur = fem::float0;
  float a5stui = fem::float0;
  float sqmq = fem::float0;
  float epss = fem::float0;
  float epsh = fem::float0;
  float facgh = fem::float0;
  float a5tsur = fem::float0;
  float a5tsui = fem::float0;
  float epst = fem::float0;
  float facqh = fem::float0;
  float a2stur = fem::float0;
  float a2stui = fem::float0;
  float a2ustr = fem::float0;
  float a2usti = fem::float0;
  float a2tusr = fem::float0;
  float a2tusi = fem::float0;
  float a4stur = fem::float0;
  float a4stui = fem::float0;
  float epsu = fem::float0;
  float bestu = fem::float0;
  float beust = fem::float0;
  float betus = fem::float0;
  float beuts = fem::float0;
  float betsu = fem::float0;
  float besut = fem::float0;
  float w3stur = fem::float0;
  float w3stui = fem::float0;
  float w3sutr = fem::float0;
  float w3suti = fem::float0;
  float w3tsur = fem::float0;
  float w3tsui = fem::float0;
  float w3tusr = fem::float0;
  float w3tusi = fem::float0;
  float w3ustr = fem::float0;
  float w3usti = fem::float0;
  float w3utsr = fem::float0;
  float w3utsi = fem::float0;
  float b2stur = fem::float0;
  float b2stui = fem::float0;
  float b2sutr = fem::float0;
  float b2suti = fem::float0;
  float b2tsur = fem::float0;
  float b2tsui = fem::float0;
  float b2tusr = fem::float0;
  float b2tusi = fem::float0;
  float b2ustr = fem::float0;
  float b2usti = fem::float0;
  float b2utsr = fem::float0;
  float b2utsi = fem::float0;
  float b4stur = fem::float0;
  float b4stui = fem::float0;
  float b4tusr = fem::float0;
  float b4tusi = fem::float0;
  float b4ustr = fem::float0;
  float b4usti = fem::float0;
  float asre = fem::float0;
  float asim = fem::float0;
  float a0stur = fem::float0;
  float a0stui = fem::float0;
  float a0tsur = fem::float0;
  float a0tsui = fem::float0;
  float a0utsr = fem::float0;
  float a0utsi = fem::float0;
  float a1stur = fem::float0;
  float a1stui = fem::float0;
  float faczp = fem::float0;
  float api = fem::float0;
  float vpi = fem::float0;
  float fhc = fem::float0;
  int il = fem::int0;
  int iu = fem::int0;
  float rmql = fem::float0;
  float rmqu = fem::float0;
  float fachc = fem::float0;
  int kchhc = fem::int0;
  float facr = fem::float0;
  float fhcq = fem::float0;
  float fachcq = fem::float0;
  int ichn = fem::int0;
  int kfl1 = fem::int0;
  int kfl2 = fem::int0;
  /// C
  /// C...Differential matrix elements for all included subprocesses.
  /// C...Note that what is coded is (disregarding the COMFAC factor)
  /// C...1) for 2 -> 1 processes: s-hat/pi*d(sigma-hat), where,
  /// C...when d(sigma-hat) is given in the zero-width limit, the delta
  /// C...function in tau is replaced by a Breit-Wigner:
  /// C...1/pi*(s*m_res*Gamma_res)/((s*tau-m_res^2)^2+(m_res*Gamma_res)^2);
  /// C...2) for 2 -> 2 processes: (s-hat)**2/pi*d(sigma-hat)/d(t-hat);
  /// C...i.e., dimensionless quantities. COMFAC contains the factor
  /// C...pi/s and the conversion factor from GeV^-2 to mb.
  /// C
  /// C...Reset number of channels and cross-section.
  nchn = 0;
  sigs = 0.f;
  /// C
  /// C...Read kinematical variables and limits.
  isub = mint(1);
  taumin = vint(11);
  ystmin = vint(12);
  ctnmin = vint(13);
  ctpmin = vint(14);
  xt2min = vint(15);
  taupmn = vint(16);
  tau = vint(21);
  yst = vint(22);
  cth = vint(23);
  xt2 = vint(25);
  taup = vint(26);
  taumax = vint(31);
  ystmax = vint(32);
  ctnmax = vint(33);
  ctpmax = vint(34);
  xt2max = vint(35);
  taupmx = vint(36);
  /// C
  /// C...Derive kinematical quantities.
  if (iset(isub) <= 2 || iset(isub) == 5) {
    x(1) = fem::sqrt(tau) * fem::exp(yst);
    x(2) = fem::sqrt(tau) * fem::exp(-yst);
  } else {
    x(1) = fem::sqrt(taup) * fem::exp(yst);
    x(2) = fem::sqrt(taup) * fem::exp(-yst);
  }
  if (mint(43) == 4 && iset(isub) >= 1 && (x(1) > 0.999f || x(2) > 0.999f)) {
    return;
  }
  sh = tau * vint(2);
  sqm3 = vint(63);
  sqm4 = vint(64);
  rm3 = sqm3 / sh;
  rm4 = sqm4 / sh;
  be34 = fem::sqrt(fem::pow2((1.f - rm3 - rm4)) - 4.f * rm3 * rm4);
  rpts = 4.f * fem::pow2(vint(71)) / sh;
  be34l = fem::sqrt(
      fem::max(0.f, fem::pow2((1.f - rm3 - rm4)) - 4.f * rm3 * rm4 - rpts));
  rm34 = 2.f * rm3 * rm4;
  rsqm = 1.f + rm34;
  rthm = (4.f * rm3 * rm4 + rpts) / (1.f - rm3 - rm4 + be34l);
  th = -0.5f * sh * fem::max(rthm, 1.f - rm3 - rm4 - be34 * cth);
  uh = -0.5f * sh * fem::max(rthm, 1.f - rm3 - rm4 + be34 * cth);
  sqpth = 0.25f * sh * fem::pow2(be34) * (1.f - fem::pow2(cth));
  sh2 = fem::pow2(sh);
  th2 = fem::pow2(th);
  uh2 = fem::pow2(uh);
  /// C
  /// C...Choice of Q2 scale.
  if (iset(isub) == 1 || iset(isub) == 3) {
    q2 = sh;
  } else if (fem::mod(iset(isub), 2) == 0 || iset(isub) == 5) {
    if (mstp(32) == 1) {
      q2 = 2.f * sh * th * uh / (fem::pow2(sh) + fem::pow2(th) + fem::pow2(uh));
    } else if (mstp(32) == 2) {
      q2 = sqpth + 0.5f * (sqm3 + sqm4);
    } else if (mstp(32) == 3) {
      q2 = fem::min(-th, -uh);
    } else if (mstp(32) == 4) {
      q2 = sh;
    }
    if (iset(isub) == 5 && mstp(82) >= 2) {
      q2 += fem::pow2(parp(82));
    }
  }
  /// C
  /// C...Store derived kinematical quantities.
  vint(41) = x(1);
  vint(42) = x(2);
  vint(44) = sh;
  vint(43) = fem::sqrt(sh);
  vint(45) = th;
  vint(46) = uh;
  vint(48) = sqpth;
  vint(47) = fem::sqrt(sqpth);
  vint(50) = taup * vint(2);
  vint(49) = fem::sqrt(fem::max(0.f, vint(50)));
  vint(52) = q2;
  vint(51) = fem::sqrt(q2);
  /// C
  /// C...Calculate parton structure functions.
  if (iset(isub) <= 0) {
    goto statement_145;
  }
  if (mint(43) >= 2) {
    q2sf = q2;
    if (iset(isub) == 3 || iset(isub) == 4) {
      q2sf = fem::pow2(pmas(23, 1));
      if (isub == 8 || isub == 76 || isub == 77) {
        q2sf = fem::pow2(pmas(24, 1));
      }
    }
    FEM_DO_SAFE(i, 3 - mint(41), mint(42)) {
      xsf = x(i);
      if (iset(isub) == 5) {
        xsf = x(i) / vint(142 + i);
      }
      pystfu(cmn, mint(10 + i), xsf, q2sf, xpq, i);
      FEM_DO_SAFE(kfl, -6, 6) { xsfx(i, kfl) = xpq(kfl); }
    }
  }
  /// C
  /// C...Calculate alpha_strong and K-factor.
  if (mstp(33) != 3) {
    as = ulalps(cmn, q2);
  }
  fack = 1.f;
  faca = 1.f;
  if (mstp(33) == 1) {
    fack = parp(31);
  } else if (mstp(33) == 2) {
    fack = parp(31);
    faca = parp(32) / parp(31);
  } else if (mstp(33) == 3) {
    q2as = parp(33) * q2;
    if (iset(isub) == 5 && mstp(82) >= 2) {
      q2as += paru(112) * parp(82);
    }
    as = ulalps(cmn, q2as);
  }
  radc = 1.f + as / paru(1);
  /// C
  /// C...Set flags for allowed reacting partons/leptons.
  FEM_DO_SAFE(i, 1, 2) {
    FEM_DO_SAFE(j, -40, 40) { kfac(i, j) = 0; }
    if (mint(40 + i) == 1) {
      kfac(i, mint(10 + i)) = 1;
    } else {
      FEM_DO_SAFE(j, -40, 40) {
        kfac(i, j) = kfin(i, j);
        if (fem::abs(j) > mstp(54) && j != 21) {
          kfac(i, j) = 0;
        }
        if (fem::abs(j) <= 6) {
          if (xsfx(i, j) < 1.e-10f) {
            kfac(i, j) = 0;
          }
        } else if (j == 21) {
          if (xsfx(i, 0) < 1.e-10f) {
            kfac(i, 21) = 0;
          }
        }
      }
    }
  }
  /// C
  /// C...Lower and upper limit for flavour loops.
  min1 = 0;
  max1 = 0;
  min2 = 0;
  max2 = 0;
  FEM_DO_SAFE(j, -20, 20) {
    if (kfac(1, -j) == 1) {
      min1 = -j;
    }
    if (kfac(1, j) == 1) {
      max1 = j;
    }
    if (kfac(2, -j) == 1) {
      min2 = -j;
    }
    if (kfac(2, j) == 1) {
      max2 = j;
    }
  }
  mina = fem::min(min1, min2);
  maxa = fem::max(max1, max2);
  /// C
  /// C...Common conversion factors (including Jacobian) for subprocesses.
  sqmz = fem::pow2(pmas(23, 1));
  gmmz = pmas(23, 1) * pmas(23, 2);
  sqmw = fem::pow2(pmas(24, 1));
  gmmw = pmas(24, 1) * pmas(24, 2);
  sqmh = fem::pow2(pmas(25, 1));
  gmmh = pmas(25, 1) * pmas(25, 2);
  sqmzp = fem::pow2(pmas(32, 1));
  gmmzp = pmas(32, 1) * pmas(32, 2);
  sqmhc = fem::pow2(pmas(37, 1));
  gmmhc = pmas(37, 1) * pmas(37, 2);
  sqmr = fem::pow2(pmas(40, 1));
  gmmr = pmas(40, 1) * pmas(40, 2);
  aem = paru(101);
  xw = paru(102);
  /// C
  /// C...Phase space integral in tau and y*.
  comfac = paru(1) * paru(5) / vint(2);
  if (mint(43) == 4) {
    comfac = comfac * fack;
  }
  if ((mint(43) >= 2 || iset(isub) == 3 || iset(isub) == 4) &&
      iset(isub) != 5) {
    atau0 = fem::log(taumax / taumin);
    atau1 = (taumax - taumin) / (taumax * taumin);
    h1 = coef(isub, 1) + (atau0 / atau1) * coef(isub, 2) / tau;
    if (mint(72) >= 1) {
      taur1 = vint(73);
      gamr1 = vint(74);
      atau2 = fem::log(taumax / taumin * (taumin + taur1) / (taumax + taur1)) /
              taur1;
      atau3 = (fem::atan((taumax - taur1) / gamr1) -
               fem::atan((taumin - taur1) / gamr1)) /
              gamr1;
      h1 += (atau0 / atau2) * coef(isub, 3) / (tau + taur1) +
            (atau0 / atau3) * coef(isub, 4) * tau /
                (fem::pow2((tau - taur1)) + fem::pow2(gamr1));
    }
    if (mint(72) == 2) {
      taur2 = vint(75);
      gamr2 = vint(76);
      atau4 = fem::log(taumax / taumin * (taumin + taur2) / (taumax + taur2)) /
              taur2;
      atau5 = (fem::atan((taumax - taur2) / gamr2) -
               fem::atan((taumin - taur2) / gamr2)) /
              gamr2;
      h1 += (atau0 / atau4) * coef(isub, 5) / (tau + taur2) +
            (atau0 / atau5) * coef(isub, 6) * tau /
                (fem::pow2((tau - taur2)) + fem::pow2(gamr2));
    }
    comfac = comfac * atau0 / (tau * h1);
  }
  if (mint(43) == 4 && iset(isub) != 5) {
    ayst0 = ystmax - ystmin;
    ayst1 = 0.5f * fem::pow2((ystmax - ystmin));
    ayst2 = ayst1;
    ayst3 = 2.f * (fem::atan(fem::exp(ystmax)) - fem::atan(fem::exp(ystmin)));
    h2 = (ayst0 / ayst1) * coef(isub, 7) * (yst - ystmin) +
         (ayst0 / ayst2) * coef(isub, 8) * (ystmax - yst) +
         (ayst0 / ayst3) * coef(isub, 9) / fem::cosh(yst);
    comfac = comfac * ayst0 / h2;
  }
  /// C
  /// C...2 -> 1 processes: reduction in angular part of phase space integral
  /// C...for case of decaying resonance.
  acth0 = ctnmax - ctnmin + ctpmax - ctpmin;
  /// Clin-4/2008 modified a la pythia6115.f to avoid invalid MDCY subcript#1,
  /// C     also break up compound IF statements:
  /// C      IF((ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3).AND.
  /// C     &MDCY(KFPR(ISUB,1),1).EQ.1) THEN
  /// C        IF(KFPR(ISUB,1).EQ.25.OR.KFPR(ISUB,1).EQ.37) THEN
  /// C          COMFAC=COMFAC*0.5*ACTH0
  /// C        ELSE
  /// C          COMFAC=COMFAC*0.125*(3.*ACTH0+CTNMAX**3-CTNMIN**3+
  /// C     &    CTPMAX**3-CTPMIN**3)
  /// C        ENDIF
  if (iset(isub) == 1 || iset(isub) == 3) {
    if (mdcy(lucomp(cmn, kfpr(isub, 1)), 1) == 1) {
      if (kfpr(isub, 1) == 25 || kfpr(isub, 1) == 37) {
        comfac = comfac * 0.5f * acth0;
      } else {
        comfac = comfac * 0.125f *
                 (3.f * acth0 + fem::pow3(ctnmax) - fem::pow3(ctnmin) +
                  fem::pow3(ctpmax) - fem::pow3(ctpmin));
      }
    }
    /// C
    /// C...2 -> 2 processes: angular part of phase space integral.
  } else if (iset(isub) == 2 || iset(isub) == 4) {
    acth1 = fem::log(
        (fem::max(rm34, rsqm - ctnmin) * fem::max(rm34, rsqm - ctpmin)) /
        (fem::max(rm34, rsqm - ctnmax) * fem::max(rm34, rsqm - ctpmax)));
    acth2 = fem::log(
        (fem::max(rm34, rsqm + ctnmax) * fem::max(rm34, rsqm + ctpmax)) /
        (fem::max(rm34, rsqm + ctnmin) * fem::max(rm34, rsqm + ctpmin)));
    acth3 = 1.f / fem::max(rm34, rsqm - ctnmax) -
            1.f / fem::max(rm34, rsqm - ctnmin) +
            1.f / fem::max(rm34, rsqm - ctpmax) -
            1.f / fem::max(rm34, rsqm - ctpmin);
    acth4 = 1.f / fem::max(rm34, rsqm + ctnmin) -
            1.f / fem::max(rm34, rsqm + ctnmax) +
            1.f / fem::max(rm34, rsqm + ctpmin) -
            1.f / fem::max(rm34, rsqm + ctpmax);
    h3 = coef(isub, 10) +
         (acth0 / acth1) * coef(isub, 11) / fem::max(rm34, rsqm - cth) +
         (acth0 / acth2) * coef(isub, 12) / fem::max(rm34, rsqm + cth) +
         (acth0 / acth3) * coef(isub, 13) /
             fem::pow2(fem::max(rm34, rsqm - cth)) +
         (acth0 / acth4) * coef(isub, 14) /
             fem::pow2(fem::max(rm34, rsqm + cth));
    comfac = comfac * acth0 * 0.5f * be34 / h3;
  }
  /// C
  /// C...2 -> 3, 4 processes: phace space integral in tau'.
  if (mint(43) >= 2 && (iset(isub) == 3 || iset(isub) == 4)) {
    ataup0 = fem::log(taupmx / taupmn);
    ataup1 =
        (fem::pow4((1.f - tau / taupmx)) - fem::pow4((1.f - tau / taupmn))) /
        (4.f * tau);
    h4 = coef(isub, 15) + ataup0 / ataup1 * coef(isub, 16) / taup *
                              fem::pow3((1.f - tau / taup));
    if (1.f - tau / taup > 1.e-4f) {
      fzw =
          (1.f + tau / taup) * fem::log(taup / tau) - 2.f * (1.f - tau / taup);
    } else {
      fzw = 1.f / 6.f * fem::pow3((1.f - tau / taup)) * tau / taup;
    }
    comfac = comfac * ataup0 * fzw / h4;
  }
  /// C
  /// C...Phase space integral for low-pT and multiple interactions.
  if (iset(isub) == 5) {
    comfac = paru(1) * paru(5) * fack * 0.5f * vint(2) / sh2;
    atau0 = fem::log(2.f * (1.f + fem::sqrt(1.f - xt2)) / xt2 - 1.f);
    atau1 = 2.f * fem::atan(1.f / xt2 - 1.f) / fem::sqrt(xt2);
    h1 = coef(isub, 1) + (atau0 / atau1) * coef(isub, 2) / fem::sqrt(tau);
    comfac = comfac * atau0 / h1;
    ayst0 = ystmax - ystmin;
    ayst1 = 0.5f * fem::pow2((ystmax - ystmin));
    ayst3 = 2.f * (fem::atan(fem::exp(ystmax)) - fem::atan(fem::exp(ystmin)));
    h2 = (ayst0 / ayst1) * coef(isub, 7) * (yst - ystmin) +
         (ayst0 / ayst1) * coef(isub, 8) * (ystmax - yst) +
         (ayst0 / ayst3) * coef(isub, 9) / fem::cosh(yst);
    comfac = comfac * ayst0 / h2;
    if (mstp(82) <= 1) {
      comfac = comfac * fem::pow2(xt2) * (1.f / vint(149) - 1.f);
    }
    /// C...For MSTP(82)>=2 an additional factor (xT2/(xT2+VINT(149))**2 is
    /// C...introduced to make cross-section finite for xT2 -> 0.
    if (mstp(82) >= 2) {
      comfac = comfac * fem::pow2(xt2) / (vint(149) * (1.f + vint(149)));
    }
  }
/// C
/// C...A: 2 -> 1, tree diagrams.
/// C
statement_145:
  if (isub <= 10) {
    if (isub == 1) {
      /// C...f + fb -> gamma*/Z0.
      mint(61) = 2;
      pywidt(cmn, 23, fem::sqrt(sh), wdtp, wdte);
      facz = comfac * fem::pow2(aem) * 4.f / 3.f;
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_150;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        facf = 1.f;
        if (fem::iabs(i) <= 10) {
          facf = faca / 3.f;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            facf * facz *
            (fem::pow2(ei) * vint(111) +
             ei * vi / (8.f * xw * (1.f - xw)) * sh * (sh - sqmz) /
                 (fem::pow2((sh - sqmz)) + fem::pow2(gmmz)) * vint(112) +
             (fem::pow2(vi) + fem::pow2(ai)) /
                 fem::pow2((16.f * xw * (1.f - xw))) * sh2 /
                 (fem::pow2((sh - sqmz)) + fem::pow2(gmmz)) * vint(114));
      statement_150:;
      }
      /// C
    } else if (isub == 2) {
      /// C...f + fb' -> W+/-.
      pywidt(cmn, 24, fem::sqrt(sh), wdtp, wdte);
      facw = comfac * fem::pow2((aem / xw)) * 1.f / 24 * sh2 /
             (fem::pow2((sh - sqmw)) + fem::pow2(gmmw));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_170;
        }
        ia = fem::iabs(i);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_160;
          }
          ja = fem::iabs(j);
          if (i * j > 0 || fem::mod(ia + ja, 2) == 0) {
            goto statement_160;
          }
          if ((ia <= 10 && ja > 10) || (ia > 10 && ja <= 10)) {
            goto statement_160;
          }
          kchw = (kchg(ia, 1) * fem::isign(1, i) +
                  kchg(ja, 1) * fem::isign(1, j)) /
                 3;
          facf = 1.f;
          if (ia <= 10) {
            facf = vckm((ia + 1) / 2, (ja + 1) / 2) * faca / 3.f;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) =
              facf * facw * (wdte(0, 1) + wdte(0, (5 - kchw) / 2) + wdte(0, 4));
        statement_160:;
        }
      statement_170:;
      }
      /// C
    } else if (isub == 3) {
      /// C...f + fb -> H0.
      pywidt(cmn, 25, fem::sqrt(sh), wdtp, wdte);
      fach = comfac * fem::pow2((aem / xw)) * 1.f / 48.f *
             fem::pow2((sh / sqmw)) * sh2 /
             (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) *
             (wdte(0, 1) + wdte(0, 2) + wdte(0, 4));
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_180;
        }
        rmq = fem::pow2(pmas(fem::iabs(i), 1)) / sh;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = fach * rmq * fem::sqrt(fem::max(0.f, 1.f - 4.f * rmq));
      statement_180:;
      }
      /// C
    } else if (isub == 4) {
      /// C...gamma + W+/- -> W+/-.
      /// C
    } else if (isub == 5) {
      /// C...Z0 + Z0 -> H0.
      pywidt(cmn, 25, fem::sqrt(sh), wdtp, wdte);
      fach = comfac * 1.f /
             (128.f * fem::pow2(paru(1)) * 16.f * fem::pow3((1.f - xw))) *
             fem::pow4((aem / xw)) * fem::pow2((sh / sqmw)) * sh2 /
             (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) *
             (wdte(0, 1) + wdte(0, 2) + wdte(0, 4));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_200;
        }
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_190;
          }
          ei = kchg(fem::iabs(i), 1) / 3.f;
          ai = fem::sign(1.f, ei);
          vi = ai - 4.f * ei * xw;
          ej = kchg(fem::iabs(j), 1) / 3.f;
          aj = fem::sign(1.f, ej);
          vj = aj - 4.f * ej * xw;
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * (fem::pow2(vi) + fem::pow2(ai)) *
                       (fem::pow2(vj) + fem::pow2(aj));
        statement_190:;
        }
      statement_200:;
      }
      /// C
    } else if (isub == 6) {
      /// C...Z0 + W+/- -> W+/-.
      /// C
    } else if (isub == 7) {
      /// C...W+ + W- -> Z0.
      /// C
    } else if (isub == 8) {
      /// C...W+ + W- -> H0.
      pywidt(cmn, 25, fem::sqrt(sh), wdtp, wdte);
      fach = comfac * 1.f / (128 * fem::pow2(paru(1))) * fem::pow4((aem / xw)) *
             fem::pow2((sh / sqmw)) * sh2 /
             (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) *
             (wdte(0, 1) + wdte(0, 2) + wdte(0, 4));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_220;
        }
        ei = fem::sign(1.f, fem::ffloat(i)) * kchg(fem::iabs(i), 1);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_210;
          }
          ej = fem::sign(1.f, fem::ffloat(j)) * kchg(fem::iabs(j), 1);
          if (ei * ej > 0.f) {
            goto statement_210;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * vint(180 + i) * vint(180 + j);
        statement_210:;
        }
      statement_220:;
      }
    }
    /// C
    /// C...B: 2 -> 2, tree diagrams.
    /// C
  } else if (isub <= 20) {
    if (isub == 11) {
      /// C...f + f' -> f + f'.
      facqq1 = comfac * fem::pow2(as) * 4.f / 9.f * (sh2 + uh2) / th2;
      facqqb =
          comfac * fem::pow2(as) * 4.f / 9.f *
          ((sh2 + uh2) / th2 * faca - mstp(34) * 2.f / 3.f * uh2 / (sh * th));
      facqq2 = comfac * fem::pow2(as) * 4.f / 9.f *
               ((sh2 + th2) / uh2 - mstp(34) * 2.f / 3.f * sh2 / (th * uh));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_240;
        }
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_230;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = facqq1;
          if (i == -j) {
            sigh(nchn) = facqqb;
          }
          if (i == j) {
            sigh(nchn) = 0.5f * sigh(nchn);
            nchn++;
            isig(nchn, 1) = i;
            isig(nchn, 2) = j;
            isig(nchn, 3) = 2;
            sigh(nchn) = 0.5f * facqq2;
          }
        statement_230:;
        }
      statement_240:;
      }
      /// C
    } else if (isub == 12) {
      /// C...f + fb -> f' + fb' (q + qb -> q' + qb' only).
      pywidt(cmn, 21, fem::sqrt(sh), wdtp, wdte);
      facqqb = comfac * fem::pow2(as) * 4.f / 9.f * (th2 + uh2) / sh2 *
               (wdte(0, 1) + wdte(0, 2) + wdte(0, 3) + wdte(0, 4));
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_250;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facqqb;
      statement_250:;
      }
      /// C
    } else if (isub == 13) {
      /// C...f + fb -> g + g (q + qb -> g + g only).
      facgg1 = comfac * fem::pow2(as) * 32.f / 27.f *
               (uh / th - (2.f + mstp(34) * 1.f / 4.f) * uh2 / sh2);
      facgg2 = comfac * fem::pow2(as) * 32.f / 27.f *
               (th / uh - (2.f + mstp(34) * 1.f / 4.f) * th2 / sh2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_260;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = 0.5f * facgg1;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 2;
        sigh(nchn) = 0.5f * facgg2;
      statement_260:;
      }
      /// C
    } else if (isub == 14) {
      /// C...f + fb -> g + gamma (q + qb -> g + gamma only).
      facgg = comfac * as * aem * 8.f / 9.f * (th2 + uh2) / (th * uh);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_270;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facgg * fem::pow2(ei);
      statement_270:;
      }
      /// C
    } else if (isub == 15) {
      /// C...f + fb -> g + Z0 (q + qb -> g + Z0 only).
      faczg = comfac * as * aem / (xw * (1.f - xw)) * 1.f / 18.f *
              (th2 + uh2 + 2.f * sqm4 * sh) / (th * uh);
      faczg = faczg * wids(23, 2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_280;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = faczg * (fem::pow2(vi) + fem::pow2(ai));
      statement_280:;
      }
      /// C
    } else if (isub == 16) {
      /// C...f + fb' -> g + W+/- (q + qb' -> g + W+/- only).
      facwg = comfac * as * aem / xw * 2.f / 9.f *
              (th2 + uh2 + 2.f * sqm4 * sh) / (th * uh);
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_300;
        }
        ia = fem::iabs(i);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_290;
          }
          ja = fem::iabs(j);
          if (i * j > 0 || fem::mod(ia + ja, 2) == 0) {
            goto statement_290;
          }
          kchw = (kchg(ia, 1) * fem::isign(1, i) +
                  kchg(ja, 1) * fem::isign(1, j)) /
                 3;
          fckm = 1.f;
          if (mint(43) == 4) {
            fckm = vckm((ia + 1) / 2, (ja + 1) / 2);
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = facwg * fckm * wids(24, (5 - kchw) / 2);
        statement_290:;
        }
      statement_300:;
      }
      /// C
    } else if (isub == 17) {
      /// C...f + fb -> g + H0 (q + qb -> g + H0 only).
      /// C
    } else if (isub == 18) {
      /// C...f + fb -> gamma + gamma.
      facgg =
          comfac * faca * fem::pow2(aem) * 1.f / 3.f * (th2 + uh2) / (th * uh);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_310;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facgg * fem::pow4(ei);
      statement_310:;
      }
      /// C
    } else if (isub == 19) {
      /// C...f + fb -> gamma + Z0.
      facgz = comfac * faca * fem::pow2(aem) / (xw * (1.f - xw)) * 1.f / 24.f *
              (th2 + uh2 + 2.f * sqm4 * sh) / (th * uh);
      facgz = facgz * wids(23, 2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_320;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facgz * fem::pow2(ei) * (fem::pow2(vi) + fem::pow2(ai));
      statement_320:;
      }
      /// C
    } else if (isub == 20) {
      /// C...f + fb' -> gamma + W+/-.
      facgw = comfac * faca * fem::pow2(aem) / xw * 1.f / 6.f *
              fem::pow2(((2.f * uh - th) / (3.f * (sh - sqm4)))) *
              (th2 + uh2 + 2.f * sqm4 * sh) / (th * uh);
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_340;
        }
        ia = fem::iabs(i);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_330;
          }
          ja = fem::iabs(j);
          if (i * j > 0 || fem::mod(ia + ja, 2) == 0) {
            goto statement_330;
          }
          kchw = (kchg(ia, 1) * fem::isign(1, i) +
                  kchg(ja, 1) * fem::isign(1, j)) /
                 3;
          fckm = 1.f;
          if (mint(43) == 4) {
            fckm = vckm((ia + 1) / 2, (ja + 1) / 2);
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = facgw * fckm * wids(24, (5 - kchw) / 2);
        statement_330:;
        }
      statement_340:;
      }
    }
    /// C
  } else if (isub <= 30) {
    if (isub == 21) {
      /// C...f + fb -> gamma + H0.
      /// C
    } else if (isub == 22) {
      /// C...f + fb -> Z0 + Z0.
      faczz = comfac * faca * fem::pow2((aem / (xw * (1.f - xw)))) * 1.f /
              768.f *
              (uh / th + th / uh + 2.f * (sqm3 + sqm4) * sh / (th * uh) -
               sqm3 * sqm4 * (1.f / th2 + 1.f / uh2));
      faczz = faczz * wids(23, 1);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_350;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            faczz * (fem::pow4(vi) + 6.f * fem::pow2(vi) * fem::pow2(ai) +
                     fem::pow4(ai));
      statement_350:;
      }
      /// C
    } else if (isub == 23) {
      /// C...f + fb' -> Z0 + W+/-.
      faczw = comfac * faca * fem::pow2((aem / xw)) * 1.f / 6.f;
      faczw = faczw * wids(23, 2);
      thuh = fem::max(th * uh - sqm3 * sqm4, sh * fem::pow2(ckin(3)));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_370;
        }
        ia = fem::iabs(i);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_360;
          }
          ja = fem::iabs(j);
          if (i * j > 0 || fem::mod(ia + ja, 2) == 0) {
            goto statement_360;
          }
          kchw = (kchg(ia, 1) * fem::isign(1, i) +
                  kchg(ja, 1) * fem::isign(1, j)) /
                 3;
          ei = kchg(ia, 1) / 3.f;
          ai = fem::sign(1.f, ei);
          vi = ai - 4.f * ei * xw;
          ej = kchg(ja, 1) / 3.f;
          aj = fem::sign(1.f, ej);
          vj = aj - 4.f * ej * xw;
          if (vi + ai > 0) {
            visav = vi;
            aisav = ai;
            vi = vj;
            ai = aj;
            vj = visav;
            aj = aisav;
          }
          fckm = 1.f;
          if (mint(43) == 4) {
            fckm = vckm((ia + 1) / 2, (ja + 1) / 2);
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) =
              faczw * fckm *
              (1.f / fem::pow2((sh - sqmw)) *
                   ((9.f - 8.f * xw) / 4.f * thuh +
                    (8.f * xw - 6.f) / 4.f * sh * (sqm3 + sqm4)) +
               (thuh - sh * (sqm3 + sqm4)) / (2.f * (sh - sqmw)) *
                   ((vj + aj) / th - (vi + ai) / uh) +
               thuh / (16.f * (1.f - xw)) *
                   (fem::pow2((vj + aj)) / th2 + fem::pow2((vi + ai)) / uh2) +
               sh * (sqm3 + sqm4) / (8.f * (1.f - xw)) * (vi + ai) * (vj + aj) /
                   (th * uh)) *
              wids(24, (5 - kchw) / 2);
        statement_360:;
        }
      statement_370:;
      }
      /// C
    } else if (isub == 24) {
      /// C...f + fb -> Z0 + H0.
      thuh = fem::max(th * uh - sqm3 * sqm4, sh * fem::pow2(ckin(3)));
      fachz = comfac * faca * fem::pow2((aem / (xw * (1.f - xw)))) * 1.f /
              96.f * (thuh + 2.f * sh * sqmz) / fem::pow2((sh - sqmz));
      fachz = fachz * wids(23, 2) * wids(25, 2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_380;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = fachz * (fem::pow2(vi) + fem::pow2(ai));
      statement_380:;
      }
      /// C
    } else if (isub == 25) {
      /// C...f + fb -> W+ + W-.
      facww = comfac * faca * fem::pow2((aem / xw)) * 1.f / 12.f;
      facww = facww * wids(24, 1);
      thuh = fem::max(th * uh - sqm3 * sqm4, sh * fem::pow2(ckin(3)));
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_390;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        dsigww = thuh / sh2 *
                     (3.f -
                      (sh - 3.f * (sqm3 + sqm4)) / (sh - sqmz) * (vi + ai) /
                          (2.f * ai * (1.f - xw)) +
                      fem::pow2((sh / (sh - sqmz))) *
                          (1.f - 2.f * (sqm3 + sqm4) / sh +
                           12.f * sqm3 * sqm4 / sh2) *
                          (fem::pow2(vi) + fem::pow2(ai)) /
                          (8.f * fem::pow2((1.f - xw)))) -
                 2.f * sqmz / (sh - sqmz) * (vi + ai) / ai +
                 sqmz * sh / fem::pow2((sh - sqmz)) *
                     (1.f - 2.f * (sqm3 + sqm4) / sh) *
                     (fem::pow2(vi) + fem::pow2(ai)) / (2.f * (1.f - xw));
        if (kchg(fem::iabs(i), 1) < 0) {
          dsigww += 2.f * (1.f + sqmz / (sh - sqmz) * (vi + ai) / (2.f * ai)) *
                        (thuh / (sh * th) - (sqm3 + sqm4) / th) +
                    thuh / th2;
        } else {
          dsigww += 2.f * (1.f + sqmz / (sh - sqmz) * (vi + ai) / (2.f * ai)) *
                        (thuh / (sh * uh) - (sqm3 + sqm4) / uh) +
                    thuh / uh2;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facww * dsigww;
      statement_390:;
      }
      /// C
    } else if (isub == 26) {
      /// C...f + fb' -> W+/- + H0.
      thuh = fem::max(th * uh - sqm3 * sqm4, sh * fem::pow2(ckin(3)));
      fachw = comfac * faca * fem::pow2((aem / xw)) * 1.f / 24.f *
              (thuh + 2.f * sh * sqmw) / fem::pow2((sh - sqmw));
      fachw = fachw * wids(25, 2);
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_410;
        }
        ia = fem::iabs(i);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(1, j) == 0) {
            goto statement_400;
          }
          ja = fem::iabs(j);
          if (i * j > 0 || fem::mod(ia + ja, 2) == 0) {
            goto statement_400;
          }
          kchw = (kchg(ia, 1) * fem::isign(1, i) +
                  kchg(ja, 1) * fem::isign(1, j)) /
                 3;
          fckm = 1.f;
          if (mint(43) == 4) {
            fckm = vckm((ia + 1) / 2, (ja + 1) / 2);
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fachw * fckm * wids(24, (5 - kchw) / 2);
        statement_400:;
        }
      statement_410:;
      }
      /// C
    } else if (isub == 27) {
      /// C...f + fb -> H0 + H0.
      /// C
    } else if (isub == 28) {
      /// C...f + g -> f + g (q + g -> q + g only).
      facqg1 = comfac * fem::pow2(as) * 4.f / 9.f *
               ((2.f + mstp(34) * 1.f / 4.f) * uh2 / th2 - uh / sh) * faca;
      facqg2 = comfac * fem::pow2(as) * 4.f / 9.f *
               ((2.f + mstp(34) * 1.f / 4.f) * sh2 / th2 - sh / uh);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0) {
          goto statement_430;
        }
        FEM_DO_SAFE(isde, 1, 2) {
          if (isde == 1 && kfac(1, i) * kfac(2, 21) == 0) {
            goto statement_420;
          }
          if (isde == 2 && kfac(1, 21) * kfac(2, i) == 0) {
            goto statement_420;
          }
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 1;
          sigh(nchn) = facqg1;
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 2;
          sigh(nchn) = facqg2;
        statement_420:;
        }
      statement_430:;
      }
      /// C
    } else if (isub == 29) {
      /// C...f + g -> f + gamma (q + g -> q + gamma only).
      fgq = comfac * faca * as * aem * 1.f / 3.f * (sh2 + uh2) / (-sh * uh);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0) {
          goto statement_450;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        facgq = fgq * fem::pow2(ei);
        FEM_DO_SAFE(isde, 1, 2) {
          if (isde == 1 && kfac(1, i) * kfac(2, 21) == 0) {
            goto statement_440;
          }
          if (isde == 2 && kfac(1, 21) * kfac(2, i) == 0) {
            goto statement_440;
          }
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 1;
          sigh(nchn) = facgq;
        statement_440:;
        }
      statement_450:;
      }
      /// C
    } else if (isub == 30) {
      /// C...f + g -> f + Z0 (q + g -> q + Z0 only).
      fzq = comfac * faca * as * aem / (xw * (1.f - xw)) * 1.f / 48.f *
            (sh2 + uh2 + 2.f * sqm4 * th) / (-sh * uh);
      fzq = fzq * wids(23, 2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0) {
          goto statement_470;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        faczq = fzq * (fem::pow2(vi) + fem::pow2(ai));
        FEM_DO_SAFE(isde, 1, 2) {
          if (isde == 1 && kfac(1, i) * kfac(2, 21) == 0) {
            goto statement_460;
          }
          if (isde == 2 && kfac(1, 21) * kfac(2, i) == 0) {
            goto statement_460;
          }
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 1;
          sigh(nchn) = faczq;
        statement_460:;
        }
      statement_470:;
      }
    }
    /// C
  } else if (isub <= 40) {
    if (isub == 31) {
      /// C...f + g -> f' + W+/- (q + g -> q' + W+/- only).
      facwq = comfac * faca * as * aem / xw * 1.f / 12.f *
              (sh2 + uh2 + 2.f * sqm4 * th) / (-sh * uh);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0) {
          goto statement_490;
        }
        ia = fem::iabs(i);
        kchw = fem::isign(1, kchg(ia, 1) * fem::isign(1, i));
        FEM_DO_SAFE(isde, 1, 2) {
          if (isde == 1 && kfac(1, i) * kfac(2, 21) == 0) {
            goto statement_480;
          }
          if (isde == 2 && kfac(1, 21) * kfac(2, i) == 0) {
            goto statement_480;
          }
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 1;
          sigh(nchn) = facwq * vint(180 + i) * wids(24, (5 - kchw) / 2);
        statement_480:;
        }
      statement_490:;
      }
      /// C
    } else if (isub == 32) {
      /// C...f + g -> f + H0 (q + g -> q + H0 only).
      /// C
    } else if (isub == 33) {
      /// C...f + gamma -> f + g (q + gamma -> q + g only).
      /// C
    } else if (isub == 34) {
      /// C...f + gamma -> f + gamma.
      /// C
    } else if (isub == 35) {
      /// C...f + gamma -> f + Z0.
      /// C
    } else if (isub == 36) {
      /// C...f + gamma -> f' + W+/-.
      /// C
    } else if (isub == 37) {
      /// C...f + gamma -> f + H0.
      /// C
    } else if (isub == 38) {
      /// C...f + Z0 -> f + g (q + Z0 -> q + g only).
      /// C
    } else if (isub == 39) {
      /// C...f + Z0 -> f + gamma.
      /// C
    } else if (isub == 40) {
      /// C...f + Z0 -> f + Z0.
    }
    /// C
  } else if (isub <= 50) {
    if (isub == 41) {
      /// C...f + Z0 -> f' + W+/-.
      /// C
    } else if (isub == 42) {
      /// C...f + Z0 -> f + H0.
      /// C
    } else if (isub == 43) {
      /// C...f + W+/- -> f' + g (q + W+/- -> q' + g only).
      /// C
    } else if (isub == 44) {
      /// C...f + W+/- -> f' + gamma.
      /// C
    } else if (isub == 45) {
      /// C...f + W+/- -> f' + Z0.
      /// C
    } else if (isub == 46) {
      /// C...f + W+/- -> f' + W+/-.
      /// C
    } else if (isub == 47) {
      /// C...f + W+/- -> f' + H0.
      /// C
    } else if (isub == 48) {
      /// C...f + H0 -> f + g (q + H0 -> q + g only).
      /// C
    } else if (isub == 49) {
      /// C...f + H0 -> f + gamma.
      /// C
    } else if (isub == 50) {
      /// C...f + H0 -> f + Z0.
    }
    /// C
  } else if (isub <= 60) {
    if (isub == 51) {
      /// C...f + H0 -> f' + W+/-.
      /// C
    } else if (isub == 52) {
      /// C...f + H0 -> f + H0.
      /// C
    } else if (isub == 53) {
      /// C...g + g -> f + fb (g + g -> q + qb only).
      pywidt(cmn, 21, fem::sqrt(sh), wdtp, wdte);
      facqq1 = comfac * fem::pow2(as) * 1.f / 6.f *
               (uh / th - (2.f + mstp(34) * 1.f / 4.f) * uh2 / sh2) *
               (wdte(0, 1) + wdte(0, 2) + wdte(0, 3) + wdte(0, 4)) * faca;
      facqq2 = comfac * fem::pow2(as) * 1.f / 6.f *
               (th / uh - (2.f + mstp(34) * 1.f / 4.f) * th2 / sh2) *
               (wdte(0, 1) + wdte(0, 2) + wdte(0, 3) + wdte(0, 4)) * faca;
      if (kfac(1, 21) * kfac(2, 21) == 0) {
        goto statement_500;
      }
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 1;
      sigh(nchn) = facqq1;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 2;
      sigh(nchn) = facqq2;
    statement_500:;
      /// C
    } else if (isub == 54) {
      /// C...g + gamma -> f + fb (g + gamma -> q + qb only).
      /// C
    } else if (isub == 55) {
      /// C...g + gamma -> f + fb (g + gamma -> q + qb only).
      /// C
    } else if (isub == 56) {
      /// C...g + gamma -> f + fb (g + gamma -> q + qb only).
      /// C
    } else if (isub == 57) {
      /// C...g + gamma -> f + fb (g + gamma -> q + qb only).
      /// C
    } else if (isub == 58) {
      /// C...gamma + gamma -> f + fb.
      /// C
    } else if (isub == 59) {
      /// C...gamma + Z0 -> f + fb.
      /// C
    } else if (isub == 60) {
      /// C...gamma + W+/- -> f + fb'.
    }
    /// C
  } else if (isub <= 70) {
    if (isub == 61) {
      /// C...gamma + H0 -> f + fb.
      /// C
    } else if (isub == 62) {
      /// C...Z0 + Z0 -> f + fb.
      /// C
    } else if (isub == 63) {
      /// C...Z0 + W+/- -> f + fb'.
      /// C
    } else if (isub == 64) {
      /// C...Z0 + H0 -> f + fb.
      /// C
    } else if (isub == 65) {
      /// C...W+ + W- -> f + fb.
      /// C
    } else if (isub == 66) {
      /// C...W+/- + H0 -> f + fb'.
      /// C
    } else if (isub == 67) {
      /// C...H0 + H0 -> f + fb.
      /// C
    } else if (isub == 68) {
      /// C...g + g -> g + g.
      facgg1 = comfac * fem::pow2(as) * 9.f / 4.f *
               (sh2 / th2 + 2.f * sh / th + 3.f + 2.f * th / sh + th2 / sh2) *
               faca;
      facgg2 = comfac * fem::pow2(as) * 9.f / 4.f *
               (uh2 / sh2 + 2.f * uh / sh + 3.f + 2.f * sh / uh + sh2 / uh2) *
               faca;
      facgg3 = comfac * fem::pow2(as) * 9.f / 4.f *
               (th2 / uh2 + 2.f * th / uh + 3 + 2.f * uh / th + uh2 / th2);
      if (kfac(1, 21) * kfac(2, 21) == 0) {
        goto statement_510;
      }
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 1;
      sigh(nchn) = 0.5f * facgg1;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 2;
      sigh(nchn) = 0.5f * facgg2;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 3;
      sigh(nchn) = 0.5f * facgg3;
    statement_510:;
      /// C
    } else if (isub == 69) {
      /// C...gamma + gamma -> W+ + W-.
      /// C
    } else if (isub == 70) {
      /// C...gamma + W+/- -> gamma + W+/-.
    }
    /// C
  } else if (isub <= 80) {
    if (isub == 71) {
      /// C...Z0 + Z0 -> Z0 + Z0.
      be2 = 1.f - 4.f * sqmz / sh;
      th = -0.5f * sh * be2 * (1.f - cth);
      uh = -0.5f * sh * be2 * (1.f + cth);
      shang = 1.f / (1.f - xw) * sqmw / sqmz * fem::pow2((1.f + be2));
      ashre = (sh - sqmh) / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      ashim = -gmmh / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      thang = 1.f / (1.f - xw) * sqmw / sqmz * fem::pow2((be2 - cth));
      athre = (th - sqmh) / (fem::pow2((th - sqmh)) + fem::pow2(gmmh)) * thang;
      athim = -gmmh / (fem::pow2((th - sqmh)) + fem::pow2(gmmh)) * thang;
      uhang = 1.f / (1.f - xw) * sqmw / sqmz * fem::pow2((be2 + cth));
      auhre = (uh - sqmh) / (fem::pow2((uh - sqmh)) + fem::pow2(gmmh)) * uhang;
      auhim = -gmmh / (fem::pow2((uh - sqmh)) + fem::pow2(gmmh)) * uhang;
      fach = 0.5f * comfac * 1.f /
             (4096.f * fem::pow2(paru(1)) * 16.f * fem::pow2((1.f - xw))) *
             fem::pow4((aem / xw)) * fem::pow2((sh / sqmw)) *
             (fem::pow2((ashre + athre + auhre)) +
              fem::pow2((ashim + athim + auhim))) *
             sqmz / sqmw;
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_530;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        avi = fem::pow2(ai) + fem::pow2(vi);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_520;
          }
          ej = kchg(fem::iabs(j), 1) / 3.f;
          aj = fem::sign(1.f, ej);
          vj = aj - 4.f * ej * xw;
          avj = fem::pow2(aj) + fem::pow2(vj);
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * avi * avj;
        statement_520:;
        }
      statement_530:;
      }
      /// C
    } else if (isub == 72) {
      /// C...Z0 + Z0 -> W+ + W-.
      be2 = fem::sqrt((1.f - 4.f * sqmw / sh) * (1.f - 4.f * sqmz / sh));
      cth2 = fem::pow2(cth);
      th = -0.5f * sh * (1.f - 2.f * (sqmw + sqmz) / sh - be2 * cth);
      uh = -0.5f * sh * (1.f - 2.f * (sqmw + sqmz) / sh + be2 * cth);
      shang = 4.f * fem::sqrt(sqmw / (sqmz * (1.f - xw))) *
              (1.f - 2.f * sqmw / sh) * (1.f - 2.f * sqmz / sh);
      ashre = (sh - sqmh) / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      ashim = -gmmh / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      atwre = (1.f - xw) / sqmz * sh / (th - sqmw) *
              (fem::pow2((cth - be2)) *
                   (3.f / 2.f + be2 / 2.f * cth - (sqmw + sqmz) / sh +
                    fem::pow2((sqmw - sqmz)) / (sh * sqmw)) +
               4.f * ((sqmw + sqmz) / sh * (1.f - 3.f * cth2) +
                      8.f * sqmw * sqmz / sh2 * (2.f * cth2 - 1.f) +
                      4.f * (fem::pow2(sqmw) + fem::pow2(sqmz)) / sh2 * cth2 +
                      2.f * (sqmw + sqmz) / sh * be2 * cth));
      atwim = 0.f;
      auwre = (1.f - xw) / sqmz * sh / (uh - sqmw) *
              (fem::pow2((cth + be2)) *
                   (3.f / 2.f - be2 / 2.f * cth - (sqmw + sqmz) / sh +
                    fem::pow2((sqmw - sqmz)) / (sh * sqmw)) +
               4.f * ((sqmw + sqmz) / sh * (1.f - 3.f * cth2) +
                      8.f * sqmw * sqmz / sh2 * (2.f * cth2 - 1.f) +
                      4.f * (fem::pow2(sqmw) + fem::pow2(sqmz)) / sh2 * cth2 -
                      2.f * (sqmw + sqmz) / sh * be2 * cth));
      auwim = 0.f;
      a4re = 2.f * (1.f - xw) / sqmz * (3.f - cth2 - 4.f * (sqmw + sqmz) / sh);
      a4im = 0.f;
      fach = comfac * 1.f /
             (4096.f * fem::pow2(paru(1)) * 16.f * fem::pow2((1.f - xw))) *
             fem::pow4((aem / xw)) * fem::pow2((sh / sqmw)) *
             (fem::pow2((ashre + atwre + auwre + a4re)) +
              fem::pow2((ashim + atwim + auwim + a4im))) *
             sqmz / sqmw;
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_550;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        avi = fem::pow2(ai) + fem::pow2(vi);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_540;
          }
          ej = kchg(fem::iabs(j), 1) / 3.f;
          aj = fem::sign(1.f, ej);
          vj = aj - 4.f * ej * xw;
          avj = fem::pow2(aj) + fem::pow2(vj);
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * avi * avj;
        statement_540:;
        }
      statement_550:;
      }
      /// C
    } else if (isub == 73) {
      /// C...Z0 + W+/- -> Z0 + W+/-.
      be2 = 1.f - 2.f * (sqmz + sqmw) / sh + fem::pow2(((sqmz - sqmw) / sh));
      ep1 = 1.f + (sqmz - sqmw) / sh;
      ep2 = 1.f - (sqmz - sqmw) / sh;
      th = -0.5f * sh * be2 * (1.f - cth);
      uh = fem::pow2((sqmz - sqmw)) / sh - 0.5f * sh * be2 * (1.f + cth);
      thang = fem::sqrt(sqmw / (sqmz * (1.f - xw))) * (be2 - ep1 * cth) *
              (be2 - ep2 * cth);
      athre = (th - sqmh) / (fem::pow2((th - sqmh)) + fem::pow2(gmmh)) * thang;
      athim = -gmmh / (fem::pow2((th - sqmh)) + fem::pow2(gmmh)) * thang;
      aswre = (1.f - xw) / sqmz * sh / (sh - sqmw) *
              (-be2 * fem::pow4((ep1 + ep2)) * cth +
               1.f / 4.f * fem::pow2((be2 + ep1 * ep2)) *
                   (fem::pow2((ep1 - ep2)) - 4.f * be2 * cth) +
               2.f * be2 * (be2 + ep1 * ep2) * fem::pow2((ep1 + ep2)) * cth -
               1.f / 16.f * sh / sqmw *
                   fem::pow2((fem::pow2(ep1) - fem::pow2(ep2))) *
                   fem::pow2((be2 + ep1 * ep2)));
      aswim = 0.f;
      auwre =
          (1.f - xw) / sqmz * sh / (uh - sqmw) *
          (-be2 * (ep2 + ep1 * cth) * (ep1 + ep2 * cth) * (be2 + ep1 * ep2) +
           be2 * (ep2 + ep1 * cth) * (be2 + ep1 * ep2 * cth) *
               (2.f * ep2 - ep2 * cth + ep1) -
           be2 * fem::pow2((ep2 + ep1 * cth)) * (be2 - fem::pow2(ep2) * cth) -
           1.f / 8.f * fem::pow2((be2 + ep1 * ep2 * cth)) *
               (fem::pow2((ep1 + ep2)) + 2.f * be2 * (1.f - cth)) +
           1.f / 32.f * sh / sqmw * fem::pow2((be2 + ep1 * ep2 * cth)) *
               fem::pow2((fem::pow2(ep1) - fem::pow2(ep2))) -
           be2 * (ep1 + ep2 * cth) * (ep2 + ep1 * cth) * (be2 + ep1 * ep2) +
           be2 * (ep1 + ep2 * cth) * (be2 + ep1 * ep2 * cth) *
               (2.f * ep1 - ep1 * cth + ep2) -
           be2 * fem::pow2((ep1 + ep2 * cth)) * (be2 - fem::pow2(ep1) * cth) -
           1.f / 8.f * fem::pow2((be2 + ep1 * ep2 * cth)) *
               (fem::pow2((ep1 + ep2)) + 2.f * be2 * (1.f - cth)) +
           1.f / 32.f * sh / sqmw * fem::pow2((be2 + ep1 * ep2 * cth)) *
               fem::pow2((fem::pow2(ep1) - fem::pow2(ep2))));
      auwim = 0.f;
      a4re = (1.f - xw) / sqmz *
             (fem::pow2(ep1) * fem::pow2(ep2) * (fem::pow2(cth) - 1.f) -
              2.f * be2 * (fem::pow2(ep1) + fem::pow2(ep2) + ep1 * ep2) * cth -
              2.f * be2 * ep1 * ep2);
      a4im = 0.f;
      fach = comfac * 1.f / (4096.f * fem::pow2(paru(1)) * 4.f * (1.f - xw)) *
             fem::pow4((aem / xw)) * fem::pow2((sh / sqmw)) *
             (fem::pow2((athre + aswre + auwre + a4re)) +
              fem::pow2((athim + aswim + auwim + a4im))) *
             fem::sqrt(sqmz / sqmw);
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_570;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        avi = fem::pow2(ai) + fem::pow2(vi);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_560;
          }
          ej = kchg(fem::iabs(j), 1) / 3.f;
          aj = fem::sign(1.f, ej);
          vj = ai - 4.f * ej * xw;
          avj = fem::pow2(aj) + fem::pow2(vj);
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * (avi * vint(180 + j) + vint(180 + i) * avj);
        statement_560:;
        }
      statement_570:;
      }
      /// C
    } else if (isub == 75) {
      /// C...W+ + W- -> gamma + gamma.
      /// C
    } else if (isub == 76) {
      /// C...W+ + W- -> Z0 + Z0.
      be2 = fem::sqrt((1.f - 4.f * sqmw / sh) * (1.f - 4.f * sqmz / sh));
      cth2 = fem::pow2(cth);
      th = -0.5f * sh * (1.f - 2.f * (sqmw + sqmz) / sh - be2 * cth);
      uh = -0.5f * sh * (1.f - 2.f * (sqmw + sqmz) / sh + be2 * cth);
      shang = 4.f * fem::sqrt(sqmw / (sqmz * (1.f - xw))) *
              (1.f - 2.f * sqmw / sh) * (1.f - 2.f * sqmz / sh);
      ashre = (sh - sqmh) / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      ashim = -gmmh / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      atwre = (1.f - xw) / sqmz * sh / (th - sqmw) *
              (fem::pow2((cth - be2)) *
                   (3.f / 2.f + be2 / 2.f * cth - (sqmw + sqmz) / sh +
                    fem::pow2((sqmw - sqmz)) / (sh * sqmw)) +
               4.f * ((sqmw + sqmz) / sh * (1.f - 3.f * cth2) +
                      8.f * sqmw * sqmz / sh2 * (2.f * cth2 - 1.f) +
                      4.f * (fem::pow2(sqmw) + fem::pow2(sqmz)) / sh2 * cth2 +
                      2.f * (sqmw + sqmz) / sh * be2 * cth));
      atwim = 0.f;
      auwre = (1.f - xw) / sqmz * sh / (uh - sqmw) *
              (fem::pow2((cth + be2)) *
                   (3.f / 2.f - be2 / 2.f * cth - (sqmw + sqmz) / sh +
                    fem::pow2((sqmw - sqmz)) / (sh * sqmw)) +
               4.f * ((sqmw + sqmz) / sh * (1.f - 3.f * cth2) +
                      8.f * sqmw * sqmz / sh2 * (2.f * cth2 - 1.f) +
                      4.f * (fem::pow2(sqmw) + fem::pow2(sqmz)) / sh2 * cth2 -
                      2.f * (sqmw + sqmz) / sh * be2 * cth));
      auwim = 0.f;
      a4re = 2.f * (1.f - xw) / sqmz * (3.f - cth2 - 4.f * (sqmw + sqmz) / sh);
      a4im = 0.f;
      fach = 0.5f * comfac * 1.f / (4096.f * fem::pow2(paru(1))) *
             fem::pow4((aem / xw)) * fem::pow2((sh / sqmw)) *
             (fem::pow2((ashre + atwre + auwre + a4re)) +
              fem::pow2((ashim + atwim + auwim + a4im)));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_590;
        }
        ei = fem::sign(1.f, fem::ffloat(i)) * kchg(fem::iabs(i), 1);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_580;
          }
          ej = fem::sign(1.f, fem::ffloat(j)) * kchg(fem::iabs(j), 1);
          if (ei * ej > 0.f) {
            goto statement_580;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * vint(180 + i) * vint(180 + j);
        statement_580:;
        }
      statement_590:;
      }
      /// C
    } else if (isub == 77) {
      /// C...W+/- + W+/- -> W+/- + W+/-.
      be2 = 1.f - 4.f * sqmw / sh;
      be4 = fem::pow2(be2);
      cth2 = fem::pow2(cth);
      cth3 = fem::pow3(cth);
      th = -0.5f * sh * be2 * (1.f - cth);
      uh = -0.5f * sh * be2 * (1.f + cth);
      shang = fem::pow2((1.f + be2));
      ashre = (sh - sqmh) / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      ashim = -gmmh / (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) * shang;
      thang = fem::pow2((be2 - cth));
      athre = (th - sqmh) / (fem::pow2((th - sqmh)) + fem::pow2(gmmh)) * thang;
      athim = -gmmh / (fem::pow2((th - sqmh)) + fem::pow2(gmmh)) * thang;
      sgzang = 1.f / sqmw * be2 * fem::pow2((3.f - be2)) * cth;
      asgre = xw * sgzang;
      asgim = 0.f;
      aszre = (1.f - xw) * sh / (sh - sqmz) * sgzang;
      aszim = 0.f;
      tgzang = 1.f / sqmw *
               (be2 * (4.f - 2.f * be2 + be4) +
                be2 * (4.f - 10.f * be2 + be4) * cth +
                (2.f - 11.f * be2 + 10.f * be4) * cth2 + be2 * cth3);
      atgre = 0.5f * xw * sh / th * tgzang;
      atgim = 0.f;
      atzre = 0.5f * (1.f - xw) * sh / (th - sqmz) * tgzang;
      atzim = 0.f;
      a4re = 1.f / sqmw * (1.f + 2.f * be2 - 6.f * be2 * cth - cth2);
      a4im = 0.f;
      fach =
          comfac * 1.f / (4096.f * fem::pow2(paru(1))) * fem::pow4((aem / xw)) *
          fem::pow2((sh / sqmw)) *
          (fem::pow2((ashre + athre + asgre + aszre + atgre + atzre + a4re)) +
           fem::pow2((ashim + athim + asgim + aszim + atgim + atzim + a4im)));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_610;
        }
        ei = fem::sign(1.f, fem::ffloat(i)) * kchg(fem::iabs(i), 1);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_600;
          }
          ej = fem::sign(1.f, fem::ffloat(j)) * kchg(fem::iabs(j), 1);
          if (ei * ej > 0.f) {
            goto statement_600;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) = fach * vint(180 + i) * vint(180 + j);
        statement_600:;
        }
      statement_610:;
      }
      /// C
    } else if (isub == 78) {
      /// C...W+/- + H0 -> W+/- + H0.
      /// C
    } else if (isub == 79) {
      /// C...H0 + H0 -> H0 + H0.
      /// C
    }
    /// C
    /// C...C: 2 -> 2, tree diagrams with masses.
    /// C
  } else if (isub <= 90) {
    if (isub == 81) {
      /// C...q + qb -> Q + QB.
      facqqb = comfac * fem::pow2(as) * 4.f / 9.f *
               ((fem::pow2((th - sqm3)) + fem::pow2((uh - sqm3))) / sh2 +
                2.f * sqm3 / sh);
      if (mstp(35) >= 1) {
        if (mstp(35) == 1) {
          alssg = parp(35);
        } else {
          mst115 = mstu(115);
          mstu(115) = mstp(36);
          q2bn = fem::sqrt(sqm3 *
                           (fem::pow2((fem::sqrt(sh) - 2.f * fem::sqrt(sqm3))) +
                            fem::pow2(parp(36))));
          alssg = ulalps(cmn, q2bn);
          mstu(115) = mst115;
        }
        xrepu = paru(1) * alssg /
                (6.f * fem::sqrt(fem::max(1e-20f, 1.f - 4.f * sqm3 / sh)));
        frepu = xrepu / (fem::exp(fem::min(100.f, xrepu)) - 1.f);
        pari(81) = frepu;
        facqqb = facqqb * frepu;
      }
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_620;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facqqb;
      statement_620:;
      }
      /// C
    } else if (isub == 82) {
      /// C...g + g -> Q + QB.
      facqq1 = comfac * faca * fem::pow2(as) * 1.f / 6.f *
               ((uh - sqm3) / (th - sqm3) - 2.f * fem::pow2((uh - sqm3)) / sh2 +
                4.f * sqm3 / sh * (th * uh - fem::pow2(sqm3)) /
                    fem::pow2((th - sqm3)));
      facqq2 = comfac * faca * fem::pow2(as) * 1.f / 6.f *
               ((th - sqm3) / (uh - sqm3) - 2.f * fem::pow2((th - sqm3)) / sh2 +
                4.f * sqm3 / sh * (th * uh - fem::pow2(sqm3)) /
                    fem::pow2((uh - sqm3)));
      if (mstp(35) >= 1) {
        if (mstp(35) == 1) {
          alssg = parp(35);
        } else {
          mst115 = mstu(115);
          mstu(115) = mstp(36);
          q2bn = fem::sqrt(sqm3 *
                           (fem::pow2((fem::sqrt(sh) - 2.f * fem::sqrt(sqm3))) +
                            fem::pow2(parp(36))));
          alssg = ulalps(cmn, q2bn);
          mstu(115) = mst115;
        }
        xattr = 4.f * paru(1) * alssg /
                (3.f * fem::sqrt(fem::max(1e-20f, 1.f - 4.f * sqm3 / sh)));
        fattr = xattr / (1.f - fem::exp(-fem::min(100.f, xattr)));
        xrepu = paru(1) * alssg /
                (6.f * fem::sqrt(fem::max(1e-20f, 1.f - 4.f * sqm3 / sh)));
        frepu = xrepu / (fem::exp(fem::min(100.f, xrepu)) - 1.f);
        fatre = (2.f * fattr + 5.f * frepu) / 7.f;
        pari(81) = fatre;
        facqq1 = facqq1 * fatre;
        facqq2 = facqq2 * fatre;
      }
      if (kfac(1, 21) * kfac(2, 21) == 0) {
        goto statement_630;
      }
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 1;
      sigh(nchn) = facqq1;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 2;
      sigh(nchn) = facqq2;
    statement_630:;
      /// C
    }
    /// C
    /// C...D: Mimimum bias processes.
    /// C
  } else if (isub <= 100) {
    if (isub == 91) {
      /// C...Elastic scattering.
      sigs = xsec(isub, 1);
      /// C
    } else if (isub == 92) {
      /// C...Single diffractive scattering.
      sigs = xsec(isub, 1);
      /// C
    } else if (isub == 93) {
      /// C...Double diffractive scattering.
      sigs = xsec(isub, 1);
      /// C
    } else if (isub == 94) {
      /// C...Central diffractive scattering.
      sigs = xsec(isub, 1);
      /// C
    } else if (isub == 95) {
      /// C...Low-pT scattering.
      sigs = xsec(isub, 1);
      /// C
    } else if (isub == 96) {
      /// C...Multiple interactions: sum of QCD processes.
      pywidt(cmn, 21, fem::sqrt(sh), wdtp, wdte);
      /// C
      /// C...q + q' -> q + q'.
      facqq1 = comfac * fem::pow2(as) * 4.f / 9.f * (sh2 + uh2) / th2;
      facqqb =
          comfac * fem::pow2(as) * 4.f / 9.f *
          ((sh2 + uh2) / th2 * faca - mstp(34) * 2.f / 3.f * uh2 / (sh * th));
      facqq2 = comfac * fem::pow2(as) * 4.f / 9.f *
               ((sh2 + th2) / uh2 - mstp(34) * 2.f / 3.f * sh2 / (th * uh));
      FEM_DO_SAFE(i, -3, 3) {
        if (i == 0) {
          goto statement_650;
        }
        FEM_DO_SAFE(j, -3, 3) {
          if (j == 0) {
            goto statement_640;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 111;
          sigh(nchn) = facqq1;
          if (i == -j) {
            sigh(nchn) = facqqb;
          }
          if (i == j) {
            sigh(nchn) = 0.5f * sigh(nchn);
            nchn++;
            isig(nchn, 1) = i;
            isig(nchn, 2) = j;
            isig(nchn, 3) = 112;
            sigh(nchn) = 0.5f * facqq2;
          }
        statement_640:;
        }
      statement_650:;
      }
      /// C
      /// C...q + qb -> q' + qb' or g + g.
      facqqb = comfac * fem::pow2(as) * 4.f / 9.f * (th2 + uh2) / sh2 *
               (wdte(0, 1) + wdte(0, 2) + wdte(0, 3) + wdte(0, 4));
      facgg1 = comfac * fem::pow2(as) * 32.f / 27.f *
               (uh / th - (2.f + mstp(34) * 1.f / 4.f) * uh2 / sh2);
      facgg2 = comfac * fem::pow2(as) * 32.f / 27.f *
               (th / uh - (2.f + mstp(34) * 1.f / 4.f) * th2 / sh2);
      FEM_DO_SAFE(i, -3, 3) {
        if (i == 0) {
          goto statement_660;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 121;
        sigh(nchn) = facqqb;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 131;
        sigh(nchn) = 0.5f * facgg1;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 132;
        sigh(nchn) = 0.5f * facgg2;
      statement_660:;
      }
      /// C
      /// C...q + g -> q + g.
      facqg1 = comfac * fem::pow2(as) * 4.f / 9.f *
               ((2.f + mstp(34) * 1.f / 4.f) * uh2 / th2 - uh / sh) * faca;
      facqg2 = comfac * fem::pow2(as) * 4.f / 9.f *
               ((2.f + mstp(34) * 1.f / 4.f) * sh2 / th2 - sh / uh);
      FEM_DO_SAFE(i, -3, 3) {
        if (i == 0) {
          goto statement_680;
        }
        FEM_DO_SAFE(isde, 1, 2) {
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 281;
          sigh(nchn) = facqg1;
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 282;
          sigh(nchn) = facqg2;
        }
      statement_680:;
      }
      /// C
      /// C...g + g -> q + qb or g + g.
      facqq1 = comfac * fem::pow2(as) * 1.f / 6.f *
               (uh / th - (2.f + mstp(34) * 1.f / 4.f) * uh2 / sh2) *
               (wdte(0, 1) + wdte(0, 2) + wdte(0, 3) + wdte(0, 4)) * faca;
      facqq2 = comfac * fem::pow2(as) * 1.f / 6.f *
               (th / uh - (2.f + mstp(34) * 1.f / 4.f) * th2 / sh2) *
               (wdte(0, 1) + wdte(0, 2) + wdte(0, 3) + wdte(0, 4)) * faca;
      facgg1 = comfac * fem::pow2(as) * 9.f / 4.f *
               (sh2 / th2 + 2.f * sh / th + 3.f + 2.f * th / sh + th2 / sh2) *
               faca;
      facgg2 = comfac * fem::pow2(as) * 9.f / 4.f *
               (uh2 / sh2 + 2.f * uh / sh + 3.f + 2.f * sh / uh + sh2 / uh2) *
               faca;
      facgg3 = comfac * fem::pow2(as) * 9.f / 4.f *
               (th2 / uh2 + 2.f * th / uh + 3 + 2.f * uh / th + uh2 / th2);
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 531;
      sigh(nchn) = facqq1;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 532;
      sigh(nchn) = facqq2;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 681;
      sigh(nchn) = 0.5f * facgg1;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 682;
      sigh(nchn) = 0.5f * facgg2;
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 683;
      sigh(nchn) = 0.5f * facgg3;
    }
    /// C
    /// C...E: 2 -> 1, loop diagrams.
    /// C
  } else if (isub <= 110) {
    if (isub == 101) {
      /// C...g + g -> gamma*/Z0.
      /// C
    } else if (isub == 102) {
      /// C...g + g -> H0.
      pywidt(cmn, 25, fem::sqrt(sh), wdtp, wdte);
      etare = 0.f;
      etaim = 0.f;
      FEM_DO_SAFE(i, 1, 2 * mstp(1)) {
        eps = 4.f * fem::pow2(pmas(i, 1)) / sh;
        if (eps <= 1.f) {
          if (eps > 1.e-4f) {
            root = fem::sqrt(1.f - eps);
            rln = fem::log((1.f + root) / (1.f - root));
          } else {
            rln = fem::log(4.f / eps - 2.f);
          }
          phire = 0.25f * (fem::pow2(rln) - fem::pow2(paru(1)));
          phiim = 0.5f * paru(1) * rln;
        } else {
          phire = -fem::pow2((fem::asin(1.f / fem::sqrt(eps))));
          phiim = 0.f;
        }
        etare += 0.5f * eps * (1.f + (eps - 1.f) * phire);
        etaim += 0.5f * eps * (eps - 1.f) * phiim;
      }
      eta2 = fem::pow2(etare) + fem::pow2(etaim);
      fach = comfac * faca * fem::pow2((as / paru(1) * aem / xw)) * 1.f /
             512.f * fem::pow2((sh / sqmw)) * eta2 * sh2 /
             (fem::pow2((sh - sqmh)) + fem::pow2(gmmh)) *
             (wdte(0, 1) + wdte(0, 2) + wdte(0, 4));
      if (kfac(1, 21) * kfac(2, 21) == 0) {
        goto statement_700;
      }
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 1;
      sigh(nchn) = fach;
    statement_700:;
      /// C
    }
    /// C
    /// C...F: 2 -> 2, box diagrams.
    /// C
  } else if (isub <= 120) {
    if (isub == 111) {
      /// C...f + fb -> g + H0 (q + qb -> g + H0 only).
      a5stur = 0.f;
      a5stui = 0.f;
      FEM_DO_SAFE(i, 1, 2 * mstp(1)) {
        sqmq = fem::pow2(pmas(i, 1));
        epss = 4.f * sqmq / sh;
        epsh = 4.f * sqmq / sqmh;
        a5stur += sqmq / sqmh *
                  (4.f +
                   4.f * sh / (th + uh) *
                       (pyw1au(cmn, epss, 1) - pyw1au(cmn, epsh, 1)) +
                   (1.f - 4.f * sqmq / (th + uh)) *
                       (pyw2au(cmn, epss, 1) - pyw2au(cmn, epsh, 1)));
        a5stui += sqmq / sqmh *
                  (4.f * sh / (th + uh) *
                       (pyw1au(cmn, epss, 2) - pyw1au(cmn, epsh, 2)) +
                   (1.f - 4.f * sqmq / (th + uh)) *
                       (pyw2au(cmn, epss, 2) - pyw2au(cmn, epsh, 2)));
      }
      facgh = comfac * faca / (144.f * fem::pow2(paru(1))) * aem / xw *
              fem::pow3(as) * sqmh / sqmw * sqmh / sh *
              (fem::pow2(uh) + fem::pow2(th)) / fem::pow2((uh + th)) *
              (fem::pow2(a5stur) + fem::pow2(a5stui));
      facgh = facgh * wids(25, 2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_720;
        }
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) = facgh;
      statement_720:;
      }
      /// C
    } else if (isub == 112) {
      /// C...f + g -> f + H0 (q + g -> q + H0 only).
      a5tsur = 0.f;
      a5tsui = 0.f;
      FEM_DO_SAFE(i, 1, 2 * mstp(1)) {
        sqmq = fem::pow2(pmas(i, 1));
        epst = 4.f * sqmq / th;
        epsh = 4.f * sqmq / sqmh;
        a5tsur += sqmq / sqmh *
                  (4.f +
                   4.f * th / (sh + uh) *
                       (pyw1au(cmn, epst, 1) - pyw1au(cmn, epsh, 1)) +
                   (1.f - 4.f * sqmq / (sh + uh)) *
                       (pyw2au(cmn, epst, 1) - pyw2au(cmn, epsh, 1)));
        a5tsui += sqmq / sqmh *
                  (4.f * th / (sh + uh) *
                       (pyw1au(cmn, epst, 2) - pyw1au(cmn, epsh, 2)) +
                   (1.f - 4.f * sqmq / (sh + uh)) *
                       (pyw2au(cmn, epst, 2) - pyw2au(cmn, epsh, 2)));
      }
      facqh = comfac * faca / (384.f * fem::pow2(paru(1))) * aem / xw *
              fem::pow3(as) * sqmh / sqmw * sqmh / (-th) *
              (fem::pow2(uh) + fem::pow2(sh)) / fem::pow2((uh + sh)) *
              (fem::pow2(a5tsur) + fem::pow2(a5tsui));
      facqh = facqh * wids(25, 2);
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0) {
          goto statement_750;
        }
        FEM_DO_SAFE(isde, 1, 2) {
          if (isde == 1 && kfac(1, i) * kfac(2, 21) == 0) {
            goto statement_740;
          }
          if (isde == 2 && kfac(1, 21) * kfac(2, i) == 0) {
            goto statement_740;
          }
          nchn++;
          isig(nchn, isde) = i;
          isig(nchn, 3 - isde) = 21;
          isig(nchn, 3) = 1;
          sigh(nchn) = facqh;
        statement_740:;
        }
      statement_750:;
      }
      /// C
    } else if (isub == 113) {
      /// C...g + g -> g + H0.
      a2stur = 0.f;
      a2stui = 0.f;
      a2ustr = 0.f;
      a2usti = 0.f;
      a2tusr = 0.f;
      a2tusi = 0.f;
      a4stur = 0.f;
      a4stui = 0.f;
      FEM_DO_SAFE(i, 6, 2 * mstp(1)) {
        /// C'''Only t-quarks yet included
        sqmq = fem::pow2(pmas(i, 1));
        epss = 4.f * sqmq / sh;
        epst = 4.f * sqmq / th;
        epsu = 4.f * sqmq / uh;
        epsh = 4.f * sqmq / sqmh;
        if (epsh < 1.e-6f) {
          goto statement_760;
        }
        bestu = 0.5f * (1.f + fem::sqrt(1.f + epss * th / uh));
        beust = 0.5f * (1.f + fem::sqrt(1.f + epsu * sh / th));
        betus = 0.5f * (1.f + fem::sqrt(1.f + epst * uh / sh));
        beuts = bestu;
        betsu = beust;
        besut = betus;
        w3stur = pyi3au(cmn, bestu, epsh, 1) - pyi3au(cmn, bestu, epss, 1) -
                 pyi3au(cmn, bestu, epsu, 1);
        w3stui = pyi3au(cmn, bestu, epsh, 2) - pyi3au(cmn, bestu, epss, 2) -
                 pyi3au(cmn, bestu, epsu, 2);
        w3sutr = pyi3au(cmn, besut, epsh, 1) - pyi3au(cmn, besut, epss, 1) -
                 pyi3au(cmn, besut, epst, 1);
        w3suti = pyi3au(cmn, besut, epsh, 2) - pyi3au(cmn, besut, epss, 2) -
                 pyi3au(cmn, besut, epst, 2);
        w3tsur = pyi3au(cmn, betsu, epsh, 1) - pyi3au(cmn, betsu, epst, 1) -
                 pyi3au(cmn, betsu, epsu, 1);
        w3tsui = pyi3au(cmn, betsu, epsh, 2) - pyi3au(cmn, betsu, epst, 2) -
                 pyi3au(cmn, betsu, epsu, 2);
        w3tusr = pyi3au(cmn, betus, epsh, 1) - pyi3au(cmn, betus, epst, 1) -
                 pyi3au(cmn, betus, epss, 1);
        w3tusi = pyi3au(cmn, betus, epsh, 2) - pyi3au(cmn, betus, epst, 2) -
                 pyi3au(cmn, betus, epss, 2);
        w3ustr = pyi3au(cmn, beust, epsh, 1) - pyi3au(cmn, beust, epsu, 1) -
                 pyi3au(cmn, beust, epst, 1);
        w3usti = pyi3au(cmn, beust, epsh, 2) - pyi3au(cmn, beust, epsu, 2) -
                 pyi3au(cmn, beust, epst, 2);
        w3utsr = pyi3au(cmn, beuts, epsh, 1) - pyi3au(cmn, beuts, epsu, 1) -
                 pyi3au(cmn, beuts, epss, 1);
        w3utsi = pyi3au(cmn, beuts, epsh, 2) - pyi3au(cmn, beuts, epsu, 2) -
                 pyi3au(cmn, beuts, epss, 2);
        b2stur = sqmq / fem::pow2(sqmh) *
                 (sh * (uh - sh) / (sh + uh) +
                  2.f * th * uh * (uh + 2.f * sh) / fem::pow2((sh + uh)) *
                      (pyw1au(cmn, epst, 1) - pyw1au(cmn, epsh, 1)) +
                  (sqmq - sh / 4.f) * (0.5f * pyw2au(cmn, epss, 1) +
                                       0.5f * pyw2au(cmn, epsh, 1) -
                                       pyw2au(cmn, epst, 1) + w3stur) +
                  fem::pow2(sh) *
                      (2.f * sqmq / fem::pow2((sh + uh)) - 0.5f / (sh + uh)) *
                      (pyw2au(cmn, epst, 1) - pyw2au(cmn, epsh, 1)) +
                  0.5f * th * uh / sh *
                      (pyw2au(cmn, epsh, 1) - 2.f * pyw2au(cmn, epst, 1)) +
                  0.125f * (sh - 12.f * sqmq - 4.f * th * uh / sh) * w3tsur);
        b2stui = sqmq / fem::pow2(sqmh) *
                 (2.f * th * uh * (uh + 2.f * sh) / fem::pow2((sh + uh)) *
                      (pyw1au(cmn, epst, 2) - pyw1au(cmn, epsh, 2)) +
                  (sqmq - sh / 4.f) * (0.5f * pyw2au(cmn, epss, 2) +
                                       0.5f * pyw2au(cmn, epsh, 2) -
                                       pyw2au(cmn, epst, 2) + w3stui) +
                  fem::pow2(sh) *
                      (2.f * sqmq / fem::pow2((sh + uh)) - 0.5f / (sh + uh)) *
                      (pyw2au(cmn, epst, 2) - pyw2au(cmn, epsh, 2)) +
                  0.5f * th * uh / sh *
                      (pyw2au(cmn, epsh, 2) - 2.f * pyw2au(cmn, epst, 2)) +
                  0.125f * (sh - 12.f * sqmq - 4.f * th * uh / sh) * w3tsui);
        b2sutr = sqmq / fem::pow2(sqmh) *
                 (sh * (th - sh) / (sh + th) +
                  2.f * uh * th * (th + 2.f * sh) / fem::pow2((sh + th)) *
                      (pyw1au(cmn, epsu, 1) - pyw1au(cmn, epsh, 1)) +
                  (sqmq - sh / 4.f) * (0.5f * pyw2au(cmn, epss, 1) +
                                       0.5f * pyw2au(cmn, epsh, 1) -
                                       pyw2au(cmn, epsu, 1) + w3sutr) +
                  fem::pow2(sh) *
                      (2.f * sqmq / fem::pow2((sh + th)) - 0.5f / (sh + th)) *
                      (pyw2au(cmn, epsu, 1) - pyw2au(cmn, epsh, 1)) +
                  0.5f * uh * th / sh *
                      (pyw2au(cmn, epsh, 1) - 2.f * pyw2au(cmn, epsu, 1)) +
                  0.125f * (sh - 12.f * sqmq - 4.f * uh * th / sh) * w3ustr);
        b2suti = sqmq / fem::pow2(sqmh) *
                 (2.f * uh * th * (th + 2.f * sh) / fem::pow2((sh + th)) *
                      (pyw1au(cmn, epsu, 2) - pyw1au(cmn, epsh, 2)) +
                  (sqmq - sh / 4.f) * (0.5f * pyw2au(cmn, epss, 2) +
                                       0.5f * pyw2au(cmn, epsh, 2) -
                                       pyw2au(cmn, epsu, 2) + w3suti) +
                  fem::pow2(sh) *
                      (2.f * sqmq / fem::pow2((sh + th)) - 0.5f / (sh + th)) *
                      (pyw2au(cmn, epsu, 2) - pyw2au(cmn, epsh, 2)) +
                  0.5f * uh * th / sh *
                      (pyw2au(cmn, epsh, 2) - 2.f * pyw2au(cmn, epsu, 2)) +
                  0.125f * (sh - 12.f * sqmq - 4.f * uh * th / sh) * w3usti);
        b2tsur = sqmq / fem::pow2(sqmh) *
                 (th * (uh - th) / (th + uh) +
                  2.f * sh * uh * (uh + 2.f * th) / fem::pow2((th + uh)) *
                      (pyw1au(cmn, epss, 1) - pyw1au(cmn, epsh, 1)) +
                  (sqmq - th / 4.f) * (0.5f * pyw2au(cmn, epst, 1) +
                                       0.5f * pyw2au(cmn, epsh, 1) -
                                       pyw2au(cmn, epss, 1) + w3tsur) +
                  fem::pow2(th) *
                      (2.f * sqmq / fem::pow2((th + uh)) - 0.5f / (th + uh)) *
                      (pyw2au(cmn, epss, 1) - pyw2au(cmn, epsh, 1)) +
                  0.5f * sh * uh / th *
                      (pyw2au(cmn, epsh, 1) - 2.f * pyw2au(cmn, epss, 1)) +
                  0.125f * (th - 12.f * sqmq - 4.f * sh * uh / th) * w3stur);
        b2tsui = sqmq / fem::pow2(sqmh) *
                 (2.f * sh * uh * (uh + 2.f * th) / fem::pow2((th + uh)) *
                      (pyw1au(cmn, epss, 2) - pyw1au(cmn, epsh, 2)) +
                  (sqmq - th / 4.f) * (0.5f * pyw2au(cmn, epst, 2) +
                                       0.5f * pyw2au(cmn, epsh, 2) -
                                       pyw2au(cmn, epss, 2) + w3tsui) +
                  fem::pow2(th) *
                      (2.f * sqmq / fem::pow2((th + uh)) - 0.5f / (th + uh)) *
                      (pyw2au(cmn, epss, 2) - pyw2au(cmn, epsh, 2)) +
                  0.5f * sh * uh / th *
                      (pyw2au(cmn, epsh, 2) - 2.f * pyw2au(cmn, epss, 2)) +
                  0.125f * (th - 12.f * sqmq - 4.f * sh * uh / th) * w3stui);
        b2tusr = sqmq / fem::pow2(sqmh) *
                 (th * (sh - th) / (th + sh) +
                  2.f * uh * sh * (sh + 2.f * th) / fem::pow2((th + sh)) *
                      (pyw1au(cmn, epsu, 1) - pyw1au(cmn, epsh, 1)) +
                  (sqmq - th / 4.f) * (0.5f * pyw2au(cmn, epst, 1) +
                                       0.5f * pyw2au(cmn, epsh, 1) -
                                       pyw2au(cmn, epsu, 1) + w3tusr) +
                  fem::pow2(th) *
                      (2.f * sqmq / fem::pow2((th + sh)) - 0.5f / (th + sh)) *
                      (pyw2au(cmn, epsu, 1) - pyw2au(cmn, epsh, 1)) +
                  0.5f * uh * sh / th *
                      (pyw2au(cmn, epsh, 1) - 2.f * pyw2au(cmn, epsu, 1)) +
                  0.125f * (th - 12.f * sqmq - 4.f * uh * sh / th) * w3utsr);
        b2tusi = sqmq / fem::pow2(sqmh) *
                 (2.f * uh * sh * (sh + 2.f * th) / fem::pow2((th + sh)) *
                      (pyw1au(cmn, epsu, 2) - pyw1au(cmn, epsh, 2)) +
                  (sqmq - th / 4.f) * (0.5f * pyw2au(cmn, epst, 2) +
                                       0.5f * pyw2au(cmn, epsh, 2) -
                                       pyw2au(cmn, epsu, 2) + w3tusi) +
                  fem::pow2(th) *
                      (2.f * sqmq / fem::pow2((th + sh)) - 0.5f / (th + sh)) *
                      (pyw2au(cmn, epsu, 2) - pyw2au(cmn, epsh, 2)) +
                  0.5f * uh * sh / th *
                      (pyw2au(cmn, epsh, 2) - 2.f * pyw2au(cmn, epsu, 2)) +
                  0.125f * (th - 12.f * sqmq - 4.f * uh * sh / th) * w3utsi);
        b2ustr = sqmq / fem::pow2(sqmh) *
                 (uh * (th - uh) / (uh + th) +
                  2.f * sh * th * (th + 2.f * uh) / fem::pow2((uh + th)) *
                      (pyw1au(cmn, epss, 1) - pyw1au(cmn, epsh, 1)) +
                  (sqmq - uh / 4.f) * (0.5f * pyw2au(cmn, epsu, 1) +
                                       0.5f * pyw2au(cmn, epsh, 1) -
                                       pyw2au(cmn, epss, 1) + w3ustr) +
                  fem::pow2(uh) *
                      (2.f * sqmq / fem::pow2((uh + th)) - 0.5f / (uh + th)) *
                      (pyw2au(cmn, epss, 1) - pyw2au(cmn, epsh, 1)) +
                  0.5f * sh * th / uh *
                      (pyw2au(cmn, epsh, 1) - 2.f * pyw2au(cmn, epss, 1)) +
                  0.125f * (uh - 12.f * sqmq - 4.f * sh * th / uh) * w3sutr);
        b2usti = sqmq / fem::pow2(sqmh) *
                 (2.f * sh * th * (th + 2.f * uh) / fem::pow2((uh + th)) *
                      (pyw1au(cmn, epss, 2) - pyw1au(cmn, epsh, 2)) +
                  (sqmq - uh / 4.f) * (0.5f * pyw2au(cmn, epsu, 2) +
                                       0.5f * pyw2au(cmn, epsh, 2) -
                                       pyw2au(cmn, epss, 2) + w3usti) +
                  fem::pow2(uh) *
                      (2.f * sqmq / fem::pow2((uh + th)) - 0.5f / (uh + th)) *
                      (pyw2au(cmn, epss, 2) - pyw2au(cmn, epsh, 2)) +
                  0.5f * sh * th / uh *
                      (pyw2au(cmn, epsh, 2) - 2.f * pyw2au(cmn, epss, 2)) +
                  0.125f * (uh - 12.f * sqmq - 4.f * sh * th / uh) * w3suti);
        b2utsr = sqmq / fem::pow2(sqmh) *
                 (uh * (sh - uh) / (uh + sh) +
                  2.f * th * sh * (sh + 2.f * uh) / fem::pow2((uh + sh)) *
                      (pyw1au(cmn, epst, 1) - pyw1au(cmn, epsh, 1)) +
                  (sqmq - uh / 4.f) * (0.5f * pyw2au(cmn, epsu, 1) +
                                       0.5f * pyw2au(cmn, epsh, 1) -
                                       pyw2au(cmn, epst, 1) + w3utsr) +
                  fem::pow2(uh) *
                      (2.f * sqmq / fem::pow2((uh + sh)) - 0.5f / (uh + sh)) *
                      (pyw2au(cmn, epst, 1) - pyw2au(cmn, epsh, 1)) +
                  0.5f * th * sh / uh *
                      (pyw2au(cmn, epsh, 1) - 2.f * pyw2au(cmn, epst, 1)) +
                  0.125f * (uh - 12.f * sqmq - 4.f * th * sh / uh) * w3tusr);
        b2utsi = sqmq / fem::pow2(sqmh) *
                 (2.f * th * sh * (sh + 2.f * uh) / fem::pow2((uh + sh)) *
                      (pyw1au(cmn, epst, 2) - pyw1au(cmn, epsh, 2)) +
                  (sqmq - uh / 4.f) * (0.5f * pyw2au(cmn, epsu, 2) +
                                       0.5f * pyw2au(cmn, epsh, 2) -
                                       pyw2au(cmn, epst, 2) + w3utsi) +
                  fem::pow2(uh) *
                      (2.f * sqmq / fem::pow2((uh + sh)) - 0.5f / (uh + sh)) *
                      (pyw2au(cmn, epst, 2) - pyw2au(cmn, epsh, 2)) +
                  0.5f * th * sh / uh *
                      (pyw2au(cmn, epsh, 2) - 2.f * pyw2au(cmn, epst, 2)) +
                  0.125f * (uh - 12.f * sqmq - 4.f * th * sh / uh) * w3tusi);
        b4stur = sqmq / sqmh *
                 (-2.f / 3.f +
                  (sqmq / sqmh - 1.f / 4.f) *
                      (pyw2au(cmn, epss, 1) - pyw2au(cmn, epsh, 1) + w3stur));
        b4stui = sqmq / sqmh * (sqmq / sqmh - 1.f / 4.f) *
                 (pyw2au(cmn, epss, 2) - pyw2au(cmn, epsh, 2) + w3stui);
        b4tusr = sqmq / sqmh *
                 (-2.f / 3.f +
                  (sqmq / sqmh - 1.f / 4.f) *
                      (pyw2au(cmn, epst, 1) - pyw2au(cmn, epsh, 1) + w3tusr));
        b4tusi = sqmq / sqmh * (sqmq / sqmh - 1.f / 4.f) *
                 (pyw2au(cmn, epst, 2) - pyw2au(cmn, epsh, 2) + w3tusi);
        b4ustr = sqmq / sqmh *
                 (-2.f / 3.f +
                  (sqmq / sqmh - 1.f / 4.f) *
                      (pyw2au(cmn, epsu, 1) - pyw2au(cmn, epsh, 1) + w3ustr));
        b4usti = sqmq / sqmh * (sqmq / sqmh - 1.f / 4.f) *
                 (pyw2au(cmn, epsu, 2) - pyw2au(cmn, epsh, 2) + w3usti);
        a2stur += b2stur + b2sutr;
        a2stui += b2stui + b2suti;
        a2ustr += b2ustr + b2utsr;
        a2usti += b2usti + b2utsi;
        a2tusr += b2tusr + b2tsur;
        a2tusi += b2tusi + b2tsui;
        a4stur += b4stur + b4ustr + b4tusr;
        a4stui += b4stui + b4usti + b4tusi;
      statement_760:;
      }
      facgh = comfac * faca * 3.f / (128.f * fem::pow2(paru(1))) * aem / xw *
              fem::pow3(as) * sqmh / sqmw * fem::pow3(sqmh) / (sh * th * uh) *
              (fem::pow2(a2stur) + fem::pow2(a2stui) + fem::pow2(a2ustr) +
               fem::pow2(a2usti) + fem::pow2(a2tusr) + fem::pow2(a2tusi) +
               fem::pow2(a4stur) + fem::pow2(a4stui));
      facgh = facgh * wids(25, 2);
      if (kfac(1, 21) * kfac(2, 21) == 0) {
        goto statement_770;
      }
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 1;
      sigh(nchn) = facgh;
    statement_770:;
      /// C
    } else if (isub == 114) {
      /// C...g + g -> gamma + gamma.
      asre = 0.f;
      asim = 0.f;
      FEM_DO_SAFE(i, 1, 2 * mstp(1)) {
        ei = kchg(fem::iabs(i), 1) / 3.f;
        sqmq = fem::pow2(pmas(i, 1));
        epss = 4.f * sqmq / sh;
        epst = 4.f * sqmq / th;
        epsu = 4.f * sqmq / uh;
        if (epss + fem::abs(epst) + fem::abs(epsu) < 3.e-6f) {
          a0stur = 1.f + (th - uh) / sh * fem::log(th / uh) +
                   0.5f * (th2 + uh2) / sh2 *
                       (fem::pow2(fem::log(th / uh)) + fem::pow2(paru(1)));
          a0stui = 0.f;
          a0tsur = 1.f + (sh - uh) / th * fem::log(-sh / uh) +
                   0.5f * (sh2 + uh2) / th2 * fem::pow2(fem::log(-sh / uh));
          a0tsui = -paru(1) *
                   ((sh - uh) / th + (sh2 + uh2) / th2 * fem::log(-sh / uh));
          a0utsr = 1.f + (th - sh) / uh * fem::log(-th / sh) +
                   0.5f * (th2 + sh2) / uh2 * fem::pow2(fem::log(-th / sh));
          a0utsi = paru(1) *
                   ((th - sh) / uh + (th2 + sh2) / uh2 * fem::log(-th / sh));
          a1stur = -1.f;
          a1stui = 0.f;
          a2stur = -1.f;
          a2stui = 0.f;
        } else {
          bestu = 0.5f * (1.f + fem::sqrt(1.f + epss * th / uh));
          beust = 0.5f * (1.f + fem::sqrt(1.f + epsu * sh / th));
          betus = 0.5f * (1.f + fem::sqrt(1.f + epst * uh / sh));
          beuts = bestu;
          betsu = beust;
          besut = betus;
          a0stur =
              1.f + (1.f + 2.f * th / sh) * pyw1au(cmn, epst, 1) +
              (1.f + 2.f * uh / sh) * pyw1au(cmn, epsu, 1) +
              0.5f * ((th2 + uh2) / sh2 - epss) *
                  (pyw2au(cmn, epst, 1) + pyw2au(cmn, epsu, 1)) -
              0.25f * epst * (1.f - 0.5f * epss) *
                  (pyi3au(cmn, besut, epss, 1) + pyi3au(cmn, besut, epst, 1)) -
              0.25f * epsu * (1.f - 0.5f * epss) *
                  (pyi3au(cmn, bestu, epss, 1) + pyi3au(cmn, bestu, epsu, 1)) +
              0.25f *
                  (-2.f * (th2 + uh2) / sh2 + 4.f * epss + epst + epsu +
                   0.5f * epst * epsu) *
                  (pyi3au(cmn, betsu, epst, 1) + pyi3au(cmn, betsu, epsu, 1));
          a0stui =
              (1.f + 2.f * th / sh) * pyw1au(cmn, epst, 2) +
              (1.f + 2.f * uh / sh) * pyw1au(cmn, epsu, 2) +
              0.5f * ((th2 + uh2) / sh2 - epss) *
                  (pyw2au(cmn, epst, 2) + pyw2au(cmn, epsu, 2)) -
              0.25f * epst * (1.f - 0.5f * epss) *
                  (pyi3au(cmn, besut, epss, 2) + pyi3au(cmn, besut, epst, 2)) -
              0.25f * epsu * (1.f - 0.5f * epss) *
                  (pyi3au(cmn, bestu, epss, 2) + pyi3au(cmn, bestu, epsu, 2)) +
              0.25f *
                  (-2.f * (th2 + uh2) / sh2 + 4.f * epss + epst + epsu +
                   0.5f * epst * epsu) *
                  (pyi3au(cmn, betsu, epst, 2) + pyi3au(cmn, betsu, epsu, 2));
          a0tsur =
              1.f + (1.f + 2.f * sh / th) * pyw1au(cmn, epss, 1) +
              (1.f + 2.f * uh / th) * pyw1au(cmn, epsu, 1) +
              0.5f * ((sh2 + uh2) / th2 - epst) *
                  (pyw2au(cmn, epss, 1) + pyw2au(cmn, epsu, 1)) -
              0.25f * epss * (1.f - 0.5f * epst) *
                  (pyi3au(cmn, betus, epst, 1) + pyi3au(cmn, betus, epss, 1)) -
              0.25f * epsu * (1.f - 0.5f * epst) *
                  (pyi3au(cmn, betsu, epst, 1) + pyi3au(cmn, betsu, epsu, 1)) +
              0.25f *
                  (-2.f * (sh2 + uh2) / th2 + 4.f * epst + epss + epsu +
                   0.5f * epss * epsu) *
                  (pyi3au(cmn, bestu, epss, 1) + pyi3au(cmn, bestu, epsu, 1));
          a0tsui =
              (1.f + 2.f * sh / th) * pyw1au(cmn, epss, 2) +
              (1.f + 2.f * uh / th) * pyw1au(cmn, epsu, 2) +
              0.5f * ((sh2 + uh2) / th2 - epst) *
                  (pyw2au(cmn, epss, 2) + pyw2au(cmn, epsu, 2)) -
              0.25f * epss * (1.f - 0.5f * epst) *
                  (pyi3au(cmn, betus, epst, 2) + pyi3au(cmn, betus, epss, 2)) -
              0.25f * epsu * (1.f - 0.5f * epst) *
                  (pyi3au(cmn, betsu, epst, 2) + pyi3au(cmn, betsu, epsu, 2)) +
              0.25f *
                  (-2.f * (sh2 + uh2) / th2 + 4.f * epst + epss + epsu +
                   0.5f * epss * epsu) *
                  (pyi3au(cmn, bestu, epss, 2) + pyi3au(cmn, bestu, epsu, 2));
          a0utsr =
              1.f + (1.f + 2.f * th / uh) * pyw1au(cmn, epst, 1) +
              (1.f + 2.f * sh / uh) * pyw1au(cmn, epss, 1) +
              0.5f * ((th2 + sh2) / uh2 - epsu) *
                  (pyw2au(cmn, epst, 1) + pyw2au(cmn, epss, 1)) -
              0.25f * epst * (1.f - 0.5f * epsu) *
                  (pyi3au(cmn, beust, epsu, 1) + pyi3au(cmn, beust, epst, 1)) -
              0.25f * epss * (1.f - 0.5f * epsu) *
                  (pyi3au(cmn, beuts, epsu, 1) + pyi3au(cmn, beuts, epss, 1)) +
              0.25f *
                  (-2.f * (th2 + sh2) / uh2 + 4.f * epsu + epst + epss +
                   0.5f * epst * epss) *
                  (pyi3au(cmn, betus, epst, 1) + pyi3au(cmn, betus, epss, 1));
          a0utsi =
              (1.f + 2.f * th / uh) * pyw1au(cmn, epst, 2) +
              (1.f + 2.f * sh / uh) * pyw1au(cmn, epss, 2) +
              0.5f * ((th2 + sh2) / uh2 - epsu) *
                  (pyw2au(cmn, epst, 2) + pyw2au(cmn, epss, 2)) -
              0.25f * epst * (1.f - 0.5f * epsu) *
                  (pyi3au(cmn, beust, epsu, 2) + pyi3au(cmn, beust, epst, 2)) -
              0.25f * epss * (1.f - 0.5f * epsu) *
                  (pyi3au(cmn, beuts, epsu, 2) + pyi3au(cmn, beuts, epss, 2)) +
              0.25f *
                  (-2.f * (th2 + sh2) / uh2 + 4.f * epsu + epst + epss +
                   0.5f * epst * epss) *
                  (pyi3au(cmn, betus, epst, 2) + pyi3au(cmn, betus, epss, 2));
          a1stur =
              -1.f -
              0.25f * (epss + epst + epsu) *
                  (pyw2au(cmn, epss, 1) + pyw2au(cmn, epst, 1) +
                   pyw2au(cmn, epsu, 1)) +
              0.25f * (epsu + 0.5f * epss * epst) *
                  (pyi3au(cmn, besut, epss, 1) + pyi3au(cmn, besut, epst, 1)) +
              0.25f * (epst + 0.5f * epss * epsu) *
                  (pyi3au(cmn, bestu, epss, 1) + pyi3au(cmn, bestu, epsu, 1)) +
              0.25f * (epss + 0.5f * epst * epsu) *
                  (pyi3au(cmn, betsu, epst, 1) + pyi3au(cmn, betsu, epsu, 1));
          a1stui =
              -0.25f * (epss + epst + epsu) *
                  (pyw2au(cmn, epss, 2) + pyw2au(cmn, epst, 2) +
                   pyw2au(cmn, epsu, 2)) +
              0.25f * (epsu + 0.5f * epss * epst) *
                  (pyi3au(cmn, besut, epss, 2) + pyi3au(cmn, besut, epst, 2)) +
              0.25f * (epst + 0.5f * epss * epsu) *
                  (pyi3au(cmn, bestu, epss, 2) + pyi3au(cmn, bestu, epsu, 2)) +
              0.25f * (epss + 0.5f * epst * epsu) *
                  (pyi3au(cmn, betsu, epst, 2) + pyi3au(cmn, betsu, epsu, 2));
          a2stur =
              -1.f +
              0.125f * epss * epst *
                  (pyi3au(cmn, besut, epss, 1) + pyi3au(cmn, besut, epst, 1)) +
              0.125f * epss * epsu *
                  (pyi3au(cmn, bestu, epss, 1) + pyi3au(cmn, bestu, epsu, 1)) +
              0.125f * epst * epsu *
                  (pyi3au(cmn, betsu, epst, 1) + pyi3au(cmn, betsu, epsu, 1));
          a2stui =
              0.125f * epss * epst *
                  (pyi3au(cmn, besut, epss, 2) + pyi3au(cmn, besut, epst, 2)) +
              0.125f * epss * epsu *
                  (pyi3au(cmn, bestu, epss, 2) + pyi3au(cmn, bestu, epsu, 2)) +
              0.125f * epst * epsu *
                  (pyi3au(cmn, betsu, epst, 2) + pyi3au(cmn, betsu, epsu, 2));
        }
        asre +=
            fem::pow2(ei) * (a0stur + a0tsur + a0utsr + 4.f * a1stur + a2stur);
        asim +=
            fem::pow2(ei) * (a0stui + a0tsui + a0utsi + 4.f * a1stui + a2stui);
      }
      facgg = comfac * faca / (8.f * fem::pow2(paru(1))) * fem::pow2(as) *
              fem::pow2(aem) * (fem::pow2(asre) + fem::pow2(asim));
      if (kfac(1, 21) * kfac(2, 21) == 0) {
        goto statement_790;
      }
      nchn++;
      isig(nchn, 1) = 21;
      isig(nchn, 2) = 21;
      isig(nchn, 3) = 1;
      sigh(nchn) = facgg;
    statement_790:;
      /// C
    } else if (isub == 115) {
      /// C...g + g -> gamma + Z0.
      /// C
    } else if (isub == 116) {
      /// C...g + g -> Z0 + Z0.
      /// C
    } else if (isub == 117) {
      /// C...g + g -> W+ + W-.
      /// C
    }
    /// C
    /// C...G: 2 -> 3, tree diagrams.
    /// C
  } else if (isub <= 140) {
    if (isub == 121) {
      /// C...g + g -> f + fb + H0.
      /// C
    }
    /// C
    /// C...H: 2 -> 1, tree diagrams, non-standard model processes.
    /// C
  } else if (isub <= 160) {
    if (isub == 141) {
      /// C...f + fb -> gamma*/Z0/Z'0.
      mint(61) = 2;
      pywidt(cmn, 32, fem::sqrt(sh), wdtp, wdte);
      faczp = comfac * fem::pow2(aem) * 4.f / 9.f;
      FEM_DO_SAFE(i, mina, maxa) {
        if (i == 0 || kfac(1, i) * kfac(2, -i) == 0) {
          goto statement_800;
        }
        ei = kchg(fem::iabs(i), 1) / 3.f;
        ai = fem::sign(1.f, ei);
        vi = ai - 4.f * ei * xw;
        api = fem::sign(1.f, ei);
        vpi = api - 4.f * ei * xw;
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            faczp *
            (fem::pow2(ei) * vint(111) +
             ei * vi / (8.f * xw * (1.f - xw)) * sh * (sh - sqmz) /
                 (fem::pow2((sh - sqmz)) + fem::pow2(gmmz)) * vint(112) +
             ei * vpi / (8.f * xw * (1.f - xw)) * sh * (sh - sqmzp) /
                 (fem::pow2((sh - sqmzp)) + fem::pow2(gmmzp)) * vint(113) +
             (fem::pow2(vi) + fem::pow2(ai)) /
                 fem::pow2((16.f * xw * (1.f - xw))) * sh2 /
                 (fem::pow2((sh - sqmz)) + fem::pow2(gmmz)) * vint(114) +
             2.f * (vi * vpi + ai * api) / fem::pow2((16.f * xw * (1.f - xw))) *
                 sh2 * ((sh - sqmz) * (sh - sqmzp) + gmmz * gmmzp) /
                 ((fem::pow2((sh - sqmz)) + fem::pow2(gmmz)) *
                  (fem::pow2((sh - sqmzp)) + fem::pow2(gmmzp))) *
                 vint(115) +
             (fem::pow2(vpi) + fem::pow2(api)) /
                 fem::pow2((16.f * xw * (1.f - xw))) * sh2 /
                 (fem::pow2((sh - sqmzp)) + fem::pow2(gmmzp)) * vint(116));
      statement_800:;
      }
      /// C
    } else if (isub == 142) {
      /// C...f + fb' -> H+/-.
      pywidt(cmn, 37, fem::sqrt(sh), wdtp, wdte);
      fhc = comfac * fem::pow2((aem / xw)) * 1.f / 48.f *
            fem::pow2((sh / sqmw)) * sh2 /
            (fem::pow2((sh - sqmhc)) + fem::pow2(gmmhc));
      /// C'''No construction yet for leptons
      FEM_DO_SAFE(i, 1, mstp(54) / 2) {
        il = 2 * i - 1;
        iu = 2 * i;
        rmql = fem::pow2(pmas(il, 1)) / sh;
        rmqu = fem::pow2(pmas(iu, 1)) / sh;
        fachc = fhc *
                ((rmql * paru(121) + rmqu / paru(121)) * (1.f - rmql - rmqu) -
                 4.f * rmql * rmqu) /
                fem::sqrt(fem::max(
                    0.f, fem::pow2((1.f - rmql - rmqu)) - 4.f * rmql * rmqu));
        if (kfac(1, il) * kfac(2, -iu) == 0) {
          goto statement_810;
        }
        kchhc = (kchg(il, 1) - kchg(iu, 1)) / 3;
        nchn++;
        isig(nchn, 1) = il;
        isig(nchn, 2) = -iu;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachc * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_810:
        if (kfac(1, -il) * kfac(2, iu) == 0) {
          goto statement_820;
        }
        kchhc = (-kchg(il, 1) + kchg(iu, 1)) / 3;
        nchn++;
        isig(nchn, 1) = -il;
        isig(nchn, 2) = iu;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachc * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_820:
        if (kfac(1, iu) * kfac(2, -il) == 0) {
          goto statement_830;
        }
        kchhc = (kchg(iu, 1) - kchg(il, 1)) / 3;
        nchn++;
        isig(nchn, 1) = iu;
        isig(nchn, 2) = -il;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachc * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_830:
        if (kfac(1, -iu) * kfac(2, il) == 0) {
          goto statement_840;
        }
        kchhc = (-kchg(iu, 1) + kchg(il, 1)) / 3;
        nchn++;
        isig(nchn, 1) = -iu;
        isig(nchn, 2) = il;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachc * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_840:;
      }
      /// C
    } else if (isub == 143) {
      /// C...f + fb -> R.
      pywidt(cmn, 40, fem::sqrt(sh), wdtp, wdte);
      facr = comfac * fem::pow2((aem / xw)) * 1.f / 9.f * sh2 /
             (fem::pow2((sh - sqmr)) + fem::pow2(gmmr));
      FEM_DO_SAFE(i, min1, max1) {
        if (i == 0 || kfac(1, i) == 0) {
          goto statement_860;
        }
        ia = fem::iabs(i);
        FEM_DO_SAFE(j, min2, max2) {
          if (j == 0 || kfac(2, j) == 0) {
            goto statement_850;
          }
          ja = fem::iabs(j);
          if (i * j > 0 || fem::iabs(ia - ja) != 2) {
            goto statement_850;
          }
          nchn++;
          isig(nchn, 1) = i;
          isig(nchn, 2) = j;
          isig(nchn, 3) = 1;
          sigh(nchn) =
              facr * (wdte(0, 1) + wdte(0, (10 - (i + j)) / 4) + wdte(0, 4));
        statement_850:;
        }
      statement_860:;
      }
      /// C
    }
    /// C
    /// C...I: 2 -> 2, tree diagrams, non-standard model processes.
    /// C
  } else {
    if (isub == 161) {
      /// C...f + g -> f' + H+/- (q + g -> q' + H+/- only).
      fhcq = comfac * faca * as * aem / xw * 1.f / 24;
      FEM_DO_SAFE(i, 1, mstp(54)) {
        iu = i + fem::mod(i, 2);
        sqmq = fem::pow2(pmas(iu, 1));
        fachcq = fhcq / paru(121) * sqmq / sqmw *
                 (sh / (sqmq - uh) +
                  2.f * sqmq * (sqmhc - uh) / fem::pow2((sqmq - uh)) +
                  (sqmq - uh) / sh + 2.f * sqmq / (sqmq - uh) +
                  2.f * (sqmhc - uh) / (sqmq - uh) * (sqmhc - sqmq - sh) / sh);
        if (kfac(1, -i) * kfac(2, 21) == 0) {
          goto statement_870;
        }
        kchhc = fem::isign(1, -kchg(i, 1));
        nchn++;
        isig(nchn, 1) = -i;
        isig(nchn, 2) = 21;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachcq * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_870:
        if (kfac(1, i) * kfac(2, 21) == 0) {
          goto statement_880;
        }
        kchhc = fem::isign(1, kchg(i, 1));
        nchn++;
        isig(nchn, 1) = i;
        isig(nchn, 2) = 21;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachcq * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_880:
        if (kfac(1, 21) * kfac(2, -i) == 0) {
          goto statement_890;
        }
        kchhc = fem::isign(1, -kchg(i, 1));
        nchn++;
        isig(nchn, 1) = 21;
        isig(nchn, 2) = -i;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachcq * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_890:
        if (kfac(1, 21) * kfac(2, i) == 0) {
          goto statement_900;
        }
        kchhc = fem::isign(1, kchg(i, 1));
        nchn++;
        isig(nchn, 1) = 21;
        isig(nchn, 2) = i;
        isig(nchn, 3) = 1;
        sigh(nchn) =
            fachcq * (wdte(0, 1) + wdte(0, (5 - kchhc) / 2) + wdte(0, 4));
      statement_900:;
      }
      /// C
    }
  }
  /// C
  /// C...Multiply with structure functions.
  if (isub <= 90 || isub >= 96) {
    FEM_DO_SAFE(ichn, 1, nchn) {
      if (mint(41) == 2) {
        kfl1 = isig(ichn, 1);
        if (kfl1 == 21) {
          kfl1 = 0;
        }
        sigh(ichn) = sigh(ichn) * xsfx(1, kfl1);
      }
      if (mint(42) == 2) {
        kfl2 = isig(ichn, 2);
        if (kfl2 == 21) {
          kfl2 = 0;
        }
        sigh(ichn) = sigh(ichn) * xsfx(2, kfl2);
      }
      sigs += sigh(ichn);
    }
  }
  /// C
}

struct pymult_save {
  int irbin;
  arr<int> nmul;
  float rbin;
  arr<float> sigm;
  float xc2;
  float xt2;
  float xt2fac;
  float xts;

  pymult_save()
      : irbin(fem::int0),
        nmul(dimension(20), fem::fill0),
        rbin(fem::float0),
        sigm(dimension(20), fem::fill0),
        xc2(fem::float0),
        xt2(fem::float0),
        xt2fac(fem::float0),
        xts(fem::float0) {}
};

/// C
/// C*********************************************************************
/// C
void pymult(common& cmn, int const& mmul) {
  FEM_CMN_SVE(pymult);
  common_write write(cmn);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float> ckin(cmn.ckin, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_cref<float, 2> coef(cmn.coef, dimension(200, 20));
  arr_ref<int, 2> ngen(cmn.ngen, dim1(0, 200).dim2(3));
  arr_cref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  int& irbin = sve.irbin;
  arr_ref<int> nmul(sve.nmul, dimension(20));
  float& rbin = sve.rbin;
  arr_ref<float> sigm(sve.sigm, dimension(20));
  float& xc2 = sve.xc2;
  float& xt2 = sve.xt2;
  float& xt2fac = sve.xt2fac;
  float& xts = sve.xts;
  int isub = fem::int0;
  float sigsum = fem::float0;
  int ixt2 = fem::int0;
  int itry = fem::int0;
  float rsca = fem::float0;
  float taup = fem::float0;
  float tau = fem::float0;
  float ryst = fem::float0;
  int myst = fem::int0;
  int nchn = fem::int0;
  float sigs = fem::float0;
  float yke = fem::float0;
  float so = fem::float0;
  float xi = fem::float0;
  float yi = fem::float0;
  float xk = fem::float0;
  int iit = fem::int0;
  float xf = fem::float0;
  float yf = fem::float0;
  float sp = fem::float0;
  float sop = fem::float0;
  float deltab = fem::float0;
  float b = fem::float0;
  float ov = fem::float0;
  float cq2 = fem::float0;
  float pacc = fem::float0;
  float yk = fem::float0;
  float rtype = fem::float0;
  float b2 = fem::float0;
  float rncor = fem::float0;
  float sigcor = fem::float0;
  int ibin = fem::int0;
  float sigabv = fem::float0;
  int nmax = fem::int0;
  int nstr = fem::int0;
  int i = fem::int0;
  int kcs = fem::int0;
  int j = fem::int0;
  int ist = fem::int0;
  arr<int, 2> kstr(dimension(500, 2), fem::fill0);
  float x1m = fem::float0;
  float x2m = fem::float0;
  float rflav = fem::float0;
  float pt = fem::float0;
  float phi = fem::float0;
  float cth = fem::float0;
  float dmin = fem::float0;
  int istr = fem::int0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  float dist = fem::float0;
  int ist1 = fem::int0;
  int ist2 = fem::int0;
  int istm = fem::int0;
  /// C
  /// C...Initializes treatment of multiple interactions, selects kinematics
  /// C...of hardest interaction if low-pT physics included in run, and
  /// C...generates all non-hardest interactions.
  /// C
  /// C...Initialization of multiple interaction treatment.
  if (mmul == 1) {
    if (mstp(122) >= 1) {
      write(mstu(11),
            "(/,1x,'****** PYMULT: initialization of multiple inter',"
            "'actions for MSTP(82) =',i2,' ******')"),
          mstp(82);
    }
    isub = 96;
    mint(1) = 96;
    vint(63) = 0.f;
    vint(64) = 0.f;
    vint(143) = 1.f;
    vint(144) = 1.f;
  /// C
  /// C...Loop over phase space points: xT2 choice in 20 bins.
  statement_100:
    sigsum = 0.f;
    FEM_DO_SAFE(ixt2, 1, 20) {
      nmul(ixt2) = mstp(83);
      sigm(ixt2) = 0.f;
      FEM_DO_SAFE(itry, 1, mstp(83)) {
        rsca = 0.05f * ((21 - ixt2) - rlu(cmn, 0));
        xt2 = vint(149) * (1.f + vint(149)) / (vint(149) + rsca) - vint(149);
        xt2 = fem::max(0.01f * vint(149), xt2);
        vint(25) = xt2;
        /// C
        /// C...Choose tau and y*. Calculate cos(theta-hat).
        if (rlu(cmn, 0) <= coef(isub, 1)) {
          taup = fem::pow((2.f * (1.f + fem::sqrt(1.f - xt2)) / xt2 - 1.f),
                          rlu(cmn, 0));
          tau = xt2 * fem::pow2((1.f + taup)) / (4.f * taup);
        } else {
          tau =
              xt2 *
              (1.f + fem::pow2(fem::tan(
                         rlu(cmn, 0) * fem::atan(fem::sqrt(1.f / xt2 - 1.f)))));
        }
        vint(21) = tau;
        pyklim(cmn, 2);
        ryst = rlu(cmn, 0);
        myst = 1;
        if (ryst > coef(isub, 7)) {
          myst = 2;
        }
        if (ryst > coef(isub, 7) + coef(isub, 8)) {
          myst = 3;
        }
        pykmap(cmn, 2, myst, rlu(cmn, 0));
        vint(23) = fem::sqrt(fem::max(0.f, 1.f - xt2 / tau)) *
                   fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
        /// C
        /// C...Calculate differential cross-section.
        vint(71) = 0.5f * vint(1) * fem::sqrt(xt2);
        pysigh(cmn, nchn, sigs);
        sigm(ixt2) += sigs;
      }
      sigsum += sigm(ixt2);
    }
    sigsum = sigsum / (20.f * mstp(83));
    /// C
    /// C...Reject result if sigma(parton-parton) is smaller than hadronic one.
    if (sigsum < 1.1f * vint(106)) {
      if (mstp(122) >= 1) {
        write(mstu(11),
              "(8x,'pT0 =',f5.2,' GeV gives sigma(parton-parton) =',1p,e9.2,"
              "' mb: rejected')"),
            parp(82), sigsum;
      }
      parp(82) = 0.9f * parp(82);
      vint(149) = 4.f * fem::pow2(parp(82)) / vint(2);
      goto statement_100;
    }
    if (mstp(122) >= 1) {
      write(mstu(11),
            "(8x,'pT0 =',f5.2,' GeV gives sigma(parton-parton) =',1p,e9.2,"
            "' mb: accepted')"),
          parp(82), sigsum;
    }
    /// C
    /// C...Start iteration to find k factor.
    yke = sigsum / vint(106);
    so = 0.5f;
    xi = 0.f;
    yi = 0.f;
    xk = 0.5f;
    iit = 0;
  statement_130:
    if (iit == 0) {
      xk = 2.f * xk;
    } else if (iit == 1) {
      xk = 0.5f * xk;
    } else {
      xk = xi + (yke - yi) * (xf - xi) / (yf - yi);
    }
    /// C
    /// C...Evaluate overlap integrals.
    if (mstp(82) == 2) {
      sp = 0.5f * paru(1) * (1.f - fem::exp(-xk));
      sop = sp / paru(1);
    } else {
      if (mstp(82) == 3) {
        deltab = 0.02f;
      }
      if (mstp(82) == 4) {
        deltab = fem::min(0.01f, 0.05f * parp(84));
      }
      sp = 0.f;
      sop = 0.f;
      b = -0.5f * deltab;
    statement_140:
      b += deltab;
      if (mstp(82) == 3) {
        ov = fem::exp(-fem::pow2(b)) / paru(2);
      } else {
        cq2 = fem::pow2(parp(84));
        ov = (fem::pow2((1.f - parp(83))) *
                  fem::exp(-fem::min(100.f, fem::pow2(b))) +
              2.f * parp(83) * (1.f - parp(83)) * 2.f / (1.f + cq2) *
                  fem::exp(-fem::min(100.f, fem::pow2(b) * 2.f / (1.f + cq2))) +
              fem::pow2(parp(83)) / cq2 *
                  fem::exp(-fem::min(100.f, fem::pow2(b) / cq2))) /
             paru(2);
      }
      pacc = 1.f - fem::exp(-fem::min(100.f, paru(1) * xk * ov));
      sp += paru(2) * b * deltab * pacc;
      sop += paru(2) * b * deltab * ov * pacc;
      if (b < 1.f || b * pacc > 1e-6f) {
        goto statement_140;
      }
    }
    yk = paru(1) * xk * so / sp;
    /// C
    /// C...Continue iteration until convergence.
    if (yk < yke) {
      xi = xk;
      yi = yk;
      if (iit == 1) {
        iit = 2;
      }
    } else {
      xf = xk;
      yf = yk;
      if (iit == 0) {
        iit = 1;
      }
    }
    if (fem::abs(yk - yke) >= 1e-5f * yke) {
      goto statement_130;
    }
    /// C
    /// C...Store some results for subsequent use.
    vint(145) = sigsum;
    vint(146) = sop / so;
    vint(147) = sop / sp;
    /// C
    /// C...Initialize iteration in xT2 for hardest interaction.
  } else if (mmul == 2) {
    if (mstp(82) <= 0) {
    } else if (mstp(82) == 1) {
      xt2 = 1.f;
      xt2fac = xsec(96, 1) / vint(106) * vint(149) / (1.f - vint(149));
    } else if (mstp(82) == 2) {
      xt2 = 1.f;
      xt2fac =
          vint(146) * xsec(96, 1) / vint(106) * vint(149) * (1.f + vint(149));
    } else {
      xc2 = 4.f * fem::pow2(ckin(3)) / vint(2);
      if (ckin(3) <= ckin(5) || mint(82) >= 2) {
        xc2 = 0.f;
      }
    }
    /// C
  } else if (mmul == 3) {
    /// C...Low-pT or multiple interactions (first semihard interaction):
    /// C...choose xT2 according to dpT2/pT2**2*exp(-(sigma above pT2)/norm)
    /// C...or (MSTP(82)>=2) dpT2/(pT2+pT0**2)**2*exp(-....).
    isub = mint(1);
    if (mstp(82) <= 0) {
      xt2 = 0.f;
    } else if (mstp(82) == 1) {
      xt2 = xt2fac * xt2 / (xt2fac - xt2 * fem::log(rlu(cmn, 0)));
    } else if (mstp(82) == 2) {
      if (xt2 < 1.f &&
          fem::exp(-xt2fac * xt2 / (vint(149) * (xt2 + vint(149)))) >
              rlu(cmn, 0)) {
        xt2 = 1.f;
      }
      if (xt2 >= 1.f) {
        xt2 = (1.f + vint(149)) * xt2fac /
                  (xt2fac -
                   (1.f + vint(149)) *
                       fem::log(1.f -
                                rlu(cmn, 0) *
                                    (1.f - fem::exp(-xt2fac /
                                                    (vint(149) *
                                                     (1.f + vint(149))))))) -
              vint(149);
      } else {
        xt2 = -xt2fac / fem::log(fem::exp(-xt2fac / (xt2 + vint(149))) +
                                 rlu(cmn, 0) *
                                     (fem::exp(-xt2fac / vint(149)) -
                                      fem::exp(-xt2fac / (xt2 + vint(149))))) -
              vint(149);
      }
      xt2 = fem::max(0.01f * vint(149), xt2);
    } else {
      xt2 = (xc2 + vint(149)) * (1.f + vint(149)) /
                (1.f + vint(149) - rlu(cmn, 0) * (1.f - xc2)) -
            vint(149);
      xt2 = fem::max(0.01f * vint(149), xt2);
    }
    vint(25) = xt2;
    /// C
    /// C...Low-pT: choose xT2, tau, y* and cos(theta-hat) fixed.
    if (mstp(82) <= 1 && xt2 < vint(149)) {
      if (mint(82) == 1) {
        ngen(0, 1) = ngen(0, 1) - 1;
      }
      if (mint(82) == 1) {
        ngen(isub, 1) = ngen(isub, 1) - 1;
      }
      isub = 95;
      mint(1) = isub;
      vint(21) = 0.01f * vint(149);
      vint(22) = 0.f;
      vint(23) = 0.f;
      vint(25) = 0.01f * vint(149);
      /// C
    } else {
      /// C...Multiple interactions (first semihard interaction).
      /// C...Choose tau and y*. Calculate cos(theta-hat).
      if (rlu(cmn, 0) <= coef(isub, 1)) {
        taup = fem::pow((2.f * (1.f + fem::sqrt(1.f - xt2)) / xt2 - 1.f),
                        rlu(cmn, 0));
        tau = xt2 * fem::pow2((1.f + taup)) / (4.f * taup);
      } else {
        tau = xt2 *
              (1.f + fem::pow2(fem::tan(
                         rlu(cmn, 0) * fem::atan(fem::sqrt(1.f / xt2 - 1.f)))));
      }
      vint(21) = tau;
      pyklim(cmn, 2);
      ryst = rlu(cmn, 0);
      myst = 1;
      if (ryst > coef(isub, 7)) {
        myst = 2;
      }
      if (ryst > coef(isub, 7) + coef(isub, 8)) {
        myst = 3;
      }
      pykmap(cmn, 2, myst, rlu(cmn, 0));
      vint(23) = fem::sqrt(fem::max(0.f, 1.f - xt2 / tau)) *
                 fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
    }
    vint(71) = 0.5f * vint(1) * fem::sqrt(vint(25));
    /// C
    /// C...Store results of cross-section calculation.
  } else if (mmul == 4) {
    isub = mint(1);
    xts = vint(25);
    if (iset(isub) == 1) {
      xts = vint(21);
    }
    if (iset(isub) == 2) {
      xts = (4.f * vint(48) + 2.f * vint(63) + 2.f * vint(64)) / vint(2);
    }
    if (iset(isub) == 3 || iset(isub) == 4) {
      xts = vint(26);
    }
    rbin = fem::max(0.000001f, fem::min(0.999999f, xts * (1.f + vint(149)) /
                                                       (xts + vint(149))));
    irbin = fem::fint(1.f + 20.f * rbin);
    if (isub == 96) {
      nmul(irbin)++;
    }
    if (isub == 96) {
      sigm(irbin) += vint(153);
    }
    /// C
    /// C...Choose impact parameter.
  } else if (mmul == 5) {
    if (mstp(82) == 3) {
      vint(148) = rlu(cmn, 0) / (paru(2) * vint(147));
    } else {
      rtype = rlu(cmn, 0);
      cq2 = fem::pow2(parp(84));
      if (rtype < fem::pow2((1.f - parp(83)))) {
        b2 = -fem::log(rlu(cmn, 0));
      } else if (rtype < 1.f - fem::pow2(parp(83))) {
        b2 = -0.5f * (1.f + cq2) * fem::log(rlu(cmn, 0));
      } else {
        b2 = -cq2 * fem::log(rlu(cmn, 0));
      }
      vint(148) =
          (fem::pow2((1.f - parp(83))) * fem::exp(-fem::min(100.f, b2)) +
           2.f * parp(83) * (1.f - parp(83)) * 2.f / (1.f + cq2) *
               fem::exp(-fem::min(100.f, b2 * 2.f / (1.f + cq2))) +
           fem::pow2(parp(83)) / cq2 * fem::exp(-fem::min(100.f, b2 / cq2))) /
          (paru(2) * vint(147));
    }
    /// C
    /// C...Multiple interactions (variable impact parameter) : reject with
    /// C...probability exp(-overlap*cross-section above pT/normalization).
    rncor = (irbin - 20.f * rbin) * nmul(irbin);
    sigcor = (irbin - 20.f * rbin) * sigm(irbin);
    FEM_DO_SAFE(ibin, irbin + 1, 20) {
      rncor += nmul(ibin);
      sigcor += sigm(ibin);
    }
    sigabv = (sigcor / rncor) * vint(149) * (1.f - xts) / (xts + vint(149));
    vint(150) =
        fem::exp(-fem::min(100.f, vint(146) * vint(148) * sigabv / vint(106)));
    /// C
    /// C...Generate additional multiple semihard interactions.
  } else if (mmul == 6) {
    /// C
    /// C...Reconstruct strings in hard scattering.
    isub = mint(1);
    nmax = mint(84) + 4;
    if (iset(isub) == 1) {
      nmax = mint(84) + 2;
    }
    nstr = 0;
    FEM_DO_SAFE(i, mint(84) + 1, nmax) {
      kcs = kchg(lucomp(cmn, k(i, 2)), 2) * fem::isign(1, k(i, 2));
      if (kcs == 0) {
        goto statement_170;
      }
      FEM_DO_SAFE(j, 1, 4) {
        if (kcs == 1 && (j == 2 || j == 4)) {
          goto statement_160;
        }
        if (kcs == -1 && (j == 1 || j == 3)) {
          goto statement_160;
        }
        if (j <= 2) {
          ist = fem::mod(k(i, j + 3) / mstu(5), mstu(5));
        } else {
          ist = fem::mod(k(i, j + 1), mstu(5));
        }
        if (ist < mint(84) || ist > i) {
          goto statement_160;
        }
        if (kchg(lucomp(cmn, k(ist, 2)), 2) == 0) {
          goto statement_160;
        }
        nstr++;
        if (j == 1 || j == 4) {
          kstr(nstr, 1) = i;
          kstr(nstr, 2) = ist;
        } else {
          kstr(nstr, 1) = ist;
          kstr(nstr, 2) = i;
        }
      statement_160:;
      }
    statement_170:;
    }
    /// C
    /// C...Set up starting values for iteration in xT2.
    xt2 = vint(25);
    if (iset(isub) == 1) {
      xt2 = vint(21);
    }
    if (iset(isub) == 2) {
      xt2 = (4.f * vint(48) + 2.f * vint(63) + 2.f * vint(64)) / vint(2);
    }
    if (iset(isub) == 3 || iset(isub) == 4) {
      xt2 = vint(26);
    }
    isub = 96;
    mint(1) = 96;
    if (mstp(82) <= 1) {
      xt2fac = xsec(isub, 1) * vint(149) / ((1.f - vint(149)) * vint(106));
    } else {
      xt2fac = vint(146) * vint(148) * xsec(isub, 1) / vint(106) * vint(149) *
               (1.f + vint(149));
    }
    vint(63) = 0.f;
    vint(64) = 0.f;
    vint(151) = 0.f;
    vint(152) = 0.f;
    vint(143) = 1.f - vint(141);
    vint(144) = 1.f - vint(142);
  /// C
  /// C...Iterate downwards in xT2.
  statement_180:
    if (mstp(82) <= 1) {
      xt2 = xt2fac * xt2 / (xt2fac - xt2 * fem::log(rlu(cmn, 0)));
      if (xt2 < vint(149)) {
        goto statement_220;
      }
    } else {
      if (xt2 <= 0.01f * vint(149)) {
        goto statement_220;
      }
      xt2 = xt2fac * (xt2 + vint(149)) /
                (xt2fac - (xt2 + vint(149)) * fem::log(rlu(cmn, 0))) -
            vint(149);
      if (xt2 <= 0.f) {
        goto statement_220;
      }
      xt2 = fem::max(0.01f * vint(149), xt2);
    }
    vint(25) = xt2;
    /// C
    /// C...Choose tau and y*. Calculate cos(theta-hat).
    if (rlu(cmn, 0) <= coef(isub, 1)) {
      taup = fem::pow((2.f * (1.f + fem::sqrt(1.f - xt2)) / xt2 - 1.f),
                      rlu(cmn, 0));
      tau = xt2 * fem::pow2((1.f + taup)) / (4.f * taup);
    } else {
      tau = xt2 *
            (1.f + fem::pow2(fem::tan(rlu(cmn, 0) *
                                      fem::atan(fem::sqrt(1.f / xt2 - 1.f)))));
    }
    vint(21) = tau;
    pyklim(cmn, 2);
    ryst = rlu(cmn, 0);
    myst = 1;
    if (ryst > coef(isub, 7)) {
      myst = 2;
    }
    if (ryst > coef(isub, 7) + coef(isub, 8)) {
      myst = 3;
    }
    pykmap(cmn, 2, myst, rlu(cmn, 0));
    vint(23) = fem::sqrt(fem::max(0.f, 1.f - xt2 / tau)) *
               fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
    /// C
    /// C...Check that x not used up. Accept or reject kinematical variables.
    x1m = fem::sqrt(tau) * fem::exp(vint(22));
    x2m = fem::sqrt(tau) * fem::exp(-vint(22));
    if (vint(143) - x1m < 0.01f || vint(144) - x2m < 0.01f) {
      goto statement_180;
    }
    vint(71) = 0.5f * vint(1) * fem::sqrt(xt2);
    pysigh(cmn, nchn, sigs);
    if (sigs < xsec(isub, 1) * rlu(cmn, 0)) {
      goto statement_180;
    }
    /// C
    /// C...Reset K, P and V vectors. Select some variables.
    FEM_DO_SAFE(i, n + 1, n + 2) {
      FEM_DO_SAFE(j, 1, 5) {
        k(i, j) = 0;
        p(i, j) = 0.f;
        v(i, j) = 0.f;
      }
    }
    rflav = rlu(cmn, 0);
    pt = 0.5f * vint(1) * fem::sqrt(xt2);
    phi = paru(2) * rlu(cmn, 0);
    cth = vint(23);
    /// C
    /// C...Add first parton to event record.
    k(n + 1, 1) = 3;
    k(n + 1, 2) = 21;
    if (rflav >= fem::max(parp(85), parp(86))) {
      k(n + 1, 2) = 1 + fem::fint((2.f + parj(2)) * rlu(cmn, 0));
    }
    p(n + 1, 1) = pt * fem::cos(phi);
    p(n + 1, 2) = pt * fem::sin(phi);
    p(n + 1, 3) =
        0.25f * vint(1) * (vint(41) * (1.f + cth) - vint(42) * (1.f - cth));
    p(n + 1, 4) =
        0.25f * vint(1) * (vint(41) * (1.f + cth) + vint(42) * (1.f - cth));
    p(n + 1, 5) = 0.f;
    /// C
    /// C...Add second parton to event record.
    k(n + 2, 1) = 3;
    k(n + 2, 2) = 21;
    if (k(n + 1, 2) != 21) {
      k(n + 2, 2) = -k(n + 1, 2);
    }
    p(n + 2, 1) = -p(n + 1, 1);
    p(n + 2, 2) = -p(n + 1, 2);
    p(n + 2, 3) =
        0.25f * vint(1) * (vint(41) * (1.f - cth) - vint(42) * (1.f + cth));
    p(n + 2, 4) =
        0.25f * vint(1) * (vint(41) * (1.f - cth) + vint(42) * (1.f + cth));
    p(n + 2, 5) = 0.f;
    /// C
    if (rflav < parp(85) && nstr >= 1) {
      /// C....Choose relevant string pieces to place gluons on.
      FEM_DO_SAFE(i, n + 1, n + 2) {
        dmin = 1e8f;
        FEM_DO_SAFE(istr, 1, nstr) {
          i1 = kstr(istr, 1);
          i2 = kstr(istr, 2);
          dist = (p(i, 4) * p(i1, 4) - p(i, 1) * p(i1, 1) - p(i, 2) * p(i1, 2) -
                  p(i, 3) * p(i1, 3)) *
                 (p(i, 4) * p(i2, 4) - p(i, 1) * p(i2, 1) - p(i, 2) * p(i2, 2) -
                  p(i, 3) * p(i2, 3)) /
                 fem::max(1.f, p(i1, 4) * p(i2, 4) - p(i1, 1) * p(i2, 1) -
                                   p(i1, 2) * p(i2, 2) - p(i1, 3) * p(i2, 3));
          if (istr == 1 || dist < dmin) {
            dmin = dist;
            ist1 = i1;
            ist2 = i2;
            istm = istr;
          }
        }
        /// C
        /// C....Colour flow adjustments, new string pieces.
        if (k(ist1, 4) / mstu(5) == ist2) {
          k(ist1, 4) = mstu(5) * i + fem::mod(k(ist1, 4), mstu(5));
        }
        if (fem::mod(k(ist1, 5), mstu(5)) == ist2) {
          k(ist1, 5) = mstu(5) * (k(ist1, 5) / mstu(5)) + i;
        }
        k(i, 5) = mstu(5) * ist1;
        k(i, 4) = mstu(5) * ist2;
        if (k(ist2, 5) / mstu(5) == ist1) {
          k(ist2, 5) = mstu(5) * i + fem::mod(k(ist2, 5), mstu(5));
        }
        if (fem::mod(k(ist2, 4), mstu(5)) == ist1) {
          k(ist2, 4) = mstu(5) * (k(ist2, 4) / mstu(5)) + i;
        }
        kstr(istm, 2) = i;
        kstr(nstr + 1, 1) = i;
        kstr(nstr + 1, 2) = ist2;
        nstr++;
      }
      /// C
      /// C...String drawing and colour flow for gluon loop.
    } else if (k(n + 1, 2) == 21) {
      k(n + 1, 4) = mstu(5) * (n + 2);
      k(n + 1, 5) = mstu(5) * (n + 2);
      k(n + 2, 4) = mstu(5) * (n + 1);
      k(n + 2, 5) = mstu(5) * (n + 1);
      kstr(nstr + 1, 1) = n + 1;
      kstr(nstr + 1, 2) = n + 2;
      kstr(nstr + 2, 1) = n + 2;
      kstr(nstr + 2, 2) = n + 1;
      nstr += 2;
      /// C
      /// C...String drawing and colour flow for q-qbar pair.
    } else {
      k(n + 1, 4) = mstu(5) * (n + 2);
      k(n + 2, 5) = mstu(5) * (n + 1);
      kstr(nstr + 1, 1) = n + 1;
      kstr(nstr + 1, 2) = n + 2;
      nstr++;
    }
    /// C
    /// C...Update remaining energy; iterate.
    n += 2;
    if (n > mstu(4) - mstu(32) - 10) {
      luerrm(cmn, 11, "(PYMULT:) no more memory left in LUJETS");
      if (mstu(21) >= 1) {
        return;
      }
    }
    mint(31)++;
    vint(151) += vint(41);
    vint(152) += vint(42);
    vint(143) = vint(143) - vint(41);
    vint(144) = vint(144) - vint(42);
    if (mint(31) < 240) {
      goto statement_180;
    }
  statement_220:;
  }
  /// C
  /// C...Format statements for printout.
  /// C
}

/// C
/// C*********************************************************************
/// C
void pyspli(common& cmn, int const& kf, int const& kflin, int& kflch,
            int& kflsp) {
  /// C
  /// C...In case of a hadron remnant which is more complicated than just a
  /// C...quark or a diquark, split it into two (partons or hadron + parton).
  /// C
  /// C...Preliminaries. Parton composition.
  int kfa = fem::iabs(kf);
  int kfs = fem::isign(1, kf);
  arr_1d<3, int> kfl(fem::fill0);
  kfl(1) = fem::mod(kfa / 1000, 10);
  kfl(2) = fem::mod(kfa / 100, 10);
  kfl(3) = fem::mod(kfa / 10, 10);
  int kflr = kflin * kfs;
  kflch = 0;
  /// C
  /// C...Subdivide meson.
  int kfdump = fem::int0;
  int nagr = fem::int0;
  int j = fem::int0;
  float ragr = fem::float0;
  int iagr = fem::int0;
  int id1 = fem::int0;
  int id2 = fem::int0;
  int ksp = fem::int0;
  if (kfl(1) == 0) {
    kfl(2) = kfl(2) * fem::pow((-1), kfl(2));
    kfl(3) = -kfl(3) * fem::pow((-1), fem::iabs(kfl(2)));
    if (kflr == kfl(2)) {
      kflsp = kfl(3);
    } else if (kflr == kfl(3)) {
      kflsp = kfl(2);
    } else if (fem::iabs(kflr) == 21 && rlu(cmn, 0) > 0.5f) {
      kflsp = kfl(2);
      kflch = kfl(3);
    } else if (fem::iabs(kflr) == 21) {
      kflsp = kfl(3);
      kflch = kfl(2);
    } else if (kflr * kfl(2) > 0) {
      lukfdi(cmn, -kflr, kfl(2), kfdump, kflch);
      kflsp = kfl(3);
    } else {
      lukfdi(cmn, -kflr, kfl(3), kfdump, kflch);
      kflsp = kfl(2);
    }
    /// C
    /// C...Subdivide baryon.
  } else {
    nagr = 0;
    FEM_DO_SAFE(j, 1, 3) {
      if (kflr == kfl(j)) {
        nagr++;
      }
    }
    if (nagr >= 1) {
      ragr = 0.00001f + (nagr - 0.00002f) * rlu(cmn, 0);
      iagr = 0;
      FEM_DO_SAFE(j, 1, 3) {
        if (kflr == kfl(j)) {
          ragr = ragr - 1.f;
        }
        if (iagr == 0 && ragr <= 0.f) {
          iagr = j;
        }
      }
    } else {
      iagr = fem::fint(1.00001f + 2.99998f * rlu(cmn, 0));
    }
    id1 = 1;
    if (iagr == 1) {
      id1 = 2;
    }
    if (iagr == 1 && kfl(3) > kfl(2)) {
      id1 = 3;
    }
    id2 = 6 - iagr - id1;
    ksp = 3;
    if (fem::mod(kfa, 10) == 2 && kfl(1) == kfl(2)) {
      if (iagr != 3 && rlu(cmn, 0) > 0.25f) {
        ksp = 1;
      }
    } else if (fem::mod(kfa, 10) == 2 && kfl(2) >= kfl(3)) {
      if (iagr != 1 && rlu(cmn, 0) > 0.25f) {
        ksp = 1;
      }
    } else if (fem::mod(kfa, 10) == 2) {
      if (iagr == 1) {
        ksp = 1;
      }
      if (iagr != 1 && rlu(cmn, 0) > 0.75f) {
        ksp = 1;
      }
    }
    kflsp = 1000 * kfl(id1) + 100 * kfl(id2) + ksp;
    if (kflin == 21) {
      kflch = kfl(iagr);
    } else if (nagr == 0 && kflr > 0) {
      lukfdi(cmn, -kflr, kfl(iagr), kfdump, kflch);
    } else if (nagr == 0) {
      lukfdi(cmn, 10000 + kflsp, -kflr, kfdump, kflch);
      kflsp = kfl(iagr);
    }
  }
  /// C
  /// C...Add on correct sign for result.
  kflch = kflch * kfs;
  kflsp = kflsp * kfs;
  /// C
}

/// C
/// C*********************************************************************
/// C
void pykcut(common& cmn, int& mcut) {
  /// C
  /// C...Dummy routine, which the user can replace in order to make cuts on
  /// C...the kinematics on the parton level before the matrix elements are
  /// C...evaluated and the event is generated. The cross-section estimates
  /// C...will automatically take these cuts into account, so the given
  /// C...values are for the allowed phase space region only. MCUT=0 means
  /// C...that the event has passed the cuts, MCUT=1 that it has failed.
  /// C
  mcut = 0;
  /// C
}

/// C
/// C*********************************************************************
/// C
void pyrand(common& cmn) {
  common_write write(cmn);
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int> msub(cmn.msub, dimension(200));
  arr_cref<float> ckin(cmn.ckin, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_cref<int, 2> kfpr(cmn.kfpr, dimension(200, 2));
  arr_cref<float, 2> coef(cmn.coef, dimension(200, 20));
  arr_cref<int, 2> isig(cmn.isig, dimension(1000, 3));
  arr_cref<float> sigh(cmn.sigh, dimension(1000));
  arr_ref<int, 2> ngen(cmn.ngen, dim1(0, 200).dim2(3));
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  int isub = fem::int0;
  float rsub = fem::float0;
  int i = fem::int0;
  int kfr1 = fem::int0;
  float taur1 = fem::float0;
  float gamr1 = fem::float0;
  int kfr2 = fem::int0;
  float taur2 = fem::float0;
  float gamr2 = fem::float0;
  int is = fem::int0;
  float sh = fem::float0;
  float sqm1 = fem::float0;
  float sqm2 = fem::float0;
  float sqm3 = fem::float0;
  float sqm4 = fem::float0;
  float sqla12 = fem::float0;
  float sqla34 = fem::float0;
  float thter1 = fem::float0;
  float thter2 = fem::float0;
  float thl = fem::float0;
  float thu = fem::float0;
  float thm = fem::float0;
  int jtmax = fem::int0;
  int jt = fem::int0;
  float sqmmin = fem::float0;
  float sqmi = fem::float0;
  float sqmj = fem::float0;
  float sqmf = fem::float0;
  float squa = fem::float0;
  float quar = fem::float0;
  float sqmmax = fem::float0;
  float b = fem::float0;
  float c = fem::float0;
  float expth = fem::float0;
  float tharg = fem::float0;
  float th = fem::float0;
  float ratlog = fem::float0;
  float rtau = fem::float0;
  int mtau = fem::int0;
  float rtaup = fem::float0;
  int mtaup = fem::int0;
  float ryst = fem::float0;
  int myst = fem::int0;
  float rcth = fem::float0;
  int mcth = fem::int0;
  int mcut = fem::int0;
  int nchn = fem::int0;
  float sigs = fem::float0;
  float viol = fem::float0;
  float xdif = fem::float0;
  float rsigs = fem::float0;
  float qt2 = fem::float0;
  float rqqbar = fem::float0;
  int ichn = fem::int0;
  int kfl1 = fem::int0;
  int kfl2 = fem::int0;
  int kfldum = fem::int0;
  /// C
  /// C...Generates quantities characterizing the high-pT scattering at the
  /// C...parton level according to the matrix elements. Chooses incoming,
  /// C...reacting partons, their momentum fractions and one of the possible
  /// C...subprocesses.
  /// C
  /// C...Initial values, specifically for (first) semihard interaction.
  mint(17) = 0;
  mint(18) = 0;
  vint(143) = 1.f;
  vint(144) = 1.f;
  if (msub(95) == 1 || mint(82) >= 2) {
    pymult(cmn, 2);
  }
  isub = 0;
statement_100:
  mint(51) = 0;
  /// C
  /// C...Choice of process type - first event of overlay.
  if (mint(82) == 1 && (isub <= 90 || isub > 96)) {
    rsub = xsec(0, 1) * rlu(cmn, 0);
    FEM_DO_SAFE(i, 1, 200) {
      if (msub(i) != 1) {
        goto statement_110;
      }
      isub = i;
      rsub = rsub - xsec(i, 1);
      if (rsub <= 0.f) {
        goto statement_120;
      }
    statement_110:;
    }
  statement_120:
    if (isub == 95) {
      isub = 96;
    }
    /// C
    /// C...Choice of inclusive process type - overlayed events.
  } else if (mint(82) >= 2 && isub == 0) {
    rsub = vint(131) * rlu(cmn, 0);
    isub = 96;
    if (rsub > vint(106)) {
      isub = 93;
    }
    if (rsub > vint(106) + vint(104)) {
      isub = 92;
    }
    if (rsub > vint(106) + vint(104) + vint(103)) {
      isub = 91;
    }
  }
  if (mint(82) == 1) {
    ngen(0, 1)++;
  }
  if (mint(82) == 1) {
    ngen(isub, 1)++;
  }
  mint(1) = isub;
  /// C
  /// C...Find resonances (explicit or implicit in cross-section).
  mint(72) = 0;
  kfr1 = 0;
  if (iset(isub) == 1 || iset(isub) == 3) {
    kfr1 = kfpr(isub, 1);
  } else if (isub >= 71 && isub <= 77) {
    kfr1 = 25;
  }
  if (kfr1 != 0) {
    taur1 = fem::pow2(pmas(kfr1, 1)) / vint(2);
    gamr1 = pmas(kfr1, 1) * pmas(kfr1, 2) / vint(2);
    mint(72) = 1;
    mint(73) = kfr1;
    vint(73) = taur1;
    vint(74) = gamr1;
  }
  if (isub == 141) {
    kfr2 = 23;
    taur2 = fem::pow2(pmas(kfr2, 1)) / vint(2);
    gamr2 = pmas(kfr2, 1) * pmas(kfr2, 2) / vint(2);
    mint(72) = 2;
    mint(74) = kfr2;
    vint(75) = taur2;
    vint(76) = gamr2;
  }
  /// C
  /// C...Find product masses and minimum pT of process,
  /// C...optionally with broadening according to a truncated Breit-Wigner.
  vint(63) = 0.f;
  vint(64) = 0.f;
  mint(71) = 0;
  vint(71) = ckin(3);
  if (mint(82) >= 2) {
    vint(71) = 0.f;
  }
  if (iset(isub) == 2 || iset(isub) == 4) {
    FEM_DO_SAFE(i, 1, 2) {
      if (kfpr(isub, i) == 0) {
      } else if (mstp(42) <= 0) {
        vint(62 + i) = fem::pow2(pmas(kfpr(isub, i), 1));
      } else {
        vint(62 + i) = fem::pow2(ulmass(cmn, kfpr(isub, i)));
      }
    }
    if (fem::min(vint(63), vint(64)) < fem::pow2(ckin(6))) {
      mint(71) = 1;
    }
    if (mint(71) == 1) {
      vint(71) = fem::max(ckin(3), ckin(5));
    }
  }
  /// C
  if (iset(isub) == 0) {
    /// C...Double or single diffractive, or elastic scattering:
    /// C...choose m^2 according to 1/m^2 (diffractive), constant (elastic)
    is = fem::fint(1.5f + rlu(cmn, 0));
    vint(63) = fem::pow2(vint(3));
    vint(64) = fem::pow2(vint(4));
    if (isub == 92 || isub == 93) {
      vint(62 + is) = fem::pow2(parp(111));
    }
    if (isub == 93) {
      vint(65 - is) = fem::pow2(parp(111));
    }
    sh = vint(2);
    sqm1 = fem::pow2(vint(3));
    sqm2 = fem::pow2(vint(4));
    sqm3 = vint(63);
    sqm4 = vint(64);
    sqla12 = fem::pow2((sh - sqm1 - sqm2)) - 4.f * sqm1 * sqm2;
    sqla34 = fem::pow2((sh - sqm3 - sqm4)) - 4.f * sqm3 * sqm4;
    thter1 =
        sqm1 + sqm2 + sqm3 + sqm4 - (sqm1 - sqm2) * (sqm3 - sqm4) / sh - sh;
    thter2 = fem::sqrt(fem::max(0.f, sqla12)) *
             fem::sqrt(fem::max(0.f, sqla34)) / sh;
    thl = 0.5f * (thter1 - thter2);
    thu = 0.5f * (thter1 + thter2);
    thm = fem::min(fem::max(thl, parp(101)), thu);
    jtmax = 0;
    if (isub == 92 || isub == 93) {
      jtmax = isub - 91;
    }
    FEM_DO_SAFE(jt, 1, jtmax) {
      mint(13 + 3 * jt - is * (2 * jt - 3)) = 1;
      sqmmin = vint(59 + 3 * jt - is * (2 * jt - 3));
      sqmi = fem::pow2(vint(8 - 3 * jt + is * (2 * jt - 3)));
      sqmj = fem::pow2(vint(3 * jt - 1 - is * (2 * jt - 3)));
      sqmf = vint(68 - 3 * jt + is * (2 * jt - 3));
      squa = 0.5f * sh / sqmi *
             ((1.f + (sqmi - sqmj) / sh) * thm + sqmi - sqmf -
              fem::pow2(sqmj) / sh + (sqmi + sqmj) * sqmf / sh +
              fem::pow2((sqmi - sqmj)) / fem::pow2(sh) * sqmf);
      quar =
          sh / sqmi *
          (thm * (thm + sh - sqmi - sqmj - sqmf * (1.f - (sqmi - sqmj) / sh)) +
           sqmi * sqmj - sqmj * sqmf * (1.f + (sqmi - sqmj - sqmf) / sh));
      sqmmax = squa + fem::sqrt(fem::max(0.f, fem::pow2(squa) - quar));
      if (fem::abs(quar / fem::pow2(squa)) < 1.e-06f) {
        sqmmax = 0.5f * quar / squa;
      }
      sqmmax = fem::min(sqmmax, fem::pow2((vint(1) - fem::sqrt(sqmf))));
      vint(59 + 3 * jt - is * (2 * jt - 3)) =
          sqmmin * fem::pow((sqmmax / sqmmin), rlu(cmn, 0));
    }
    /// C...Choose t-hat according to exp(B*t-hat+C*t-hat^2).
    sqm3 = vint(63);
    sqm4 = vint(64);
    sqla34 = fem::pow2((sh - sqm3 - sqm4)) - 4.f * sqm3 * sqm4;
    thter1 =
        sqm1 + sqm2 + sqm3 + sqm4 - (sqm1 - sqm2) * (sqm3 - sqm4) / sh - sh;
    thter2 = fem::sqrt(fem::max(0.f, sqla12)) *
             fem::sqrt(fem::max(0.f, sqla34)) / sh;
    thl = 0.5f * (thter1 - thter2);
    thu = 0.5f * (thter1 + thter2);
    b = vint(121);
    c = vint(122);
    if (isub == 92 || isub == 93) {
      b = 0.5f * b;
      c = 0.5f * c;
    }
    thm = fem::min(fem::max(thl, parp(101)), thu);
    expth = 0.f;
    tharg = b * (thm - thu);
    if (tharg > -20.f) {
      expth = fem::exp(tharg);
    }
  statement_150:
    th = thu + fem::log(expth + (1.f - expth) * rlu(cmn, 0)) / b;
    th = fem::max(thm, fem::min(thu, th));
    ratlog = fem::min((b + c * (th + thm)) * (th - thm),
                      (b + c * (th + thu)) * (th - thu));
    if (ratlog < fem::log(rlu(cmn, 0))) {
      goto statement_150;
    }
    vint(21) = 1.f;
    vint(22) = 0.f;
    vint(23) = fem::min(1.f, fem::max(-1.f, (2.f * th - thter1) / thter2));
    /// C
    /// C...Note: in the following, by In is meant the integral over the
    /// C...quantity multiplying coefficient cn.
    /// C...Choose tau according to h1(tau)/tau, where
    /// C...h1(tau) = c0 + I0/I1*c1*1/tau + I0/I2*c2*1/(tau+tau_R) +
    /// C...I0/I3*c3*tau/((s*tau-m^2)^2+(m*Gamma)^2) +
    /// C...I0/I4*c4*1/(tau+tau_R') +
    /// C...I0/I5*c5*tau/((s*tau-m'^2)^2+(m'*Gamma')^2), and
    /// C...c0 + c1 + c2 + c3 + c4 + c5 = 1
  } else if (iset(isub) >= 1 && iset(isub) <= 4) {
    pyklim(cmn, 1);
    if (mint(51) != 0) {
      goto statement_100;
    }
    rtau = rlu(cmn, 0);
    mtau = 1;
    if (rtau > coef(isub, 1)) {
      mtau = 2;
    }
    if (rtau > coef(isub, 1) + coef(isub, 2)) {
      mtau = 3;
    }
    if (rtau > coef(isub, 1) + coef(isub, 2) + coef(isub, 3)) {
      mtau = 4;
    }
    if (rtau > coef(isub, 1) + coef(isub, 2) + coef(isub, 3) + coef(isub, 4)) {
      mtau = 5;
    }
    if (rtau > coef(isub, 1) + coef(isub, 2) + coef(isub, 3) + coef(isub, 4) +
                   coef(isub, 5)) {
      mtau = 6;
    }
    pykmap(cmn, 1, mtau, rlu(cmn, 0));
    /// C
    /// C...2 -> 3, 4 processes:
    /// C...Choose tau' according to h4(tau,tau')/tau', where
    /// C...h4(tau,tau') = c0 + I0/I1*c1*(1 - tau/tau')^3/tau', and
    /// C...c0 + c1 = 1.
    if (iset(isub) == 3 || iset(isub) == 4) {
      pyklim(cmn, 4);
      if (mint(51) != 0) {
        goto statement_100;
      }
      rtaup = rlu(cmn, 0);
      mtaup = 1;
      if (rtaup > coef(isub, 15)) {
        mtaup = 2;
      }
      pykmap(cmn, 4, mtaup, rlu(cmn, 0));
    }
    /// C
    /// C...Choose y* according to h2(y*), where
    /// C...h2(y*) = I0/I1*c1*(y*-y*min) + I0/I2*c2*(y*max-y*) +
    /// C...I0/I3*c3*1/cosh(y*), I0 = y*max-y*min, and c1 + c2 + c3 = 1.
    pyklim(cmn, 2);
    if (mint(51) != 0) {
      goto statement_100;
    }
    ryst = rlu(cmn, 0);
    myst = 1;
    if (ryst > coef(isub, 7)) {
      myst = 2;
    }
    if (ryst > coef(isub, 7) + coef(isub, 8)) {
      myst = 3;
    }
    pykmap(cmn, 2, myst, rlu(cmn, 0));
    /// C
    /// C...2 -> 2 processes:
    /// C...Choose cos(theta-hat) (cth) according to h3(cth), where
    /// C...h3(cth) = c0 + I0/I1*c1*1/(A - cth) + I0/I2*c2*1/(A + cth) +
    /// C...I0/I3*c3*1/(A - cth)^2 + I0/I4*c4*1/(A + cth)^2,
    /// C...A = 1 + 2*(m3*m4/sh)^2 (= 1 for massless products),
    /// C...and c0 + c1 + c2 + c3 + c4 = 1.
    pyklim(cmn, 3);
    if (mint(51) != 0) {
      goto statement_100;
    }
    if (iset(isub) == 2 || iset(isub) == 4) {
      rcth = rlu(cmn, 0);
      mcth = 1;
      if (rcth > coef(isub, 10)) {
        mcth = 2;
      }
      if (rcth > coef(isub, 10) + coef(isub, 11)) {
        mcth = 3;
      }
      if (rcth > coef(isub, 10) + coef(isub, 11) + coef(isub, 12)) {
        mcth = 4;
      }
      if (rcth >
          coef(isub, 10) + coef(isub, 11) + coef(isub, 12) + coef(isub, 13)) {
        mcth = 5;
      }
      pykmap(cmn, 3, mcth, rlu(cmn, 0));
    }
    /// C
    /// C...Low-pT or multiple interactions (first semihard interaction).
  } else if (iset(isub) == 5) {
    pymult(cmn, 3);
    isub = mint(1);
  }
  /// C
  /// C...Choose azimuthal angle.
  vint(24) = paru(2) * rlu(cmn, 0);
  /// C
  /// C...Check against user cuts on kinematics at parton level.
  mint(51) = 0;
  if (isub <= 90 || isub > 100) {
    pyklim(cmn, 0);
  }
  if (mint(51) != 0) {
    goto statement_100;
  }
  if (mint(82) == 1 && mstp(141) >= 1) {
    mcut = 0;
    if (msub(91) + msub(92) + msub(93) + msub(94) + msub(95) == 0) {
      pykcut(cmn, mcut);
    }
    if (mcut != 0) {
      goto statement_100;
    }
  }
  /// C
  /// C...Calculate differential cross-section for different subprocesses.
  pysigh(cmn, nchn, sigs);
  /// C
  /// C...Calculations for Monte Carlo estimate of all cross-sections.
  if (mint(82) == 1 && isub <= 90 || isub >= 96) {
    xsec(isub, 2) += sigs;
  } else if (mint(82) == 1) {
    xsec(isub, 2) += xsec(isub, 1);
  }
  /// C
  /// C...Multiple interactions: store results of cross-section calculation.
  if (mint(43) == 4 && mstp(82) >= 3) {
    vint(153) = sigs;
    pymult(cmn, 4);
  }
  /// C
  /// C...Weighting using estimate of maximum of differential cross-section.
  viol = sigs / xsec(isub, 1);
  if (viol < rlu(cmn, 0)) {
    goto statement_100;
  }
  /// C
  /// C...Check for possible violation of estimated maximum of differential
  /// C...cross-section used in weighting.
  if (mstp(123) <= 0) {
    if (viol > 1.f) {
      write(
          mstu(11),
          "(1x,'Error: maximum violated by',1p,e11.3,1x,'in event',1x,i7,'.',/,"
          "1x,'Execution stopped!')"),
          viol, ngen(0, 3) + 1;
      write(mstu(11),
            "(1x,'ISUB = ',i3,'; Point of violation:',/,1x,'tau=',1p,e11.3,"
            "', y* =',e11.3,', cthe = ',0p,f11.7,', tau'' =',1p,e11.3)"),
          isub, vint(21), vint(22), vint(23), vint(26);
      FEM_STOP(0);
    }
  } else if (mstp(123) == 1) {
    if (viol > vint(108)) {
      vint(108) = viol;
      /// C          IF(VIOL.GT.1.) THEN
      /// C            WRITE(MSTU(11),1200) VIOL,NGEN(0,3)+1
      /// C            WRITE(MSTU(11),1100) ISUB,VINT(21),VINT(22),VINT(23),
      /// C     &      VINT(26)
      /// C          ENDIF
    }
  } else if (viol > vint(108)) {
    vint(108) = viol;
    if (viol > 1.f) {
      xdif = xsec(isub, 1) * (viol - 1.f);
      xsec(isub, 1) += xdif;
      if (msub(isub) == 1 && (isub <= 90 || isub > 96)) {
        xsec(0, 1) += xdif;
      }
      /// C          WRITE(MSTU(11),1200) VIOL,NGEN(0,3)+1
      /// C          WRITE(MSTU(11),1100)
      /// ISUB,VINT(21),VINT(22),VINT(23),VINT(26) C          IF(ISUB.LE.9) THEN
      /// C            WRITE(MSTU(11),1300) ISUB,XSEC(ISUB,1)
      /// C          ELSEIF(ISUB.LE.99) THEN
      /// C            WRITE(MSTU(11),1400) ISUB,XSEC(ISUB,1)
      /// C          ELSE
      /// C            WRITE(MSTU(11),1500) ISUB,XSEC(ISUB,1)
      /// C          ENDIF
      vint(108) = 1.f;
    }
  }
  /// C
  /// C...Multiple interactions: choose impact parameter.
  vint(148) = 1.f;
  if (mint(43) == 4 && (isub <= 90 || isub >= 96) && mstp(82) >= 3) {
    pymult(cmn, 5);
    if (vint(150) < rlu(cmn, 0)) {
      goto statement_100;
    }
  }
  if (mint(82) == 1 && msub(95) == 1) {
    if (isub <= 90 || isub >= 95) {
      ngen(95, 1)++;
    }
    if (isub <= 90 || isub >= 96) {
      ngen(96, 2)++;
    }
  }
  if (isub <= 90 || isub >= 96) {
    mint(31)++;
  }
  /// C
  /// C...Choose flavour of reacting partons (and subprocess).
  rsigs = sigs * rlu(cmn, 0);
  qt2 = vint(48);
  rqqbar = parp(87) *
           (1.f - fem::pow2((qt2 / (qt2 + fem::pow2((parp(88) * parp(82)))))));
  if (isub != 95 && (isub != 96 || mstp(82) <= 1 || rlu(cmn, 0) > rqqbar)) {
    FEM_DO_SAFE(ichn, 1, nchn) {
      kfl1 = isig(ichn, 1);
      kfl2 = isig(ichn, 2);
      mint(2) = isig(ichn, 3);
      rsigs = rsigs - sigh(ichn);
      if (rsigs <= 0.f) {
        goto statement_210;
      }
    }
    /// C
    /// C...Multiple interactions: choose qqbar preferentially at small pT.
  } else if (isub == 96) {
    pyspli(cmn, mint(11), 21, kfl1, kfldum);
    pyspli(cmn, mint(12), 21, kfl2, kfldum);
    mint(1) = 11;
    mint(2) = 1;
    if (kfl1 == kfl2 && rlu(cmn, 0) < 0.5f) {
      mint(2) = 2;
    }
    /// C
    /// C...Low-pT: choose string drawing configuration.
  } else {
    kfl1 = 21;
    kfl2 = 21;
    rsigs = 6.f * rlu(cmn, 0);
    mint(2) = 1;
    if (rsigs > 1.f) {
      mint(2) = 2;
    }
    if (rsigs > 2.f) {
      mint(2) = 3;
    }
  }
/// C
/// C...Reassign QCD process. Partons before initial state radiation.
statement_210:
  if (mint(2) > 10) {
    mint(1) = mint(2) / 10;
    mint(2) = fem::mod(mint(2), 10);
  }
  mint(15) = kfl1;
  mint(16) = kfl2;
  mint(13) = mint(15);
  mint(14) = mint(16);
  vint(141) = vint(41);
  vint(142) = vint(42);
  /// C
  /// C...Format statements for differential cross-section maximum violations.
  /// Clin 1200 FORMAT(1X,'Warning: maximum violated by',1P,E11.3,1X,
  /// C     &'in event',1X,I7)
  /// C 1300 FORMAT(1X,'XSEC(',I1,',1) increased to',1P,E11.3)
  /// C 1400 FORMAT(1X,'XSEC(',I2,',1) increased to',1P,E11.3)
  /// Clin 1500 FORMAT(1X,'XSEC(',I3,',1) increased to',1P,E11.3)
  /// C
}

/// C
/// C*********************************************************************
/// C
void pyscat(common& cmn) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<float, 2> vckm(cmn.vckm, dimension(4, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_cref<int, 2> kfpr(cmn.kfpr, dimension(200, 2));
  arr_cref<int, 3> icol(cmn.icol, dimension(40, 4, 2));
  ///
  int isub = fem::int0;
  int idoc = fem::int0;
  int ipu1 = fem::int0;
  int ipu2 = fem::int0;
  int ipu3 = fem::int0;
  int ipu4 = fem::int0;
  int ipu5 = fem::int0;
  int ipu6 = fem::int0;
  int jt = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int kfres = fem::int0;
  float sh = fem::float0;
  float shr = fem::float0;
  float shp = fem::float0;
  float shpr = fem::float0;
  float shuser = fem::float0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  arr_1d<41, float> wdtp(dim1(0, 40), fem::fill0);
  arr_2d<41, 6, float> wdte(dim1(0, 40).dim2(0, 5), fem::fill0);
  float rkfl = fem::float0;
  int kflq = fem::int0;
  int js = fem::int0;
  int kcc = fem::int0;
  int kcs = fem::int0;
  int kch1 = fem::int0;
  int kch2 = fem::int0;
  float xh = fem::float0;
  arr_1d<2, float> pmq(fem::fill0);
  float zmin = fem::float0;
  float zmax = fem::float0;
  arr_1d<2, float> z(fem::fill0);
  float sqc1 = fem::float0;
  float c1 = fem::float0;
  float c2 = fem::float0;
  arr_1d<2, float> cthe(fem::fill0);
  float phir = fem::float0;
  float cphi = fem::float0;
  float ang = fem::float0;
  float z1 = fem::float0;
  float z2 = fem::float0;
  float z3 = fem::float0;
  int ia = fem::int0;
  float rvckm = fem::float0;
  int ib = fem::int0;
  int ipm = fem::int0;
  int idc = fem::int0;
  int ja = fem::int0;
  int kfa1 = fem::int0;
  int kfa2 = fem::int0;
  arr_1d<2, float> phi(fem::fill0);
  float pabs = fem::float0;
  float ptabs = fem::float0;
  int izw = fem::int0;
  int ipu = fem::int0;
  float bexcm = fem::float0;
  float beycm = fem::float0;
  float bezcm = fem::float0;
  float gamcm = fem::float0;
  float bepcm = fem::float0;
  float px = fem::float0;
  float py = fem::float0;
  float pz = fem::float0;
  float thecm = fem::float0;
  float phicm = fem::float0;
  float sqlam = fem::float0;
  float cthwz = fem::float0;
  float sthwz = fem::float0;
  float phiwz = fem::float0;
  int jc = fem::int0;
  /// C
  /// C...Finds outgoing flavours and event type; sets up the kinematics
  /// C...and colour flow of the hard scattering.
  /// C
  /// C...Choice of subprocess, number of documentation lines.
  isub = mint(1);
  idoc = 6 + iset(isub);
  if (isub == 95) {
    idoc = 8;
  }
  mint(3) = idoc - 6;
  if (idoc >= 9) {
    idoc += 2;
  }
  mint(4) = idoc;
  ipu1 = mint(84) + 1;
  ipu2 = mint(84) + 2;
  ipu3 = mint(84) + 3;
  ipu4 = mint(84) + 4;
  ipu5 = mint(84) + 5;
  ipu6 = mint(84) + 6;
  /// C
  /// C...Reset K, P and V vectors. Store incoming particles.
  FEM_DO_SAFE(jt, 1, mstp(126) + 10) {
    i = mint(83) + jt;
    FEM_DO_SAFE(j, 1, 5) {
      k(i, j) = 0;
      p(i, j) = 0.f;
      v(i, j) = 0.f;
    }
  }
  FEM_DO_SAFE(jt, 1, 2) {
    i = mint(83) + jt;
    k(i, 1) = 21;
    k(i, 2) = mint(10 + jt);
    p(i, 1) = 0.f;
    p(i, 2) = 0.f;
    p(i, 5) = vint(2 + jt);
    p(i, 3) = vint(5) * fem::pow((-1), (jt + 1));
    p(i, 4) = fem::sqrt(fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
  }
  mint(6) = 2;
  kfres = 0;
  /// C
  /// C...Store incoming partons in their CM-frame.
  sh = vint(44);
  shr = fem::sqrt(sh);
  shp = vint(26) * vint(2);
  shpr = fem::sqrt(shp);
  shuser = shr;
  if (iset(isub) >= 3) {
    shuser = shpr;
  }
  FEM_DO_SAFE(jt, 1, 2) {
    i = mint(84) + jt;
    k(i, 1) = 14;
    k(i, 2) = mint(14 + jt);
    k(i, 3) = mint(83) + 2 + jt;
    p(i, 5) = ulmass(cmn, k(i, 2));
  }
  if (p(ipu1, 5) + p(ipu2, 5) >= shuser) {
    p(ipu1, 5) = 0.f;
    p(ipu2, 5) = 0.f;
  }
  p(ipu1, 4) =
      0.5f *
      (shuser + (fem::pow2(p(ipu1, 5)) - fem::pow2(p(ipu2, 5))) / shuser);
  p(ipu1, 3) =
      fem::sqrt(fem::max(0.f, fem::pow2(p(ipu1, 4)) - fem::pow2(p(ipu1, 5))));
  p(ipu2, 4) = shuser - p(ipu1, 4);
  p(ipu2, 3) = -p(ipu1, 3);
  /// C
  /// C...Copy incoming partons to documentation lines.
  FEM_DO_SAFE(jt, 1, 2) {
    i1 = mint(83) + 4 + jt;
    i2 = mint(84) + jt;
    k(i1, 1) = 21;
    k(i1, 2) = k(i2, 2);
    k(i1, 3) = i1 - 2;
    FEM_DO_SAFE(j, 1, 5) { p(i1, j) = p(i2, j); }
  }
  /// C
  /// C...Choose new quark flavour for relevant annihilation graphs.
  if (isub == 12 || isub == 53) {
    pywidt(cmn, 21, shr, wdtp, wdte);
    rkfl = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) * rlu(cmn, 0);
    FEM_DO_SAFE(i, 1, 2 * mstp(1)) {
      kflq = i;
      rkfl = rkfl - (wdte(i, 1) + wdte(i, 2) + wdte(i, 4));
      if (rkfl <= 0.f) {
        goto statement_150;
      }
    }
  statement_150:;
  }
  /// C
  /// C...Final state flavours and colour flow: default values.
  js = 1;
  mint(21) = mint(15);
  mint(22) = mint(16);
  mint(23) = 0;
  mint(24) = 0;
  kcc = 20;
  kcs = fem::isign(1, mint(15));
  /// C
  if (isub <= 10) {
    if (isub == 1) {
      /// C...f + fb -> gamma*/Z0.
      kfres = 23;
      /// C
    } else if (isub == 2) {
      /// C...f + fb' -> W+/- .
      kch1 = kchg(fem::iabs(mint(15)), 1) * fem::isign(1, mint(15));
      kch2 = kchg(fem::iabs(mint(16)), 1) * fem::isign(1, mint(16));
      kfres = fem::isign(24, kch1 + kch2);
      /// C
    } else if (isub == 3) {
      /// C...f + fb -> H0.
      kfres = 25;
      /// C
    } else if (isub == 4) {
      /// C...gamma + W+/- -> W+/-.
      /// C
    } else if (isub == 5) {
      /// C...Z0 + Z0 -> H0.
      xh = sh / shp;
      mint(21) = mint(15);
      mint(22) = mint(16);
      pmq(1) = ulmass(cmn, mint(21));
      pmq(2) = ulmass(cmn, mint(22));
    statement_240:
      jt = fem::fint(1.5f + rlu(cmn, 0));
      zmin = 2.f * pmq(jt) / shpr;
      zmax = 1.f - pmq(3 - jt) / shpr -
             (sh - fem::pow2(pmq(jt))) / (shpr * (shpr - pmq(3 - jt)));
      zmax = fem::min(1.f - xh, zmax);
      z(jt) = zmin + (zmax - zmin) * rlu(cmn, 0);
      if (-1.f + (1.f + xh) / (1.f - z(jt)) - xh / fem::pow2((1.f - z(jt))) <
          fem::pow2((1.f - xh)) / (4.f * xh) * rlu(cmn, 0)) {
        goto statement_240;
      }
      sqc1 = 1.f - 4.f * fem::pow2(pmq(jt)) / (fem::pow2(z(jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_240;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f +
           2.f * (fem::pow2(pmas(23, 1)) - fem::pow2(pmq(jt))) / (z(jt) * shp);
      cthe(jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                           (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                 c1;
      cthe(jt) = fem::min(1.f, fem::max(-1.f, cthe(jt)));
      z(3 - jt) = 1.f - xh / (1.f - z(jt));
      sqc1 = 1.f - 4.f * fem::pow2(pmq(3 - jt)) / (fem::pow2(z(3 - jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_240;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f + 2.f * (fem::pow2(pmas(23, 1)) - fem::pow2(pmq(3 - jt))) /
                     (z(3 - jt) * shp);
      cthe(3 - jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                               (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                     c1;
      cthe(3 - jt) = fem::min(1.f, fem::max(-1.f, cthe(3 - jt)));
      phir = paru(2) * rlu(cmn, 0);
      cphi = fem::cos(phir);
      ang = cthe(1) * cthe(2) - fem::sqrt(1.f - fem::pow2(cthe(1))) *
                                    fem::sqrt(1.f - fem::pow2(cthe(2))) * cphi;
      z1 = 2.f - z(jt);
      z2 = ang * fem::sqrt(fem::pow2(z(jt)) - 4.f * fem::pow2(pmq(jt)) / shp);
      z3 = 1.f - z(jt) - xh + (fem::pow2(pmq(1)) + fem::pow2(pmq(2))) / shp;
      z(3 - jt) = 2.f / (fem::pow2(z1) - fem::pow2(z2)) *
                  (z1 * z3 + z2 * fem::sqrt(fem::pow2(z3) -
                                            (fem::pow2(z1) - fem::pow2(z2)) *
                                                fem::pow2(pmq(3 - jt)) / shp));
      zmin = 2.f * pmq(3 - jt) / shpr;
      zmax = 1.f - pmq(jt) / shpr -
             (sh - fem::pow2(pmq(3 - jt))) / (shpr * (shpr - pmq(jt)));
      zmax = fem::min(1.f - xh, zmax);
      if (z(3 - jt) < zmin || z(3 - jt) > zmax) {
        goto statement_240;
      }
      kcc = 22;
      kfres = 25;
      /// C
    } else if (isub == 6) {
      /// C...Z0 + W+/- -> W+/-.
      /// C
    } else if (isub == 7) {
      /// C...W+ + W- -> Z0.
      /// C
    } else if (isub == 8) {
      /// C...W+ + W- -> H0.
      xh = sh / shp;
    statement_250:
      FEM_DO_SAFE(jt, 1, 2) {
        i = mint(14 + jt);
        ia = fem::iabs(i);
        if (ia <= 10) {
          rvckm = vint(180 + i) * rlu(cmn, 0);
          FEM_DO_SAFE(j, 1, mstp(1)) {
            ib = 2 * j - 1 + fem::mod(ia, 2);
            ipm = (5 - fem::isign(1, i)) / 2;
            idc = j + mdcy(ia, 2) + 2;
            if (mdme(idc, 1) != 1 && mdme(idc, 1) != ipm) {
              goto statement_270;
            }
            mint(20 + jt) = fem::isign(ib, i);
            rvckm = rvckm - vckm((ia + 1) / 2, (ib + 1) / 2);
            if (rvckm <= 0.f) {
              goto statement_280;
            }
          statement_270:;
          }
        } else {
          ib = 2 * ((ia + 1) / 2) - 1 + fem::mod(ia, 2);
          mint(20 + jt) = fem::isign(ib, i);
        }
      statement_280:
        pmq(jt) = ulmass(cmn, mint(20 + jt));
      }
      jt = fem::fint(1.5f + rlu(cmn, 0));
      zmin = 2.f * pmq(jt) / shpr;
      zmax = 1.f - pmq(3 - jt) / shpr -
             (sh - fem::pow2(pmq(jt))) / (shpr * (shpr - pmq(3 - jt)));
      zmax = fem::min(1.f - xh, zmax);
      z(jt) = zmin + (zmax - zmin) * rlu(cmn, 0);
      if (-1.f + (1.f + xh) / (1.f - z(jt)) - xh / fem::pow2((1.f - z(jt))) <
          fem::pow2((1.f - xh)) / (4.f * xh) * rlu(cmn, 0)) {
        goto statement_250;
      }
      sqc1 = 1.f - 4.f * fem::pow2(pmq(jt)) / (fem::pow2(z(jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_250;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f +
           2.f * (fem::pow2(pmas(24, 1)) - fem::pow2(pmq(jt))) / (z(jt) * shp);
      cthe(jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                           (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                 c1;
      cthe(jt) = fem::min(1.f, fem::max(-1.f, cthe(jt)));
      z(3 - jt) = 1.f - xh / (1.f - z(jt));
      sqc1 = 1.f - 4.f * fem::pow2(pmq(3 - jt)) / (fem::pow2(z(3 - jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_250;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f + 2.f * (fem::pow2(pmas(24, 1)) - fem::pow2(pmq(3 - jt))) /
                     (z(3 - jt) * shp);
      cthe(3 - jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                               (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                     c1;
      cthe(3 - jt) = fem::min(1.f, fem::max(-1.f, cthe(3 - jt)));
      phir = paru(2) * rlu(cmn, 0);
      cphi = fem::cos(phir);
      ang = cthe(1) * cthe(2) - fem::sqrt(1.f - fem::pow2(cthe(1))) *
                                    fem::sqrt(1.f - fem::pow2(cthe(2))) * cphi;
      z1 = 2.f - z(jt);
      z2 = ang * fem::sqrt(fem::pow2(z(jt)) - 4.f * fem::pow2(pmq(jt)) / shp);
      z3 = 1.f - z(jt) - xh + (fem::pow2(pmq(1)) + fem::pow2(pmq(2))) / shp;
      z(3 - jt) = 2.f / (fem::pow2(z1) - fem::pow2(z2)) *
                  (z1 * z3 + z2 * fem::sqrt(fem::pow2(z3) -
                                            (fem::pow2(z1) - fem::pow2(z2)) *
                                                fem::pow2(pmq(3 - jt)) / shp));
      zmin = 2.f * pmq(3 - jt) / shpr;
      zmax = 1.f - pmq(jt) / shpr -
             (sh - fem::pow2(pmq(3 - jt))) / (shpr * (shpr - pmq(jt)));
      zmax = fem::min(1.f - xh, zmax);
      if (z(3 - jt) < zmin || z(3 - jt) > zmax) {
        goto statement_250;
      }
      kcc = 22;
      kfres = 25;
    }
    /// C
  } else if (isub <= 20) {
    if (isub == 11) {
      /// C...f + f' -> f + f'; th = (p(f)-p(f))**2.
      kcc = mint(2);
      if (mint(15) * mint(16) < 0) {
        kcc += 2;
      }
      /// C
    } else if (isub == 12) {
      /// C...f + fb -> f' + fb'; th = (p(f)-p(f'))**2.
      mint(21) = fem::isign(kflq, mint(15));
      mint(22) = -mint(21);
      kcc = 4;
      /// C
    } else if (isub == 13) {
      /// C...f + fb -> g + g; th arbitrary.
      mint(21) = 21;
      mint(22) = 21;
      kcc = mint(2) + 4;
      /// C
    } else if (isub == 14) {
      /// C...f + fb -> g + gam; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 21;
      mint(23 - js) = 22;
      kcc = 17 + js;
      /// C
    } else if (isub == 15) {
      /// C...f + fb -> g + Z0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 21;
      mint(23 - js) = 23;
      kcc = 17 + js;
      /// C
    } else if (isub == 16) {
      /// C...f + fb' -> g + W+/-; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2.
      kch1 = kchg(fem::iabs(mint(15)), 1) * fem::isign(1, mint(15));
      kch2 = kchg(fem::iabs(mint(16)), 1) * fem::isign(1, mint(16));
      if (mint(15) * (kch1 + kch2) < 0) {
        js = 2;
      }
      mint(20 + js) = 21;
      mint(23 - js) = fem::isign(24, kch1 + kch2);
      kcc = 17 + js;
      /// C
    } else if (isub == 17) {
      /// C...f + fb -> g + H0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 21;
      mint(23 - js) = 25;
      kcc = 17 + js;
      /// C
    } else if (isub == 18) {
      /// C...f + fb -> gamma + gamma; th arbitrary.
      mint(21) = 22;
      mint(22) = 22;
      /// C
    } else if (isub == 19) {
      /// C...f + fb -> gamma + Z0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 22;
      mint(23 - js) = 23;
      /// C
    } else if (isub == 20) {
      /// C...f + fb' -> gamma + W+/-; th = (p(f)-p(W-))**2 or
      /// (p(fb')-p(W+))**2.
      kch1 = kchg(fem::iabs(mint(15)), 1) * fem::isign(1, mint(15));
      kch2 = kchg(fem::iabs(mint(16)), 1) * fem::isign(1, mint(16));
      if (mint(15) * (kch1 + kch2) < 0) {
        js = 2;
      }
      mint(20 + js) = 22;
      mint(23 - js) = fem::isign(24, kch1 + kch2);
    }
    /// C
  } else if (isub <= 30) {
    if (isub == 21) {
      /// C...f + fb -> gamma + H0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 22;
      mint(23 - js) = 25;
      /// C
    } else if (isub == 22) {
      /// C...f + fb -> Z0 + Z0; th arbitrary.
      mint(21) = 23;
      mint(22) = 23;
      /// C
    } else if (isub == 23) {
      /// C...f + fb' -> Z0 + W+/-; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2.
      kch1 = kchg(fem::iabs(mint(15)), 1) * fem::isign(1, mint(15));
      kch2 = kchg(fem::iabs(mint(16)), 1) * fem::isign(1, mint(16));
      if (mint(15) * (kch1 + kch2) < 0) {
        js = 2;
      }
      mint(20 + js) = 23;
      mint(23 - js) = fem::isign(24, kch1 + kch2);
      /// C
    } else if (isub == 24) {
      /// C...f + fb -> Z0 + H0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 23;
      mint(23 - js) = 25;
      /// C
    } else if (isub == 25) {
      /// C...f + fb -> W+ + W-; th = (p(f)-p(W-))**2.
      mint(21) = -fem::isign(24, mint(15));
      mint(22) = -mint(21);
      /// C
    } else if (isub == 26) {
      /// C...f + fb' -> W+/- + H0; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2.
      kch1 = kchg(fem::iabs(mint(15)), 1) * fem::isign(1, mint(15));
      kch2 = kchg(fem::iabs(mint(16)), 1) * fem::isign(1, mint(16));
      if (mint(15) * (kch1 + kch2) > 0) {
        js = 2;
      }
      mint(20 + js) = fem::isign(24, kch1 + kch2);
      mint(23 - js) = 25;
      /// C
    } else if (isub == 27) {
      /// C...f + fb -> H0 + H0.
      /// C
    } else if (isub == 28) {
      /// C...f + g -> f + g; th = (p(f)-p(f))**2.
      kcc = mint(2) + 6;
      if (mint(15) == 21) {
        kcc += 2;
      }
      if (mint(15) != 21) {
        kcs = fem::isign(1, mint(15));
      }
      if (mint(16) != 21) {
        kcs = fem::isign(1, mint(16));
      }
      /// C
    } else if (isub == 29) {
      /// C...f + g -> f + gamma; th = (p(f)-p(f))**2.
      if (mint(15) == 21) {
        js = 2;
      }
      mint(23 - js) = 22;
      kcc = 15 + js;
      kcs = fem::isign(1, mint(14 + js));
      /// C
    } else if (isub == 30) {
      /// C...f + g -> f + Z0; th = (p(f)-p(f))**2.
      if (mint(15) == 21) {
        js = 2;
      }
      mint(23 - js) = 23;
      kcc = 15 + js;
      kcs = fem::isign(1, mint(14 + js));
    }
    /// C
  } else if (isub <= 40) {
    if (isub == 31) {
      /// C...f + g -> f' + W+/-; th = (p(f)-p(f'))**2; choose flavour f'.
      if (mint(15) == 21) {
        js = 2;
      }
      i = mint(14 + js);
      ia = fem::iabs(i);
      mint(23 - js) = fem::isign(24, kchg(ia, 1) * i);
      rvckm = vint(180 + i) * rlu(cmn, 0);
      FEM_DO_SAFE(j, 1, mstp(1)) {
        ib = 2 * j - 1 + fem::mod(ia, 2);
        ipm = (5 - fem::isign(1, i)) / 2;
        idc = j + mdcy(ia, 2) + 2;
        if (mdme(idc, 1) != 1 && mdme(idc, 1) != ipm) {
          goto statement_220;
        }
        mint(20 + js) = fem::isign(ib, i);
        rvckm = rvckm - vckm((ia + 1) / 2, (ib + 1) / 2);
        if (rvckm <= 0.f) {
          goto statement_230;
        }
      statement_220:;
      }
    statement_230:
      kcc = 15 + js;
      kcs = fem::isign(1, mint(14 + js));
      /// C
    } else if (isub == 32) {
      /// C...f + g -> f + H0; th = (p(f)-p(f))**2.
      if (mint(15) == 21) {
        js = 2;
      }
      mint(23 - js) = 25;
      kcc = 15 + js;
      kcs = fem::isign(1, mint(14 + js));
      /// C
    } else if (isub == 33) {
      /// C...f + gamma -> f + g.
      /// C
    } else if (isub == 34) {
      /// C...f + gamma -> f + gamma.
      /// C
    } else if (isub == 35) {
      /// C...f + gamma -> f + Z0.
      /// C
    } else if (isub == 36) {
      /// C...f + gamma -> f' + W+/-.
      /// C
    } else if (isub == 37) {
      /// C...f + gamma -> f + H0.
      /// C
    } else if (isub == 38) {
      /// C...f + Z0 -> f + g.
      /// C
    } else if (isub == 39) {
      /// C...f + Z0 -> f + gamma.
      /// C
    } else if (isub == 40) {
      /// C...f + Z0 -> f + Z0.
    }
    /// C
  } else if (isub <= 50) {
    if (isub == 41) {
      /// C...f + Z0 -> f' + W+/-.
      /// C
    } else if (isub == 42) {
      /// C...f + Z0 -> f + H0.
      /// C
    } else if (isub == 43) {
      /// C...f + W+/- -> f' + g.
      /// C
    } else if (isub == 44) {
      /// C...f + W+/- -> f' + gamma.
      /// C
    } else if (isub == 45) {
      /// C...f + W+/- -> f' + Z0.
      /// C
    } else if (isub == 46) {
      /// C...f + W+/- -> f' + W+/-.
      /// C
    } else if (isub == 47) {
      /// C...f + W+/- -> f' + H0.
      /// C
    } else if (isub == 48) {
      /// C...f + H0 -> f + g.
      /// C
    } else if (isub == 49) {
      /// C...f + H0 -> f + gamma.
      /// C
    } else if (isub == 50) {
      /// C...f + H0 -> f + Z0.
    }
    /// C
  } else if (isub <= 60) {
    if (isub == 51) {
      /// C...f + H0 -> f' + W+/-.
      /// C
    } else if (isub == 52) {
      /// C...f + H0 -> f + H0.
      /// C
    } else if (isub == 53) {
      /// C...g + g -> f + fb; th arbitrary.
      kcs = fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
      mint(21) = fem::isign(kflq, kcs);
      mint(22) = -mint(21);
      kcc = mint(2) + 10;
      /// C
    } else if (isub == 54) {
      /// C...g + gamma -> f + fb.
      /// C
    } else if (isub == 55) {
      /// C...g + Z0 -> f + fb.
      /// C
    } else if (isub == 56) {
      /// C...g + W+/- -> f + fb'.
      /// C
    } else if (isub == 57) {
      /// C...g + H0 -> f + fb.
      /// C
    } else if (isub == 58) {
      /// C...gamma + gamma -> f + fb.
      /// C
    } else if (isub == 59) {
      /// C...gamma + Z0 -> f + fb.
      /// C
    } else if (isub == 60) {
      /// C...gamma + W+/- -> f + fb'.
    }
    /// C
  } else if (isub <= 70) {
    if (isub == 61) {
      /// C...gamma + H0 -> f + fb.
      /// C
    } else if (isub == 62) {
      /// C...Z0 + Z0 -> f + fb.
      /// C
    } else if (isub == 63) {
      /// C...Z0 + W+/- -> f + fb'.
      /// C
    } else if (isub == 64) {
      /// C...Z0 + H0 -> f + fb.
      /// C
    } else if (isub == 65) {
      /// C...W+ + W- -> f + fb.
      /// C
    } else if (isub == 66) {
      /// C...W+/- + H0 -> f + fb'.
      /// C
    } else if (isub == 67) {
      /// C...H0 + H0 -> f + fb.
      /// C
    } else if (isub == 68) {
      /// C...g + g -> g + g; th arbitrary.
      kcc = mint(2) + 12;
      kcs = fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
      /// C
    } else if (isub == 69) {
      /// C...gamma + gamma -> W+ + W-.
      /// C
    } else if (isub == 70) {
      /// C...gamma + W+/- -> gamma + W+/-
    }
    /// C
  } else if (isub <= 80) {
    if (isub == 71 || isub == 72) {
      /// C...Z0 + Z0 -> Z0 + Z0; Z0 + Z0 -> W+ + W-.
      xh = sh / shp;
      mint(21) = mint(15);
      mint(22) = mint(16);
      pmq(1) = ulmass(cmn, mint(21));
      pmq(2) = ulmass(cmn, mint(22));
    statement_290:
      jt = fem::fint(1.5f + rlu(cmn, 0));
      zmin = 2.f * pmq(jt) / shpr;
      zmax = 1.f - pmq(3 - jt) / shpr -
             (sh - fem::pow2(pmq(jt))) / (shpr * (shpr - pmq(3 - jt)));
      zmax = fem::min(1.f - xh, zmax);
      z(jt) = zmin + (zmax - zmin) * rlu(cmn, 0);
      if (-1.f + (1.f + xh) / (1.f - z(jt)) - xh / fem::pow2((1.f - z(jt))) <
          fem::pow2((1.f - xh)) / (4.f * xh) * rlu(cmn, 0)) {
        goto statement_290;
      }
      sqc1 = 1.f - 4.f * fem::pow2(pmq(jt)) / (fem::pow2(z(jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_290;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f +
           2.f * (fem::pow2(pmas(23, 1)) - fem::pow2(pmq(jt))) / (z(jt) * shp);
      cthe(jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                           (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                 c1;
      cthe(jt) = fem::min(1.f, fem::max(-1.f, cthe(jt)));
      z(3 - jt) = 1.f - xh / (1.f - z(jt));
      sqc1 = 1.f - 4.f * fem::pow2(pmq(3 - jt)) / (fem::pow2(z(3 - jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_290;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f + 2.f * (fem::pow2(pmas(23, 1)) - fem::pow2(pmq(3 - jt))) /
                     (z(3 - jt) * shp);
      cthe(3 - jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                               (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                     c1;
      cthe(3 - jt) = fem::min(1.f, fem::max(-1.f, cthe(3 - jt)));
      phir = paru(2) * rlu(cmn, 0);
      cphi = fem::cos(phir);
      ang = cthe(1) * cthe(2) - fem::sqrt(1.f - fem::pow2(cthe(1))) *
                                    fem::sqrt(1.f - fem::pow2(cthe(2))) * cphi;
      z1 = 2.f - z(jt);
      z2 = ang * fem::sqrt(fem::pow2(z(jt)) - 4.f * fem::pow2(pmq(jt)) / shp);
      z3 = 1.f - z(jt) - xh + (fem::pow2(pmq(1)) + fem::pow2(pmq(2))) / shp;
      z(3 - jt) = 2.f / (fem::pow2(z1) - fem::pow2(z2)) *
                  (z1 * z3 + z2 * fem::sqrt(fem::pow2(z3) -
                                            (fem::pow2(z1) - fem::pow2(z2)) *
                                                fem::pow2(pmq(3 - jt)) / shp));
      zmin = 2.f * pmq(3 - jt) / shpr;
      zmax = 1.f - pmq(jt) / shpr -
             (sh - fem::pow2(pmq(3 - jt))) / (shpr * (shpr - pmq(jt)));
      zmax = fem::min(1.f - xh, zmax);
      if (z(3 - jt) < zmin || z(3 - jt) > zmax) {
        goto statement_290;
      }
      kcc = 22;
      /// C
    } else if (isub == 73) {
      /// C...Z0 + W+/- -> Z0 + W+/-.
      xh = sh / shp;
    statement_300:
      jt = fem::fint(1.5f + rlu(cmn, 0));
      i = mint(14 + jt);
      ia = fem::iabs(i);
      if (ia <= 10) {
        rvckm = vint(180 + i) * rlu(cmn, 0);
        FEM_DO_SAFE(j, 1, mstp(1)) {
          ib = 2 * j - 1 + fem::mod(ia, 2);
          ipm = (5 - fem::isign(1, i)) / 2;
          idc = j + mdcy(ia, 2) + 2;
          if (mdme(idc, 1) != 1 && mdme(idc, 1) != ipm) {
            goto statement_320;
          }
          mint(20 + jt) = fem::isign(ib, i);
          rvckm = rvckm - vckm((ia + 1) / 2, (ib + 1) / 2);
          if (rvckm <= 0.f) {
            goto statement_330;
          }
        statement_320:;
        }
      } else {
        ib = 2 * ((ia + 1) / 2) - 1 + fem::mod(ia, 2);
        mint(20 + jt) = fem::isign(ib, i);
      }
    statement_330:
      pmq(jt) = ulmass(cmn, mint(20 + jt));
      mint(23 - jt) = mint(17 - jt);
      pmq(3 - jt) = ulmass(cmn, mint(23 - jt));
      jt = fem::fint(1.5f + rlu(cmn, 0));
      zmin = 2.f * pmq(jt) / shpr;
      zmax = 1.f - pmq(3 - jt) / shpr -
             (sh - fem::pow2(pmq(jt))) / (shpr * (shpr - pmq(3 - jt)));
      zmax = fem::min(1.f - xh, zmax);
      z(jt) = zmin + (zmax - zmin) * rlu(cmn, 0);
      if (-1.f + (1.f + xh) / (1.f - z(jt)) - xh / fem::pow2((1.f - z(jt))) <
          fem::pow2((1.f - xh)) / (4.f * xh) * rlu(cmn, 0)) {
        goto statement_300;
      }
      sqc1 = 1.f - 4.f * fem::pow2(pmq(jt)) / (fem::pow2(z(jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_300;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f +
           2.f * (fem::pow2(pmas(23, 1)) - fem::pow2(pmq(jt))) / (z(jt) * shp);
      cthe(jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                           (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                 c1;
      cthe(jt) = fem::min(1.f, fem::max(-1.f, cthe(jt)));
      z(3 - jt) = 1.f - xh / (1.f - z(jt));
      sqc1 = 1.f - 4.f * fem::pow2(pmq(3 - jt)) / (fem::pow2(z(3 - jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_300;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f + 2.f * (fem::pow2(pmas(23, 1)) - fem::pow2(pmq(3 - jt))) /
                     (z(3 - jt) * shp);
      cthe(3 - jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                               (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                     c1;
      cthe(3 - jt) = fem::min(1.f, fem::max(-1.f, cthe(3 - jt)));
      phir = paru(2) * rlu(cmn, 0);
      cphi = fem::cos(phir);
      ang = cthe(1) * cthe(2) - fem::sqrt(1.f - fem::pow2(cthe(1))) *
                                    fem::sqrt(1.f - fem::pow2(cthe(2))) * cphi;
      z1 = 2.f - z(jt);
      z2 = ang * fem::sqrt(fem::pow2(z(jt)) - 4.f * fem::pow2(pmq(jt)) / shp);
      z3 = 1.f - z(jt) - xh + (fem::pow2(pmq(1)) + fem::pow2(pmq(2))) / shp;
      z(3 - jt) = 2.f / (fem::pow2(z1) - fem::pow2(z2)) *
                  (z1 * z3 + z2 * fem::sqrt(fem::pow2(z3) -
                                            (fem::pow2(z1) - fem::pow2(z2)) *
                                                fem::pow2(pmq(3 - jt)) / shp));
      zmin = 2.f * pmq(3 - jt) / shpr;
      zmax = 1.f - pmq(jt) / shpr -
             (sh - fem::pow2(pmq(3 - jt))) / (shpr * (shpr - pmq(jt)));
      zmax = fem::min(1.f - xh, zmax);
      if (z(3 - jt) < zmin || z(3 - jt) > zmax) {
        goto statement_300;
      }
      kcc = 22;
      /// C
    } else if (isub == 74) {
      /// C...Z0 + H0 -> Z0 + H0.
      /// C
    } else if (isub == 75) {
      /// C...W+ + W- -> gamma + gamma.
      /// C
    } else if (isub == 76 || isub == 77) {
      /// C...W+ + W- -> Z0 + Z0; W+ + W- -> W+ + W-.
      xh = sh / shp;
    statement_340:
      FEM_DO_SAFE(jt, 1, 2) {
        i = mint(14 + jt);
        ia = fem::iabs(i);
        if (ia <= 10) {
          rvckm = vint(180 + i) * rlu(cmn, 0);
          FEM_DO_SAFE(j, 1, mstp(1)) {
            ib = 2 * j - 1 + fem::mod(ia, 2);
            ipm = (5 - fem::isign(1, i)) / 2;
            idc = j + mdcy(ia, 2) + 2;
            if (mdme(idc, 1) != 1 && mdme(idc, 1) != ipm) {
              goto statement_360;
            }
            mint(20 + jt) = fem::isign(ib, i);
            rvckm = rvckm - vckm((ia + 1) / 2, (ib + 1) / 2);
            if (rvckm <= 0.f) {
              goto statement_370;
            }
          statement_360:;
          }
        } else {
          ib = 2 * ((ia + 1) / 2) - 1 + fem::mod(ia, 2);
          mint(20 + jt) = fem::isign(ib, i);
        }
      statement_370:
        pmq(jt) = ulmass(cmn, mint(20 + jt));
      }
      jt = fem::fint(1.5f + rlu(cmn, 0));
      zmin = 2.f * pmq(jt) / shpr;
      zmax = 1.f - pmq(3 - jt) / shpr -
             (sh - fem::pow2(pmq(jt))) / (shpr * (shpr - pmq(3 - jt)));
      zmax = fem::min(1.f - xh, zmax);
      z(jt) = zmin + (zmax - zmin) * rlu(cmn, 0);
      if (-1.f + (1.f + xh) / (1.f - z(jt)) - xh / fem::pow2((1.f - z(jt))) <
          fem::pow2((1.f - xh)) / (4.f * xh) * rlu(cmn, 0)) {
        goto statement_340;
      }
      sqc1 = 1.f - 4.f * fem::pow2(pmq(jt)) / (fem::pow2(z(jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_340;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f +
           2.f * (fem::pow2(pmas(24, 1)) - fem::pow2(pmq(jt))) / (z(jt) * shp);
      cthe(jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                           (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                 c1;
      cthe(jt) = fem::min(1.f, fem::max(-1.f, cthe(jt)));
      z(3 - jt) = 1.f - xh / (1.f - z(jt));
      sqc1 = 1.f - 4.f * fem::pow2(pmq(3 - jt)) / (fem::pow2(z(3 - jt)) * shp);
      if (sqc1 < 1.e-8f) {
        goto statement_340;
      }
      c1 = fem::sqrt(sqc1);
      c2 = 1.f + 2.f * (fem::pow2(pmas(24, 1)) - fem::pow2(pmq(3 - jt))) /
                     (z(3 - jt) * shp);
      cthe(3 - jt) = (c2 - (fem::pow2(c2) - fem::pow2(c1)) /
                               (c2 + (2.f * rlu(cmn, 0) - 1.f) * c1)) /
                     c1;
      cthe(3 - jt) = fem::min(1.f, fem::max(-1.f, cthe(3 - jt)));
      phir = paru(2) * rlu(cmn, 0);
      cphi = fem::cos(phir);
      ang = cthe(1) * cthe(2) - fem::sqrt(1.f - fem::pow2(cthe(1))) *
                                    fem::sqrt(1.f - fem::pow2(cthe(2))) * cphi;
      z1 = 2.f - z(jt);
      z2 = ang * fem::sqrt(fem::pow2(z(jt)) - 4.f * fem::pow2(pmq(jt)) / shp);
      z3 = 1.f - z(jt) - xh + (fem::pow2(pmq(1)) + fem::pow2(pmq(2))) / shp;
      z(3 - jt) = 2.f / (fem::pow2(z1) - fem::pow2(z2)) *
                  (z1 * z3 + z2 * fem::sqrt(fem::pow2(z3) -
                                            (fem::pow2(z1) - fem::pow2(z2)) *
                                                fem::pow2(pmq(3 - jt)) / shp));
      zmin = 2.f * pmq(3 - jt) / shpr;
      zmax = 1.f - pmq(jt) / shpr -
             (sh - fem::pow2(pmq(3 - jt))) / (shpr * (shpr - pmq(jt)));
      zmax = fem::min(1.f - xh, zmax);
      if (z(3 - jt) < zmin || z(3 - jt) > zmax) {
        goto statement_340;
      }
      kcc = 22;
      /// C
    } else if (isub == 78) {
      /// C...W+/- + H0 -> W+/- + H0.
      /// C
    } else if (isub == 79) {
      /// C...H0 + H0 -> H0 + H0.
    }
    /// C
  } else if (isub <= 90) {
    if (isub == 81) {
      /// C...q + qb -> Q' + Qb'; th = (p(q)-p(q'))**2.
      mint(21) = fem::isign(mint(46), mint(15));
      mint(22) = -mint(21);
      kcc = 4;
      /// C
    } else if (isub == 82) {
      /// C...g + g -> Q + Qb; th arbitrary.
      kcs = fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
      mint(21) = fem::isign(mint(46), kcs);
      mint(22) = -mint(21);
      kcc = mint(2) + 10;
    }
    /// C
  } else if (isub <= 100) {
    if (isub == 95) {
      /// C...Low-pT ( = energyless g + g -> g + g).
      kcc = mint(2) + 12;
      kcs = fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
      /// C
    } else if (isub == 96) {
      /// C...Multiple interactions (should be reassigned to QCD process).
    }
    /// C
  } else if (isub <= 110) {
    if (isub == 101) {
      /// C...g + g -> gamma*/Z0.
      kcc = 21;
      kfres = 22;
      /// C
    } else if (isub == 102) {
      /// C...g + g -> H0.
      kcc = 21;
      kfres = 25;
    }
    /// C
  } else if (isub <= 120) {
    if (isub == 111) {
      /// C...f + fb -> g + H0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(20 + js) = 21;
      mint(23 - js) = 25;
      kcc = 17 + js;
      /// C
    } else if (isub == 112) {
      /// C...f + g -> f + H0; th = (p(f) - p(f))**2.
      if (mint(15) == 21) {
        js = 2;
      }
      mint(23 - js) = 25;
      kcc = 15 + js;
      kcs = fem::isign(1, mint(14 + js));
      /// C
    } else if (isub == 113) {
      /// C...g + g -> g + H0; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(23 - js) = 25;
      kcc = 22 + js;
      kcs = fem::pow((-1), fem::fint(1.5f + rlu(cmn, 0)));
      /// C
    } else if (isub == 114) {
      /// C...g + g -> gamma + gamma; th arbitrary.
      if (rlu(cmn, 0) > 0.5f) {
        js = 2;
      }
      mint(21) = 22;
      mint(22) = 22;
      kcc = 21;
      /// C
    } else if (isub == 115) {
      /// C...g + g -> gamma + Z0.
      /// C
    } else if (isub == 116) {
      /// C...g + g -> Z0 + Z0.
      /// C
    } else if (isub == 117) {
      /// C...g + g -> W+ + W-.
    }
    /// C
  } else if (isub <= 140) {
    if (isub == 121) {
      /// C...g + g -> f + fb + H0.
    }
    /// C
  } else if (isub <= 160) {
    if (isub == 141) {
      /// C...f + fb -> gamma*/Z0/Z'0.
      kfres = 32;
      /// C
    } else if (isub == 142) {
      /// C...f + fb' -> H+/-.
      kch1 = kchg(fem::iabs(mint(15)), 1) * fem::isign(1, mint(15));
      kch2 = kchg(fem::iabs(mint(16)), 1) * fem::isign(1, mint(16));
      kfres = fem::isign(37, kch1 + kch2);
      /// C
    } else if (isub == 143) {
      /// C...f + fb' -> R.
      kfres = fem::isign(40, mint(15) + mint(16));
    }
    /// C
  } else {
    if (isub == 161) {
      /// C...g + f -> H+/- + f'; th = (p(f)-p(f))**2.
      if (mint(16) == 21) {
        js = 2;
      }
      ia = fem::iabs(mint(17 - js));
      mint(20 + js) = fem::isign(37, kchg(ia, 1) * mint(17 - js));
      ja = ia + fem::mod(ia, 2) - fem::mod(ia + 1, 2);
      mint(23 - js) = fem::isign(ja, mint(17 - js));
      kcc = 18 - js;
      if (mint(15) != 21) {
        kcs = fem::isign(1, mint(15));
      }
      if (mint(16) != 21) {
        kcs = fem::isign(1, mint(16));
      }
    }
  }
  /// C
  if (idoc == 7) {
    /// C...Resonance not decaying: store colour connection indices.
    i = mint(83) + 7;
    k(ipu3, 1) = 1;
    k(ipu3, 2) = kfres;
    k(ipu3, 3) = i;
    p(ipu3, 4) = shuser;
    p(ipu3, 5) = shuser;
    k(ipu1, 4) = ipu2;
    k(ipu1, 5) = ipu2;
    k(ipu2, 4) = ipu1;
    k(ipu2, 5) = ipu1;
    k(i, 1) = 21;
    k(i, 2) = kfres;
    p(i, 4) = shuser;
    p(i, 5) = shuser;
    n = ipu3;
    mint(21) = kfres;
    mint(22) = 0;
    /// C
  } else if (idoc == 8) {
    /// C...2 -> 2 processes: store outgoing partons in their CM-frame.
    FEM_DO_SAFE(jt, 1, 2) {
      i = mint(84) + 2 + jt;
      k(i, 1) = 1;
      if (fem::iabs(mint(20 + jt)) <= 10 || mint(20 + jt) == 21) {
        k(i, 1) = 3;
      }
      k(i, 2) = mint(20 + jt);
      k(i, 3) = mint(83) + idoc + jt - 2;
      if (fem::iabs(k(i, 2)) <= 10 || k(i, 2) == 21) {
        p(i, 5) = ulmass(cmn, k(i, 2));
      } else {
        p(i, 5) = fem::sqrt(vint(63 + fem::mod(js + jt, 2)));
      }
    }
    if (p(ipu3, 5) + p(ipu4, 5) >= shr) {
      kfa1 = fem::iabs(mint(21));
      kfa2 = fem::iabs(mint(22));
      if ((kfa1 > 3 && kfa1 != 21) || (kfa2 > 3 && kfa2 != 21)) {
        mint(51) = 1;
        return;
      }
      p(ipu3, 5) = 0.f;
      p(ipu4, 5) = 0.f;
    }
    p(ipu3, 4) =
        0.5f * (shr + (fem::pow2(p(ipu3, 5)) - fem::pow2(p(ipu4, 5))) / shr);
    p(ipu3, 3) =
        fem::sqrt(fem::max(0.f, fem::pow2(p(ipu3, 4)) - fem::pow2(p(ipu3, 5))));
    p(ipu4, 4) = shr - p(ipu3, 4);
    p(ipu4, 3) = -p(ipu3, 3);
    n = ipu4;
    mint(7) = mint(83) + 7;
    mint(8) = mint(83) + 8;
    /// C
    /// C...Rotate outgoing partons using cos(theta)=(th-uh)/lam(sh,sqm3,sqm4).
    ludbrb(ipu3, ipu4, fem::acos(vint(23)), vint(24), 0e0, 0e0, 0e0);
    /// C
  } else if (idoc == 9) {
    /// C'''2 -> 3 processes:
    /// C
  } else if (idoc == 11) {
    /// C...Z0 + Z0 -> H0, W+ + W- -> H0: store Higgs and outgoing partons.
    phi(1) = paru(2) * rlu(cmn, 0);
    phi(2) = phi(1) - phir;
    FEM_DO_SAFE(jt, 1, 2) {
      i = mint(84) + 2 + jt;
      k(i, 1) = 1;
      if (fem::iabs(mint(20 + jt)) <= 10 || mint(20 + jt) == 21) {
        k(i, 1) = 3;
      }
      k(i, 2) = mint(20 + jt);
      k(i, 3) = mint(83) + idoc + jt - 2;
      p(i, 5) = ulmass(cmn, k(i, 2));
      if (0.5f * shpr * z(jt) <= p(i, 5)) {
        p(i, 5) = 0.f;
      }
      pabs = fem::sqrt(
          fem::max(0.f, fem::pow2((0.5f * shpr * z(jt))) - fem::pow2(p(i, 5))));
      ptabs = pabs * fem::sqrt(fem::max(0.f, 1.f - fem::pow2(cthe(jt))));
      p(i, 1) = ptabs * fem::cos(phi(jt));
      p(i, 2) = ptabs * fem::sin(phi(jt));
      p(i, 3) = pabs * cthe(jt) * fem::pow((-1), (jt + 1));
      p(i, 4) = 0.5f * shpr * z(jt);
      izw = mint(83) + 6 + jt;
      k(izw, 1) = 21;
      k(izw, 2) = 23;
      if (isub == 8) {
        k(izw, 2) = fem::isign(24, luchge(cmn, mint(14 + jt)));
      }
      k(izw, 3) = izw - 2;
      p(izw, 1) = -p(i, 1);
      p(izw, 2) = -p(i, 2);
      p(izw, 3) = (0.5f * shpr - pabs * cthe(jt)) * fem::pow((-1), (jt + 1));
      p(izw, 4) = 0.5f * shpr * (1.f - z(jt));
      p(izw, 5) = -fem::sqrt(fem::max(
          0.f, fem::pow2(p(izw, 3)) + fem::pow2(ptabs) - fem::pow2(p(izw, 4))));
    }
    i = mint(83) + 9;
    k(ipu5, 1) = 1;
    k(ipu5, 2) = kfres;
    k(ipu5, 3) = i;
    p(ipu5, 5) = shr;
    p(ipu5, 1) = -p(ipu3, 1) - p(ipu4, 1);
    p(ipu5, 2) = -p(ipu3, 2) - p(ipu4, 2);
    p(ipu5, 3) = -p(ipu3, 3) - p(ipu4, 3);
    p(ipu5, 4) = shpr - p(ipu3, 4) - p(ipu4, 4);
    k(i, 1) = 21;
    k(i, 2) = kfres;
    FEM_DO_SAFE(j, 1, 5) { p(i, j) = p(ipu5, j); }
    n = ipu5;
    mint(23) = kfres;
    /// C
  } else if (idoc == 12) {
    /// C...Z0 and W+/- scattering: store bosons and outgoing partons.
    phi(1) = paru(2) * rlu(cmn, 0);
    phi(2) = phi(1) - phir;
    FEM_DO_SAFE(jt, 1, 2) {
      i = mint(84) + 2 + jt;
      k(i, 1) = 1;
      if (fem::iabs(mint(20 + jt)) <= 10 || mint(20 + jt) == 21) {
        k(i, 1) = 3;
      }
      k(i, 2) = mint(20 + jt);
      k(i, 3) = mint(83) + idoc + jt - 2;
      p(i, 5) = ulmass(cmn, k(i, 2));
      if (0.5f * shpr * z(jt) <= p(i, 5)) {
        p(i, 5) = 0.f;
      }
      pabs = fem::sqrt(
          fem::max(0.f, fem::pow2((0.5f * shpr * z(jt))) - fem::pow2(p(i, 5))));
      ptabs = pabs * fem::sqrt(fem::max(0.f, 1.f - fem::pow2(cthe(jt))));
      p(i, 1) = ptabs * fem::cos(phi(jt));
      p(i, 2) = ptabs * fem::sin(phi(jt));
      p(i, 3) = pabs * cthe(jt) * fem::pow((-1), (jt + 1));
      p(i, 4) = 0.5f * shpr * z(jt);
      izw = mint(83) + 6 + jt;
      k(izw, 1) = 21;
      if (mint(14 + jt) == mint(20 + jt)) {
        k(izw, 2) = 23;
      } else {
        k(izw, 2) = fem::isign(
            24, luchge(cmn, mint(14 + jt)) - luchge(cmn, mint(20 + jt)));
      }
      k(izw, 3) = izw - 2;
      p(izw, 1) = -p(i, 1);
      p(izw, 2) = -p(i, 2);
      p(izw, 3) = (0.5f * shpr - pabs * cthe(jt)) * fem::pow((-1), (jt + 1));
      p(izw, 4) = 0.5f * shpr * (1.f - z(jt));
      p(izw, 5) = -fem::sqrt(fem::max(
          0.f, fem::pow2(p(izw, 3)) + fem::pow2(ptabs) - fem::pow2(p(izw, 4))));
      ipu = mint(84) + 4 + jt;
      k(ipu, 1) = 3;
      k(ipu, 2) = kfpr(isub, jt);
      k(ipu, 3) = mint(83) + 8 + jt;
      if (fem::iabs(k(ipu, 2)) <= 10 || k(ipu, 2) == 21) {
        p(ipu, 5) = ulmass(cmn, k(ipu, 2));
      } else {
        p(ipu, 5) = fem::sqrt(vint(63 + fem::mod(js + jt, 2)));
      }
      mint(22 + jt) = k(izw, 2);
    }
    if (isub == 72) {
      k(mint(84) + 4 + fem::fint(1.5f + rlu(cmn, 0)), 2) = -24;
    }
    /// C...Find rotation and boost for hard scattering subsystem.
    i1 = mint(83) + 7;
    i2 = mint(83) + 8;
    bexcm = (p(i1, 1) + p(i2, 1)) / (p(i1, 4) + p(i2, 4));
    beycm = (p(i1, 2) + p(i2, 2)) / (p(i1, 4) + p(i2, 4));
    bezcm = (p(i1, 3) + p(i2, 3)) / (p(i1, 4) + p(i2, 4));
    gamcm = (p(i1, 4) + p(i2, 4)) / shr;
    bepcm = bexcm * p(i1, 1) + beycm * p(i1, 2) + bezcm * p(i1, 3);
    px = p(i1, 1) + gamcm * (gamcm / (1.f + gamcm) * bepcm - p(i1, 4)) * bexcm;
    py = p(i1, 2) + gamcm * (gamcm / (1.f + gamcm) * bepcm - p(i1, 4)) * beycm;
    pz = p(i1, 3) + gamcm * (gamcm / (1.f + gamcm) * bepcm - p(i1, 4)) * bezcm;
    thecm = ulangl(cmn, pz, fem::sqrt(fem::pow2(px) + fem::pow2(py)));
    phicm = ulangl(cmn, px, py);
    /// C...Store hard scattering subsystem. Rotate and boost it.
    sqlam = fem::pow2((sh - fem::pow2(p(ipu5, 5)) - fem::pow2(p(ipu6, 5)))) -
            4.f * fem::pow2(p(ipu5, 5)) * fem::pow2(p(ipu6, 5));
    pabs = fem::sqrt(fem::max(0.f, sqlam / (4.f * sh)));
    cthwz = vint(23);
    sthwz = fem::sqrt(fem::max(0.f, 1.f - fem::pow2(cthwz)));
    phiwz = vint(24) - phicm;
    p(ipu5, 1) = pabs * sthwz * fem::cos(phiwz);
    p(ipu5, 2) = pabs * sthwz * fem::sin(phiwz);
    p(ipu5, 3) = pabs * cthwz;
    p(ipu5, 4) = fem::sqrt(fem::pow2(pabs) + fem::pow2(p(ipu5, 5)));
    p(ipu6, 1) = -p(ipu5, 1);
    p(ipu6, 2) = -p(ipu5, 2);
    p(ipu6, 3) = -p(ipu5, 3);
    p(ipu6, 4) = fem::sqrt(fem::pow2(pabs) + fem::pow2(p(ipu6, 5)));
    ludbrb(ipu5, ipu6, thecm, phicm, fem::dble(bexcm), fem::dble(beycm),
           fem::dble(bezcm));
    FEM_DO_SAFE(jt, 1, 2) {
      i1 = mint(83) + 8 + jt;
      i2 = mint(84) + 4 + jt;
      k(i1, 1) = 21;
      k(i1, 2) = k(i2, 2);
      FEM_DO_SAFE(j, 1, 5) { p(i1, j) = p(i2, j); }
    }
    n = ipu6;
    mint(7) = mint(83) + 9;
    mint(8) = mint(83) + 10;
  }
  /// C
  if (idoc >= 8) {
    /// C...Store colour connection indices.
    FEM_DO_SAFE(j, 1, 2) {
      jc = j;
      if (kcs == -1) {
        jc = 3 - j;
      }
      if (icol(kcc, 1, jc) != 0 && k(ipu1, 1) == 14) {
        k(ipu1, j + 3) += mint(84) + icol(kcc, 1, jc);
      }
      if (icol(kcc, 2, jc) != 0 && k(ipu2, 1) == 14) {
        k(ipu2, j + 3) += mint(84) + icol(kcc, 2, jc);
      }
      if (icol(kcc, 3, jc) != 0 && k(ipu3, 1) == 3) {
        k(ipu3, j + 3) = mstu(5) * (mint(84) + icol(kcc, 3, jc));
      }
      if (icol(kcc, 4, jc) != 0 && k(ipu4, 1) == 3) {
        k(ipu4, j + 3) = mstu(5) * (mint(84) + icol(kcc, 4, jc));
      }
    }
    /// C
    /// C...Copy outgoing partons to documentation lines.
    FEM_DO_SAFE(i, 1, 2) {
      i1 = mint(83) + idoc - 2 + i;
      i2 = mint(84) + 2 + i;
      k(i1, 1) = 21;
      k(i1, 2) = k(i2, 2);
      if (idoc <= 9) {
        k(i1, 3) = 0;
      }
      if (idoc >= 11) {
        k(i1, 3) = mint(83) + 2 + i;
      }
      FEM_DO_SAFE(j, 1, 5) { p(i1, j) = p(i2, j); }
    }
  }
  mint(52) = n;
  /// C
  /// C...Low-pT events: remove gluons used for string drawing purposes.
  if (isub == 95) {
    k(ipu3, 1) += 10;
    k(ipu4, 1) += 10;
    FEM_DO_SAFE(j, 41, 66) { vint(j) = 0.f; }
    FEM_DO_SAFE(i, mint(83) + 5, mint(83) + 8) {
      FEM_DO_SAFE(j, 1, 5) { p(i, j) = 0.f; }
    }
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void pysspa(common& cmn, int& ipu1, int& ipu2) {
  common_write write(cmn);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<float> paru(cmn.paru, dimension(200));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_cref<float, 2> xsfx(cmn.xsfx, dim1(2).dim2(-40, 40));
  ///
  int ipus1 = fem::int0;
  int ipus2 = fem::int0;
  int isub = fem::int0;
  float q2e = fem::float0;
  float tmax = fem::float0;
  float xe0 = fem::float0;
  float alams = fem::float0;
  int ns = fem::int0;
  int jt = fem::int0;
  arr_1d<4, int> kfls(fem::fill0);
  arr_1d<2, float> xs(fem::fill0);
  arr_1d<2, float> zs(fem::fill0);
  arr_1d<2, float> q2s(fem::fill0);
  arr_1d<2, float> tevs(fem::fill0);
  arr_1d<2, float> alam(fem::fill0);
  arr_1d<2, float> the2(fem::fill0);
  int kfl = fem::int0;
  arr_2d<2, 13, float> xfs(dim1(2).dim2(-6, 6), fem::fill0);
  double dsh = fem::double0;
  int kflb = fem::int0;
  float xb = fem::float0;
  arr_1d<13, float> xfb(dim1(-6, 6), fem::fill0);
  double dshr = fem::double0;
  double dshz = fem::double0;
  float xe = fem::float0;
  float q2b = fem::float0;
  float tevb = fem::float0;
  float alsdum = fem::float0;
  float tevbsv = fem::float0;
  float b0 = fem::float0;
  arr_1d<13, float> wtap(dim1(-6, 6), fem::fill0);
  arr_1d<13, float> wtsf(dim1(-6, 6), fem::fill0);
  float wtapq = fem::float0;
  float wtsum = fem::float0;
  float xfbo = fem::float0;
  float q2ref = fem::float0;
  float wtran = fem::float0;
  int kfla = fem::int0;
  float z = fem::float0;
  float wtz = fem::float0;
  float rsoft = fem::float0;
  float alprat = fem::float0;
  float the2t = fem::float0;
  arr_1d<13, float> xfn(dim1(-6, 6), fem::fill0);
  float xfbn = fem::float0;
  float xa = fem::float0;
  arr_1d<13, float> xfa(dim1(-6, 6), fem::fill0);
  float xfan = fem::float0;
  float wtsfa = fem::float0;
  arr_1d<3, double> dq2(fem::fill0);
  double dplcm = fem::double0;
  int jr = fem::int0;
  int i = fem::int0;
  int ipo = fem::int0;
  int j = fem::int0;
  arr_1d<2, int> is(fem::fill0);
  arr_1d<3, double> dpc(fem::fill0);
  arr_1d<4, double> dpd(fem::fill0);
  int ikin = fem::int0;
  double dmsma = fem::double0;
  int it = fem::int0;
  float q2tim = fem::float0;
  double dms = fem::double0;
  double dpt2 = fem::double0;
  arr_1d<4, double> dpb(fem::fill0);
  double dbez = fem::double0;
  float the = fem::float0;
  int id1 = fem::int0;
  int id2 = fem::int0;
  int ir = fem::int0;
  arr_1d<5, float> robo(fem::fill0);
  float robot = fem::float0;
  /// C
  /// C...Generates spacelike parton showers.
  /// C
  /// C...Calculate maximum virtuality and check that evolution possible.
  ipus1 = ipu1;
  ipus2 = ipu2;
  isub = mint(1);
  q2e = vint(52);
  if (iset(isub) == 1) {
    q2e = q2e / parp(67);
  } else if (iset(isub) == 3 || iset(isub) == 4) {
    q2e = fem::pow2(pmas(23, 1));
    if (isub == 8 || isub == 76 || isub == 77) {
      q2e = fem::pow2(pmas(24, 1));
    }
  }
  tmax = fem::log(parp(67) * parp(63) * q2e / fem::pow2(parp(61)));
  if (parp(67) * q2e <
          fem::max(fem::pow2(parp(62)), 2.f * fem::pow2(parp(61))) ||
      tmax < 0.2f) {
    return;
  }
  /// C
  /// C...Common constants and initial values. Save normal Lambda value.
  xe0 = 2.f * parp(65) / vint(1);
  alams = paru(111);
  paru(111) = parp(61);
  ns = n;
statement_100:
  n = ns;
  FEM_DO_SAFE(jt, 1, 2) {
    kfls(jt) = mint(14 + jt);
    kfls(jt + 2) = kfls(jt);
    xs(jt) = vint(40 + jt);
    zs(jt) = 1.f;
    q2s(jt) = parp(67) * q2e;
    tevs(jt) = tmax;
    alam(jt) = parp(61);
    the2(jt) = 100.f;
    FEM_DO_SAFE(kfl, -6, 6) { xfs(jt, kfl) = xsfx(jt, kfl); }
  }
  dsh = fem::dble(vint(44));
  if (iset(isub) == 3 || iset(isub) == 4) {
    dsh = fem::dble(vint(26) * vint(2));
  }
/// C
/// C...Pick up leg with highest virtuality.
statement_120:
  n++;
  jt = 1;
  if (n > ns + 1 && q2s(2) > q2s(1)) {
    jt = 2;
  }
  kflb = kfls(jt);
  xb = xs(jt);
  FEM_DO_SAFE(kfl, -6, 6) { xfb(kfl) = xfs(jt, kfl); }
  dshr = 2e0 * fem::sqrt(dsh);
  dshz = dsh / fem::dble(zs(jt));
  xe = fem::max(xe0, xb * (1.f / (1.f - parp(66)) - 1.f));
  if (xb + xe >= 0.999f) {
    q2b = 0.f;
    goto statement_220;
  }
  /// C
  /// C...Maximum Q2 without or with Q2 ordering. Effective Lambda and n_f.
  if (mstp(62) <= 1) {
    q2b = 0.5f * (1.f / zs(jt) + 1.f) * q2s(jt) +
          0.5f * (1.f / zs(jt) - 1.f) *
              (q2s(3 - jt) - fem::sngl(dsh) +
               fem::sqrt(fem::pow2((fem::sngl(dsh) + q2s(1) + q2s(2))) +
                         8.f * q2s(1) * q2s(2) * zs(jt) / (1.f - zs(jt))));
    tevb = fem::log(parp(63) * q2b / fem::pow2(alam(jt)));
  } else {
    q2b = q2s(jt);
    tevb = tevs(jt);
  }
  alsdum = ulalps(cmn, parp(63) * q2b);
  tevb += 2.f * fem::log(alam(jt) / paru(117));
  tevbsv = tevb;
  alam(jt) = paru(117);
  b0 = (33.f - 2.f * mstu(118)) / 6.f;
  /// C
  /// C...Calculate Altarelli-Parisi and structure function weights.
  FEM_DO_SAFE(kfl, -6, 6) {
    wtap(kfl) = 0.f;
    wtsf(kfl) = 0.f;
  }
  if (kflb == 21) {
    wtapq = 16.f * (1.f - fem::sqrt(xb + xe)) / (3.f * fem::sqrt(xb));
    FEM_DO_SAFE(kfl, -mstp(54), mstp(54)) {
      if (kfl == 0) {
        wtap(kfl) = 6.f * fem::log((1.f - xb) / xe);
      }
      if (kfl != 0) {
        wtap(kfl) = wtapq;
      }
    }
  } else {
    wtap(0) = 0.5f * xb * (1.f / (xb + xe) - 1.f);
    wtap(kflb) = 8.f * fem::log((1.f - xb) * (xb + xe) / xe) / 3.f;
  }
statement_160:
  wtsum = 0.f;
  if (kflb != 21) {
    xfbo = xfb(kflb);
  }
  if (kflb == 21) {
    xfbo = xfb(0);
  }
  /// C***************************************************************
  /// C**********ERROR HAS OCCURED HERE
  if (xfbo == 0.0f) {
    write(mstu(11), "(5x,'structure function has a zero point here')");
    write(mstu(11), "(5x,'xf(x,i=',i5,')=',f10.5)"), kflb, xfb(kflb);
    xfbo = 0.00001f;
  }
  /// C****************************************************************
  FEM_DO_SAFE(kfl, -mstp(54), mstp(54)) {
    wtsf(kfl) = xfb(kfl) / xfbo;
    wtsum += wtap(kfl) * wtsf(kfl);
  }
  wtsum = fem::max(0.0001f, wtsum);
/// C
/// C...Choose new t: fix alpha_s, alpha_s(Q2), alpha_s(k_T2).
statement_180:
  if (mstp(64) <= 0) {
    tevb += fem::log(rlu(cmn, 0)) * paru(2) / (paru(111) * wtsum);
  } else if (mstp(64) == 1) {
    tevb =
        tevb * fem::exp(fem::max(-100.f, fem::log(rlu(cmn, 0)) * b0 / wtsum));
  } else {
    tevb = tevb * fem::exp(fem::max(
                      -100.f, fem::log(rlu(cmn, 0)) * b0 / (5.f * wtsum)));
  }
statement_190:
  q2ref = fem::pow2(alam(jt)) * fem::exp(tevb);
  q2b = q2ref / parp(63);
  /// C
  /// C...Evolution ended or select flavour for branching parton.
  if (q2b < fem::pow2(parp(62))) {
    q2b = 0.f;
  } else {
    wtran = rlu(cmn, 0) * wtsum;
    kfla = -mstp(54) - 1;
  statement_200:
    kfla++;
    wtran = wtran - wtap(kfla) * wtsf(kfla);
    if (kfla < mstp(54) && wtran > 0.f) {
      goto statement_200;
    }
    if (kfla == 0) {
      kfla = 21;
    }
    /// C
    /// C...Choose z value and corrective weight.
    if (kflb == 21 && kfla == 21) {
      z = 1.f /
          (1.f + ((1.f - xb) / xb) * fem::pow((xe / (1.f - xb)), rlu(cmn, 0)));
      wtz = fem::pow2((1.f - z * (1.f - z)));
    } else if (kflb == 21) {
      z = xb / fem::pow2((1.f - rlu(cmn, 0) * (1.f - fem::sqrt(xb + xe))));
      wtz = 0.5f * (1.f + fem::pow2((1.f - z))) * fem::sqrt(z);
    } else if (kfla == 21) {
      z = xb * (1.f + rlu(cmn, 0) * (1.f / (xb + xe) - 1.f));
      wtz = 1.f - 2.f * z * (1.f - z);
    } else {
      z = 1.f -
          (1.f - xb) * fem::pow((xe / ((xb + xe) * (1.f - xb))), rlu(cmn, 0));
      wtz = 0.5f * (1.f + fem::pow2(z));
    }
    /// C
    /// C...Option with resummation of soft gluon emission as effective z shift.
    if (mstp(65) >= 1) {
      rsoft = 6.f;
      if (kflb != 21) {
        rsoft = 8.f / 3.f;
      }
      z = z * fem::pow((tevb / tevs(jt)), (rsoft * xe / ((xb + xe) * b0)));
      if (z <= xb) {
        goto statement_180;
      }
    }
    /// C
    /// C...Option with alpha_s(k_T2)Q2): demand k_T2 > cutoff, reweight.
    if (mstp(64) >= 2) {
      if ((1.f - z) * q2b < fem::pow2(parp(62))) {
        goto statement_180;
      }
      alprat = tevb / (tevb + fem::log(1.f - z));
      if (alprat < 5.f * rlu(cmn, 0)) {
        goto statement_180;
      }
      if (alprat > 5.f) {
        wtz = wtz * alprat / 5.f;
      }
    }
    /// C
    /// C...Option with angular ordering requirement.
    if (mstp(62) >= 3) {
      the2t =
          (4.f * fem::pow2(z) * q2b) / (vint(2) * (1.f - z) * fem::pow2(xb));
      if (the2t > the2(jt)) {
        goto statement_180;
      }
    }
    /// C
    /// C...Weighting with new structure functions.
    pystfu(cmn, mint(10 + jt), xb, q2ref, xfn, jt);
    if (kflb != 21) {
      xfbn = xfn(kflb);
    }
    if (kflb == 21) {
      xfbn = xfn(0);
    }
    if (xfbn < 1e-20f) {
      if (kfla == kflb) {
        tevb = tevbsv;
        wtap(kflb) = 0.f;
        goto statement_160;
      } else if (tevbsv - tevb > 0.2f) {
        tevb = 0.5f * (tevbsv + tevb);
        goto statement_190;
      } else {
        xfbn = 1e-10f;
      }
    }
    FEM_DO_SAFE(kfl, -mstp(54), mstp(54)) { xfb(kfl) = xfn(kfl); }
    xa = xb / z;
    pystfu(cmn, mint(10 + jt), xa, q2ref, xfa, jt);
    if (kfla != 21) {
      xfan = xfa(kfla);
    }
    if (kfla == 21) {
      xfan = xfa(0);
    }
    if (xfan < 1e-20f) {
      goto statement_160;
    }
    if (kfla != 21) {
      wtsfa = wtsf(kfla);
    }
    if (kfla == 21) {
      wtsfa = wtsf(0);
    }
    if (wtz * xfan / xfbn < rlu(cmn, 0) * wtsfa) {
      goto statement_160;
    }
  }
/// C
/// C...Define two hard scatterers in their CM-frame.
statement_220:
  if (n == ns + 2) {
    dq2(jt) = fem::dble(q2b);
    dplcm =
        fem::dsqrt(fem::pow2((dsh + dq2(1) + dq2(2))) - 4e0 * dq2(1) * dq2(2)) /
        dshr;
    FEM_DO_SAFE(jr, 1, 2) {
      i = ns + jr;
      if (jr == 1) {
        ipo = ipus1;
      }
      if (jr == 2) {
        ipo = ipus2;
      }
      FEM_DO_SAFE(j, 1, 5) {
        k(i, j) = 0;
        p(i, j) = 0.f;
        v(i, j) = 0.f;
      }
      k(i, 1) = 14;
      k(i, 2) = kfls(jr + 2);
      k(i, 4) = ipo;
      k(i, 5) = ipo;
      p(i, 3) = fem::sngl(dplcm) * fem::pow((-1), (jr + 1));
      p(i, 4) = fem::sngl((dsh + dq2(3 - jr) - dq2(jr)) / dshr);
      p(i, 5) = -fem::sqrt(fem::sngl(dq2(jr)));
      k(ipo, 1) = 14;
      k(ipo, 3) = i;
      k(ipo, 4) = fem::mod(k(ipo, 4), mstu(5)) + mstu(5) * i;
      k(ipo, 5) = fem::mod(k(ipo, 5), mstu(5)) + mstu(5) * i;
    }
    /// C
    /// C...Find maximum allowed mass of timelike parton.
  } else if (n > ns + 2) {
    jr = 3 - jt;
    dq2(3) = fem::dble(q2b);
    dpc(1) = fem::dble(p(is(1), 4));
    dpc(2) = fem::dble(p(is(2), 4));
    dpc(3) = fem::dble(0.5f * (fem::abs(p(is(1), 3)) + fem::abs(p(is(2), 3))));
    dpd(1) = dsh + dq2(jr) + dq2(jt);
    dpd(2) = dshz + dq2(jr) + dq2(3);
    dpd(3) = fem::sqrt(fem::pow2(dpd(1)) - 4e0 * dq2(jr) * dq2(jt));
    dpd(4) = fem::sqrt(fem::pow2(dpd(2)) - 4e0 * dq2(jr) * dq2(3));
    ikin = 0;
    if (q2s(jr) >= fem::pow2((0.5f * parp(62))) &&
        dpd(1) - dpd(3) >= 1e-10 * dpd(1)) {
      ikin = 1;
    }
    if (ikin == 0) {
      dmsma = (dq2(jt) / fem::dble(zs(jt)) - dq2(3)) *
              (dsh / (dsh + dq2(jt)) - dsh / (dshz + dq2(3)));
    }
    if (ikin == 1) {
      dmsma = (dpd(1) * dpd(2) - dpd(3) * dpd(4)) / (2.e0 * dq2(jr)) - dq2(jt) -
              dq2(3);
    }
    /// C
    /// C...Generate timelike parton shower (if required).
    it = n;
    FEM_DO_SAFE(j, 1, 5) {
      k(it, j) = 0;
      p(it, j) = 0.f;
      v(it, j) = 0.f;
    }
    k(it, 1) = 3;
    k(it, 2) = 21;
    if (kflb == 21 && kfls(jt + 2) != 21) {
      k(it, 2) = -kfls(jt + 2);
    }
    if (kflb != 21 && kfls(jt + 2) == 21) {
      k(it, 2) = kflb;
    }
    p(it, 5) = ulmass(cmn, k(it, 2));
    if (fem::sngl(dmsma) <= fem::pow2(p(it, 5))) {
      goto statement_100;
    }
    if (mstp(63) >= 1) {
      p(it, 4) =
          fem::sngl((dshz - dsh - fem::pow2(fem::dble(p(it, 5)))) / dshr);
      p(it, 3) = fem::sqrt(fem::pow2(p(it, 4)) - fem::pow2(p(it, 5)));
      if (mstp(63) == 1) {
        q2tim = fem::sngl(dmsma);
      } else if (mstp(63) == 2) {
        q2tim = fem::min(fem::sngl(dmsma), parp(71) * q2s(jt));
      } else {
        /// C'''Here remains to introduce angular ordering in first branching.
        q2tim = fem::sngl(dmsma);
      }
      lushow(cmn, it, 0, fem::sqrt(q2tim));
      if (n >= it + 1) {
        p(it, 5) = p(it + 1, 5);
      }
    }
    /// C
    /// C...Reconstruct kinematics of branching: timelike parton shower.
    dms = fem::dble(fem::pow2(p(it, 5)));
    if (ikin == 0) {
      dpt2 = (dmsma - dms) * (dshz + dq2(3)) / (dsh + dq2(jt));
    }
    if (ikin == 1) {
      dpt2 = (dmsma - dms) *
             (0.5e0 * dpd(1) * dpd(2) + 0.5e0 * dpd(3) * dpd(4) -
              dq2(jr) * (dq2(jt) + dq2(3) + dms)) /
             (4.e0 * dsh * fem::pow2(dpc(3)));
    }
    if (dpt2 < 0.e0) {
      goto statement_100;
    }
    dpb(1) =
        (0.5e0 * dpd(2) - dpc(jr) * (dshz + dq2(jr) - dq2(jt) - dms) / dshr) /
            dpc(3) -
        dpc(3);
    p(it, 1) = fem::sqrt(fem::sngl(dpt2));
    p(it, 3) = fem::sngl(dpb(1)) * fem::pow((-1), (jt + 1));
    p(it, 4) = fem::sngl((dshz - dsh - dms) / dshr);
    if (n >= it + 1) {
      dpb(1) = fem::sqrt(fem::pow2(dpb(1)) + dpt2);
      dpb(2) = fem::sqrt(fem::pow2(dpb(1)) + dms);
      dpb(3) = fem::dble(p(it + 1, 3));
      dpb(4) = fem::sqrt(fem::pow2(dpb(3)) + dms);
      dbez = (dpb(4) * dpb(1) - dpb(3) * dpb(2)) /
             (dpb(4) * dpb(2) - dpb(3) * dpb(1));
      ludbrb(it + 1, n, 0.f, 0.f, 0e0, 0e0, dbez);
      the = ulangl(cmn, p(it, 3), p(it, 1));
      ludbrb(it + 1, n, the, 0.f, 0e0, 0e0, 0e0);
    }
    /// C
    /// C...Reconstruct kinematics of branching: spacelike parton.
    FEM_DO_SAFE(j, 1, 5) {
      k(n + 1, j) = 0;
      p(n + 1, j) = 0.f;
      v(n + 1, j) = 0.f;
    }
    k(n + 1, 1) = 14;
    k(n + 1, 2) = kflb;
    p(n + 1, 1) = p(it, 1);
    p(n + 1, 3) = p(it, 3) + p(is(jt), 3);
    p(n + 1, 4) = p(it, 4) + p(is(jt), 4);
    p(n + 1, 5) = -fem::sqrt(fem::sngl(dq2(3)));
    /// C
    /// C...Define colour flow of branching.
    k(is(jt), 3) = n + 1;
    k(it, 3) = n + 1;
    id1 = it;
    if ((k(n + 1, 2) > 0 && k(n + 1, 2) != 21 && k(id1, 2) > 0 &&
         k(id1, 2) != 21) ||
        (k(n + 1, 2) < 0 && k(id1, 2) == 21) ||
        (k(n + 1, 2) == 21 && k(id1, 2) == 21 && rlu(cmn, 0) > 0.5f) ||
        (k(n + 1, 2) == 21 && k(id1, 2) < 0)) {
      id1 = is(jt);
    }
    id2 = it + is(jt) - id1;
    k(n + 1, 4) += id1;
    k(n + 1, 5) += id2;
    k(id1, 4) += mstu(5) * (n + 1);
    k(id1, 5) += mstu(5) * id2;
    k(id2, 4) += mstu(5) * id1;
    k(id2, 5) += mstu(5) * (n + 1);
    n++;
    /// C
    /// C...Boost to new CM-frame.
    ludbrb(ns + 1, n, 0.f, 0.f,
           -fem::dble((p(n, 1) + p(is(jr), 1)) / (p(n, 4) + p(is(jr), 4))), 0e0,
           -fem::dble((p(n, 3) + p(is(jr), 3)) / (p(n, 4) + p(is(jr), 4))));
    ir = n + (jt - 1) * (is(1) - n);
    ludbrb(ns + 1, n, -ulangl(cmn, p(ir, 3), p(ir, 1)), paru(2) * rlu(cmn, 0),
           0e0, 0e0, 0e0);
  }
  /// C
  /// C...Save quantities, loop back.
  is(jt) = n;
  q2s(jt) = q2b;
  dq2(jt) = fem::dble(q2b);
  if (mstp(62) >= 3) {
    the2(jt) = the2t;
  }
  dsh = dshz;
  if (q2b >= fem::pow2((0.5f * parp(62)))) {
    kfls(jt + 2) = kfls(jt);
    kfls(jt) = kfla;
    xs(jt) = xa;
    zs(jt) = z;
    FEM_DO_SAFE(kfl, -6, 6) { xfs(jt, kfl) = xfa(kfl); }
    tevs(jt) = tevb;
  } else {
    if (jt == 1) {
      ipu1 = n;
    }
    if (jt == 2) {
      ipu2 = n;
    }
  }
  if (n > mstu(4) - mstu(32) - 10) {
    luerrm(cmn, 11, "(PYSSPA:) no more memory left in LUJETS");
    if (mstu(21) >= 1) {
      n = ns;
    }
    if (mstu(21) >= 1) {
      return;
    }
  }
  if (fem::max(q2s(1), q2s(2)) >= fem::pow2((0.5f * parp(62))) || n <= ns + 1) {
    goto statement_120;
  }
  /// C
  /// C...Boost hard scattering partons to frame of shower initiators.
  FEM_DO_SAFE(j, 1, 3) {
    robo(j + 2) = (p(ns + 1, j) + p(ns + 2, j)) / (p(ns + 1, 4) + p(ns + 2, 4));
  }
  FEM_DO_SAFE(j, 1, 5) { p(n + 2, j) = p(ns + 1, j); }
  robot = fem::pow2(robo(3)) + fem::pow2(robo(4)) + fem::pow2(robo(5));
  if (robot >= 0.999999f) {
    robot = 1.00001f * fem::sqrt(robot);
    robo(3) = robo(3) / robot;
    robo(4) = robo(4) / robot;
    robo(5) = robo(5) / robot;
  }
  ludbrb(n + 2, n + 2, 0.f, 0.f, -fem::dble(robo(3)), -fem::dble(robo(4)),
         -fem::dble(robo(5)));
  robo(2) = ulangl(cmn, p(n + 2, 1), p(n + 2, 2));
  robo(1) = ulangl(cmn, p(n + 2, 3),
                   fem::sqrt(fem::pow2(p(n + 2, 1)) + fem::pow2(p(n + 2, 2))));
  ludbrb(mint(83) + 5, ns, robo(1), robo(2), fem::dble(robo(3)),
         fem::dble(robo(4)), fem::dble(robo(5)));
  /// C
  /// C...Store user information. Reset Lambda value.
  k(ipu1, 3) = mint(83) + 3;
  k(ipu2, 3) = mint(83) + 4;
  FEM_DO_SAFE(jt, 1, 2) {
    mint(12 + jt) = kfls(jt);
    vint(140 + jt) = xs(jt);
  }
  paru(111) = alams;
  /// C
}

struct pyremn_save {
  fem::variant_bindings hstrng_bindings;
};

/// C
/// C*********************************************************************
/// C
void pyremn(common& cmn, int const& ipu1, int const& ipu2) {
  FEM_CMN_SVE(pyremn);
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pphi(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pthi(dimension(300, 15));
      hstrng.allocate(), nfp, pphi, nft, pthi;
    }
  }
  arr_cref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_cref<float, 2> pphi(hstrng.bind<float>(), dimension(300, 15));
  arr_cref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_cref<float, 2> pthi(hstrng.bind<float>(), dimension(300, 15));
  int jt = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int isub = fem::int0;
  int ilep = fem::int0;
  int iq = fem::int0;
  int ip = fem::int0;
  int ilepr = fem::int0;
  int ns = fem::int0;
  int ipu = fem::int0;
  float shs = fem::float0;
  arr_1d<6, float> pms(fem::fill0);
  float rpt1 = fem::float0;
  float rpt2 = fem::float0;
  float ssw2 = fem::float0;
  float pt = fem::float0;
  float phi = fem::float0;
  int jpt = fem::int0;
  float ptgs = fem::float0;
  int iint = fem::int0;
  float pkcsq = fem::float0;
  float q2 = fem::float0;
  int i1 = fem::int0;
  int i2 = fem::int0;
  float shr = fem::float0;
  arr_1d<5, float> robo(fem::fill0);
  int nmax = fem::int0;
  float peh = fem::float0;
  float pzh = fem::float0;
  float shh = fem::float0;
  float pmmin = fem::float0;
  float pei = fem::float0;
  float pzi = fem::float0;
  arr_1d<2, int> kflch(fem::fill0);
  arr_1d<2, int> kflsp(fem::fill0);
  arr_1d<2, int> is(fem::fill0);
  int kfls = fem::int0;
  int imb = fem::int0;
  float chik = fem::float0;
  arr_1d<2, float> chi(fem::fill0);
  float cut = fem::float0;
  float cutr = fem::float0;
  float chir = fem::float0;
  float pe = fem::float0;
  float pz = fem::float0;
  float pw1 = fem::float0;
  float pef = fem::float0;
  float pzf = fem::float0;
  float pt2 = fem::float0;
  float phipt = fem::float0;
  float rqp = fem::float0;
  float sinth = fem::float0;
  float betax = fem::float0;
  float pem = fem::float0;
  float pzm = fem::float0;
  float betaz = fem::float0;
  /// C
  /// C...Adds on target remnants (one or two from each side) and
  /// C...includes primordial kT.
  /// C...COMMON BLOCK FROM HIJING
  /// C
  /// C...Special case for lepton-lepton interaction.
  if (mint(43) == 1) {
    FEM_DO_SAFE(jt, 1, 2) {
      i = mint(83) + jt + 2;
      k(i, 1) = 21;
      k(i, 2) = k(i - 2, 2);
      k(i, 3) = i - 2;
      FEM_DO_SAFE(j, 1, 5) { p(i, j) = p(i - 2, j); }
    }
  }
  /// C
  /// C...Find event type, set pointers.
  if (ipu1 == 0 && ipu2 == 0) {
    return;
  }
  isub = mint(1);
  ilep = 0;
  if (ipu1 == 0) {
    ilep = 1;
  }
  if (ipu2 == 0) {
    ilep = 2;
  }
  if (isub == 95) {
    ilep = -1;
  }
  if (ilep == 1) {
    iq = mint(84) + 1;
  }
  if (ilep == 2) {
    iq = mint(84) + 2;
  }
  ip = fem::max(ipu1, ipu2);
  ilepr = mint(83) + 5 - ilep;
  ns = n;
/// C
/// C...Define initial partons, including primordial kT.
statement_110:
  FEM_DO_SAFE(jt, 1, 2) {
    i = mint(83) + jt + 2;
    if (jt == 1) {
      ipu = ipu1;
    }
    if (jt == 2) {
      ipu = ipu2;
    }
    k(i, 1) = 21;
    k(i, 3) = i - 2;
    if (isub == 95) {
      k(i, 2) = 21;
      shs = 0.f;
    } else if (mint(40 + jt) == 1 && ipu != 0) {
      k(i, 2) = k(ipu, 2);
      p(i, 5) = p(ipu, 5);
      p(i, 1) = 0.f;
      p(i, 2) = 0.f;
      pms(jt) = fem::pow2(p(i, 5));
    } else if (ipu != 0) {
      k(i, 2) = k(ipu, 2);
      p(i, 5) = p(ipu, 5);
      /// C...No primordial kT or chosen according to truncated Gaussian or
      /// C...exponential.
      /// C
      /// C     X.N. Wang (7.22.97)
      /// C
      rpt1 = 0.0f;
      rpt2 = 0.0f;
      ssw2 = fem::pow2((pphi(ihnt2(11), 4) + pthi(ihnt2(12), 4))) -
             fem::pow2((pphi(ihnt2(11), 1) + pthi(ihnt2(12), 1))) -
             fem::pow2((pphi(ihnt2(11), 2) + pthi(ihnt2(12), 2))) -
             fem::pow2((pphi(ihnt2(11), 3) + pthi(ihnt2(12), 3)));
      /// C
      /// C********this is s of the current NN collision
      if (ssw2 <= 4.0f * fem::pow2(parp(93))) {
        goto statement_1211;
      }
      /// C
      if (ihpr2(5) <= 0) {
      statement_120:
        if (mstp(91) <= 0) {
          pt = 0.f;
        } else if (mstp(91) == 1) {
          pt = parp(91) * fem::sqrt(-fem::log(rlu(cmn, 0)));
        } else {
          rpt1 = rlu(cmn, 0);
          rpt2 = rlu(cmn, 0);
          pt = -parp(92) * fem::log(rpt1 * rpt2);
        }
        if (pt > parp(93)) {
          goto statement_120;
        }
        phi = paru(2) * rlu(cmn, 0);
        rpt1 = pt * fem::cos(phi);
        rpt2 = pt * fem::sin(phi);
      } else if (ihpr2(5) == 1) {
        if (jt == 1) {
          jpt = nfp(ihnt2(11), 11);
        }
        if (jt == 2) {
          jpt = nft(ihnt2(12), 11);
        }
      statement_1205:
        ptgs = parp(91) * fem::sqrt(-fem::log(rlu(cmn, 0)));
        if (ptgs > parp(93)) {
          goto statement_1205;
        }
        phi = 2.0f * hipr1(40) * rlu(cmn, 0);
        rpt1 = ptgs * fem::cos(phi);
        rpt2 = ptgs * fem::sin(phi);
        FEM_DO_SAFE(iint, 1, jpt - 1) {
          pkcsq = parp(91) * fem::sqrt(-fem::log(rlu(cmn, 0)));
          phi = 2.0f * hipr1(40) * rlu(cmn, 0);
          rpt1 += pkcsq * fem::cos(phi);
          rpt2 += pkcsq * fem::sin(phi);
        }
        if (fem::pow2(rpt1) + fem::pow2(rpt2) >= ssw2 / 4.0f) {
          goto statement_1205;
        }
      }
    /// C     X.N. Wang
    /// C                     ********When initial interaction among soft
    /// partons is C                             assumed the primordial pt comes
    /// from the sum of C                             pt of JPT-1 number of
    /// initial interaction, JPT C                             is the number of
    /// interaction including present C                             one that
    /// nucleon hassuffered
    statement_1211:
      p(i, 1) = rpt1;
      p(i, 2) = rpt2;
      pms(jt) = fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
    } else {
      k(i, 2) = k(iq, 2);
      q2 = vint(52);
      p(i, 5) = -fem::sqrt(q2);
      pms(jt) = -q2;
      shs =
          (1.f - vint(43 - jt)) * q2 / vint(43 - jt) + fem::pow2(vint(5 - jt));
    }
  }
  /// C
  /// C...Kinematics construction for initial partons.
  i1 = mint(83) + 3;
  i2 = mint(83) + 4;
  if (ilep == 0) {
    shs = vint(141) * vint(142) * vint(2) + fem::pow2((p(i1, 1) + p(i2, 1))) +
          fem::pow2((p(i1, 2) + p(i2, 2)));
  }
  shr = fem::sqrt(fem::max(0.f, shs));
  if (ilep == 0) {
    if (fem::pow2((shs - pms(1) - pms(2))) - 4.f * pms(1) * pms(2) <= 0.f) {
      goto statement_110;
    }
    p(i1, 4) = 0.5f * (shr + (pms(1) - pms(2)) / shr);
    p(i1, 3) = fem::sqrt(fem::max(0.f, fem::pow2(p(i1, 4)) - pms(1)));
    p(i2, 4) = shr - p(i1, 4);
    p(i2, 3) = -p(i1, 3);
  } else if (ilep == 1) {
    p(i1, 4) = p(iq, 4);
    p(i1, 3) = p(iq, 3);
    p(i2, 4) = p(ip, 4);
    p(i2, 3) = p(ip, 3);
  } else if (ilep == 2) {
    p(i1, 4) = p(ip, 4);
    p(i1, 3) = p(ip, 3);
    p(i2, 4) = p(iq, 4);
    p(i2, 3) = p(iq, 3);
  }
  if (mint(43) == 1) {
    return;
  }
  /// C
  /// C...Transform partons to overall CM-frame (not for leptoproduction).
  if (ilep == 0) {
    robo(3) = (p(i1, 1) + p(i2, 1)) / shr;
    robo(4) = (p(i1, 2) + p(i2, 2)) / shr;
    ludbrb(i1, i2, 0.f, 0.f, -fem::dble(robo(3)), -fem::dble(robo(4)), 0e0);
    robo(2) = ulangl(cmn, p(i1, 1), p(i1, 2));
    ludbrb(i1, i2, 0.f, -robo(2), 0e0, 0e0, 0e0);
    robo(1) = ulangl(cmn, p(i1, 3), p(i1, 1));
    ludbrb(i1, i2, -robo(1), 0.f, 0e0, 0e0, 0e0);
    nmax = fem::max(mint(52), ipu1, ipu2);
    ludbrb(i1, nmax, robo(1), robo(2), fem::dble(robo(3)), fem::dble(robo(4)),
           0e0);
    robo(5) = fem::max(
        -0.999999f,
        fem::min(0.999999f, (vint(141) - vint(142)) / (vint(141) + vint(142))));
    ludbrb(i1, nmax, 0.f, 0.f, 0e0, 0e0, fem::dble(robo(5)));
  }
  /// C
  /// C...Check invariant mass of remnant system:
  /// C...hadronic events or leptoproduction.
  if (ilep <= 0) {
    if (mstp(81) <= 0 || mstp(82) <= 0 || isub == 95) {
      vint(151) = 0.f;
      vint(152) = 0.f;
    }
    peh = p(i1, 4) + p(i2, 4) + 0.5f * vint(1) * (vint(151) + vint(152));
    pzh = p(i1, 3) + p(i2, 3) + 0.5f * vint(1) * (vint(151) - vint(152));
    shh = fem::pow2((vint(1) - peh)) - fem::pow2((p(i1, 1) + p(i2, 1))) -
          fem::pow2((p(i1, 2) + p(i2, 2))) - fem::pow2(pzh);
    pmmin = p(mint(83) + 1, 5) + p(mint(83) + 2, 5) + ulmass(cmn, k(i1, 2)) +
            ulmass(cmn, k(i2, 2));
    if (shr >= vint(1) || shh <= fem::pow2((pmmin + parp(111)))) {
      mint(51) = 1;
      return;
    }
    shr = fem::sqrt(shh + fem::pow2((p(i1, 1) + p(i2, 1))) +
                    fem::pow2((p(i1, 2) + p(i2, 2))));
  } else {
    pei = p(iq, 4) + p(ip, 4);
    pzi = p(iq, 3) + p(ip, 3);
    pms(ilep) = fem::max(0.f, fem::pow2(pei) - fem::pow2(pzi));
    pmmin = p(ilepr - 2, 5) + ulmass(cmn, k(ilepr, 2)) + fem::sqrt(pms(ilep));
    if (shr <= pmmin + parp(111)) {
      mint(51) = 1;
      return;
    }
  }
/// C
/// C...Subdivide remnant if necessary, store first parton.
statement_140:
  i = ns;
  FEM_DO_SAFE(jt, 1, 2) {
    if (jt == ilep) {
      goto statement_190;
    }
    if (jt == 1) {
      ipu = ipu1;
    }
    if (jt == 2) {
      ipu = ipu2;
    }
    pyspli(cmn, mint(10 + jt), mint(12 + jt), kflch(jt), kflsp(jt));
    i++;
    is(jt) = i;
    FEM_DO_SAFE(j, 1, 5) {
      k(i, j) = 0;
      p(i, j) = 0.f;
      v(i, j) = 0.f;
    }
    k(i, 1) = 3;
    k(i, 2) = kflsp(jt);
    k(i, 3) = mint(83) + jt;
    p(i, 5) = ulmass(cmn, k(i, 2));
    /// C
    /// C...First parton colour connections and transverse mass.
    kfls = (3 - kchg(lucomp(cmn, kflsp(jt)), 2) * fem::isign(1, kflsp(jt))) / 2;
    k(i, kfls + 3) = ipu;
    k(ipu, 6 - kfls) = fem::mod(k(ipu, 6 - kfls), mstu(5)) + mstu(5) * i;
    if (kflch(jt) == 0) {
      p(i, 1) = -p(mint(83) + jt + 2, 1);
      p(i, 2) = -p(mint(83) + jt + 2, 2);
      pms(jt) = fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
      /// C
      /// C...When extra remnant parton or hadron: find relative pT, store.
    } else {
      luptdi(cmn, 1, p(i, 1), p(i, 2));
      pms(jt + 2) =
          fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
      i++;
      FEM_DO_SAFE(j, 1, 5) {
        k(i, j) = 0;
        p(i, j) = 0.f;
        v(i, j) = 0.f;
      }
      k(i, 1) = 1;
      k(i, 2) = kflch(jt);
      k(i, 3) = mint(83) + jt;
      p(i, 5) = ulmass(cmn, k(i, 2));
      p(i, 1) = -p(mint(83) + jt + 2, 1) - p(i - 1, 1);
      p(i, 2) = -p(mint(83) + jt + 2, 2) - p(i - 1, 2);
      pms(jt + 4) =
          fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) + fem::pow2(p(i, 2));
      /// C...Relative distribution of energy for particle into two jets.
      imb = 1;
      if (fem::mod(mint(10 + jt) / 1000, 10) != 0) {
        imb = 2;
      }
      if (fem::iabs(kflch(jt)) <= 10 || kflch(jt) == 21) {
        chik = parp(92 + 2 * imb);
        if (mstp(92) <= 1) {
          if (imb == 1) {
            chi(jt) = rlu(cmn, 0);
          }
          if (imb == 2) {
            chi(jt) = 1.f - fem::sqrt(rlu(cmn, 0));
          }
        } else if (mstp(92) == 2) {
          chi(jt) = 1.f - fem::pow(rlu(cmn, 0), (1.f / (1.f + chik)));
        } else if (mstp(92) == 3) {
          cut = 2.f * 0.3f / vint(1);
        statement_170:
          chi(jt) = fem::pow2(rlu(cmn, 0));
          if (fem::pow(
                  (fem::pow2(chi(jt)) / (fem::pow2(chi(jt)) + fem::pow2(cut))),
                  0.25f) *
                  fem::pow((1.f - chi(jt)), chik) <
              rlu(cmn, 0)) {
            goto statement_170;
          }
        } else {
          cut = 2.f * 0.3f / vint(1);
          cutr = (1.f + fem::sqrt(1.f + fem::pow2(cut))) / cut;
        statement_180:
          chir = cut * fem::pow(cutr, rlu(cmn, 0));
          chi(jt) = (fem::pow2(chir) - fem::pow2(cut)) / (2.f * chir);
          if (fem::pow((1.f - chi(jt)), chik) < rlu(cmn, 0)) {
            goto statement_180;
          }
        }
        /// C...Relative distribution of energy for particle into jet plus
        /// particle.
      } else {
        if (mstp(92) <= 1) {
          if (imb == 1) {
            chi(jt) = rlu(cmn, 0);
          }
          if (imb == 2) {
            chi(jt) = 1.f - fem::sqrt(rlu(cmn, 0));
          }
        } else {
          chi(jt) =
              1.f - fem::pow(rlu(cmn, 0), (1.f / (1.f + parp(93 + 2 * imb))));
        }
        if (fem::mod(kflch(jt) / 1000, 10) != 0) {
          chi(jt) = 1.f - chi(jt);
        }
      }
      pms(jt) = pms(jt + 4) / chi(jt) + pms(jt + 2) / (1.f - chi(jt));
      kfls = kchg(lucomp(cmn, kflch(jt)), 2) * fem::isign(1, kflch(jt));
      if (kfls != 0) {
        k(i, 1) = 3;
        kfls = (3 - kfls) / 2;
        k(i, kfls + 3) = ipu;
        k(ipu, 6 - kfls) = fem::mod(k(ipu, 6 - kfls), mstu(5)) + mstu(5) * i;
      }
    }
  statement_190:;
  }
  if (shr <= fem::sqrt(pms(1)) + fem::sqrt(pms(2))) {
    goto statement_140;
  }
  n = i;
  /// C
  /// C...Reconstruct kinematics of remnants.
  FEM_DO_SAFE(jt, 1, 2) {
    if (jt == ilep) {
      goto statement_200;
    }
    pe = 0.5f * (shr + (pms(jt) - pms(3 - jt)) / shr);
    pz = fem::sqrt(fem::pow2(pe) - pms(jt));
    if (kflch(jt) == 0) {
      p(is(jt), 4) = pe;
      p(is(jt), 3) = pz * fem::pow((-1), (jt - 1));
    } else {
      pw1 = chi(jt) * (pe + pz);
      p(is(jt) + 1, 4) = 0.5f * (pw1 + pms(jt + 4) / pw1);
      p(is(jt) + 1, 3) =
          0.5f * (pw1 - pms(jt + 4) / pw1) * fem::pow((-1), (jt - 1));
      p(is(jt), 4) = pe - p(is(jt) + 1, 4);
      p(is(jt), 3) = pz * fem::pow((-1), (jt - 1)) - p(is(jt) + 1, 3);
    }
  statement_200:;
  }
  /// C
  /// C...Hadronic events: boost remnants to correct longitudinal frame.
  if (ilep <= 0) {
    ludbrb(ns + 1, n, 0.f, 0.f, 0e0, 0e0, -fem::dble(pzh / (vint(1) - peh)));
    /// C...Leptoproduction events: boost colliding subsystem.
  } else {
    nmax = fem::max(ip, mint(52));
    pef = shr - pe;
    pzf = pz * fem::pow((-1), (ilep - 1));
    pt2 = fem::pow2(p(ilepr, 1)) + fem::pow2(p(ilepr, 2));
    phipt = ulangl(cmn, p(ilepr, 1), p(ilepr, 2));
    ludbrb(mint(84) + 1, nmax, 0.f, -phipt, 0e0, 0e0, 0e0);
    rqp = p(iq, 3) * (pt2 + fem::pow2(pei)) - p(iq, 4) * pei * pzi;
    sinth = p(iq, 4) *
            fem::sqrt(
                pt2 * (pt2 + fem::pow2(pei)) /
                (fem::pow2(rqp) + pt2 * fem::pow2(p(iq, 4)) * fem::pow2(pzi))) *
            fem::sign(1.f, -rqp);
    ludbrb(mint(84) + 1, nmax, fem::asin(sinth), 0.f, 0e0, 0e0, 0e0);
    betax =
        (-pei * pzi * sinth +
         fem::sqrt(pt2 * (pt2 + fem::pow2(pei) - fem::pow2((pzi * sinth))))) /
        (pt2 + fem::pow2(pei));
    ludbrb(mint(84) + 1, nmax, 0.f, 0.f, fem::dble(betax), 0e0, 0e0);
    ludbrb(mint(84) + 1, nmax, 0.f, phipt, 0e0, 0e0, 0e0);
    pem = p(iq, 4) + p(ip, 4);
    pzm = p(iq, 3) + p(ip, 3);
    betaz = (-pem * pzm + pzf * fem::sqrt(fem::pow2(pzf) + fem::pow2(pem) -
                                          fem::pow2(pzm))) /
            (fem::pow2(pzf) + fem::pow2(pem));
    ludbrb(mint(84) + 1, nmax, 0.f, 0.f, 0e0, 0e0, fem::dble(betaz));
    ludbrb(i1, i2, fem::asin(sinth), 0.f, fem::dble(betax), 0e0, 0e0);
    ludbrb(i1, i2, 0.f, phipt, 0e0, 0e0, fem::dble(betaz));
  }
  /// C
}

/// C
/// C.................... hipyset1.35.f
/// C
/// C     Modified for HIJING program
/// C
/// C    modification July 22, 1997  In pyremnn put an upper limit
/// C     on the total pt kick the parton can accumulate via multiple
/// C     scattering. Set the upper limit to be the sqrt(s)/2,
/// C     this is fix cronin bug for Pb+Pb events at SPS energy.
/// C
/// C Last modification Oct. 1993 to comply with non-vax
/// C machines' compiler
/// C
/// C*********************************************************************
/// C
void lu2ent(common& cmn, int const& ip, int const& kf1, int const& kf2,
            float const& pecm) {
  /// COMMON lujets
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  /// COMMON ludat1
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  /// COMMON ludat2
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  ///
  /// C
  /// C...Purpose: to store two partons/particles in their CM frame,
  /// C...with the first along the +z axis.
  /// C
  /// C...Standard checks.
  mstu(28) = 0;
  if (mstu(12) >= 1) {
    lulist(cmn, 0);
  }
  int ipa = fem::max(1, fem::iabs(ip));
  if (ipa > mstu(4) - 1) {
    luerrm(cmn, 21, "(LU2ENT:) writing outside LUJETS memory");
  }
  int kc1 = lucomp(cmn, kf1);
  int kc2 = lucomp(cmn, kf2);
  if (kc1 == 0 || kc2 == 0) {
    luerrm(cmn, 12, "(LU2ENT:) unknown flavour code");
  }
  /// C
  /// C...Find masses. Reset K, P and V vectors.
  float pm1 = 0.f;
  if (mstu(10) == 1) {
    pm1 = p(ipa, 5);
  }
  if (mstu(10) >= 2) {
    pm1 = ulmass(cmn, kf1);
  }
  float pm2 = 0.f;
  if (mstu(10) == 1) {
    pm2 = p(ipa + 1, 5);
  }
  if (mstu(10) >= 2) {
    pm2 = ulmass(cmn, kf2);
  }
  int i = fem::int0;
  int j = fem::int0;
  FEM_DO_SAFE(i, ipa, ipa + 1) {
    FEM_DO_SAFE(j, 1, 5) {
      k(i, j) = 0;
      p(i, j) = 0.f;
      v(i, j) = 0.f;
    }
  }
  /// C
  /// C...Check flavours.
  int kq1 = kchg(kc1, 2) * fem::isign(1, kf1);
  int kq2 = kchg(kc2, 2) * fem::isign(1, kf2);
  if (kq1 + kq2 != 0 && kq1 + kq2 != 4) {
    luerrm(cmn, 2, "(LU2ENT:) unphysical flavour combination");
  }
  k(ipa, 2) = kf1;
  k(ipa + 1, 2) = kf2;
  /// C
  /// C...Store partons/particles in K vectors for normal case.
  if (ip >= 0) {
    k(ipa, 1) = 1;
    if (kq1 != 0 && kq2 != 0) {
      k(ipa, 1) = 2;
    }
    k(ipa + 1, 1) = 1;
    /// C
    /// C...Store partons in K vectors for parton shower evolution.
  } else {
    if (kq1 == 0 || kq2 == 0) {
      luerrm(cmn, 2,
             "(LU2ENT:) requested flavours can not develop parton shower");
    }
    k(ipa, 1) = 3;
    k(ipa + 1, 1) = 3;
    k(ipa, 4) = mstu(5) * (ipa + 1);
    k(ipa, 5) = k(ipa, 4);
    k(ipa + 1, 4) = mstu(5) * ipa;
    k(ipa + 1, 5) = k(ipa + 1, 4);
  }
  /// C
  /// C...Check kinematics and store partons/particles in P vectors.
  if (pecm <= pm1 + pm2) {
    luerrm(cmn, 13, "(LU2ENT:) energy smaller than sum of masses");
  }
  float pa =
      fem::sqrt(fem::max(
          0.f, fem::pow2((fem::pow2(pecm) - fem::pow2(pm1) - fem::pow2(pm2))) -
                   fem::pow2((2.f * pm1 * pm2)))) /
      (2.f * pecm);
  p(ipa, 3) = pa;
  p(ipa, 4) = fem::sqrt(fem::pow2(pm1) + fem::pow2(pa));
  p(ipa, 5) = pm1;
  p(ipa + 1, 3) = -pa;
  p(ipa + 1, 4) = fem::sqrt(fem::pow2(pm2) + fem::pow2(pa));
  p(ipa + 1, 5) = pm2;
  /// C
  /// C...Set N. Optionally fragment/decay.
  n = ipa + 1;
  if (ip == 0) {
    luexec(cmn);
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void pyresd(common& cmn) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_cref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> kfdp(cmn.kfdp, dimension(2000, 5));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_cref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  ///
  int i1 = fem::int0;
  int i2 = fem::int0;
  int i3 = fem::int0;
  int i4 = fem::int0;
  int i5 = fem::int0;
  int i6 = fem::int0;
  arr_2d<6, 6, std::complex<float> > ha(fem::fill0);
  arr_2d<6, 6, std::complex<float> > hc(fem::fill0);
  double dt = fem::double0;
  double du = fem::double0;
  double d34 = fem::double0;
  double d56 = fem::double0;
  int isub = fem::int0;
  float sh = fem::float0;
  arr_2d<10, 6, int> iref(fem::fill0);
  int np = fem::int0;
  int ip = fem::int0;
  int ninh = fem::int0;
  int jtmax = fem::int0;
  int jt = fem::int0;
  arr_1d<2, int> kdcy(fem::fill0);
  arr_1d<2, int> kfl1(fem::fill0);
  arr_1d<2, int> kfl2(fem::fill0);
  arr_1d<2, int> nsd(fem::fill0);
  int id = fem::int0;
  int kfa = fem::int0;
  arr_1d<41, float> wdtp(dim1(0, 40), fem::fill0);
  arr_2d<41, 6, float> wdte(dim1(0, 40).dim2(0, 5), fem::fill0);
  int ipm = fem::int0;
  int i12 = fem::int0;
  float rkfl = fem::float0;
  int i = fem::int0;
  int idc = fem::int0;
  float pid5 = fem::float0;
  arr_1d<2, float> cthe(fem::fill0);
  arr_1d<2, float> phi(fem::fill0);
  arr_1d<6, int> ilin(fem::fill0);
  int imin = fem::int0;
  int imax = fem::int0;
  int iord = fem::int0;
  float xw = fem::float0;
  int j = fem::int0;
  arr_2d<6, 4, float> coup(fem::fill0);
  float sqmz = fem::float0;
  float gzmz = fem::float0;
  float sqmw = fem::float0;
  float gzmw = fem::float0;
  float sqmzp = fem::float0;
  float gzmzp = fem::float0;
  float therr = fem::float0;
  float phirr = fem::float0;
  arr_2d<6, 4, float> pk(fem::fill0);
  arr_2d<6, 6, float> pkk(fem::fill0);
  float wt = fem::float0;
  float wtmax = fem::float0;
  float ei = fem::float0;
  float ai = fem::float0;
  float vi = fem::float0;
  float ef = fem::float0;
  float af = fem::float0;
  float vf = fem::float0;
  float gg = fem::float0;
  float gz = fem::float0;
  float zz = fem::float0;
  float asym = fem::float0;
  float s34 = fem::float0;
  float s56 = fem::float0;
  float ti = fem::float0;
  float ui = fem::float0;
  float cawz = fem::float0;
  float cbwz = fem::float0;
  float cdww = fem::float0;
  float caww = fem::float0;
  float cbww = fem::float0;
  float ccww = fem::float0;
  float api = fem::float0;
  float vpi = fem::float0;
  float apf = fem::float0;
  float vpf = fem::float0;
  float gzp = fem::float0;
  float zzp = fem::float0;
  float zpzp = fem::float0;
  int idoc = fem::int0;
  /// C
  /// C...Allows resonances to decay (including parton showers for hadronic
  /// C...channels).
  /// C
  /// C...The F, Xi and Xj functions of Gunion and Kunszt
  /// C...(Phys. Rev. D33, 665, plus errata from the authors).
  fgk(i1, i2, i3, i4, i5, i6) =
      4.f * ha(i1, i3) * hc(i2, i6) *
      (ha(i1, i5) * hc(i1, i4) + ha(i3, i5) * hc(i3, i4));
  digk(dt, du) = -4.e0 * d34 * d56 + dt * (3.e0 * dt + 4.e0 * du) +
                 fem::pow2(dt) * (dt * du / (d34 * d56) -
                                  2.e0 * (1.e0 / d34 + 1.e0 / d56) * (dt + du) +
                                  2.e0 * (d34 / d56 + d56 / d34));
  djgk(dt, du) = 8.e0 * fem::pow2((d34 + d56)) -
                 8.e0 * (d34 + d56) * (dt + du) - 6.e0 * dt * du -
                 2.e0 * dt * du *
                     (dt * du / (d34 * d56) -
                      2.e0 * (1.e0 / d34 + 1.e0 / d56) * (dt + du) +
                      2.e0 * (d34 / d56 + d56 / d34));
  /// C
  /// C...Define initial two objects, initialize loop.
  isub = mint(1);
  sh = vint(44);
  iref(1, 5) = 0;
  iref(1, 6) = 0;
  if (iset(isub) == 1 || iset(isub) == 3) {
    iref(1, 1) = mint(84) + 2 + iset(isub);
    iref(1, 2) = 0;
    iref(1, 3) = mint(83) + 6 + iset(isub);
    iref(1, 4) = 0;
  } else if (iset(isub) == 2 || iset(isub) == 4) {
    iref(1, 1) = mint(84) + 1 + iset(isub);
    iref(1, 2) = mint(84) + 2 + iset(isub);
    iref(1, 3) = mint(83) + 5 + iset(isub);
    iref(1, 4) = mint(83) + 6 + iset(isub);
  }
  np = 1;
  ip = 0;
statement_100:
  ip++;
  ninh = 0;
  /// C
  /// C...Loop over one/two resonances; reset decay rates.
  jtmax = 2;
  if (ip == 1 && (iset(isub) == 1 || iset(isub) == 3)) {
    jtmax = 1;
  }
  FEM_DO_SAFE(jt, 1, jtmax) {
    kdcy(jt) = 0;
    kfl1(jt) = 0;
    kfl2(jt) = 0;
    nsd(jt) = iref(ip, jt);
    id = iref(ip, jt);
    if (id == 0) {
      goto statement_140;
    }
    kfa = fem::iabs(k(id, 2));
    if (kfa < 23 || kfa > 40) {
      goto statement_140;
    }
    if (mdcy(kfa, 1) != 0) {
      if (isub == 1 || isub == 141) {
        mint(61) = 1;
      }
      pywidt(cmn, kfa, p(id, 5), wdtp, wdte);
      if (kchg(kfa, 3) == 0) {
        ipm = 2;
      } else {
        ipm = (5 + fem::isign(1, k(id, 2))) / 2;
      }
      if (jtmax == 1 ||
          fem::iabs(k(iref(ip, 1), 2)) != fem::iabs(k(iref(ip, 2), 2))) {
        i12 = 4;
      } else {
        if (jt == 1) {
          i12 = fem::fint(4.5f + rlu(cmn, 0));
        }
        i12 = 9 - i12;
      }
      rkfl = (wdte(0, 1) + wdte(0, ipm) + wdte(0, i12)) * rlu(cmn, 0);
      FEM_DO_SAFE(i, 1, mdcy(kfa, 3)) {
        idc = i + mdcy(kfa, 2) - 1;
        kfl1(jt) = kfdp(idc, 1) * fem::isign(1, k(id, 2));
        kfl2(jt) = kfdp(idc, 2) * fem::isign(1, k(id, 2));
        rkfl = rkfl - (wdte(i, 1) + wdte(i, ipm) + wdte(i, i12));
        if (rkfl <= 0.f) {
          goto statement_130;
        }
      }
    statement_130:;
    }
    /// C
    /// C...Summarize result on decay channel chosen.
    if ((kfa == 23 || kfa == 24) && kfl1(jt) == 0) {
      ninh++;
    }
    if (kfl1(jt) == 0) {
      goto statement_140;
    }
    kdcy(jt) = 2;
    if (fem::iabs(kfl1(jt)) <= 10 || kfl1(jt) == 21) {
      kdcy(jt) = 1;
    }
    if ((fem::iabs(kfl1(jt)) >= 23 && fem::iabs(kfl1(jt)) <= 25) ||
        (fem::iabs(kfl1(jt)) == 37)) {
      kdcy(jt) = 3;
    }
    nsd(jt) = n;
    /// C
    /// C...Fill decay products, prepared for parton showers for quarks.
    /// Clin-8/19/02 avoid actual argument in common blocks of LU2ENT:
    pid5 = p(id, 5);
    if (kdcy(jt) == 1) {
      /// C        CALL LU2ENT(-(N+1),KFL1(JT),KFL2(JT),P(ID,5))
      lu2ent(cmn, -(n + 1), kfl1(jt), kfl2(jt), pid5);
    } else {
      /// C        CALL LU2ENT(N+1,KFL1(JT),KFL2(JT),P(ID,5))
      lu2ent(cmn, n + 1, kfl1(jt), kfl2(jt), pid5);
    }
    /// C
    if (jtmax == 1) {
      cthe(jt) =
          vint(13) + (vint(33) - vint(13) + vint(34) - vint(14)) * rlu(cmn, 0);
      if (cthe(jt) > vint(33)) {
        cthe(jt) += vint(14) - vint(33);
      }
      phi(jt) = vint(24);
    } else {
      cthe(jt) = 2.f * rlu(cmn, 0) - 1.f;
      phi(jt) = paru(2) * rlu(cmn, 0);
    }
  statement_140:;
  }
  if (mint(3) == 1 && ip == 1) {
    mint(25) = kfl1(1);
    mint(26) = kfl2(1);
  }
  if (jtmax == 1 && kdcy(1) == 0) {
    goto statement_530;
  }
  if (jtmax == 2 && kdcy(1) == 0 && kdcy(2) == 0) {
    goto statement_530;
  }
  if (mstp(45) <= 0 || iref(ip, 2) == 0 || ninh >= 1) {
    goto statement_500;
  }
  if (k(iref(1, 1), 2) == 25 && ip == 1) {
    goto statement_500;
  }
  if (k(iref(1, 1), 2) == 25 && kdcy(1) * kdcy(2) == 0) {
    goto statement_500;
  }
  /// C
  /// C...Order incoming partons and outgoing resonances.
  ilin(1) = mint(84) + 1;
  if (k(mint(84) + 1, 2) > 0) {
    ilin(1) = mint(84) + 2;
  }
  if (k(ilin(1), 2) == 21) {
    ilin(1) = 2 * mint(84) + 3 - ilin(1);
  }
  ilin(2) = 2 * mint(84) + 3 - ilin(1);
  imin = 1;
  if (iref(ip, 5) == 25) {
    imin = 3;
  }
  imax = 2;
  iord = 1;
  if (k(iref(ip, 1), 2) == 23) {
    iord = 2;
  }
  if (k(iref(ip, 1), 2) == 24 && k(iref(ip, 2), 2) == -24) {
    iord = 2;
  }
  if (fem::iabs(k(iref(ip, iord), 2)) == 25) {
    iord = 3 - iord;
  }
  if (kdcy(iord) == 0) {
    iord = 3 - iord;
  }
  /// C
  /// C...Order decay products of resonances.
  FEM_DOSTEP(jt, iord, 3 - iord, 3 - 2 * iord) {
    if (kdcy(jt) == 0) {
      ilin(imax + 1) = nsd(jt);
      imax++;
    } else if (k(nsd(jt) + 1, 2) > 0) {
      ilin(imax + 1) = n + 2 * jt - 1;
      ilin(imax + 2) = n + 2 * jt;
      imax += 2;
      k(n + 2 * jt - 1, 2) = k(nsd(jt) + 1, 2);
      k(n + 2 * jt, 2) = k(nsd(jt) + 2, 2);
    } else {
      ilin(imax + 1) = n + 2 * jt;
      ilin(imax + 2) = n + 2 * jt - 1;
      imax += 2;
      k(n + 2 * jt - 1, 2) = k(nsd(jt) + 1, 2);
      k(n + 2 * jt, 2) = k(nsd(jt) + 2, 2);
    }
  }
  /// C
  /// C...Find charge, isospin, left- and righthanded couplings.
  xw = paru(102);
  FEM_DO_SAFE(i, imin, imax) {
    FEM_DO_SAFE(j, 1, 4) { coup(i, j) = 0.f; }
    kfa = fem::iabs(k(ilin(i), 2));
    if (kfa > 20) {
      goto statement_410;
    }
    coup(i, 1) = luchge(cmn, kfa) / 3.f;
    coup(i, 2) = fem::pow((-1), fem::mod(kfa, 2));
    coup(i, 4) = -2.f * coup(i, 1) * xw;
    coup(i, 3) = coup(i, 2) + coup(i, 4);
  statement_410:;
  }
  sqmz = fem::pow2(pmas(23, 1));
  gzmz = pmas(23, 1) * pmas(23, 2);
  sqmw = fem::pow2(pmas(24, 1));
  gzmw = pmas(24, 1) * pmas(24, 2);
  sqmzp = fem::pow2(pmas(32, 1));
  gzmzp = pmas(32, 1) * pmas(32, 2);
/// C
/// C...Select random angles; construct massless four-vectors.
statement_420:
  FEM_DO_SAFE(i, n + 1, n + 4) {
    k(i, 1) = 1;
    FEM_DO_SAFE(j, 1, 5) { p(i, j) = 0.f; }
  }
  FEM_DO_SAFE(jt, 1, jtmax) {
    if (kdcy(jt) == 0) {
      goto statement_440;
    }
    id = iref(ip, jt);
    p(n + 2 * jt - 1, 3) = 0.5f * p(id, 5);
    p(n + 2 * jt - 1, 4) = 0.5f * p(id, 5);
    p(n + 2 * jt, 3) = -0.5f * p(id, 5);
    p(n + 2 * jt, 4) = 0.5f * p(id, 5);
    cthe(jt) = 2.f * rlu(cmn, 0) - 1.f;
    phi(jt) = paru(2) * rlu(cmn, 0);
    ludbrb(n + 2 * jt - 1, n + 2 * jt, fem::acos(cthe(jt)), phi(jt),
           fem::dble(p(id, 1) / p(id, 4)), fem::dble(p(id, 2) / p(id, 4)),
           fem::dble(p(id, 3) / p(id, 4)));
  statement_440:;
  }
  /// C
  /// C...Store incoming and outgoing momenta, with random rotation to
  /// C...avoid accidental zeroes in HA expressions.
  FEM_DO_SAFE(i, 1, imax) {
    k(n + 4 + i, 1) = 1;
    p(n + 4 + i, 4) =
        fem::sqrt(fem::pow2(p(ilin(i), 1)) + fem::pow2(p(ilin(i), 2)) +
                  fem::pow2(p(ilin(i), 3)) + fem::pow2(p(ilin(i), 5)));
    p(n + 4 + i, 5) = p(ilin(i), 5);
    FEM_DO_SAFE(j, 1, 3) { p(n + 4 + i, j) = p(ilin(i), j); }
  }
  therr = fem::acos(2.f * rlu(cmn, 0) - 1.f);
  phirr = paru(2) * rlu(cmn, 0);
  ludbrb(n + 5, n + 4 + imax, therr, phirr, 0e0, 0e0, 0e0);
  FEM_DO_SAFE(i, 1, imax) {
    FEM_DO_SAFE(j, 1, 4) { pk(i, j) = p(n + 4 + i, j); }
  }
  /// C
  /// C...Calculate internal products.
  if (isub == 22 || isub == 23 || isub == 25) {
    FEM_DO_SAFE(i1, imin, imax - 1) {
      FEM_DO_SAFE(i2, i1 + 1, imax) {
        ha(i1, i2) =
            fem::sqrt((pk(i1, 4) - pk(i1, 3)) * (pk(i2, 4) + pk(i2, 3)) /
                      (1e-20f + fem::pow2(pk(i1, 1)) + fem::pow2(pk(i1, 2)))) *
                fem::cmplx(pk(i1, 1), pk(i1, 2)) -
            fem::sqrt((pk(i1, 4) + pk(i1, 3)) * (pk(i2, 4) - pk(i2, 3)) /
                      (1e-20f + fem::pow2(pk(i2, 1)) + fem::pow2(pk(i2, 2)))) *
                fem::cmplx(pk(i2, 1), pk(i2, 2));
        hc(i1, i2) = fem::conjg(ha(i1, i2));
        if (i1 <= 2) {
          ha(i1, i2) = fem::cmplx(0.f, 1.f) * ha(i1, i2);
        }
        if (i1 <= 2) {
          hc(i1, i2) = fem::cmplx(0.f, 1.f) * hc(i1, i2);
        }
        ha(i2, i1) = -ha(i1, i2);
        hc(i2, i1) = -hc(i1, i2);
      }
    }
  }
  FEM_DO_SAFE(i, 1, 2) {
    FEM_DO_SAFE(j, 1, 4) { pk(i, j) = -pk(i, j); }
  }
  FEM_DO_SAFE(i1, imin, imax - 1) {
    FEM_DO_SAFE(i2, i1 + 1, imax) {
      pkk(i1, i2) = 2.f * (pk(i1, 4) * pk(i2, 4) - pk(i1, 1) * pk(i2, 1) -
                           pk(i1, 2) * pk(i2, 2) - pk(i1, 3) * pk(i2, 3));
      pkk(i2, i1) = pkk(i1, i2);
    }
  }
  /// C
  if (iref(ip, 5) == 25) {
    /// C...Angular weight for H0 -> Z0 + Z0 or W+ + W- -> 4 quarks/leptons
    wt = 16.f * pkk(3, 5) * pkk(4, 6);
    if (ip == 1) {
      wtmax = fem::pow2(sh);
    }
    if (ip >= 2) {
      wtmax = fem::pow4(p(iref(ip, 6), 5));
    }
    /// C
  } else if (isub == 1) {
    if (kfa != 37) {
      /// C...Angular weight for gamma*/Z0 -> 2 quarks/leptons
      ei = kchg(fem::iabs(mint(15)), 1) / 3.f;
      ai = fem::sign(1.f, ei + 0.1f);
      vi = ai - 4.f * ei * xw;
      ef = kchg(kfa, 1) / 3.f;
      af = fem::sign(1.f, ef + 0.1f);
      vf = af - 4.f * ef * xw;
      gg = 1.f;
      gz = 1.f / (8.f * xw * (1.f - xw)) * sh * (sh - sqmz) /
           (fem::pow2((sh - sqmz)) + fem::pow2(gzmz));
      zz = 1.f / fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sh) /
           (fem::pow2((sh - sqmz)) + fem::pow2(gzmz));
      if (mstp(43) == 1) {
        /// C...Only gamma* production included
        gz = 0.f;
        zz = 0.f;
      } else if (mstp(43) == 2) {
        /// C...Only Z0 production included
        gg = 0.f;
        gz = 0.f;
      }
      asym = 2.f * (ei * ai * gz * ef * af + 4.f * vi * ai * zz * vf * af) /
             (fem::pow2(ei) * gg * fem::pow2(ef) + ei * vi * gz * ef * vf +
              (fem::pow2(vi) + fem::pow2(ai)) * zz *
                  (fem::pow2(vf) + fem::pow2(af)));
      wt = 1.f + asym * cthe(jt) + fem::pow2(cthe(jt));
      wtmax = 2.f + fem::abs(asym);
    } else {
      /// C...Angular weight for gamma*/Z0 -> H+ + H-
      wt = 1.f - fem::pow2(cthe(jt));
      wtmax = 1.f;
    }
    /// C
  } else if (isub == 2) {
    /// C...Angular weight for W+/- -> 2 quarks/leptons
    wt = fem::pow2((1.f + cthe(jt)));
    wtmax = 4.f;
    /// C
  } else if (isub == 15 || isub == 19) {
    /// C...Angular weight for f + fb -> gluon/gamma + Z0 ->
    /// C...-> gluon/gamma + 2 quarks/leptons
    wt = (fem::pow2((coup(1, 3) * coup(3, 3))) +
          fem::pow2((coup(1, 4) * coup(3, 4)))) *
             (fem::pow2(pkk(1, 3)) + fem::pow2(pkk(2, 4))) +
         (fem::pow2((coup(1, 3) * coup(3, 4))) +
          fem::pow2((coup(1, 4) * coup(3, 3)))) *
             (fem::pow2(pkk(1, 4)) + fem::pow2(pkk(2, 3)));
    wtmax = (fem::pow2(coup(1, 3)) + fem::pow2(coup(1, 4))) *
            (fem::pow2(coup(3, 3)) + fem::pow2(coup(3, 4))) *
            (fem::pow2((pkk(1, 3) + pkk(1, 4))) +
             fem::pow2((pkk(2, 3) + pkk(2, 4))));
    /// C
  } else if (isub == 16 || isub == 20) {
    /// C...Angular weight for f + fb' -> gluon/gamma + W+/- ->
    /// C...-> gluon/gamma + 2 quarks/leptons
    wt = fem::pow2(pkk(1, 3)) + fem::pow2(pkk(2, 4));
    wtmax =
        fem::pow2((pkk(1, 3) + pkk(1, 4))) + fem::pow2((pkk(2, 3) + pkk(2, 4)));
    /// C
  } else if (isub == 22) {
    /// C...Angular weight for f + fb -> Z0 + Z0 -> 4 quarks/leptons
    s34 = fem::pow2(p(iref(ip, iord), 5));
    s56 = fem::pow2(p(iref(ip, 3 - iord), 5));
    ti = pkk(1, 3) + pkk(1, 4) + s34;
    ui = pkk(1, 5) + pkk(1, 6) + s56;
    wt = fem::pow4(coup(1, 3)) *
             (fem::pow2((coup(3, 3) * coup(5, 3) *
                         fem::abs(fgk(1, 2, 3, 4, 5, 6) / ti +
                                  fgk(1, 2, 5, 6, 3, 4) / ui))) +
              fem::pow2((coup(3, 4) * coup(5, 3) *
                         fem::abs(fgk(1, 2, 4, 3, 5, 6) / ti +
                                  fgk(1, 2, 5, 6, 4, 3) / ui))) +
              fem::pow2((coup(3, 3) * coup(5, 4) *
                         fem::abs(fgk(1, 2, 3, 4, 6, 5) / ti +
                                  fgk(1, 2, 6, 5, 3, 4) / ui))) +
              fem::pow2((coup(3, 4) * coup(5, 4) *
                         fem::abs(fgk(1, 2, 4, 3, 6, 5) / ti +
                                  fgk(1, 2, 6, 5, 4, 3) / ui)))) +
         fem::pow4(coup(1, 4)) *
             (fem::pow2((coup(3, 3) * coup(5, 3) *
                         fem::abs(fgk(2, 1, 5, 6, 3, 4) / ti +
                                  fgk(2, 1, 3, 4, 5, 6) / ui))) +
              fem::pow2((coup(3, 4) * coup(5, 3) *
                         fem::abs(fgk(2, 1, 6, 5, 3, 4) / ti +
                                  fgk(2, 1, 3, 4, 6, 5) / ui))) +
              fem::pow2((coup(3, 3) * coup(5, 4) *
                         fem::abs(fgk(2, 1, 5, 6, 4, 3) / ti +
                                  fgk(2, 1, 4, 3, 5, 6) / ui))) +
              fem::pow2((coup(3, 4) * coup(5, 4) *
                         fem::abs(fgk(2, 1, 6, 5, 4, 3) / ti +
                                  fgk(2, 1, 4, 3, 6, 5) / ui))));
    wtmax = 4.f * s34 * s56 * (fem::pow4(coup(1, 3)) + fem::pow4(coup(1, 4))) *
            (fem::pow2(coup(3, 3)) + fem::pow2(coup(3, 4))) *
            (fem::pow2(coup(5, 3)) + fem::pow2(coup(5, 4))) * 4.f *
            (ti / ui + ui / ti + 2.f * sh * (s34 + s56) / (ti * ui) -
             s34 * s56 * (1.f / fem::pow2(ti) + 1.f / fem::pow2(ui)));
    /// C
  } else if (isub == 23) {
    /// C...Angular weight for f + fb' -> Z0 + W +/- -> 4 quarks/leptons
    d34 = fem::dble(fem::pow2(p(iref(ip, iord), 5)));
    d56 = fem::dble(fem::pow2(p(iref(ip, 3 - iord), 5)));
    dt = fem::dble(pkk(1, 3) + pkk(1, 4)) + d34;
    du = fem::dble(pkk(1, 5) + pkk(1, 6)) + d56;
    cawz = coup(2, 3) / fem::sngl(dt) -
           2.f * (1.f - xw) * coup(1, 2) / (sh - sqmw);
    cbwz = coup(1, 3) / fem::sngl(du) +
           2.f * (1.f - xw) * coup(1, 2) / (sh - sqmw);
    wt = fem::pow2(coup(5, 3)) *
             fem::pow2(fem::abs(cawz * fgk(1, 2, 3, 4, 5, 6) +
                                cbwz * fgk(1, 2, 5, 6, 3, 4))) +
         fem::pow2(coup(5, 4)) *
             fem::pow2(fem::abs(cawz * fgk(1, 2, 3, 4, 6, 5) +
                                cbwz * fgk(1, 2, 6, 5, 3, 4)));
    wtmax = 4.f * fem::sngl(d34 * d56) *
            (fem::pow2(coup(5, 3)) + fem::pow2(coup(5, 4))) *
            (fem::pow2(cawz) * fem::sngl(digk(dt, du)) +
             fem::pow2(cbwz) * fem::sngl(digk(du, dt)) +
             cawz * cbwz * fem::sngl(djgk(dt, du)));
    /// C
  } else if (isub == 24) {
    /// C...Angular weight for f + fb -> Z0 + H0 -> 2 quarks/leptons + H0
    wt = (fem::pow2((coup(1, 3) * coup(3, 3))) +
          fem::pow2((coup(1, 4) * coup(3, 4)))) *
             pkk(1, 3) * pkk(2, 4) +
         (fem::pow2((coup(1, 3) * coup(3, 4))) +
          fem::pow2((coup(1, 4) * coup(3, 3)))) *
             pkk(1, 4) * pkk(2, 3);
    wtmax = (fem::pow2(coup(1, 3)) + fem::pow2(coup(1, 4))) *
            (fem::pow2(coup(3, 3)) + fem::pow2(coup(3, 4))) *
            (pkk(1, 3) + pkk(1, 4)) * (pkk(2, 3) + pkk(2, 4));
    /// C
  } else if (isub == 25) {
    /// C...Angular weight for f + fb -> W+ + W- -> 4 quarks/leptons
    d34 = fem::dble(fem::pow2(p(iref(ip, iord), 5)));
    d56 = fem::dble(fem::pow2(p(iref(ip, 3 - iord), 5)));
    dt = fem::dble(pkk(1, 3) + pkk(1, 4)) + d34;
    du = fem::dble(pkk(1, 5) + pkk(1, 6)) + d56;
    cdww = (coup(1, 3) * sqmz / (sh - sqmz) + coup(1, 2)) / sh;
    caww = cdww + 0.5f * (coup(1, 2) + 1.f) / fem::sngl(dt);
    cbww = cdww + 0.5f * (coup(1, 2) - 1.f) / fem::sngl(du);
    ccww = coup(1, 4) * sqmz / (sh - sqmz) / sh;
    wt = fem::pow2(fem::abs(caww * fgk(1, 2, 3, 4, 5, 6) -
                            cbww * fgk(1, 2, 5, 6, 3, 4))) +
         fem::pow2(ccww) *
             fem::pow2(fem::abs(fgk(2, 1, 5, 6, 3, 4) - fgk(2, 1, 3, 4, 5, 6)));
    wtmax = 4.f * fem::sngl(d34 * d56) *
            (fem::pow2(caww) * fem::sngl(digk(dt, du)) +
             fem::pow2(cbww) * fem::sngl(digk(du, dt)) -
             caww * cbww * fem::sngl(djgk(dt, du)) +
             fem::pow2(ccww) *
                 fem::sngl(digk(dt, du) + digk(du, dt) - djgk(dt, du)));
    /// C
  } else if (isub == 26) {
    /// C...Angular weight for f + fb' -> W+/- + H0 -> 2 quarks/leptons + H0
    wt = pkk(1, 3) * pkk(2, 4);
    wtmax = (pkk(1, 3) + pkk(1, 4)) * (pkk(2, 3) + pkk(2, 4));
    /// C
  } else if (isub == 30) {
    /// C...Angular weight for f + g -> f + Z0 -> f + 2 quarks/leptons
    if (k(ilin(1), 2) > 0) {
      wt = (fem::pow2((coup(1, 3) * coup(3, 3))) +
            fem::pow2((coup(1, 4) * coup(3, 4)))) *
               (fem::pow2(pkk(1, 4)) + fem::pow2(pkk(3, 5))) +
           (fem::pow2((coup(1, 3) * coup(3, 4))) +
            fem::pow2((coup(1, 4) * coup(3, 3)))) *
               (fem::pow2(pkk(1, 3)) + fem::pow2(pkk(4, 5)));
    }
    if (k(ilin(1), 2) < 0) {
      wt = (fem::pow2((coup(1, 3) * coup(3, 3))) +
            fem::pow2((coup(1, 4) * coup(3, 4)))) *
               (fem::pow2(pkk(1, 3)) + fem::pow2(pkk(4, 5))) +
           (fem::pow2((coup(1, 3) * coup(3, 4))) +
            fem::pow2((coup(1, 4) * coup(3, 3)))) *
               (fem::pow2(pkk(1, 4)) + fem::pow2(pkk(3, 5)));
    }
    wtmax = (fem::pow2(coup(1, 3)) + fem::pow2(coup(1, 4))) *
            (fem::pow2(coup(3, 3)) + fem::pow2(coup(3, 4))) *
            (fem::pow2((pkk(1, 3) + pkk(1, 4))) +
             fem::pow2((pkk(3, 5) + pkk(4, 5))));
    /// C
  } else if (isub == 31) {
    /// C...Angular weight for f + g -> f' + W+/- -> f' + 2 quarks/leptons
    if (k(ilin(1), 2) > 0) {
      wt = fem::pow2(pkk(1, 4)) + fem::pow2(pkk(3, 5));
    }
    if (k(ilin(1), 2) < 0) {
      wt = fem::pow2(pkk(1, 3)) + fem::pow2(pkk(4, 5));
    }
    wtmax =
        fem::pow2((pkk(1, 3) + pkk(1, 4))) + fem::pow2((pkk(3, 5) + pkk(4, 5)));
    /// C
  } else if (isub == 141) {
    /// C...Angular weight for gamma*/Z0/Z'0 -> 2 quarks/leptons
    ei = kchg(fem::iabs(mint(15)), 1) / 3.f;
    ai = fem::sign(1.f, ei + 0.1f);
    vi = ai - 4.f * ei * xw;
    api = fem::sign(1.f, ei + 0.1f);
    vpi = api - 4.f * ei * xw;
    ef = kchg(kfa, 1) / 3.f;
    af = fem::sign(1.f, ef + 0.1f);
    vf = af - 4.f * ef * xw;
    apf = fem::sign(1.f, ef + 0.1f);
    vpf = apf - 4.f * ef * xw;
    gg = 1.f;
    gz = 1.f / (8.f * xw * (1.f - xw)) * sh * (sh - sqmz) /
         (fem::pow2((sh - sqmz)) + fem::pow2(gzmz));
    gzp = 1.f / (8.f * xw * (1.f - xw)) * sh * (sh - sqmzp) /
          (fem::pow2((sh - sqmzp)) + fem::pow2(gzmzp));
    zz = 1.f / fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sh) /
         (fem::pow2((sh - sqmz)) + fem::pow2(gzmz));
    zzp = 2.f / fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sh) *
          ((sh - sqmz) * (sh - sqmzp) + gzmz * gzmzp) /
          ((fem::pow2((sh - sqmz)) + fem::pow2(gzmz)) *
           (fem::pow2((sh - sqmzp)) + fem::pow2(gzmzp)));
    zpzp = 1.f / fem::pow2((16.f * xw * (1.f - xw))) * fem::pow2(sh) /
           (fem::pow2((sh - sqmzp)) + fem::pow2(gzmzp));
    if (mstp(44) == 1) {
      /// C...Only gamma* production included
      gz = 0.f;
      gzp = 0.f;
      zz = 0.f;
      zzp = 0.f;
      zpzp = 0.f;
    } else if (mstp(44) == 2) {
      /// C...Only Z0 production included
      gg = 0.f;
      gz = 0.f;
      gzp = 0.f;
      zzp = 0.f;
      zpzp = 0.f;
    } else if (mstp(44) == 3) {
      /// C...Only Z'0 production included
      gg = 0.f;
      gz = 0.f;
      gzp = 0.f;
      zz = 0.f;
      zzp = 0.f;
    } else if (mstp(44) == 4) {
      /// C...Only gamma*/Z0 production included
      gzp = 0.f;
      zzp = 0.f;
      zpzp = 0.f;
    } else if (mstp(44) == 5) {
      /// C...Only gamma*/Z'0 production included
      gz = 0.f;
      zz = 0.f;
      zzp = 0.f;
    } else if (mstp(44) == 6) {
      /// C...Only Z0/Z'0 production included
      gg = 0.f;
      gz = 0.f;
      gzp = 0.f;
    }
    asym = 2.f *
           (ei * ai * gz * ef * af + ei * api * gzp * ef * apf +
            4.f * vi * ai * zz * vf * af +
            (vi * api + vpi * ai) * zzp * (vf * apf + vpf * af) +
            4.f * vpi * api * zpzp * vpf * apf) /
           (fem::pow2(ei) * gg * fem::pow2(ef) + ei * vi * gz * ef * vf +
            ei * vpi * gzp * ef * vpf +
            (fem::pow2(vi) + fem::pow2(ai)) * zz *
                (fem::pow2(vf) + fem::pow2(af)) +
            (vi * vpi + ai * api) * zzp * (vf * vpf + af * apf) +
            (fem::pow2(vpi) + fem::pow2(api)) * zpzp *
                (fem::pow2(vpf) + fem::pow2(apf)));
    wt = 1.f + asym * cthe(jt) + fem::pow2(cthe(jt));
    wtmax = 2.f + fem::abs(asym);
    /// C
  } else {
    wt = 1.f;
    wtmax = 1.f;
  }
  /// C...Obtain correct angular distribution by rejection techniques.
  if (wt < rlu(cmn, 0) * wtmax) {
    goto statement_420;
  }
/// C
/// C...Construct massive four-vectors using angles chosen. Mark decayed
/// C...resonances, add documentation lines. Shower evolution.
statement_500:
  FEM_DO_SAFE(jt, 1, jtmax) {
    if (kdcy(jt) == 0) {
      goto statement_520;
    }
    id = iref(ip, jt);
    ludbrb(nsd(jt) + 1, nsd(jt) + 2, fem::acos(cthe(jt)), phi(jt),
           fem::dble(p(id, 1) / p(id, 4)), fem::dble(p(id, 2) / p(id, 4)),
           fem::dble(p(id, 3) / p(id, 4)));
    k(id, 1) += 10;
    k(id, 4) = nsd(jt) + 1;
    k(id, 5) = nsd(jt) + 2;
    idoc = mint(83) + mint(4);
    FEM_DO_SAFE(i, nsd(jt) + 1, nsd(jt) + 2) {
      mint(4)++;
      i1 = mint(83) + mint(4);
      k(i, 3) = i1;
      k(i1, 1) = 21;
      k(i1, 2) = k(i, 2);
      k(i1, 3) = iref(ip, jt + 2);
      FEM_DO_SAFE(j, 1, 5) { p(i1, j) = p(i, j); }
    }
    if (jtmax == 1) {
      mint(7) = mint(83) + 6 + 2 * iset(isub);
      mint(8) = mint(83) + 7 + 2 * iset(isub);
    }
    /// Clin-8/19/02 avoid actual argument in common blocks of LUSHOW:
    /// C      IF(MSTP(71).GE.1.AND.KDCY(JT).EQ.1) CALL LUSHOW(NSD(JT)+1,
    /// C     &NSD(JT)+2,P(ID,5))
    pid5 = p(id, 5);
    if (mstp(71) >= 1 && kdcy(jt) == 1) {
      lushow(cmn, nsd(jt) + 1, nsd(jt) + 2, pid5);
    }
    /// C
    /// C...Check if new resonances were produced, loop back if needed.
    if (kdcy(jt) != 3) {
      goto statement_520;
    }
    np++;
    iref(np, 1) = nsd(jt) + 1;
    iref(np, 2) = nsd(jt) + 2;
    iref(np, 3) = idoc + 1;
    iref(np, 4) = idoc + 2;
    iref(np, 5) = k(iref(ip, jt), 2);
    iref(np, 6) = iref(ip, jt);
  statement_520:;
  }
statement_530:
  if (ip < np) {
    goto statement_100;
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void pydiff(common& cmn) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<float> parj(cmn.parj, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_cref<float> vint(cmn.vint, dimension(400));
  ///
  int jt = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int isub = fem::int0;
  float sqlam = fem::float0;
  float pz = fem::float0;
  float pe = fem::float0;
  int imb = fem::int0;
  float chik = fem::float0;
  float chi = fem::float0;
  float cut = fem::float0;
  float cutr = fem::float0;
  float chir = fem::float0;
  float sqm = fem::float0;
  float pzi = fem::float0;
  float pei = fem::float0;
  float pqqp = fem::float0;
  /// C
  /// C...Handles diffractive and elastic scattering.
  /// C
  /// C...Reset K, P and V vectors. Store incoming particles.
  FEM_DO_SAFE(jt, 1, mstp(126) + 10) {
    i = mint(83) + jt;
    FEM_DO_SAFE(j, 1, 5) {
      k(i, j) = 0;
      p(i, j) = 0.f;
      v(i, j) = 0.f;
    }
  }
  n = mint(84);
  mint(3) = 0;
  mint(21) = 0;
  mint(22) = 0;
  mint(23) = 0;
  mint(24) = 0;
  mint(4) = 4;
  FEM_DO_SAFE(jt, 1, 2) {
    i = mint(83) + jt;
    k(i, 1) = 21;
    k(i, 2) = mint(10 + jt);
    p(i, 5) = vint(2 + jt);
    p(i, 3) = vint(5) * fem::pow((-1), (jt + 1));
    p(i, 4) = fem::sqrt(fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
  }
  mint(6) = 2;
  /// C
  /// C...Subprocess; kinematics.
  isub = mint(1);
  sqlam =
      fem::pow2((vint(2) - vint(63) - vint(64))) - 4.f * vint(63) * vint(64);
  pz = fem::sqrt(sqlam) / (2.f * vint(1));
  FEM_DO_SAFE(jt, 1, 2) {
    i = mint(83) + jt;
    pe = (vint(2) + vint(62 + jt) - vint(65 - jt)) / (2.f * vint(1));
    /// C
    /// C...Elastically scattered particle.
    if (mint(16 + jt) <= 0) {
      n++;
      k(n, 1) = 1;
      k(n, 2) = k(i, 2);
      k(n, 3) = i + 2;
      p(n, 3) = pz * fem::pow((-1), (jt + 1));
      p(n, 4) = pe;
      p(n, 5) = p(i, 5);
      /// C
      /// C...Diffracted particle: valence quark kicked out.
    } else if (mstp(101) == 1) {
      n += 2;
      k(n - 1, 1) = 2;
      k(n, 1) = 1;
      k(n - 1, 3) = i + 2;
      k(n, 3) = i + 2;
      pyspli(cmn, k(i, 2), 21, k(n, 2), k(n - 1, 2));
      p(n - 1, 5) = ulmass(cmn, k(n - 1, 2));
      p(n, 5) = ulmass(cmn, k(n, 2));
      sqlam = fem::pow2((vint(62 + jt) - fem::pow2(p(n - 1, 5)) -
                         fem::pow2(p(n, 5)))) -
              4.f * fem::pow2(p(n - 1, 5)) * fem::pow2(p(n, 5));
      p(n - 1, 3) =
          (pe * fem::sqrt(sqlam) +
           pz * (vint(62 + jt) + fem::pow2(p(n - 1, 5)) - fem::pow2(p(n, 5)))) /
          (2.f * vint(62 + jt)) * fem::pow((-1), (jt + 1));
      p(n - 1, 4) = fem::sqrt(fem::pow2(p(n - 1, 3)) + fem::pow2(p(n - 1, 5)));
      p(n, 3) = pz * fem::pow((-1), (jt + 1)) - p(n - 1, 3);
      p(n, 4) = fem::sqrt(fem::pow2(p(n, 3)) + fem::pow2(p(n, 5)));
      /// C
      /// C...Diffracted particle: gluon kicked out.
    } else {
      n += 3;
      k(n - 2, 1) = 2;
      k(n - 1, 1) = 2;
      k(n, 1) = 1;
      k(n - 2, 3) = i + 2;
      k(n - 1, 3) = i + 2;
      k(n, 3) = i + 2;
      pyspli(cmn, k(i, 2), 21, k(n, 2), k(n - 2, 2));
      k(n - 1, 2) = 21;
      p(n - 2, 5) = ulmass(cmn, k(n - 2, 2));
      p(n - 1, 5) = 0.f;
      p(n, 5) = ulmass(cmn, k(n, 2));
    /// C...Energy distribution for particle into two jets.
    statement_120:
      imb = 1;
      if (fem::mod(k(i, 2) / 1000, 10) != 0) {
        imb = 2;
      }
      chik = parp(92 + 2 * imb);
      if (mstp(92) <= 1) {
        if (imb == 1) {
          chi = rlu(cmn, 0);
        }
        if (imb == 2) {
          chi = 1.f - fem::sqrt(rlu(cmn, 0));
        }
      } else if (mstp(92) == 2) {
        chi = 1.f - fem::pow(rlu(cmn, 0), (1.f / (1.f + chik)));
      } else if (mstp(92) == 3) {
        cut = 2.f * 0.3f / vint(1);
      statement_130:
        chi = fem::pow2(rlu(cmn, 0));
        if (fem::pow((fem::pow2(chi) / (fem::pow2(chi) + fem::pow2(cut))),
                     0.25f) *
                fem::pow((1.f - chi), chik) <
            rlu(cmn, 0)) {
          goto statement_130;
        }
      } else {
        cut = 2.f * 0.3f / vint(1);
        cutr = (1.f + fem::sqrt(1.f + fem::pow2(cut))) / cut;
      statement_140:
        chir = cut * fem::pow(cutr, rlu(cmn, 0));
        chi = (fem::pow2(chir) - fem::pow2(cut)) / (2.f * chir);
        if (fem::pow((1.f - chi), chik) < rlu(cmn, 0)) {
          goto statement_140;
        }
      }
      if (chi < fem::pow2(p(n, 5)) / vint(62 + jt) ||
          chi > 1.f - fem::pow2(p(n - 2, 5)) / vint(62 + jt)) {
        goto statement_120;
      }
      sqm = fem::pow2(p(n - 2, 5)) / (1.f - chi) + fem::pow2(p(n, 5)) / chi;
      if (fem::pow2((fem::sqrt(sqm) + parj(32))) >= vint(62 + jt)) {
        goto statement_120;
      }
      pzi = (pe * (vint(62 + jt) - sqm) + pz * (vint(62 + jt) + sqm)) /
            (2.f * vint(62 + jt));
      pei = fem::sqrt(fem::pow2(pzi) + sqm);
      pqqp = (1.f - chi) * (pei + pzi);
      p(n - 2, 3) = 0.5f * (pqqp - fem::pow2(p(n - 2, 5)) / pqqp) *
                    fem::pow((-1), (jt + 1));
      p(n - 2, 4) = fem::sqrt(fem::pow2(p(n - 2, 3)) + fem::pow2(p(n - 2, 5)));
      p(n - 1, 3) = (pz - pzi) * fem::pow((-1), (jt + 1));
      p(n - 1, 4) = fem::abs(p(n - 1, 3));
      p(n, 3) = pzi * fem::pow((-1), (jt + 1)) - p(n - 2, 3);
      p(n, 4) = fem::sqrt(fem::pow2(p(n, 3)) + fem::pow2(p(n, 5)));
    }
    /// C
    /// C...Documentation lines.
    k(i + 2, 1) = 21;
    if (mint(16 + jt) == 0) {
      k(i + 2, 2) = mint(10 + jt);
    }
    if (mint(16 + jt) != 0) {
      k(i + 2, 2) = 10 * (mint(10 + jt) / 10);
    }
    k(i + 2, 3) = i;
    p(i + 2, 3) = pz * fem::pow((-1), (jt + 1));
    p(i + 2, 4) = pe;
    p(i + 2, 5) = fem::sqrt(vint(62 + jt));
  }
  /// C
  /// C...Rotate outgoing partons/particles using cos(theta).
  ludbrb(mint(83) + 3, n, fem::acos(vint(23)), vint(24), 0e0, 0e0, 0e0);
  /// C
}

/// C
/// C*********************************************************************
/// C
void lurobo(common& cmn, float const& the, float const& phi, float const& bex,
            float const& bey, float const& bez) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  ///
  int imin = fem::int0;
  int imax = fem::int0;
  double dbx = fem::double0;
  double dby = fem::double0;
  double dbz = fem::double0;
  int imi = fem::int0;
  int ima = fem::int0;
  double dbex = fem::double0;
  double dbey = fem::double0;
  double dbez = fem::double0;
  arr_2d<3, 3, float> rot(fem::fill0);
  int i = fem::int0;
  int j = fem::int0;
  arr_1d<3, float> pr(fem::fill0);
  arr_1d<3, float> vr(fem::fill0);
  double db = fem::double0;
  double dga = fem::double0;
  arr_1d<4, double> dp(fem::fill0);
  arr_1d<4, double> dv(fem::fill0);
  double dbp = fem::double0;
  double dgabp = fem::double0;
  double dbv = fem::double0;
  double dgabv = fem::double0;
  /// C
  /// C...Purpose: to perform rotations and boosts.
  /// C
  /// C...Find range of rotation/boost. Convert boost to double precision.
  imin = 1;
  if (mstu(1) > 0) {
    imin = mstu(1);
  }
  imax = n;
  if (mstu(2) > 0) {
    imax = mstu(2);
  }
  dbx = fem::dble(bex);
  dby = fem::dble(bey);
  dbz = fem::dble(bez);
  goto statement_100;
  /// C
  /// C...Entry for specific range and double precision boost.
  /// UNHANDLED: ENTRY ludbrb(imi,ima,the,phi,dbex,dbey,dbez)
  imin = imi;
  if (imin <= 0) {
    imin = 1;
  }
  imax = ima;
  if (imax <= 0) {
    imax = n;
  }
  dbx = dbex;
  dby = dbey;
  dbz = dbez;
/// C
/// C...Check range of rotation/boost.
statement_100:
  if (imin > mstu(4) || imax > mstu(4)) {
    luerrm(cmn, 11, "(LUROBO:) range outside LUJETS memory");
    return;
  }
  /// C
  /// C...Rotate, typically from z axis to direction (theta,phi).
  /// Clin-5/2012:
  /// C      IF(THE**2+PHI**2.GT.1E-20) THEN
  if ((fem::pow2(the) + fem::pow2(phi)) > 1e-20f) {
    rot(1, 1) = fem::cos(the) * fem::cos(phi);
    rot(1, 2) = -fem::sin(phi);
    rot(1, 3) = fem::sin(the) * fem::cos(phi);
    rot(2, 1) = fem::cos(the) * fem::sin(phi);
    rot(2, 2) = fem::cos(phi);
    rot(2, 3) = fem::sin(the) * fem::sin(phi);
    rot(3, 1) = -fem::sin(the);
    rot(3, 2) = 0.f;
    rot(3, 3) = fem::cos(the);
    FEM_DO_SAFE(i, imin, imax) {
      if (k(i, 1) <= 0) {
        goto statement_130;
      }
      FEM_DO_SAFE(j, 1, 3) {
        pr(j) = p(i, j);
        vr(j) = v(i, j);
      }
      FEM_DO_SAFE(j, 1, 3) {
        p(i, j) = rot(j, 1) * pr(1) + rot(j, 2) * pr(2) + rot(j, 3) * pr(3);
        v(i, j) = rot(j, 1) * vr(1) + rot(j, 2) * vr(2) + rot(j, 3) * vr(3);
      }
    statement_130:;
    }
  }
  /// C
  /// C...Boost, typically from rest to momentum/energy=beta.
  /// Clin-5/2012:
  /// C      IF(DBX**2+DBY**2+DBZ**2.GT.1E-20) THEN
  if ((fem::pow2(dbx) + fem::pow2(dby) + fem::pow2(dbz)) > 1e-20) {
    db = fem::sqrt(fem::pow2(dbx) + fem::pow2(dby) + fem::pow2(dbz));
    if (db > 0.99999999e0) {
      /// C...Rescale boost vector if too close to unity.
      luerrm(cmn, 3, "(LUROBO:) boost vector too large");
      dbx = dbx * (0.99999999e0 / db);
      dby = dby * (0.99999999e0 / db);
      dbz = dbz * (0.99999999e0 / db);
      db = 0.99999999e0;
    }
    dga = 1e0 / fem::sqrt(1e0 - fem::pow2(db));
    FEM_DO_SAFE(i, imin, imax) {
      if (k(i, 1) <= 0) {
        goto statement_150;
      }
      FEM_DO_SAFE(j, 1, 4) {
        dp(j) = fem::dble(p(i, j));
        dv(j) = fem::dble(v(i, j));
      }
      dbp = dbx * dp(1) + dby * dp(2) + dbz * dp(3);
      dgabp = dga * (dga * dbp / (1e0 + dga) + dp(4));
      p(i, 1) = fem::sngl(dp(1) + dgabp * dbx);
      p(i, 2) = fem::sngl(dp(2) + dgabp * dby);
      p(i, 3) = fem::sngl(dp(3) + dgabp * dbz);
      p(i, 4) = fem::sngl(dga * (dp(4) + dbp));
      dbv = dbx * dv(1) + dby * dv(2) + dbz * dv(3);
      dgabv = dga * (dga * dbv / (1e0 + dga) + dv(4));
      v(i, 1) = fem::sngl(dv(1) + dgabv * dbx);
      v(i, 2) = fem::sngl(dv(2) + dgabv * dby);
      v(i, 3) = fem::sngl(dv(3) + dgabv * dbz);
      v(i, 4) = fem::sngl(dga * (dv(4) + dbv));
    statement_150:;
    }
  }
  /// C
}

/// C
/// C*********************************************************************
/// C
void pyfram(common& cmn, int const& iframe) {
  common_write write(cmn);
  /// COMMON ludat1
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  /// COMMON pypars
  arr_ref<int> msti(cmn.msti, dimension(200));
  /// COMMON pyint1
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_cref<float> vint(cmn.vint, dimension(400));
  ///
  /// C
  /// C...Performs transformations between different coordinate frames.
  /// C
  if (iframe < 1 || iframe > 2) {
    write(
        mstu(11),
        "(1x,'Error: illegal values in subroutine PYFRAM.',1x,"
        "'No transformation performed.',/,1x,'IFRAME =',1x,i5,'; MINT(6) =',1x,"
        "i5)"),
        iframe, mint(6);
    return;
  }
  if (iframe == mint(6)) {
    return;
  }
  /// C
  if (mint(6) == 1) {
    /// C...Transform from fixed target or user specified frame to
    /// C...CM-frame of incoming particles.
    lurobo(cmn, 0.f, 0.f, -vint(8), -vint(9), -vint(10));
    lurobo(cmn, 0.f, -vint(7), 0.f, 0.f, 0.f);
    lurobo(cmn, -vint(6), 0.f, 0.f, 0.f, 0.f);
    mint(6) = 2;
    /// C
  } else {
    /// C...Transform from particle CM-frame to fixed target or user specified
    /// C...frame.
    lurobo(cmn, vint(6), vint(7), vint(8), vint(9), vint(10));
    mint(6) = 1;
  }
  msti(6) = mint(6);
  /// C
}

/// C
/// C*********************************************************************
/// C
void pythia(common& cmn) {
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int> msub(cmn.msub, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> msti(cmn.msti, dimension(200));
  arr_ref<float> pari(cmn.pari, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_cref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_ref<int, 2> ngen(cmn.ngen, dim1(0, 200).dim2(3));
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  int novl = fem::int0;
  int iovl = fem::int0;
  int isub = fem::int0;
  int j = fem::int0;
  int ipu1 = fem::int0;
  int ipu2 = fem::int0;
  int nsav1 = fem::int0;
  int nsav2 = fem::int0;
  int nsav3 = fem::int0;
  int ipu3 = fem::int0;
  int ipu4 = fem::int0;
  float qmax = fem::float0;
  int i = fem::int0;
  float pt = fem::float0;
  int ngens = fem::int0;
  float xsecs = fem::float0;
  float xmaxs = fem::float0;
  float fac = fem::float0;
  int is = fem::int0;
  float pr = fem::float0;
  /// C
  /// C...Administers the generation of a high-pt event via calls to a number
  /// C...of subroutines; also computes cross-sections.
  /// C
  /// C...Loop over desired number of overlayed events (normally 1).
  mint(7) = 0;
  mint(8) = 0;
  novl = 1;
  if (mstp(131) != 0) {
    pyovly(cmn, 2);
  }
  if (mstp(131) != 0) {
    novl = mint(81);
  }
  mint(83) = 0;
  mint(84) = mstp(126);
  mstu(70) = 0;
  FEM_DO_SAFE(iovl, 1, novl) {
    if (mint(84) + 100 >= mstu(4)) {
      luerrm(cmn, 11, "(PYTHIA:) no more space in LUJETS for overlayed events");
      if (mstu(21) >= 1) {
        goto statement_200;
      }
    }
    mint(82) = iovl;
  /// C
  /// C...Generate variables of hard scattering.
  statement_100:
    if (iovl == 1) {
      ngen(0, 2)++;
    }
    mint(31) = 0;
    mint(51) = 0;
    pyrand(cmn);
    isub = mint(1);
    if (iovl == 1) {
      ngen(isub, 2)++;
      /// C
      /// C...Store information on hard interaction.
      FEM_DO_SAFE(j, 1, 200) {
        msti(j) = 0;
        pari(j) = 0.f;
      }
      msti(1) = mint(1);
      msti(2) = mint(2);
      msti(11) = mint(11);
      msti(12) = mint(12);
      msti(15) = mint(15);
      msti(16) = mint(16);
      msti(17) = mint(17);
      msti(18) = mint(18);
      pari(11) = vint(1);
      pari(12) = vint(2);
      if (isub != 95) {
        FEM_DO_SAFE(j, 13, 22) { pari(j) = vint(30 + j); }
        pari(33) = vint(41);
        pari(34) = vint(42);
        pari(35) = pari(33) - pari(34);
        pari(36) = vint(21);
        pari(37) = vint(22);
        pari(38) = vint(26);
        pari(41) = vint(23);
      }
    }
    /// C
    if (mstp(111) == -1) {
      goto statement_160;
    }
    if (isub <= 90 || isub >= 95) {
      /// C...Hard scattering (including low-pT):
      /// C...reconstruct kinematics and colour flow of hard scattering.
      pyscat(cmn);
      if (mint(51) == 1) {
        goto statement_100;
      }
      /// C
      /// C...Showering of initial state partons (optional).
      ipu1 = mint(84) + 1;
      ipu2 = mint(84) + 2;
      if (mstp(61) >= 1 && mint(43) != 1 && isub != 95) {
        pysspa(cmn, ipu1, ipu2);
      }
      nsav1 = n;
      /// C
      /// C...Multiple interactions.
      if (mstp(81) >= 1 && mint(43) == 4 && isub != 95) {
        pymult(cmn, 6);
      }
      mint(1) = isub;
      nsav2 = n;
      /// C
      /// C...Hadron remnants and primordial kT.
      pyremn(cmn, ipu1, ipu2);
      if (mint(51) == 1) {
        goto statement_100;
      }
      nsav3 = n;
      /// C
      /// C...Showering of final state partons (optional).
      ipu3 = mint(84) + 3;
      ipu4 = mint(84) + 4;
      if (mstp(71) >= 1 && isub != 95 && k(ipu3, 1) > 0 && k(ipu3, 1) <= 10 &&
          k(ipu4, 1) > 0 && k(ipu4, 1) <= 10) {
        qmax = fem::sqrt(parp(71) * vint(52));
        if (isub == 5) {
          qmax = fem::sqrt(fem::pow2(pmas(23, 1)));
        }
        if (isub == 8) {
          qmax = fem::sqrt(fem::pow2(pmas(24, 1)));
        }
        lushow(cmn, ipu3, ipu4, qmax);
      }
      /// C
      /// C...Sum up transverse and longitudinal momenta.
      if (iovl == 1) {
        pari(65) = 2.f * pari(17);
        FEM_DO_SAFE(i, mstp(126) + 1, n) {
          if (k(i, 1) <= 0 || k(i, 1) > 10) {
            goto statement_130;
          }
          pt = fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)));
          pari(69) += pt;
          if (i <= nsav1 || i > nsav3) {
            pari(66) += pt;
          }
          if (i > nsav1 && i <= nsav2) {
            pari(68) += pt;
          }
        statement_130:;
        }
        pari(67) = pari(68);
        pari(71) = vint(151);
        pari(72) = vint(152);
        pari(73) = vint(151);
        pari(74) = vint(152);
      }
      /// C
      /// C...Decay of final state resonances.
      if (mstp(41) >= 1 && isub != 95) {
        pyresd(cmn);
      }
      /// C
    } else {
      /// C...Diffractive and elastic scattering.
      pydiff(cmn);
      if (iovl == 1) {
        pari(65) = 2.f * pari(17);
        pari(66) = pari(65);
        pari(69) = pari(65);
      }
    }
    /// C
    /// C...Recalculate energies from momenta and masses (if desired).
    if (mstp(113) >= 1) {
      FEM_DO_SAFE(i, mint(83) + 1, n) {
        if (k(i, 1) > 0 && k(i, 1) <= 10) {
          p(i, 4) = fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                              fem::pow2(p(i, 3)) + fem::pow2(p(i, 5)));
        }
      }
    }
    /// C
    /// C...Rearrange partons along strings, check invariant mass cuts.
    mstu(28) = 0;
    luprep(cmn, mint(84) + 1);
    if (mstp(112) == 1 && mstu(28) == 3) {
      goto statement_100;
    }
    if (mstp(125) == 0 || mstp(125) == 1) {
      FEM_DO_SAFE(i, mint(84) + 1, n) {
        if (k(i, 2) != 94) {
          goto statement_150;
        }
        k(i + 1, 3) = fem::mod(k(i + 1, 4) / mstu(5), mstu(5));
        k(i + 2, 3) = fem::mod(k(i + 2, 4) / mstu(5), mstu(5));
      statement_150:;
      }
      luedit(cmn, 12);
      luedit(cmn, 14);
      if (mstp(125) == 0) {
        luedit(cmn, 15);
      }
      if (mstp(125) == 0) {
        mint(4) = 0;
      }
    }
    /// C
    /// C...Introduce separators between sections in LULIST event listing.
    if (iovl == 1 && mstp(125) <= 0) {
      mstu(70) = 1;
      mstu(71) = n;
    } else if (iovl == 1) {
      mstu(70) = 3;
      mstu(71) = 2;
      mstu(72) = mint(4);
      mstu(73) = n;
    }
    /// C
    /// C...Perform hadronization (if desired).
    if (mstp(111) >= 1) {
      luexec(cmn);
    }
    if (mstp(125) == 0 || mstp(125) == 1) {
      luedit(cmn, 14);
    }
  /// C
  /// C...Calculate Monte Carlo estimates of cross-sections.
  statement_160:
    if (iovl == 1) {
      if (mstp(111) != -1) {
        ngen(isub, 3)++;
      }
      ngen(0, 3)++;
      xsec(0, 3) = 0.f;
      FEM_DO_SAFE(i, 1, 200) {
        if (i == 96) {
          xsec(i, 3) = 0.f;
        } else if (msub(95) == 1 && (i == 11 || i == 12 || i == 13 || i == 28 ||
                                     i == 53 || i == 68)) {
          xsec(i, 3) = xsec(96, 2) * ngen(i, 3) /
                       fem::max(1.f, fem::ffloat(ngen(96, 1)) *
                                         fem::ffloat(ngen(96, 2)));
        } else if (ngen(i, 1) == 0) {
          xsec(i, 3) = 0.f;
        } else if (ngen(i, 2) == 0) {
          xsec(i, 3) = xsec(i, 2) * ngen(0, 3) /
                       (fem::ffloat(ngen(i, 1)) * fem::ffloat(ngen(0, 2)));
        } else {
          xsec(i, 3) = xsec(i, 2) * ngen(i, 3) /
                       (fem::ffloat(ngen(i, 1)) * fem::ffloat(ngen(i, 2)));
        }
        xsec(0, 3) += xsec(i, 3);
      }
      if (msub(95) == 1) {
        ngens =
            ngen(91, 3) + ngen(92, 3) + ngen(93, 3) + ngen(94, 3) + ngen(95, 3);
        xsecs =
            xsec(91, 3) + xsec(92, 3) + xsec(93, 3) + xsec(94, 3) + xsec(95, 3);
        xmaxs = xsec(95, 1);
        if (msub(91) == 1) {
          xmaxs += xsec(91, 1);
        }
        if (msub(92) == 1) {
          xmaxs += xsec(92, 1);
        }
        if (msub(93) == 1) {
          xmaxs += xsec(93, 1);
        }
        if (msub(94) == 1) {
          xmaxs += xsec(94, 1);
        }
        fac = 1.f;
        if (ngens < ngen(0, 3)) {
          fac = (xmaxs - xsecs) / (xsec(0, 3) - xsecs);
        }
        xsec(11, 3) = fac * xsec(11, 3);
        xsec(12, 3) = fac * xsec(12, 3);
        xsec(13, 3) = fac * xsec(13, 3);
        xsec(28, 3) = fac * xsec(28, 3);
        xsec(53, 3) = fac * xsec(53, 3);
        xsec(68, 3) = fac * xsec(68, 3);
        xsec(0, 3) =
            xsec(91, 3) + xsec(92, 3) + xsec(93, 3) + xsec(94, 3) + xsec(95, 1);
      }
      /// C
      /// C...Store final information.
      mint(5)++;
      msti(3) = mint(3);
      msti(4) = mint(4);
      msti(5) = mint(5);
      msti(6) = mint(6);
      msti(7) = mint(7);
      msti(8) = mint(8);
      msti(13) = mint(13);
      msti(14) = mint(14);
      msti(21) = mint(21);
      msti(22) = mint(22);
      msti(23) = mint(23);
      msti(24) = mint(24);
      msti(25) = mint(25);
      msti(26) = mint(26);
      msti(31) = mint(31);
      pari(1) = xsec(0, 3);
      pari(2) = xsec(0, 3) / mint(5);
      pari(31) = vint(141);
      pari(32) = vint(142);
      if (isub != 95 && mint(7) * mint(8) != 0) {
        pari(42) = 2.f * vint(47) / vint(1);
        FEM_DO_SAFE(is, 7, 8) {
          pari(36 + is) = p(mint(is), 3) / vint(1);
          pari(38 + is) = p(mint(is), 4) / vint(1);
          i = mint(is);
          pr = fem::max(1e-20f, fem::pow2(p(i, 5)) + fem::pow2(p(i, 1)) +
                                    fem::pow2(p(i, 2)));
          pari(40 + is) = fem::sign(
              fem::log(fem::min(
                  (fem::sqrt(pr + fem::pow2(p(i, 3))) + fem::abs(p(i, 3))) /
                      fem::sqrt(pr),
                  1e20f)),
              p(i, 3));
          pr = fem::max(1e-20f, fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)));
          pari(42 + is) = fem::sign(
              fem::log(fem::min(
                  (fem::sqrt(pr + fem::pow2(p(i, 3))) + fem::abs(p(i, 3))) /
                      fem::sqrt(pr),
                  1e20f)),
              p(i, 3));
          pari(44 + is) =
              p(i, 3) / fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2)) +
                                  fem::pow2(p(i, 3)));
          pari(46 + is) = ulangl(
              cmn, p(i, 3), fem::sqrt(fem::pow2(p(i, 1)) + fem::pow2(p(i, 2))));
          pari(48 + is) = ulangl(cmn, p(i, 1), p(i, 2));
        }
      }
      pari(61) = vint(148);
      if (iset(isub) == 1 || iset(isub) == 3) {
        mstu(161) = mint(21);
        mstu(162) = 0;
      } else {
        mstu(161) = mint(21);
        mstu(162) = mint(22);
      }
    }
    /// C
    /// C...Prepare to go to next overlayed event.
    msti(41) = iovl;
    if (iovl >= 2 && iovl <= 10) {
      msti(40 + iovl) = isub;
    }
    if (mstu(70) < 10) {
      mstu(70)++;
      mstu(70 + mstu(70)) = n;
    }
    mint(83) = n;
    mint(84) = n + mstp(126);
  }
  /// C
  /// C...Information on overlayed events.
  if (mstp(131) == 1 && mstp(133) >= 1) {
    pari(91) = vint(132);
    pari(92) = vint(133);
    pari(93) = vint(134);
    if (mstp(133) == 2) {
      pari(93) = pari(93) * xsec(0, 3) / vint(131);
    }
  }
/// C
/// C...Transform to the desired coordinate frame.
statement_200:
  pyfram(cmn, mstp(124));
  /// C
}

struct hijhrd_save {
  fem::variant_bindings hstrng_bindings;
  float ampx;
  float amtx;
  float ecut1;
  float ecut2;
  float epm;
  float epp;
  float etm;
  float etp;
  int i;
  int iinird;
  int iopjet;
  arr<int, 2> ip;
  int ip1;
  int ip2;
  arr<int> ipb;
  arr<int> ipq;
  int is7;
  int is8;
  int isub11;
  int isub12;
  int isub28;
  arr<int, 2> it;
  int it1;
  int it2;
  arr<int> itb;
  arr<int> itq;
  int j;
  int jj;
  int jpp;
  int jtt;
  int l0;
  int lp;
  int lpb;
  int lpq;
  int lt;
  int ltb;
  int ltq;
  int misp;
  int miss;
  int mist;
  int mxjt;
  int mxsg;
  int mxsj;
  float pep;
  float pet;
  float pinird;
  float pxp;
  float pxt;
  float pyp;
  float pyt;
  float pzp;
  float pzt;
  float qm;
  float qmass2;
  float sw;
  float sxx;
  float wm;
  float wp;

  hijhrd_save()
      : ampx(fem::float0),
        amtx(fem::float0),
        ecut1(fem::float0),
        ecut2(fem::float0),
        epm(fem::float0),
        epp(fem::float0),
        etm(fem::float0),
        etp(fem::float0),
        i(fem::int0),
        iinird(fem::int0),
        iopjet(fem::int0),
        ip(dimension(100, 2), fem::fill0),
        ip1(fem::int0),
        ip2(fem::int0),
        ipb(dimension(50), fem::fill0),
        ipq(dimension(50), fem::fill0),
        is7(fem::int0),
        is8(fem::int0),
        isub11(fem::int0),
        isub12(fem::int0),
        isub28(fem::int0),
        it(dimension(100, 2), fem::fill0),
        it1(fem::int0),
        it2(fem::int0),
        itb(dimension(50), fem::fill0),
        itq(dimension(50), fem::fill0),
        j(fem::int0),
        jj(fem::int0),
        jpp(fem::int0),
        jtt(fem::int0),
        l0(fem::int0),
        lp(fem::int0),
        lpb(fem::int0),
        lpq(fem::int0),
        lt(fem::int0),
        ltb(fem::int0),
        ltq(fem::int0),
        misp(fem::int0),
        miss(fem::int0),
        mist(fem::int0),
        mxjt(fem::int0),
        mxsg(fem::int0),
        mxsj(fem::int0),
        pep(fem::float0),
        pet(fem::float0),
        pinird(fem::float0),
        pxp(fem::float0),
        pxt(fem::float0),
        pyp(fem::float0),
        pyt(fem::float0),
        pzp(fem::float0),
        pzt(fem::float0),
        qm(fem::float0),
        qmass2(fem::float0),
        sw(fem::float0),
        sxx(fem::float0),
        wm(fem::float0),
        wp(fem::float0) {}
};

void hijhrd(common& cmn, int const& jp, int const& jt, int const& jout,
            int& jflg, int const& iopjt0) {
  FEM_CMN_SVE(hijhrd);
  common_write write(cmn);
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  arr_ref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_cref<float> hidat(cmn.hidat, dimension(10));
  arr_ref<int> npj(cmn.npj, dimension(300));
  arr_ref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_ref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_ref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_ref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_ref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_ref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_ref<int> ntj(cmn.ntj, dimension(300));
  arr_ref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_ref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_ref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_ref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_ref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_ref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  int& nsg = cmn.nsg;
  const int maxstr = 150001;
  arr_ref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_ref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_ref<int, 2> k1sg(cmn.k1sg, dimension(maxstr, 100));
  arr_ref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_ref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_ref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_ref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_ref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_ref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  int& ndr = cmn.ndr;
  arr_ref<int, 2> iadr(cmn.iadr, dimension(maxstr, 2));
  arr_ref<int> kfdr(cmn.kfdr, dimension(maxstr));
  arr_ref<float, 2> pdr(cmn.pdr, dimension(maxstr, 5));
  arr_ref<float, 2> rtdr(cmn.rtdr, dimension(maxstr, 2));
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_cref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_cref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_cref<float> vint(cmn.vint, dimension(400));
  arr_ref<float, 2> coef(cmn.coef, dimension(200, 20));
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  int& mint4 = cmn.mint4;
  int& mint5 = cmn.mint5;
  arr_cref<float, 2> atco(cmn.atco, dimension(200, 20));
  arr_cref<float> atxs(cmn.atxs, dim1(0, 200));
  float& pttrig = cmn.pttrig;
  int& maxmiss = cmn.maxmiss;
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  float& ampx = sve.ampx;
  float& amtx = sve.amtx;
  float& ecut1 = sve.ecut1;
  float& ecut2 = sve.ecut2;
  float& epm = sve.epm;
  float& epp = sve.epp;
  float& etm = sve.etm;
  float& etp = sve.etp;
  int& i = sve.i;
  int& iinird = sve.iinird;
  int& iopjet = sve.iopjet;
  arr_ref<int, 2> ip(sve.ip, dimension(100, 2));
  int& ip1 = sve.ip1;
  int& ip2 = sve.ip2;
  arr_ref<int> ipb(sve.ipb, dimension(50));
  arr_ref<int> ipq(sve.ipq, dimension(50));
  int& is7 = sve.is7;
  int& is8 = sve.is8;
  int& isub11 = sve.isub11;
  int& isub12 = sve.isub12;
  int& isub28 = sve.isub28;
  arr_ref<int, 2> it(sve.it, dimension(100, 2));
  int& it1 = sve.it1;
  int& it2 = sve.it2;
  arr_ref<int> itb(sve.itb, dimension(50));
  arr_ref<int> itq(sve.itq, dimension(50));
  int& j = sve.j;
  int& jj = sve.jj;
  int& jpp = sve.jpp;
  int& jtt = sve.jtt;
  int& l0 = sve.l0;
  int& lp = sve.lp;
  int& lpb = sve.lpb;
  int& lpq = sve.lpq;
  int& lt = sve.lt;
  int& ltb = sve.ltb;
  int& ltq = sve.ltq;
  int& misp = sve.misp;
  int& miss = sve.miss;
  int& mist = sve.mist;
  int& mxjt = sve.mxjt;
  int& mxsg = sve.mxsg;
  int& mxsj = sve.mxsj;
  float& pep = sve.pep;
  float& pet = sve.pet;
  float& pinird = sve.pinird;
  float& pxp = sve.pxp;
  float& pxt = sve.pxt;
  float& pyp = sve.pyp;
  float& pyt = sve.pyt;
  float& pzp = sve.pzp;
  float& pzt = sve.pzt;
  float& qm = sve.qm;
  float& qmass2 = sve.qmass2;
  float& sw = sve.sw;
  float& sxx = sve.sxx;
  float& wm = sve.wm;
  float& wp = sve.wp;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_ref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_ref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  /// C
  /// C        IOPTJET=1, ALL JET WILL FORM SINGLE STRING SYSTEM
  /// C                0, ONLY Q-QBAR JET FORM SINGLE STRING SYSTEM
  /// C*******Perform jets production and fragmentation when JP JT *******
  /// C     scatter. JOUT-> number of hard scatterings precede this one  *
  /// C     for the the same pair(JP,JT). JFLG->a flag to show whether   *
  /// C     jets can be produced (with valence quark=1,gluon=2, q-qbar=3)*
  /// C     or not(0). Information of jets are in  COMMON/ATTJET and     *
  /// C     /MINJET. ABS(NFP(JP,6)) is the total number jets produced by *
  /// C    JP. If NFP(JP,6)<0 JP can not produce jet anymore. *
  /// C*******************************************************************
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HIJDAT/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// C        COMMON/HJJET4/NDR,IADR(900,2),KFDR(900),PDR(900,5)
  /// Cc      SAVE /HJJET4/
  /// Cc      SAVE /RNDF77/
  /// C************************************ HIJING common block
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /LUDAT1/
  /// Cc      SAVE /PYSUBS/
  /// Cc      SAVE /PYPARS/
  /// Cc      SAVE /PYINT1/
  /// Cc      SAVE /PYINT2/
  /// Cc      SAVE /PYINT5/
  /// Cc      SAVE /HPINT/
  /// Clin-2/2012 correction:
  /// C*********************************** LU common block
  mxjt = 500;
  /// C                SIZE OF COMMON BLOCK FOR # OF PARTON PER STRING
  mxsg = 900;
  /// C                SIZE OF COMMON BLOCK FOR # OF SINGLE STRINGS
  mxsj = 100;
  /// C                SIZE OF COMMON BLOCK FOR # OF PARTON PER SINGLE
  /// C                STRING
  jflg = 0;
  ihnt2(11) = jp;
  ihnt2(12) = jt;
  /// C
  iopjet = iopjt0;
  if (iopjet == 1 && (nfp(jp, 6) != 0 || nft(jt, 6) != 0)) {
    iopjet = 0;
  }
  if (jp > ihnt2(1) || jt > ihnt2(3)) {
    return;
  }
  if (nfp(jp, 6) < 0 || nft(jt, 6) < 0) {
    return;
  }
  /// C                ******** JP or JT can not produce jet anymore
  /// C
  if (jout == 0) {
    epp = pp(jp, 4) + pp(jp, 3);
    epm = pp(jp, 4) - pp(jp, 3);
    etp = pt(jt, 4) + pt(jt, 3);
    etm = pt(jt, 4) - pt(jt, 3);
    if (epp < 0.0f) {
      goto statement_1000;
    }
    if (epm < 0.0f) {
      goto statement_1000;
    }
    if (etp < 0.0f) {
      goto statement_1000;
    }
    if (etm < 0.0f) {
      goto statement_1000;
    }
    if (epp / (epm + 0.01f) <= etp / (etm + 0.01f)) {
      return;
    }
  }
  /// C                ********for the first hard scattering of (JP,JT)
  /// C                        have collision only when Ycm(JP)>Ycm(JT)
  /// C
  ecut1 = hipr1(1) + hipr1(8) + pp(jp, 14) + pp(jp, 15);
  ecut2 = hipr1(1) + hipr1(8) + pt(jt, 14) + pt(jt, 15);
  if (pp(jp, 4) <= ecut1) {
    nfp(jp, 6) = -fem::abs(nfp(jp, 6));
    return;
  }
  if (pt(jt, 4) <= ecut2) {
    nft(jt, 6) = -fem::abs(nft(jt, 6));
    return;
  }
  /// C                *********must have enough energy to produce jets
  /// C
  miss = 0;
  misp = 0;
  mist = 0;
  /// C
  if (nfp(jp, 10) == 0 && nft(jt, 10) == 0) {
    mint(44) = mint4;
    mint(45) = mint5;
    xsec(0, 1) = atxs(0);
    xsec(11, 1) = atxs(11);
    xsec(12, 1) = atxs(12);
    xsec(28, 1) = atxs(28);
    FEM_DO_SAFE(i, 1, 20) {
      coef(11, i) = atco(11, i);
      coef(12, i) = atco(12, i);
      coef(28, i) = atco(28, i);
    }
  } else {
    isub11 = 0;
    isub12 = 0;
    isub28 = 0;
    if (xsec(11, 1) != 0) {
      isub11 = 1;
    }
    if (xsec(12, 1) != 0) {
      isub12 = 1;
    }
    if (xsec(28, 1) != 0) {
      isub28 = 1;
    }
    mint(44) = mint4 - isub11 - isub12 - isub28;
    mint(45) = mint5 - isub11 - isub12 - isub28;
    xsec(0, 1) = atxs(0) - atxs(11) - atxs(12) - atxs(28);
    xsec(11, 1) = 0.0f;
    xsec(12, 1) = 0.0f;
    xsec(28, 1) = 0.0f;
    FEM_DO_SAFE(i, 1, 20) {
      coef(11, i) = 0.0f;
      coef(12, i) = 0.0f;
      coef(28, i) = 0.0f;
    }
  }
/// C        ********Scatter the valence quarks only once per NN
/// C       collision,
/// C                afterwards only gluon can have hard scattering.
statement_155:
  pythia(cmn);
  jj = mint(31);
  if (jj != 1) {
    goto statement_155;
  }
  /// C                *********one hard collision at a time
  if (k(7, 2) == -k(8, 2)) {
    qmass2 = fem::pow2((p(7, 4) + p(8, 4))) - fem::pow2((p(7, 1) + p(8, 1))) -
             fem::pow2((p(7, 2) + p(8, 2))) - fem::pow2((p(7, 3) + p(8, 3)));
    qm = ulmass(cmn, k(7, 2));
    if (qmass2 < fem::pow2((2.0f * qm + hipr1(1)))) {
      goto statement_155;
    }
  }
  /// C                ********q-qbar jets must has minimum mass HIPR1(1)
  pxp = pp(jp, 1) - p(3, 1);
  pyp = pp(jp, 2) - p(3, 2);
  pzp = pp(jp, 3) - p(3, 3);
  pep = pp(jp, 4) - p(3, 4);
  pxt = pt(jt, 1) - p(4, 1);
  pyt = pt(jt, 2) - p(4, 2);
  pzt = pt(jt, 3) - p(4, 3);
  pet = pt(jt, 4) - p(4, 4);
  /// C
  if (pep <= ecut1) {
    misp++;
    if (misp < 50) {
      goto statement_155;
    }
    nfp(jp, 6) = -fem::abs(nfp(jp, 6));
    return;
  }
  if (pet <= ecut2) {
    mist++;
    if (mist < 50) {
      goto statement_155;
    }
    nft(jt, 6) = -fem::abs(nft(jt, 6));
    return;
  }
  /// C                ******** if the remain energy<ECUT the proj or targ
  /// C                         can not produce jet anymore
  /// C
  wp = pep + pzp + pet + pzt;
  wm = pep - pzp + pet - pzt;
  if (wp < 0.0f || wm < 0.0f) {
    miss++;
    /// Clin-6/2009 Let user set the limit when selecting high-Pt events
    /// C     because more attempts may be needed:
    /// C                IF(MISS.LT.50) GO TO 155
    if (pttrig > 0) {
      if (miss < maxmiss) {
        write(6, star), "Failed to generate minijet Pt>", pttrig, "GeV";
        goto statement_155;
      }
    } else {
      if (miss < 50) {
        goto statement_155;
      }
    }
    /// C
    return;
  }
  /// C                ********the total W+, W- must be positive
  sw = wp * wm;
  ampx = fem::sqrt(fem::pow2((ecut1 - hipr1(8))) + fem::pow2(pxp) +
                   fem::pow2(pyp) + 0.01f);
  amtx = fem::sqrt(fem::pow2((ecut2 - hipr1(8))) + fem::pow2(pxt) +
                   fem::pow2(pyt) + 0.01f);
  sxx = fem::pow2((ampx + amtx));
  if (sw < sxx || vint(43) < hipr1(1)) {
    miss++;
    /// Clin-6/2009
    /// C                IF(MISS.LT.50) GO TO 155
    if (miss > maxmiss) {
      goto statement_155;
    }
    return;
  }
  /// C                ********the proj and targ remnants must have at least
  /// C                        a CM energy that can produce two strings
  /// C                        with minimum mass HIPR1(1)(see HIJSFT HIJFRG)
  /// C
  hint1(41) = p(7, 1);
  hint1(42) = p(7, 2);
  hint1(43) = p(7, 3);
  hint1(44) = p(7, 4);
  hint1(45) = p(7, 5);
  hint1(46) = fem::sqrt(fem::pow2(p(7, 1)) + fem::pow2(p(7, 2)));
  hint1(51) = p(8, 1);
  hint1(52) = p(8, 2);
  hint1(53) = p(8, 3);
  hint1(54) = p(8, 4);
  hint1(55) = p(8, 5);
  hint1(56) = fem::sqrt(fem::pow2(p(8, 1)) + fem::pow2(p(8, 2)));
  ihnt2(14) = k(7, 2);
  ihnt2(15) = k(8, 2);
  /// C
  pinird = (1.0f - fem::exp(-2.0f * (vint(47) - hidat(1)))) /
           (1.0f + fem::exp(-2.0f * (vint(47) - hidat(1))));
  iinird = 0;
  if (ranart(cmn.nseed) <= pinird) {
    iinird = 1;
  }
  if (k(7, 2) == -k(8, 2)) {
    goto statement_190;
  }
  if (k(7, 2) == 21 && k(8, 2) == 21 && iopjet == 1) {
    goto statement_190;
  }
  /// C*******************************************************************
  /// C        gluon  jets are going to be connectd with
  /// C        the final leadng string of quark-aintquark
  /// C*******************************************************************
  jflg = 2;
  jpp = 0;
  lpq = 0;
  lpb = 0;
  jtt = 0;
  ltq = 0;
  ltb = 0;
  is7 = 0;
  is8 = 0;
  hint1(47) = 0.0f;
  hint1(48) = 0.0f;
  hint1(49) = 0.0f;
  hint1(50) = 0.0f;
  hint1(67) = 0.0f;
  hint1(68) = 0.0f;
  hint1(69) = 0.0f;
  hint1(70) = 0.0f;
  FEM_DO_SAFE(i, 9, n) {
    if (k(i, 3) == 1 || k(i, 3) == 2 || fem::abs(k(i, 2)) > 30) {
      goto statement_180;
    }
    /// C************************************************************
    if (k(i, 3) == 7) {
      hint1(47) += p(i, 1);
      hint1(48) += p(i, 2);
      hint1(49) += p(i, 3);
      hint1(50) += p(i, 4);
    }
    if (k(i, 3) == 8) {
      hint1(67) += p(i, 1);
      hint1(68) += p(i, 2);
      hint1(69) += p(i, 3);
      hint1(70) += p(i, 4);
    }
    /// C************************modifcation made on Apr 10. 1996*****
    if (k(i, 2) > 21 && k(i, 2) <= 30) {
      ndr++;
      iadr(ndr, 1) = jp;
      iadr(ndr, 2) = jt;
      kfdr(ndr) = k(i, 2);
      pdr(ndr, 1) = p(i, 1);
      pdr(ndr, 2) = p(i, 2);
      pdr(ndr, 3) = p(i, 3);
      pdr(ndr, 4) = p(i, 4);
      pdr(ndr, 5) = p(i, 5);
      rtdr(ndr, 1) = 0.5f * (yp(1, jp) + yt(1, jt));
      rtdr(ndr, 2) = 0.5f * (yp(2, jp) + yt(2, jt));
      /// C************************************************************
      goto statement_180;
      /// C************************correction made on Oct. 14,1994*****
    }
    if (k(i, 3) == 7 || k(i, 3) == 3) {
      if (k(i, 3) == 7 && k(i, 2) != 21 && k(i, 2) == k(7, 2) && is7 == 0) {
        pp(jp, 10) = p(i, 1);
        pp(jp, 11) = p(i, 2);
        pp(jp, 12) = p(i, 3);
        pzp += p(i, 3);
        pep += p(i, 4);
        nfp(jp, 10) = 1;
        is7 = 1;
        goto statement_180;
      }
      if (k(i, 3) == 3 && (k(i, 2) != 21 || iinird == 0)) {
        pxp += p(i, 1);
        pyp += p(i, 2);
        pzp += p(i, 3);
        pep += p(i, 4);
        goto statement_180;
      }
      jpp++;
      ip(jpp, 1) = i;
      ip(jpp, 2) = 0;
      if (k(i, 2) != 21) {
        if (k(i, 2) > 0) {
          lpq++;
          ipq(lpq) = jpp;
          ip(jpp, 2) = lpq;
        } else if (k(i, 2) < 0) {
          lpb++;
          ipb(lpb) = jpp;
          ip(jpp, 2) = -lpb;
        }
      }
    } else if (k(i, 3) == 8 || k(i, 3) == 4) {
      if (k(i, 3) == 8 && k(i, 2) != 21 && k(i, 2) == k(8, 2) && is8 == 0) {
        pt(jt, 10) = p(i, 1);
        pt(jt, 11) = p(i, 2);
        pt(jt, 12) = p(i, 3);
        pzt += p(i, 3);
        pet += p(i, 4);
        nft(jt, 10) = 1;
        is8 = 1;
        goto statement_180;
      }
      if (k(i, 3) == 4 && (k(i, 2) != 21 || iinird == 0)) {
        pxt += p(i, 1);
        pyt += p(i, 2);
        pzt += p(i, 3);
        pet += p(i, 4);
        goto statement_180;
      }
      jtt++;
      it(jtt, 1) = i;
      it(jtt, 2) = 0;
      if (k(i, 2) != 21) {
        if (k(i, 2) > 0) {
          ltq++;
          itq(ltq) = jtt;
          it(jtt, 2) = ltq;
        } else if (k(i, 2) < 0) {
          ltb++;
          itb(ltb) = jtt;
          it(jtt, 2) = -ltb;
        }
      }
    }
  statement_180:;
  }
  /// C
  if (lpq != lpb || ltq != ltb) {
    miss++;
    /// Clin-6/2009
    /// C                IF(MISS.LE.50) GO TO 155
    if (miss <= maxmiss) {
      goto statement_155;
    }
    write(6, star), " Q -QBAR NOT MATCHED IN HIJHRD";
    jflg = 0;
    return;
  }
  /// C****The following will rearrange the partons so that a quark is***
  /// C****allways followed by an anti-quark ****************************
  /// C
  j = 0;
statement_181:
  j++;
  if (j > jpp) {
    goto statement_182;
  }
  if (ip(j, 2) == 0) {
    goto statement_181;
  } else if (ip(j, 2) != 0) {
    lp = fem::abs(ip(j, 2));
    ip1 = ip(j, 1);
    ip2 = ip(j, 2);
    ip(j, 1) = ip(ipq(lp), 1);
    ip(j, 2) = ip(ipq(lp), 2);
    ip(ipq(lp), 1) = ip1;
    ip(ipq(lp), 2) = ip2;
    if (ip2 > 0) {
      ipq(ip2) = ipq(lp);
    } else if (ip2 < 0) {
      ipb(-ip2) = ipq(lp);
    }
    /// C                ********replace J with a quark
    ip1 = ip(j + 1, 1);
    ip2 = ip(j + 1, 2);
    ip(j + 1, 1) = ip(ipb(lp), 1);
    ip(j + 1, 2) = ip(ipb(lp), 2);
    ip(ipb(lp), 1) = ip1;
    ip(ipb(lp), 2) = ip2;
    if (ip2 > 0) {
      ipq(ip2) = ipb(lp);
    } else if (ip2 < 0) {
      ipb(-ip2) = ipb(lp);
    }
    /// C                ******** replace J+1 with anti-quark
    j++;
    goto statement_181;
  }
/// C
statement_182:
  j = 0;
statement_183:
  j++;
  if (j > jtt) {
    goto statement_184;
  }
  if (it(j, 2) == 0) {
    goto statement_183;
  } else if (it(j, 2) != 0) {
    lt = fem::abs(it(j, 2));
    it1 = it(j, 1);
    it2 = it(j, 2);
    it(j, 1) = it(itq(lt), 1);
    it(j, 2) = it(itq(lt), 2);
    it(itq(lt), 1) = it1;
    it(itq(lt), 2) = it2;
    if (it2 > 0) {
      itq(it2) = itq(lt);
    } else if (it2 < 0) {
      itb(-it2) = itq(lt);
    }
    /// C                ********replace J with a quark
    it1 = it(j + 1, 1);
    it2 = it(j + 1, 2);
    it(j + 1, 1) = it(itb(lt), 1);
    it(j + 1, 2) = it(itb(lt), 2);
    it(itb(lt), 1) = it1;
    it(itb(lt), 2) = it2;
    if (it2 > 0) {
      itq(it2) = itb(lt);
    } else if (it2 < 0) {
      itb(-it2) = itb(lt);
    }
    /// C                ******** replace J+1 with anti-quark
    j++;
    goto statement_183;
    /// C
  }
/// C
statement_184:
  if (npj(jp) + jpp > mxjt || ntj(jt) + jtt > mxjt) {
    jflg = 0;
    write(6, star), "number of partons per string exceeds";
    write(6, star), "the common block size";
    return;
  }
  /// C                        ********check the bounds of common blocks
  FEM_DO_SAFE(j, 1, jpp) {
    kfpj(jp, npj(jp) + j) = k(ip(j, 1), 2);
    pjpx(jp, npj(jp) + j) = p(ip(j, 1), 1);
    pjpy(jp, npj(jp) + j) = p(ip(j, 1), 2);
    pjpz(jp, npj(jp) + j) = p(ip(j, 1), 3);
    pjpe(jp, npj(jp) + j) = p(ip(j, 1), 4);
    pjpm(jp, npj(jp) + j) = p(ip(j, 1), 5);
  }
  npj(jp) += jpp;
  FEM_DO_SAFE(j, 1, jtt) {
    kftj(jt, ntj(jt) + j) = k(it(j, 1), 2);
    pjtx(jt, ntj(jt) + j) = p(it(j, 1), 1);
    pjty(jt, ntj(jt) + j) = p(it(j, 1), 2);
    pjtz(jt, ntj(jt) + j) = p(it(j, 1), 3);
    pjte(jt, ntj(jt) + j) = p(it(j, 1), 4);
    pjtm(jt, ntj(jt) + j) = p(it(j, 1), 5);
  }
  ntj(jt) += jtt;
  goto statement_900;
/// C*****************************************************************
/// CThis is the case of a quark-antiquark jet it will fragment alone
/// C****************************************************************
statement_190:
  jflg = 3;
  if (k(7, 2) != 21 && k(8, 2) != 21 && k(7, 2) * k(8, 2) > 0) {
    goto statement_155;
  }
  jpp = 0;
  lpq = 0;
  lpb = 0;
  FEM_DO_SAFE(i, 9, n) {
    if (k(i, 3) == 1 || k(i, 3) == 2 || fem::abs(k(i, 2)) > 30) {
      goto statement_200;
    }
    if (k(i, 2) > 21 && k(i, 2) <= 30) {
      ndr++;
      iadr(ndr, 1) = jp;
      iadr(ndr, 2) = jt;
      kfdr(ndr) = k(i, 2);
      pdr(ndr, 1) = p(i, 1);
      pdr(ndr, 2) = p(i, 2);
      pdr(ndr, 3) = p(i, 3);
      pdr(ndr, 4) = p(i, 4);
      pdr(ndr, 5) = p(i, 5);
      rtdr(ndr, 1) = 0.5f * (yp(1, jp) + yt(1, jt));
      rtdr(ndr, 2) = 0.5f * (yp(2, jp) + yt(2, jt));
      /// C************************************************************
      goto statement_200;
      /// C************************correction made on Oct. 14,1994*****
    }
    if (k(i, 3) == 3 && (k(i, 2) != 21 || iinird == 0)) {
      pxp += p(i, 1);
      pyp += p(i, 2);
      pzp += p(i, 3);
      pep += p(i, 4);
      goto statement_200;
    }
    if (k(i, 3) == 4 && (k(i, 2) != 21 || iinird == 0)) {
      pxt += p(i, 1);
      pyt += p(i, 2);
      pzt += p(i, 3);
      pet += p(i, 4);
      goto statement_200;
    }
    jpp++;
    ip(jpp, 1) = i;
    ip(jpp, 2) = 0;
    if (k(i, 2) != 21) {
      if (k(i, 2) > 0) {
        lpq++;
        ipq(lpq) = jpp;
        ip(jpp, 2) = lpq;
      } else if (k(i, 2) < 0) {
        lpb++;
        ipb(lpb) = jpp;
        ip(jpp, 2) = -lpb;
      }
    }
  statement_200:;
  }
  if (lpq != lpb) {
    miss++;
    /// Clin-6/2009
    /// C           IF(MISS.LE.50) GO TO 155
    if (miss <= maxmiss) {
      goto statement_155;
    }
    write(6, star), lpq, lpb, "Q-QBAR NOT CONSERVED OR NOT MATCHED";
    jflg = 0;
    return;
  }
  /// C
  /// C**** The following will rearrange the partons so that a quark is***
  /// C**** allways followed by an anti-quark ****************************
  j = 0;
statement_220:
  j++;
  if (j > jpp) {
    goto statement_222;
  }
  if (ip(j, 2) == 0) {
    goto statement_220;
  }
  lp = fem::abs(ip(j, 2));
  ip1 = ip(j, 1);
  ip2 = ip(j, 2);
  ip(j, 1) = ip(ipq(lp), 1);
  ip(j, 2) = ip(ipq(lp), 2);
  ip(ipq(lp), 1) = ip1;
  ip(ipq(lp), 2) = ip2;
  if (ip2 > 0) {
    ipq(ip2) = ipq(lp);
  } else if (ip2 < 0) {
    ipb(-ip2) = ipq(lp);
  }
  ipq(lp) = j;
  /// C                ********replace J with a quark
  ip1 = ip(j + 1, 1);
  ip2 = ip(j + 1, 2);
  ip(j + 1, 1) = ip(ipb(lp), 1);
  ip(j + 1, 2) = ip(ipb(lp), 2);
  ip(ipb(lp), 1) = ip1;
  ip(ipb(lp), 2) = ip2;
  if (ip2 > 0) {
    ipq(ip2) = ipb(lp);
  } else if (ip2 < 0) {
    ipb(-ip2) = ipb(lp);
  }
  /// C                ******** replace J+1 with an anti-quark
  ipb(lp) = j + 1;
  j++;
  goto statement_220;
/// C
statement_222:
  if (lpq >= 1) {
    FEM_DO_SAFE(l0, 2, lpq) {
      ip1 = ip(2 * l0 - 3, 1);
      ip2 = ip(2 * l0 - 3, 2);
      ip(2 * l0 - 3, 1) = ip(ipq(l0), 1);
      ip(2 * l0 - 3, 2) = ip(ipq(l0), 2);
      ip(ipq(l0), 1) = ip1;
      ip(ipq(l0), 2) = ip2;
      if (ip2 > 0) {
        ipq(ip2) = ipq(l0);
      } else if (ip2 < 0) {
        ipb(-ip2) = ipq(l0);
      }
      ipq(l0) = 2 * l0 - 3;
      /// C
      ip1 = ip(2 * l0 - 2, 1);
      ip2 = ip(2 * l0 - 2, 2);
      ip(2 * l0 - 2, 1) = ip(ipb(l0), 1);
      ip(2 * l0 - 2, 2) = ip(ipb(l0), 2);
      ip(ipb(l0), 1) = ip1;
      ip(ipb(l0), 2) = ip2;
      if (ip2 > 0) {
        ipq(ip2) = ipb(l0);
      } else if (ip2 < 0) {
        ipb(-ip2) = ipb(l0);
      }
      ipb(l0) = 2 * l0 - 2;
    }
    /// C                ********move all the qqbar pair to the front of
    /// C                                the list, except the first pair
    ip1 = ip(2 * lpq - 1, 1);
    ip2 = ip(2 * lpq - 1, 2);
    ip(2 * lpq - 1, 1) = ip(ipq(1), 1);
    ip(2 * lpq - 1, 2) = ip(ipq(1), 2);
    ip(ipq(1), 1) = ip1;
    ip(ipq(1), 2) = ip2;
    if (ip2 > 0) {
      ipq(ip2) = ipq(1);
    } else if (ip2 < 0) {
      ipb(-ip2) = ipq(1);
    }
    ipq(1) = 2 * lpq - 1;
    /// C                ********move the first quark to the beginning of
    /// C                                the last string system
    ip1 = ip(jpp, 1);
    ip2 = ip(jpp, 2);
    ip(jpp, 1) = ip(ipb(1), 1);
    ip(jpp, 2) = ip(ipb(1), 2);
    ip(ipb(1), 1) = ip1;
    ip(ipb(1), 2) = ip2;
    if (ip2 > 0) {
      ipq(ip2) = ipb(1);
    } else if (ip2 < 0) {
      ipb(-ip2) = ipb(1);
    }
    ipb(1) = jpp;
    /// C                ********move the first anti-quark to the end of the
    /// C                        last string system
  }
  if (nsg >= mxsg) {
    jflg = 0;
    write(6, star), "number of jets forming single strings exceeds";
    write(6, star), "the common block size";
    return;
  }
  if (jpp > mxsj) {
    jflg = 0;
    write(6, star), "number of partons per single jet system";
    write(6, star), "exceeds the common block size";
    return;
  }
  /// C                ********check the bounds of common block size
  nsg++;
  njsg(nsg) = jpp;
  iasg(nsg, 1) = jp;
  iasg(nsg, 2) = jt;
  iasg(nsg, 3) = 0;
  FEM_DO_SAFE(i, 1, jpp) {
    k1sg(nsg, i) = 2;
    k2sg(nsg, i) = k(ip(i, 1), 2);
    if (k2sg(nsg, i) < 0) {
      k1sg(nsg, i) = 1;
    }
    pxsg(nsg, i) = p(ip(i, 1), 1);
    pysg(nsg, i) = p(ip(i, 1), 2);
    pzsg(nsg, i) = p(ip(i, 1), 3);
    pesg(nsg, i) = p(ip(i, 1), 4);
    pmsg(nsg, i) = p(ip(i, 1), 5);
  }
  k1sg(nsg, 1) = 2;
  k1sg(nsg, jpp) = 1;
/// C******* reset the energy-momentum of incoming particles ********
statement_900:
  pp(jp, 1) = pxp;
  pp(jp, 2) = pyp;
  pp(jp, 3) = pzp;
  pp(jp, 4) = pep;
  pp(jp, 5) = 0.0f;
  pt(jt, 1) = pxt;
  pt(jt, 2) = pyt;
  pt(jt, 3) = pzt;
  pt(jt, 4) = pet;
  pt(jt, 5) = 0.0f;
  /// C
  nfp(jp, 6)++;
  nft(jt, 6)++;
  return;
/// C
statement_1000:
  jflg = -1;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), "Fatal HIJHRD error";
  write(6, star), jp, " proj E+,E-", epp, epm, " status", nfp(jp, 5);
  write(6, star), jt, " targ E+,E_", etp, etm, " status", nft(jt, 5);
}

struct pyinki_save {
  arr<fem::str<26> > chalp;
  arr<fem::str<8> > chcde;
  arr<int> kcde;

  pyinki_save()
      : chalp(dimension(2), fem::fill0),
        chcde(dimension(18), fem::fill0),
        kcde(dimension(18), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void pyinki(common& cmn, str_cref chfram, str_cref chbeam, str_cref chtarg,
            float const& win) {
  FEM_CMN_SVE(pyinki);
  common_write write(cmn);
  /// COMMON lujets
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  /// COMMON ludat1
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  /// COMMON pypars
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  /// COMMON pyint1
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  ///
  /// SAVE
  str_arr_ref<1> chalp(sve.chalp, dimension(2));
  str_arr_ref<1> chcde(sve.chcde, dimension(18));
  arr_ref<int> kcde(sve.kcde, dimension(18));
  ///
  if (is_called_first_time) {
    {
      static const char* values[] = {"abcdefghijklmnopqrstuvwxyz",
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chalp;
    }
    {
      static const char* values[] = {
          "e-      ", "e+      ", "nue     ", "nue~    ", "mu-     ",
          "mu+     ", "numu    ", "numu~   ", "tau-    ", "tau+    ",
          "nutau   ", "nutau~  ", "pi+     ", "pi-     ", "n       ",
          "n~      ", "p       ", "p~      "};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chcde;
    }
    {
      static const int values[] = {11,  -11,  12,   -12,   13,   -13,
                                   14,  -14,  15,   -15,   16,   -16,
                                   211, -211, 2112, -2112, 2212, -2212};
      fem::data_of_type<int>(FEM_VALUES_AND_SIZE), kcde;
    }
  }
  /// C
  /// C...Identifies the two incoming particles and sets up kinematics,
  /// C...including rotations and boosts to/from CM frame.
  /// C
  /// C...Convert character variables to lowercase and find their length.
  arr_1d<3, fem::str<8> > chcom(fem::fill0);
  chcom(1) = chfram;
  chcom(2) = chbeam;
  chcom(3) = chtarg;
  int i = fem::int0;
  arr_1d<3, int> len(fem::fill0);
  int ll = fem::int0;
  int la = fem::int0;
  arr_1d<3, fem::str<8> > chidnt(fem::fill0);
  fem::str<8> chtemp = fem::char0;
  FEM_DO_SAFE(i, 1, 3) {
    len(i) = 8;
    FEM_DOSTEP(ll, 8, 1, -1) {
      if (len(i) == ll && chcom(i)(ll, ll) == " ") {
        len(i) = ll - 1;
      }
      FEM_DO_SAFE(la, 1, 26) {
        if (chcom(i)(ll, ll) == chalp(2)(la, la)) {
          chcom(i)(ll, ll) = chalp(1)(la, la);
        }
      }
    }
    chidnt(i) = chcom(i);
    FEM_DO_SAFE(ll, 1, 6) {
      if (chidnt(i)(ll, ll + 2) == "bar") {
        chtemp = chidnt(i);
        chidnt(i) = chtemp(1, ll - 1) + str_cref("~") + chtemp(ll + 3, 8) +
                    str_cref("  ");
      }
    }
    FEM_DO_SAFE(ll, 1, 8) {
      if (chidnt(i)(ll, ll) == "_") {
        chtemp = chidnt(i);
        chidnt(i) = chtemp(1, ll - 1) + chtemp(ll + 1, 8) + str_cref(" ");
      }
    }
  }
  /// C
  /// C...Set initial state. Error for unknown codes. Reset variables.
  n = 2;
  int j = fem::int0;
  FEM_DO_SAFE(i, 1, 2) {
    k(i, 2) = 0;
    FEM_DO_SAFE(j, 1, 18) {
      if (chidnt(i + 1) == chcde(j)) {
        k(i, 2) = kcde(j);
      }
    }
    p(i, 5) = ulmass(cmn, k(i, 2));
    mint(40 + i) = 1;
    if (fem::iabs(k(i, 2)) > 100) {
      mint(40 + i) = 2;
    }
    FEM_DO_SAFE(j, 1, 5) { v(i, j) = 0.f; }
  }
  if (k(1, 2) == 0) {
    write(mstu(11),
          "(1x,'Error: unrecognized beam particle ''',a,'''.',/,1x,"
          "'Execution stopped!')"),
        chbeam(1, len(2));
  }
  if (k(2, 2) == 0) {
    write(mstu(11),
          "(1x,'Error: unrecognized target particle ''',a,'''.',/,1x,"
          "'Execution stopped!')"),
        chtarg(1, len(3));
  }
  if (k(1, 2) == 0 || k(2, 2) == 0) {
    FEM_STOP(0);
  }
  FEM_DO_SAFE(j, 6, 10) { vint(j) = 0.f; }
  fem::str<76> chinit = " ";
  /// C
  /// C...Set up kinematics for events defined in CM frame.
  int loffs = fem::int0;
  float s = fem::float0;
  if (chcom(1)(1, 2) == "cm") {
    if (chcom(2)(1, 1) != "e") {
      loffs = (34 - (len(2) + len(3))) / 2;
      chinit(loffs + 1, 76) = "PYTHIA will be initialized for a " +
                              chcom(2)(1, len(2)) + str_cref("-") +
                              chcom(3)(1, len(3)) + str_cref(" collider") +
                              str_cref(" ");
    } else {
      loffs = (33 - (len(2) + len(3))) / 2;
      chinit(loffs + 1, 76) = "PYTHIA will be initialized for an " +
                              chcom(2)(1, len(2)) + str_cref("-") +
                              chcom(3)(1, len(3)) + str_cref(" collider") +
                              str_cref(" ");
    }
    /// C        WRITE(MSTU(11),1200) CHINIT
    /// C        WRITE(MSTU(11),1300) WIN
    s = fem::pow2(win);
    p(1, 1) = 0.f;
    p(1, 2) = 0.f;
    p(2, 1) = 0.f;
    p(2, 2) = 0.f;
    p(1, 3) =
        fem::sqrt((fem::pow2((s - fem::pow2(p(1, 5)) - fem::pow2(p(2, 5)))) -
                   fem::pow2((2.f * p(1, 5) * p(2, 5)))) /
                  (4.f * s));
    p(2, 3) = -p(1, 3);
    p(1, 4) = fem::sqrt(fem::pow2(p(1, 3)) + fem::pow2(p(1, 5)));
    p(2, 4) = fem::sqrt(fem::pow2(p(2, 3)) + fem::pow2(p(2, 5)));
    /// C
    /// C...Set up kinematics for fixed target events.
  } else if (chcom(1)(1, 3) == "fix") {
    loffs = (29 - (len(2) + len(3))) / 2;
    chinit(loffs + 1, 76) = "PYTHIA will be initialized for " +
                            chcom(2)(1, len(2)) + str_cref(" on ") +
                            chcom(3)(1, len(3)) + str_cref(" fixed target") +
                            str_cref(" ");
    /// C        WRITE(MSTU(11),1200) CHINIT
    /// C        WRITE(MSTU(11),1400) WIN
    p(1, 1) = 0.f;
    p(1, 2) = 0.f;
    p(2, 1) = 0.f;
    p(2, 2) = 0.f;
    p(1, 3) = win;
    p(1, 4) = fem::sqrt(fem::pow2(p(1, 3)) + fem::pow2(p(1, 5)));
    p(2, 3) = 0.f;
    p(2, 4) = p(2, 5);
    s = fem::pow2(p(1, 5)) + fem::pow2(p(2, 5)) + 2.f * p(2, 4) * p(1, 4);
    vint(10) = p(1, 3) / (p(1, 4) + p(2, 4));
    lurobo(cmn, 0.f, 0.f, 0.f, 0.f, -vint(10));
    /// C        WRITE(MSTU(11),1500) SQRT(S)
    /// C
    /// C...Set up kinematics for events in user-defined frame.
  } else if (chcom(1)(1, 3) == "use") {
    loffs = (13 - (len(1) + len(2))) / 2;
    chinit(loffs + 1, 76) =
        "PYTHIA will be initialized for " + chcom(2)(1, len(2)) +
        str_cref(" on ") + chcom(3)(1, len(3)) +
        str_cref("user-specified configuration") + str_cref(" ");
    /// C        WRITE(MSTU(11),1200) CHINIT
    /// C        WRITE(MSTU(11),1600)
    /// C        WRITE(MSTU(11),1700) CHCOM(2),P(1,1),P(1,2),P(1,3)
    /// C        WRITE(MSTU(11),1700) CHCOM(3),P(2,1),P(2,2),P(2,3)
    p(1, 4) = fem::sqrt(fem::pow2(p(1, 1)) + fem::pow2(p(1, 2)) +
                        fem::pow2(p(1, 3)) + fem::pow2(p(1, 5)));
    p(2, 4) = fem::sqrt(fem::pow2(p(2, 1)) + fem::pow2(p(2, 2)) +
                        fem::pow2(p(2, 3)) + fem::pow2(p(2, 5)));
    FEM_DO_SAFE(j, 1, 3) {
      vint(7 + j) = fem::sngl((fem::dble(p(1, j)) + fem::dble(p(2, j))) /
                              fem::dble(p(1, 4) + p(2, 4)));
    }
    lurobo(cmn, 0.f, 0.f, -vint(8), -vint(9), -vint(10));
    vint(7) = ulangl(cmn, p(1, 1), p(1, 2));
    lurobo(cmn, 0.f, -vint(7), 0.f, 0.f, 0.f);
    vint(6) = ulangl(cmn, p(1, 3), p(1, 1));
    lurobo(cmn, -vint(6), 0.f, 0.f, 0.f, 0.f);
    s = fem::pow2(p(1, 5)) + fem::pow2(p(2, 5)) +
        2.f * (p(1, 4) * p(2, 4) - p(1, 3) * p(2, 3));
    /// C        WRITE(MSTU(11),1500) SQRT(S)
    /// C
    /// C...Unknown frame. Error for too low CM energy.
  } else {
    write(mstu(11),
          "(1x,'Error: unrecognized coordinate frame ''',a,'''.',/,1x,"
          "'Execution stopped!')"),
        chfram(1, len(1));
    FEM_STOP(0);
  }
  if (s < fem::pow2(parp(2))) {
    write(mstu(11),
          "(1x,'Error: too low CM energy,',f8.3,' GeV for event "
          "','generation.',/,"
          "1x,'Execution stopped!')"),
        fem::sqrt(s);
    FEM_STOP(0);
  }
  /// C
  /// C...Save information on incoming particles.
  mint(11) = k(1, 2);
  mint(12) = k(2, 2);
  mint(43) = 2 * mint(41) + mint(42) - 2;
  vint(1) = fem::sqrt(s);
  vint(2) = s;
  vint(3) = p(1, 5);
  vint(4) = p(2, 5);
  vint(5) = p(1, 3);
  /// C
  /// C...Store constants to be used in generation.
  if (mstp(82) <= 1) {
    vint(149) = 4.f * fem::pow2(parp(81)) / s;
  }
  if (mstp(82) >= 2) {
    vint(149) = 4.f * fem::pow2(parp(82)) / s;
  }
  /// C
  /// C...Formats for initialization and error information.
  /// Clin 1200 FORMAT(/1X,78('=')/1X,'I',76X,'I'/1X,'I',A76,'I')
  /// C 1300 FORMAT(1X,'I',18X,'at',1X,F10.3,1X,'GeV center-of-mass energy',
  /// C     &19X,'I'/1X,'I',76X,'I'/1X,78('='))
  /// C 1400 FORMAT(1X,'I',22X,'at',1X,F10.3,1X,'GeV/c lab-momentum',22X,'I')
  /// C 1500 FORMAT(1X,'I',76X,'I'/1X,'I',11X,'corresponding to',1X,F10.3,1X,
  /// C     &'GeV center-of-mass energy',12X,'I'/1X,'I',76X,'I'/1X,78('='))
  /// C 1600 FORMAT(1X,'I',76X,'I'/1X,'I',24X,'px (GeV/c)',3X,'py (GeV/c)',3X,
  /// C     &'pz (GeV/c)',16X,'I')
  /// Clin 1700 FORMAT(1X,'I',15X,A8,3(2X,F10.3,1X),15X,'I')
  /// C
}

/// C
/// C*********************************************************************
/// C
void pyinre(common& cmn) {
  arr_cref<float> paru(cmn.paru, dimension(200));
  arr_ref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_cref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_ref<float> brat(cmn.brat, dimension(2000));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<int, 2> kfpr(cmn.kfpr, dimension(200, 2));
  arr_ref<float, 2> widp(cmn.widp, dim1(21, 40).dim2(0, 40));
  arr_ref<float, 2> wide(cmn.wide, dim1(21, 40).dim2(0, 40));
  arr_ref<float, 2> wids(cmn.wids, dim1(21, 40).dim2(3));
  str_arr_ref<1> proc(cmn.proc, dim1(0, 200));
  ///
  float aem = fem::float0;
  float xw = fem::float0;
  int i = fem::int0;
  int j = fem::int0;
  float wmas = fem::float0;
  float wfac = fem::float0;
  arr_1d<41, float> wdtp(dim1(0, 40), fem::fill0);
  arr_2d<41, 6, float> wdte(dim1(0, 40).dim2(0, 5), fem::fill0);
  float hcmas = fem::float0;
  float hcfac = fem::float0;
  float zmas = fem::float0;
  float zfac = fem::float0;
  float hmas = fem::float0;
  float hfac = fem::float0;
  float zpmas = fem::float0;
  float zpfac = fem::float0;
  float rmas = fem::float0;
  float rfac = fem::float0;
  int kflqm = fem::int0;
  int idc = fem::int0;
  int kc = fem::int0;
  /// C
  /// C...Calculates full and effective widths of guage bosons, stores masses
  /// C...and widths, rescales coefficients to be used for resonance
  /// C...production generation.
  /// C
  /// C...Calculate full and effective widths of gauge bosons.
  aem = paru(101);
  xw = paru(102);
  FEM_DO_SAFE(i, 21, 40) {
    FEM_DO_SAFE(j, 0, 40) {
      widp(i, j) = 0.f;
      wide(i, j) = 0.f;
    }
  }
  /// C
  /// C...W+/-:
  wmas = pmas(24, 1);
  wfac = aem / (24.f * xw) * wmas;
  pywidt(cmn, 24, wmas, wdtp, wdte);
  wids(24, 1) = ((wdte(0, 1) + wdte(0, 2)) * (wdte(0, 1) + wdte(0, 3)) +
                 (wdte(0, 1) + wdte(0, 2) + wdte(0, 1) + wdte(0, 3)) *
                     (wdte(0, 4) + wdte(0, 5)) +
                 2.f * wdte(0, 4) * wdte(0, 5)) /
                fem::pow2(wdtp(0));
  wids(24, 2) = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) / wdtp(0);
  wids(24, 3) = (wdte(0, 1) + wdte(0, 3) + wdte(0, 4)) / wdtp(0);
  FEM_DO_SAFE(i, 0, 40) {
    widp(24, i) = wfac * wdtp(i);
    wide(24, i) = wfac * wdte(i, 0);
  }
  /// C
  /// C...H+/-:
  hcmas = pmas(37, 1);
  hcfac = aem / (8.f * xw) * fem::pow2((hcmas / wmas)) * hcmas;
  pywidt(cmn, 37, hcmas, wdtp, wdte);
  wids(37, 1) = ((wdte(0, 1) + wdte(0, 2)) * (wdte(0, 1) + wdte(0, 3)) +
                 (wdte(0, 1) + wdte(0, 2) + wdte(0, 1) + wdte(0, 3)) *
                     (wdte(0, 4) + wdte(0, 5)) +
                 2.f * wdte(0, 4) * wdte(0, 5)) /
                fem::pow2(wdtp(0));
  wids(37, 2) = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) / wdtp(0);
  wids(37, 3) = (wdte(0, 1) + wdte(0, 3) + wdte(0, 4)) / wdtp(0);
  FEM_DO_SAFE(i, 0, 40) {
    widp(37, i) = hcfac * wdtp(i);
    wide(37, i) = hcfac * wdte(i, 0);
  }
  /// C
  /// C...Z0:
  zmas = pmas(23, 1);
  zfac = aem / (48.f * xw * (1.f - xw)) * zmas;
  pywidt(cmn, 23, zmas, wdtp, wdte);
  wids(23, 1) = (fem::pow2((wdte(0, 1) + wdte(0, 2))) +
                 2.f * (wdte(0, 1) + wdte(0, 2)) * (wdte(0, 4) + wdte(0, 5)) +
                 2.f * wdte(0, 4) * wdte(0, 5)) /
                fem::pow2(wdtp(0));
  wids(23, 2) = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) / wdtp(0);
  wids(23, 3) = 0.f;
  FEM_DO_SAFE(i, 0, 40) {
    widp(23, i) = zfac * wdtp(i);
    wide(23, i) = zfac * wdte(i, 0);
  }
  /// C
  /// C...H0:
  hmas = pmas(25, 1);
  hfac = aem / (8.f * xw) * fem::pow2((hmas / wmas)) * hmas;
  pywidt(cmn, 25, hmas, wdtp, wdte);
  wids(25, 1) = (fem::pow2((wdte(0, 1) + wdte(0, 2))) +
                 2.f * (wdte(0, 1) + wdte(0, 2)) * (wdte(0, 4) + wdte(0, 5)) +
                 2.f * wdte(0, 4) * wdte(0, 5)) /
                fem::pow2(wdtp(0));
  wids(25, 2) = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) / wdtp(0);
  wids(25, 3) = 0.f;
  FEM_DO_SAFE(i, 0, 40) {
    widp(25, i) = hfac * wdtp(i);
    wide(25, i) = hfac * wdte(i, 0);
  }
  /// C
  /// C...Z'0:
  zpmas = pmas(32, 1);
  zpfac = aem / (48.f * xw * (1.f - xw)) * zpmas;
  pywidt(cmn, 32, zpmas, wdtp, wdte);
  wids(32, 1) = (fem::pow2((wdte(0, 1) + wdte(0, 2) + wdte(0, 3))) +
                 2.f * (wdte(0, 1) + wdte(0, 2)) * (wdte(0, 4) + wdte(0, 5)) +
                 2.f * wdte(0, 4) * wdte(0, 5)) /
                fem::pow2(wdtp(0));
  wids(32, 2) = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) / wdtp(0);
  wids(32, 3) = 0.f;
  FEM_DO_SAFE(i, 0, 40) {
    widp(32, i) = zpfac * wdtp(i);
    wide(32, i) = zpfac * wdte(i, 0);
  }
  /// C
  /// C...R:
  rmas = pmas(40, 1);
  rfac = 0.08f * rmas /
         ((mstp(1) - 1) *
          (1.f + 6.f * (1.f + ulalps(cmn, fem::pow2(rmas)) / paru(1))));
  pywidt(cmn, 40, rmas, wdtp, wdte);
  wids(40, 1) = ((wdte(0, 1) + wdte(0, 2)) * (wdte(0, 1) + wdte(0, 3)) +
                 (wdte(0, 1) + wdte(0, 2) + wdte(0, 1) + wdte(0, 3)) *
                     (wdte(0, 4) + wdte(0, 5)) +
                 2.f * wdte(0, 4) * wdte(0, 5)) /
                fem::pow2(wdtp(0));
  wids(40, 2) = (wdte(0, 1) + wdte(0, 2) + wdte(0, 4)) / wdtp(0);
  wids(40, 3) = (wdte(0, 1) + wdte(0, 3) + wdte(0, 4)) / wdtp(0);
  FEM_DO_SAFE(i, 0, 40) {
    widp(40, i) = wfac * wdtp(i);
    wide(40, i) = wfac * wdte(i, 0);
  }
  /// C
  /// C...Q:
  kflqm = 1;
  FEM_DO_SAFE(i, 1, fem::min(8, mdcy(21, 3))) {
    idc = i + mdcy(21, 2) - 1;
    if (mdme(idc, 1) <= 0) {
      goto statement_170;
    }
    kflqm = i;
  statement_170:;
  }
  mint(46) = kflqm;
  kfpr(81, 1) = kflqm;
  kfpr(81, 2) = kflqm;
  kfpr(82, 1) = kflqm;
  kfpr(82, 2) = kflqm;
  /// C
  /// C...Set resonance widths and branching ratios in JETSET.
  FEM_DO_SAFE(i, 1, 6) {
    if (i <= 3) {
      kc = i + 22;
    }
    if (i == 4) {
      kc = 32;
    }
    if (i == 5) {
      kc = 37;
    }
    if (i == 6) {
      kc = 40;
    }
    pmas(kc, 2) = widp(kc, 0);
    pmas(kc, 3) = fem::min(0.9f * pmas(kc, 1), 10.f * pmas(kc, 2));
    FEM_DO_SAFE(j, 1, mdcy(kc, 3)) {
      idc = j + mdcy(kc, 2) - 1;
      brat(idc) = wide(kc, j) / wide(kc, 0);
    }
  }
  /// C
  /// C...Special cases in treatment of gamma*/Z0: redefine process name.
  if (mstp(43) == 1) {
    proc(1) = "f + fb -> gamma*";
  } else if (mstp(43) == 2) {
    proc(1) = "f + fb -> Z0";
  } else if (mstp(43) == 3) {
    proc(1) = "f + fb -> gamma*/Z0";
  }
  /// C
  /// C...Special cases in treatment of gamma*/Z0/Z'0: redefine process name.
  if (mstp(44) == 1) {
    proc(141) = "f + fb -> gamma*";
  } else if (mstp(44) == 2) {
    proc(141) = "f + fb -> Z0";
  } else if (mstp(44) == 3) {
    proc(141) = "f + fb -> Z'0";
  } else if (mstp(44) == 4) {
    proc(141) = "f + fb -> gamma*/Z0";
  } else if (mstp(44) == 5) {
    proc(141) = "f + fb -> gamma*/Z'0";
  } else if (mstp(44) == 6) {
    proc(141) = "f + fb -> Z0/Z'0";
  } else if (mstp(44) == 7) {
    proc(141) = "f + fb -> gamma*/Z0/Z'0";
  }
  /// C
}

struct pyxtot_save {
  arr<float, 2> bcb;
  arr<float> bcc;
  arr<float, 2> bcs;

  pyxtot_save()
      : bcb(dimension(2, 5), fem::fill0),
        bcc(dimension(3), fem::fill0),
        bcs(dimension(5, 8), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void pyxtot(common& cmn) {
  FEM_CMN_SVE(pyxtot);
  /// COMMON ludat1
  arr_cref<float> paru(cmn.paru, dimension(200));
  /// COMMON pypars
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  /// COMMON pyint1
  arr_cref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  /// COMMON pyint5
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  /// SAVE
  arr_ref<float, 2> bcb(sve.bcb, dimension(2, 5));
  arr_ref<float> bcc(sve.bcc, dimension(3));
  arr_ref<float, 2> bcs(sve.bcs, dimension(5, 8));
  ///
  int i = fem::int0;
  int j = fem::int0;
  if (is_called_first_time) {
    {
      static const float values[] = {
          41.74f, 0.66f, 0.0000f, 337.f, 0.0f,  0.0f, -39.3f, 0.48f,
          41.66f, 0.60f, 0.0000f, 306.f, 0.0f,  0.0f, -34.6f, 0.51f,
          41.36f, 0.63f, 0.0000f, 299.f, 7.3f,  0.5f, -40.4f, 0.47f,
          41.68f, 0.63f, 0.0083f, 330.f, 0.0f,  0.0f, -39.0f, 0.48f,
          41.13f, 0.59f, 0.0074f, 278.f, 10.5f, 0.5f, -41.2f, 0.46f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(i, 1, 5) {
        FEM_DO_SAFE(j, 1, 8) { data, bcs(i, j); }
      }
    }
    {
      static const float values[] = {10.79f, -0.049f, 0.040f, 21.5f, 1.23f,
                                     9.92f,  -0.027f, 0.013f, 18.9f, 1.07f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(i, 1, 2) {
        FEM_DO_SAFE(j, 1, 5) { data, bcb(i, j); }
      }
    }
    {
      static const float values[] = {2.0164346f, -0.5590311f, 0.0376279f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), bcc;
    }
  }
  /// C
  /// C...Parametrizes total, double diffractive, single diffractive and
  /// C...elastic cross-sections for different energies and beams.
  /// C
  /// C...The following data lines are coefficients needed in the
  /// C...Block, Cahn parametrization of total cross-section and nuclear
  /// C...slope parameter; see below.
  /// C
  /// C...Total cross-section and nuclear slope parameter for pp and p-pbar
  int nfit = fem::min(5, fem::max(1, mstp(31)));
  float sigp =
      bcs(nfit, 1) +
      bcs(nfit, 2) *
          (-0.25f * fem::pow2(paru(1)) *
               (1.f - 0.25f * bcs(nfit, 3) * fem::pow2(paru(1))) +
           (1.f + 0.5f * bcs(nfit, 3) * fem::pow2(paru(1))) *
               fem::pow2((fem::log(vint(2) / bcs(nfit, 4)))) +
           bcs(nfit, 3) * fem::pow4((fem::log(vint(2) / bcs(nfit, 4))))) /
          (fem::pow2((1.f - 0.25f * bcs(nfit, 3) * fem::pow2(paru(1)))) +
           2.f * bcs(nfit, 3) *
               (1.f + 0.25f * bcs(nfit, 3) * fem::pow2(paru(1))) *
               fem::pow2((fem::log(vint(2) / bcs(nfit, 4)))) +
           fem::pow2(bcs(nfit, 3)) *
               fem::pow4((fem::log(vint(2) / bcs(nfit, 4))))) +
      bcs(nfit, 5) * fem::pow(vint(2), (bcs(nfit, 6) - 1.f)) *
          fem::sin(0.5f * paru(1) * bcs(nfit, 6));
  float sigm = -bcs(nfit, 7) * fem::pow(vint(2), (bcs(nfit, 8) - 1.f)) *
               fem::cos(0.5f * paru(1) * bcs(nfit, 8));
  float refp =
      bcs(nfit, 2) * paru(1) * fem::log(vint(2) / bcs(nfit, 4)) /
          (fem::pow2((1.f - 0.25f * bcs(nfit, 3) * fem::pow2(paru(1)))) +
           2.f * bcs(nfit, 3) *
               (1.f + 0.25f * bcs(nfit, 3) * fem::pow2(paru(1))) +
           fem::pow2((fem::log(vint(2) / bcs(nfit, 4)))) +
           fem::pow2(bcs(nfit, 3)) *
               fem::pow4((fem::log(vint(2) / bcs(nfit, 4))))) -
      bcs(nfit, 5) * fem::pow(vint(2), (bcs(nfit, 6) - 1.f)) *
          fem::cos(0.5f * paru(1) * bcs(nfit, 6));
  float refm = -bcs(nfit, 7) * fem::pow(vint(2), (bcs(nfit, 8) - 1.f)) *
               fem::sin(0.5f * paru(1) * bcs(nfit, 8));
  float sigma = sigp - fem::isign(1, mint(11) * mint(12)) * sigm;
  float rho = (refp - fem::isign(1, mint(11) * mint(12)) * refm) / sigma;
  /// C
  /// C...Nuclear slope parameter B, curvature C:
  nfit = 1;
  if (mstp(31) >= 4) {
    nfit = 2;
  }
  float bp = bcb(nfit, 1) + bcb(nfit, 2) * fem::log(vint(2)) +
             bcb(nfit, 3) * fem::pow2((fem::log(vint(2))));
  float bm = bcb(nfit, 4) + bcb(nfit, 5) * fem::log(vint(2));
  float b = bp - fem::isign(1, mint(11) * mint(12)) * sigm / sigp * (bm - bp);
  vint(121) = b;
  float c =
      -0.5f * bcc(2) / bcc(3) *
      (1.f - fem::sqrt(fem::max(0.f, 1.f + 4.f * bcc(3) / fem::pow2(bcc(2)) *
                                               (1.e-03f * vint(1) - bcc(1)))));
  vint(122) = c;
  /// C
  /// C...Elastic scattering cross-section (fixed by sigma-tot, rho and B).
  float sigel = fem::pow2(sigma) * (1.f + fem::pow2(rho)) /
                (16.f * paru(1) * paru(5) * b);
  /// C
  /// C...Single diffractive scattering cross-section from Goulianos:
  float sigsd =
      2.f * 0.68f * (1.f + 36.f / vint(2)) * fem::log(0.6f + 0.1f * vint(2));
  /// C
  /// C...Double diffractive scattering cross-section (essentially fixed by
  /// C...sigma-sd and sigma-el).
  float sigdd = fem::pow2(sigsd) / (3.f * sigel);
  /// C
  /// C...Total non-elastic, non-diffractive cross-section.
  float signd = sigma - sigdd - sigsd - sigel;
  /// C
  /// C...Rescale for pions.
  if (fem::iabs(mint(11)) == 211 && fem::iabs(mint(12)) == 211) {
    sigma = 4.f / 9.f * sigma;
    sigdd = 4.f / 9.f * sigdd;
    sigsd = 4.f / 9.f * sigsd;
    sigel = 4.f / 9.f * sigel;
    signd = 4.f / 9.f * signd;
  } else if (fem::iabs(mint(11)) == 211 || fem::iabs(mint(12)) == 211) {
    sigma = 2.f / 3.f * sigma;
    sigdd = 2.f / 3.f * sigdd;
    sigsd = 2.f / 3.f * sigsd;
    sigel = 2.f / 3.f * sigel;
    signd = 2.f / 3.f * signd;
  }
  /// C
  /// C...Save cross-sections in common block PYPARA.
  vint(101) = sigma;
  vint(102) = sigel;
  vint(103) = sigsd;
  vint(104) = sigdd;
  vint(106) = signd;
  xsec(95, 1) = signd;
  /// C
}

struct pymaxi_save {
  arr<fem::str<4> > cvar;

  pymaxi_save() : cvar(dimension(4), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void pymaxi(common& cmn) {
  FEM_CMN_SVE(pymaxi);
  common_write write(cmn);
  arr_cref<int> mstu(cmn.mstu, dimension(200));
  arr_cref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_cref<int> msub(cmn.msub, dimension(200));
  arr_cref<float> ckin(cmn.ckin, dimension(200));
  arr_cref<int> mstp(cmn.mstp, dimension(200));
  arr_cref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  arr_cref<int> iset(cmn.iset, dimension(200));
  arr_cref<int, 2> kfpr(cmn.kfpr, dimension(200, 2));
  arr_ref<float, 2> coef(cmn.coef, dimension(200, 20));
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  str_arr_cref<1> proc(cmn.proc, dim1(0, 200));
  ///
  str_arr_ref<1> cvar(sve.cvar, dimension(4));
  if (is_called_first_time) {
    static const char* values[] = {"tau ", "tau'", "y*  ", "cth "};
    fem::data_of_type_str(FEM_VALUES_AND_SIZE), cvar;
  }
  int isub = fem::int0;
  int istsb = fem::int0;
  int kfr1 = fem::int0;
  float taur1 = fem::float0;
  float gamr1 = fem::float0;
  int kfr2 = fem::int0;
  float taur2 = fem::float0;
  float gamr2 = fem::float0;
  float sqm3 = fem::float0;
  float sqm4 = fem::float0;
  arr_1d<4, int> npts(fem::fill0);
  int ntry = fem::int0;
  int j = fem::int0;
  int mcth = fem::int0;
  int mtaup = fem::int0;
  float cth = fem::float0;
  float taup = fem::float0;
  float sigsam = fem::float0;
  int nacc = fem::int0;
  int itry = fem::int0;
  int mtau = fem::int0;
  int myst = fem::int0;
  arr<int, 2> mvarpt(dimension(200, 4), fem::fill0);
  arr<float, 2> vintpt(dimension(200, 30), fem::fill0);
  int nchn = fem::int0;
  float sigs = fem::float0;
  arr_1d<200, float> sigspt(fem::fill0);
  float taumin = fem::float0;
  float taumax = fem::float0;
  float atau1 = fem::float0;
  float atau2 = fem::float0;
  float atau3 = fem::float0;
  float atau4 = fem::float0;
  float atau5 = fem::float0;
  float atau6 = fem::float0;
  float ystmin = fem::float0;
  float ystmax = fem::float0;
  float ayst0 = fem::float0;
  float ayst1 = fem::float0;
  float ayst3 = fem::float0;
  int ivar = fem::int0;
  int nbin = fem::int0;
  int j1 = fem::int0;
  arr_1d<6, int> narel(fem::fill0);
  arr_1d<6, float> wtrel(fem::fill0);
  arr_1d<6, float> coefu(fem::fill0);
  int j2 = fem::int0;
  arr_2d<6, 6, float> wtmat(fem::fill0);
  int iacc = fem::int0;
  int ibin = fem::int0;
  float tau = fem::float0;
  float taupmn = fem::float0;
  float taupmx = fem::float0;
  float ataup1 = fem::float0;
  float ataup2 = fem::float0;
  float yst = fem::float0;
  float rm34 = fem::float0;
  float rsqm = fem::float0;
  float cthmax = fem::float0;
  float cthmin = fem::float0;
  float acth1 = fem::float0;
  float acth2 = fem::float0;
  float acth3 = fem::float0;
  float acth4 = fem::float0;
  float acth5 = fem::float0;
  int msolv = fem::int0;
  int ired = fem::int0;
  float rqt = fem::float0;
  int icoe = fem::int0;
  float coefsu = fem::float0;
  int ioff = fem::int0;
  arr_1d<4, int> iaccmx(fem::fill0);
  arr_1d<4, float> sigsmx(fem::fill0);
  int nmax = fem::int0;
  int ieq = fem::int0;
  int imv = fem::int0;
  int iin = fem::int0;
  int imax = fem::int0;
  float vtau = fem::float0;
  float vyst = fem::float0;
  float vcth = fem::float0;
  float vtaup = fem::float0;
  int irpt = fem::int0;
  float vvar = fem::float0;
  int mvar = fem::int0;
  float vdel = fem::float0;
  float vmar = fem::float0;
  int imov0 = fem::int0;
  int imov = fem::int0;
  int inew = fem::int0;
  float vnew = fem::float0;
  arr_1d<3, float> sigssm(fem::fill0);
  float sigs11 = fem::float0;
  /// C
  /// C...Finds optimal set of coefficients for kinematical variable selection
  /// C...and the maximum of the part of the differential cross-section used
  /// C...in the event weighting.
  /// C
  /// C...Select subprocess to study: skip cases not applicable.
  vint(143) = 1.f;
  vint(144) = 1.f;
  xsec(0, 1) = 0.f;
  FEM_DO_SAFE(isub, 1, 200) {
    if (isub >= 91 && isub <= 95) {
      xsec(isub, 1) = vint(isub + 11);
      if (msub(isub) != 1) {
        goto statement_350;
      }
      goto statement_340;
    } else if (isub == 96) {
      if (mint(43) != 4) {
        goto statement_350;
      }
      if (msub(95) != 1 && mstp(81) <= 0 && mstp(131) <= 0) {
        goto statement_350;
      }
    } else if (isub == 11 || isub == 12 || isub == 13 || isub == 28 ||
               isub == 53 || isub == 68) {
      if (msub(isub) != 1 || msub(95) == 1) {
        goto statement_350;
      }
    } else {
      if (msub(isub) != 1) {
        goto statement_350;
      }
    }
    mint(1) = isub;
    istsb = iset(isub);
    if (isub == 96) {
      istsb = 2;
    }
    if (mstp(122) >= 2) {
      write(mstu(11),
            "(/,1x,'Coefficient optimization and maximum search for ',"
            "'subprocess no',i4,/,1x,'Coefficient modes     tau',10x,'y*',9x,"
            "'cth',9x,'tau''',7x,'sigma')"),
          isub;
    }
    /// C
    /// C...Find resonances (explicit or implicit in cross-section).
    mint(72) = 0;
    kfr1 = 0;
    if (istsb == 1 || istsb == 3) {
      kfr1 = kfpr(isub, 1);
    } else if (isub >= 71 && isub <= 77) {
      kfr1 = 25;
    }
    if (kfr1 != 0) {
      taur1 = fem::pow2(pmas(kfr1, 1)) / vint(2);
      gamr1 = pmas(kfr1, 1) * pmas(kfr1, 2) / vint(2);
      mint(72) = 1;
      mint(73) = kfr1;
      vint(73) = taur1;
      vint(74) = gamr1;
    }
    if (isub == 141) {
      kfr2 = 23;
      taur2 = fem::pow2(pmas(kfr2, 1)) / vint(2);
      gamr2 = pmas(kfr2, 1) * pmas(kfr2, 2) / vint(2);
      mint(72) = 2;
      mint(74) = kfr2;
      vint(75) = taur2;
      vint(76) = gamr2;
    }
    /// C
    /// C...Find product masses and minimum pT of process.
    sqm3 = 0.f;
    sqm4 = 0.f;
    mint(71) = 0;
    vint(71) = ckin(3);
    if (istsb == 2 || istsb == 4) {
      if (kfpr(isub, 1) != 0) {
        sqm3 = fem::pow2(pmas(kfpr(isub, 1), 1));
      }
      if (kfpr(isub, 2) != 0) {
        sqm4 = fem::pow2(pmas(kfpr(isub, 2), 1));
      }
      if (fem::min(sqm3, sqm4) < fem::pow2(ckin(6))) {
        mint(71) = 1;
      }
      if (mint(71) == 1) {
        vint(71) = fem::max(ckin(3), ckin(5));
      }
      if (isub == 96 && mstp(82) <= 1) {
        vint(71) = parp(81);
      }
      if (isub == 96 && mstp(82) >= 2) {
        vint(71) = 0.08f * parp(82);
      }
    }
    vint(63) = sqm3;
    vint(64) = sqm4;
    /// C
    /// C...Number of points for each variable: tau, tau', y*, cos(theta-hat).
    npts(1) = 2 + 2 * mint(72);
    if (mint(43) == 1 && (istsb == 1 || istsb == 2)) {
      npts(1) = 1;
    }
    npts(2) = 1;
    if (mint(43) >= 2 && (istsb == 3 || istsb == 4)) {
      npts(2) = 2;
    }
    npts(3) = 1;
    if (mint(43) == 4) {
      npts(3) = 3;
    }
    npts(4) = 1;
    if (istsb == 2 || istsb == 4) {
      npts(4) = 5;
    }
    ntry = npts(1) * npts(2) * npts(3) * npts(4);
    /// C
    /// C...Reset coefficients of cross-section weighting.
    FEM_DO_SAFE(j, 1, 20) { coef(isub, j) = 0.f; }
    coef(isub, 1) = 1.f;
    coef(isub, 7) = 0.5f;
    coef(isub, 8) = 0.5f;
    coef(isub, 10) = 1.f;
    coef(isub, 15) = 1.f;
    mcth = 0;
    mtaup = 0;
    cth = 0.f;
    taup = 0.f;
    sigsam = 0.f;
    /// C
    /// C...Find limits and select tau, y*, cos(theta-hat) and tau' values,
    /// C...in grid of phase space points.
    pyklim(cmn, 1);
    nacc = 0;
    FEM_DO_SAFE(itry, 1, ntry) {
      if (fem::mod(itry - 1, npts(2) * npts(3) * npts(4)) == 0) {
        mtau = 1 + (itry - 1) / (npts(2) * npts(3) * npts(4));
        pykmap(cmn, 1, mtau, 0.5f);
        if (istsb == 3 || istsb == 4) {
          pyklim(cmn, 4);
        }
      }
      if ((istsb == 3 || istsb == 4) &&
          fem::mod(itry - 1, npts(3) * npts(4)) == 0) {
        mtaup = 1 + fem::mod((itry - 1) / (npts(3) * npts(4)), npts(2));
        pykmap(cmn, 4, mtaup, 0.5f);
      }
      if (fem::mod(itry - 1, npts(3) * npts(4)) == 0) {
        pyklim(cmn, 2);
      }
      if (fem::mod(itry - 1, npts(4)) == 0) {
        myst = 1 + fem::mod((itry - 1) / npts(4), npts(3));
        pykmap(cmn, 2, myst, 0.5f);
        pyklim(cmn, 3);
      }
      if (istsb == 2 || istsb == 4) {
        mcth = 1 + fem::mod(itry - 1, npts(4));
        pykmap(cmn, 3, mcth, 0.5f);
      }
      if (isub == 96) {
        vint(25) = vint(21) * (1.f - fem::pow2(vint(23)));
      }
      /// C
      /// C...Calculate and store cross-section.
      mint(51) = 0;
      pyklim(cmn, 0);
      if (mint(51) == 1) {
        goto statement_120;
      }
      nacc++;
      mvarpt(nacc, 1) = mtau;
      mvarpt(nacc, 2) = mtaup;
      mvarpt(nacc, 3) = myst;
      mvarpt(nacc, 4) = mcth;
      FEM_DO_SAFE(j, 1, 30) { vintpt(nacc, j) = vint(10 + j); }
      pysigh(cmn, nchn, sigs);
      sigspt(nacc) = sigs;
      if (sigs > sigsam) {
        sigsam = sigs;
      }
      if (mstp(122) >= 2) {
        write(mstu(11), "(1x,4i4,f12.8,f12.6,f12.7,f12.8,1p,e12.4)"), mtau,
            mtaup, myst, mcth, vint(21), vint(22), vint(23), vint(26), sigs;
      }
    statement_120:;
    }
    if (sigsam == 0.f) {
      write(mstu(11),
            "(1x,'Error: requested subprocess ',i3,' has vanishing ',"
            "'cross-section.',/,1x,'Execution stopped!')"),
          isub;
      FEM_STOP(0);
    }
    /// C
    /// C...Calculate integrals in tau and y* over maximal phase space limits.
    taumin = vint(11);
    taumax = vint(31);
    atau1 = fem::log(taumax / taumin);
    atau2 = (taumax - taumin) / (taumax * taumin);
    if (npts(1) >= 3) {
      atau3 = fem::log(taumax / taumin * (taumin + taur1) / (taumax + taur1)) /
              taur1;
      atau4 = (fem::atan((taumax - taur1) / gamr1) -
               fem::atan((taumin - taur1) / gamr1)) /
              gamr1;
    }
    if (npts(1) >= 5) {
      atau5 = fem::log(taumax / taumin * (taumin + taur2) / (taumax + taur2)) /
              taur2;
      atau6 = (fem::atan((taumax - taur2) / gamr2) -
               fem::atan((taumin - taur2) / gamr2)) /
              gamr2;
    }
    ystmin = 0.5f * fem::log(taumin);
    ystmax = -ystmin;
    ayst0 = ystmax - ystmin;
    ayst1 = 0.5f * fem::pow2((ystmax - ystmin));
    ayst3 = 2.f * (fem::atan(fem::exp(ystmax)) - fem::atan(fem::exp(ystmin)));
    /// C
    /// C...Reset. Sum up cross-sections in points calculated.
    FEM_DO_SAFE(ivar, 1, 4) {
      if (npts(ivar) == 1) {
        goto statement_230;
      }
      if (isub == 96 && ivar == 4) {
        goto statement_230;
      }
      nbin = npts(ivar);
      FEM_DO_SAFE(j1, 1, nbin) {
        narel(j1) = 0;
        wtrel(j1) = 0.f;
        coefu(j1) = 0.f;
        FEM_DO_SAFE(j2, 1, nbin) { wtmat(j1, j2) = 0.f; }
      }
      FEM_DO_SAFE(iacc, 1, nacc) {
        ibin = mvarpt(iacc, ivar);
        narel(ibin)++;
        wtrel(ibin) += sigspt(iacc);
        /// C
        /// C...Sum up tau cross-section pieces in points used.
        if (ivar == 1) {
          tau = vintpt(iacc, 11);
          wtmat(ibin, 1) += 1.f;
          wtmat(ibin, 2) += (atau1 / atau2) / tau;
          if (nbin >= 3) {
            wtmat(ibin, 3) += (atau1 / atau3) / (tau + taur1);
            wtmat(ibin, 4) += (atau1 / atau4) * tau /
                              (fem::pow2((tau - taur1)) + fem::pow2(gamr1));
          }
          if (nbin >= 5) {
            wtmat(ibin, 5) += (atau1 / atau5) / (tau + taur2);
            wtmat(ibin, 6) += (atau1 / atau6) * tau /
                              (fem::pow2((tau - taur2)) + fem::pow2(gamr2));
          }
          /// C
          /// C...Sum up tau' cross-section pieces in points used.
        } else if (ivar == 2) {
          tau = vintpt(iacc, 11);
          taup = vintpt(iacc, 16);
          taupmn = vintpt(iacc, 6);
          taupmx = vintpt(iacc, 26);
          ataup1 = fem::log(taupmx / taupmn);
          ataup2 = (fem::pow4((1.f - tau / taupmx)) -
                    fem::pow4((1.f - tau / taupmn))) /
                   (4.f * tau);
          wtmat(ibin, 1) += 1.f;
          wtmat(ibin, 2) +=
              (ataup1 / ataup2) * fem::pow3((1.f - tau / taup)) / taup;
          /// C
          /// C...Sum up y* and cos(theta-hat) cross-section pieces in points
          /// used.
        } else if (ivar == 3) {
          yst = vintpt(iacc, 12);
          wtmat(ibin, 1) += (ayst0 / ayst1) * (yst - ystmin);
          wtmat(ibin, 2) += (ayst0 / ayst1) * (ystmax - yst);
          wtmat(ibin, 3) += (ayst0 / ayst3) / fem::cosh(yst);
        } else {
          rm34 = 2.f * sqm3 * sqm4 / fem::pow2((vintpt(iacc, 11) * vint(2)));
          rsqm = 1.f + rm34;
          cthmax =
              fem::sqrt(1.f - 4.f * fem::pow2(vint(71)) / (taumax * vint(2)));
          cthmin = -cthmax;
          if (cthmax > 0.9999f) {
            rm34 =
                fem::max(rm34, 2.f * fem::pow2(vint(71)) / (taumax * vint(2)));
          }
          acth1 = cthmax - cthmin;
          acth2 = fem::log(fem::max(rm34, rsqm - cthmin) /
                           fem::max(rm34, rsqm - cthmax));
          acth3 = fem::log(fem::max(rm34, rsqm + cthmax) /
                           fem::max(rm34, rsqm + cthmin));
          acth4 = 1.f / fem::max(rm34, rsqm - cthmax) -
                  1.f / fem::max(rm34, rsqm - cthmin);
          acth5 = 1.f / fem::max(rm34, rsqm + cthmin) -
                  1.f / fem::max(rm34, rsqm + cthmax);
          cth = vintpt(iacc, 13);
          wtmat(ibin, 1) += 1.f;
          wtmat(ibin, 2) += (acth1 / acth2) / fem::max(rm34, rsqm - cth);
          wtmat(ibin, 3) += (acth1 / acth3) / fem::max(rm34, rsqm + cth);
          wtmat(ibin, 4) +=
              (acth1 / acth4) / fem::pow2(fem::max(rm34, rsqm - cth));
          wtmat(ibin, 5) +=
              (acth1 / acth5) / fem::pow2(fem::max(rm34, rsqm + cth));
        }
      }
      /// C
      /// C...Check that equation system solvable; else trivial way out.
      if (mstp(122) >= 2) {
        write(mstu(11),
              "(1x,'Coefficients of equation system to be solved for ',a4)"),
            cvar(ivar);
      }
      msolv = 1;
      FEM_DO_SAFE(ibin, 1, nbin) {
        if (mstp(122) >= 2) {
          {
            write_loop wloop(cmn, mstu(11), "(1x,1p,7e11.3)");
            FEM_DO_SAFE(ired, 1, nbin) { wloop, wtmat(ibin, ired); }
            wloop, wtrel(ibin);
          }
        }
        if (narel(ibin) == 0) {
          msolv = 0;
        }
      }
      if (msolv == 0) {
        FEM_DO_SAFE(ibin, 1, nbin) { coefu(ibin) = 1.f; }
        /// C
        /// C...Solve to find relative importance of cross-section pieces.
      } else {
        FEM_DO_SAFE(ired, 1, nbin - 1) {
          FEM_DO_SAFE(ibin, ired + 1, nbin) {
            rqt = wtmat(ibin, ired) / wtmat(ired, ired);
            wtrel(ibin) = wtrel(ibin) - rqt * wtrel(ired);
            FEM_DO_SAFE(icoe, ired, nbin) {
              wtmat(ibin, icoe) = wtmat(ibin, icoe) - rqt * wtmat(ired, icoe);
            }
          }
        }
        FEM_DOSTEP(ired, nbin, 1, -1) {
          FEM_DO_SAFE(icoe, ired + 1, nbin) {
            wtrel(ired) = wtrel(ired) - wtmat(ired, icoe) * coefu(icoe);
          }
          coefu(ired) = wtrel(ired) / wtmat(ired, ired);
        }
      }
      /// C
      /// C...Normalize coefficients, with piece shared democratically.
      coefsu = 0.f;
      FEM_DO_SAFE(ibin, 1, nbin) {
        coefu(ibin) = fem::max(0.f, coefu(ibin));
        coefsu += coefu(ibin);
      }
      if (ivar == 1) {
        ioff = 0;
      }
      if (ivar == 2) {
        ioff = 14;
      }
      if (ivar == 3) {
        ioff = 6;
      }
      if (ivar == 4) {
        ioff = 9;
      }
      if (coefsu > 0.f) {
        FEM_DO_SAFE(ibin, 1, nbin) {
          coef(isub, ioff + ibin) =
              parp(121) / nbin + (1.f - parp(121)) * coefu(ibin) / coefsu;
        }
      } else {
        FEM_DO_SAFE(ibin, 1, nbin) { coef(isub, ioff + ibin) = 1.f / nbin; }
      }
      if (mstp(122) >= 2) {
        {
          write_loop wloop(cmn, mstu(11), "(1x,'Result for ',a4,':',6f9.4)");
          wloop, cvar(ivar);
          FEM_DO_SAFE(ibin, 1, nbin) { wloop, coef(isub, ioff + ibin); }
        }
      }
    statement_230:;
    }
    /// C
    /// C...Find two most promising maxima among points previously determined.
    FEM_DO_SAFE(j, 1, 4) {
      iaccmx(j) = 0;
      sigsmx(j) = 0.f;
    }
    nmax = 0;
    FEM_DO_SAFE(iacc, 1, nacc) {
      FEM_DO_SAFE(j, 1, 30) { vint(10 + j) = vintpt(iacc, j); }
      pysigh(cmn, nchn, sigs);
      ieq = 0;
      FEM_DO_SAFE(imv, 1, nmax) {
        if (fem::abs(sigs - sigsmx(imv)) < 1e-4f * (sigs + sigsmx(imv))) {
          ieq = imv;
        }
      }
      if (ieq == 0) {
        FEM_DOSTEP(imv, nmax, 1, -1) {
          iin = imv + 1;
          if (sigs <= sigsmx(imv)) {
            goto statement_280;
          }
          iaccmx(imv + 1) = iaccmx(imv);
          sigsmx(imv + 1) = sigsmx(imv);
        }
        iin = 1;
      statement_280:
        iaccmx(iin) = iacc;
        sigsmx(iin) = sigs;
        if (nmax <= 1) {
          nmax++;
        }
      }
    }
    /// C
    /// C...Read out starting position for search.
    if (mstp(122) >= 2) {
      write(
          mstu(11),
          "(1x,'Maximum search for given coefficients',/,2x,'MAX VAR ',"
          "'MOD MOV   VNEW',7x,'tau',7x,'y*',8x,'cth',7x,'tau''',7x,'sigma')");
    }
    sigsam = sigsmx(1);
    FEM_DO_SAFE(imax, 1, nmax) {
      iacc = iaccmx(imax);
      mtau = mvarpt(iacc, 1);
      mtaup = mvarpt(iacc, 2);
      myst = mvarpt(iacc, 3);
      mcth = mvarpt(iacc, 4);
      vtau = 0.5f;
      vyst = 0.5f;
      vcth = 0.5f;
      vtaup = 0.5f;
      /// C
      /// C...Starting point and step size in parameter space.
      FEM_DO_SAFE(irpt, 1, 2) {
        FEM_DO_SAFE(ivar, 1, 4) {
          if (npts(ivar) == 1) {
            goto statement_310;
          }
          if (ivar == 1) {
            vvar = vtau;
          }
          if (ivar == 2) {
            vvar = vtaup;
          }
          if (ivar == 3) {
            vvar = vyst;
          }
          if (ivar == 4) {
            vvar = vcth;
          }
          if (ivar == 1) {
            mvar = mtau;
          }
          if (ivar == 2) {
            mvar = mtaup;
          }
          if (ivar == 3) {
            mvar = myst;
          }
          if (ivar == 4) {
            mvar = mcth;
          }
          if (irpt == 1) {
            vdel = 0.1f;
          }
          if (irpt == 2) {
            vdel = fem::max(0.01f, fem::min(0.05f, vvar - 0.02f, 0.98f - vvar));
          }
          if (irpt == 1) {
            vmar = 0.02f;
          }
          if (irpt == 2) {
            vmar = 0.002f;
          }
          imov0 = 1;
          if (irpt == 1 && ivar == 1) {
            imov0 = 0;
          }
          FEM_DO_SAFE(imov, imov0, 8) {
            /// C
            /// C...Define new point in parameter space.
            if (imov == 0) {
              inew = 2;
              vnew = vvar;
            } else if (imov == 1) {
              inew = 3;
              vnew = vvar + vdel;
            } else if (imov == 2) {
              inew = 1;
              vnew = vvar - vdel;
            } else if (sigssm(3) >= fem::max(sigssm(1), sigssm(2)) &&
                       vvar + 2.f * vdel < 1.f - vmar) {
              vvar += vdel;
              sigssm(1) = sigssm(2);
              sigssm(2) = sigssm(3);
              inew = 3;
              vnew = vvar + vdel;
            } else if (sigssm(1) >= fem::max(sigssm(2), sigssm(3)) &&
                       vvar - 2.f * vdel > vmar) {
              vvar = vvar - vdel;
              sigssm(3) = sigssm(2);
              sigssm(2) = sigssm(1);
              inew = 1;
              vnew = vvar - vdel;
            } else if (sigssm(3) >= sigssm(1)) {
              vdel = 0.5f * vdel;
              vvar += vdel;
              sigssm(1) = sigssm(2);
              inew = 2;
              vnew = vvar;
            } else {
              vdel = 0.5f * vdel;
              vvar = vvar - vdel;
              sigssm(3) = sigssm(2);
              inew = 2;
              vnew = vvar;
            }
            /// C
            /// C...Convert to relevant variables and find derived new limits.
            if (ivar == 1) {
              vtau = vnew;
              pykmap(cmn, 1, mtau, vtau);
              if (istsb == 3 || istsb == 4) {
                pyklim(cmn, 4);
              }
            }
            if (ivar <= 2 && (istsb == 3 || istsb == 4)) {
              if (ivar == 2) {
                vtaup = vnew;
              }
              pykmap(cmn, 4, mtaup, vtaup);
            }
            if (ivar <= 2) {
              pyklim(cmn, 2);
            }
            if (ivar <= 3) {
              if (ivar == 3) {
                vyst = vnew;
              }
              pykmap(cmn, 2, myst, vyst);
              pyklim(cmn, 3);
            }
            if (istsb == 2 || istsb == 4) {
              if (ivar == 4) {
                vcth = vnew;
              }
              pykmap(cmn, 3, mcth, vcth);
            }
            if (isub == 96) {
              vint(25) = vint(21) * (1.f - fem::pow2(vint(23)));
            }
            /// C
            /// C...Evaluate cross-section. Save new maximum. Final maximum.
            pysigh(cmn, nchn, sigs);
            sigssm(inew) = sigs;
            if (sigs > sigsam) {
              sigsam = sigs;
            }
            if (mstp(122) >= 2) {
              write(mstu(11), "(1x,4i4,f8.4,f11.7,f9.3,f11.6,f11.7,1p,e12.4)"),
                  imax, ivar, mvar, imov, vnew, vint(21), vint(22), vint(23),
                  vint(26), sigs;
            }
          }
        statement_310:;
        }
      }
      if (imax == 1) {
        sigs11 = sigsam;
      }
    }
    xsec(isub, 1) = 1.05f * sigsam;
  statement_340:
    if (isub != 96) {
      xsec(0, 1) += xsec(isub, 1);
    }
  statement_350:;
  }
  /// C
  /// C...Print summary table.
  if (mstp(122) >= 1) {
    write(mstu(11),
          "(/,1x,8('*'),1x,'PYMAXI: summary of differential ',"
          "'cross-section maximum search',1x,8('*'))");
    write(
        mstu(11),
        "(/,11x,58('='),/,11x,'I',38x,'I',17x,'I',/,11x,'I  ISUB  ',"
        "'Subprocess name',15x,'I  Maximum value  I',/,11x,'I',38x,'I',17x,'I',"
        "/,11x,58('='),/,11x,'I',38x,'I',17x,'I')");
    FEM_DO_SAFE(isub, 1, 200) {
      if (msub(isub) != 1 && isub != 96) {
        goto statement_360;
      }
      if (isub == 96 && mint(43) != 4) {
        goto statement_360;
      }
      if (isub == 96 && msub(95) != 1 && mstp(81) <= 0) {
        goto statement_360;
      }
      if (msub(95) == 1 && (isub == 11 || isub == 12 || isub == 13 ||
                            isub == 28 || isub == 53 || isub == 68)) {
        goto statement_360;
      }
      write(mstu(11), "(11x,'I',2x,i3,3x,a28,2x,'I',2x,1p,e12.4,3x,'I')"), isub,
          proc(isub), xsec(isub, 1);
    statement_360:;
    }
    write(mstu(11), "(11x,'I',38x,'I',17x,'I',/,11x,58('='))");
  }
  /// C
  /// C...Format statements for maximization results.
  /// C
}

struct pyinit_save {
  arr<fem::str<6> > chlh;
  arr<fem::str<3> > chmo;

  pyinit_save()
      : chlh(dimension(2), fem::fill0), chmo(dimension(12), fem::fill0) {}
};

void pyinit(common& cmn, str_cref frame, str_cref beam, str_cref target,
            float const& win) {
  FEM_CMN_SVE(pyinit);
  common_write write(cmn);
  /// COMMON ludat1
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<float> paru(cmn.paru, dimension(200));
  arr_ref<float> parj(cmn.parj, dimension(200));
  /// COMMON ludat2
  arr_cref<float, 2> vckm(cmn.vckm, dimension(4, 4));
  /// COMMON ludat3
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_ref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  /// COMMON pysubs
  int& msel = cmn.msel;
  arr_ref<int> msub(cmn.msub, dimension(200));
  arr_cref<float> ckin(cmn.ckin, dimension(200));
  /// COMMON pypars
  arr_ref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<float> parp(cmn.parp, dimension(200));
  /// COMMON pyint1
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float> vint(cmn.vint, dimension(400));
  /// COMMON pyint2
  arr_cref<int> iset(cmn.iset, dimension(200));
  /// COMMON pyint5
  arr_ref<int, 2> ngen(cmn.ngen, dim1(0, 200).dim2(3));
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  /// SAVE
  str_arr_ref<1> chlh(sve.chlh, dimension(2));
  ///
  str_arr_ref<1> chmo(sve.chmo, dimension(12));
  if (is_called_first_time) {
    {
      static const char* values[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chmo;
    }
    {
      static const char* values[] = {"lepton", "hadron"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chlh;
    }
  }
  /// C
  /// C...Initializes the generation procedure; finds maxima of the
  /// C...differential cross-sections to be used for weighting.
  /// C
  /// Clin-12/2012 correct NN differential cross section in HIJING:
  write(mstu(11), star), "In PYINIT: BEAM,TARGET= ", beam, target;
  /// C
  /// C...Write headers.
  /// C      IF(MSTP(122).GE.1) WRITE(MSTU(11),1000) MSTP(181),MSTP(182),
  /// C     &MSTP(185),CHMO(MSTP(184)),MSTP(183)
  lulist(cmn, 0);
  /// C      IF(MSTP(122).GE.1) WRITE(MSTU(11),1100)
  /// C
  /// C...Identify beam and target particles and initialize kinematics.
  fem::str<8> chfram = frame + str_cref(" ");
  fem::str<8> chbeam = beam + str_cref(" ");
  fem::str<8> chtarg = target + str_cref(" ");
  pyinki(cmn, chfram, chbeam, chtarg, win);
  /// C
  /// C...Select partonic subprocesses to be included in the simulation.
  int i = fem::int0;
  if (msel != 0) {
    FEM_DO_SAFE(i, 1, 200) { msub(i) = 0; }
  }
  int j = fem::int0;
  if (mint(43) == 1 && (msel == 1 || msel == 2)) {
    /// C...Lepton+lepton -> gamma/Z0 or W.
    if (mint(11) + mint(12) == 0) {
      msub(1) = 1;
    }
    if (mint(11) + mint(12) != 0) {
      msub(2) = 1;
    }
  } else if (msel == 1) {
    /// C...High-pT QCD processes:
    msub(11) = 1;
    msub(12) = 1;
    msub(13) = 1;
    msub(28) = 1;
    msub(53) = 1;
    msub(68) = 1;
    if (mstp(82) <= 1 && ckin(3) < parp(81)) {
      msub(95) = 1;
    }
    if (mstp(82) >= 2 && ckin(3) < parp(82)) {
      msub(95) = 1;
    }
  } else if (msel == 2) {
    /// C...All QCD processes:
    msub(11) = 1;
    msub(12) = 1;
    msub(13) = 1;
    msub(28) = 1;
    msub(53) = 1;
    msub(68) = 1;
    msub(91) = 1;
    msub(92) = 1;
    msub(93) = 1;
    msub(95) = 1;
  } else if (msel >= 4 && msel <= 8) {
    /// C...Heavy quark production.
    msub(81) = 1;
    msub(82) = 1;
    FEM_DO_SAFE(j, 1, fem::min(8, mdcy(21, 3))) {
      mdme(mdcy(21, 2) + j - 1, 1) = 0;
    }
    mdme(mdcy(21, 2) + msel - 1, 1) = 1;
  } else if (msel == 10) {
    /// C...Prompt photon production:
    msub(14) = 1;
    msub(18) = 1;
    msub(29) = 1;
  } else if (msel == 11) {
    /// C...Z0/gamma* production:
    msub(1) = 1;
  } else if (msel == 12) {
    /// C...W+/- production:
    msub(2) = 1;
  } else if (msel == 13) {
    /// C...Z0 + jet:
    msub(15) = 1;
    msub(30) = 1;
  } else if (msel == 14) {
    /// C...W+/- + jet:
    msub(16) = 1;
    msub(31) = 1;
  } else if (msel == 15) {
    /// C...Z0 & W+/- pair production:
    msub(19) = 1;
    msub(20) = 1;
    msub(22) = 1;
    msub(23) = 1;
    msub(25) = 1;
  } else if (msel == 16) {
    /// C...H0 production:
    msub(3) = 1;
    msub(5) = 1;
    msub(8) = 1;
    msub(102) = 1;
  } else if (msel == 17) {
    /// C...H0 & Z0 or W+/- pair production:
    msub(24) = 1;
    msub(26) = 1;
  } else if (msel == 21) {
    /// C...Z'0 production:
    msub(141) = 1;
  } else if (msel == 22) {
    /// C...H+/- production:
    msub(142) = 1;
  } else if (msel == 23) {
    /// C...R production:
    msub(143) = 1;
  }
  /// C
  /// C...Count number of subprocesses on.
  mint(44) = 0;
  int isub = fem::int0;
  FEM_DO_SAFE(isub, 1, 200) {
    if (mint(43) < 4 && isub >= 91 && isub <= 96 && msub(isub) == 1) {
      write(mstu(11),
            "(1x,'Error: process number ',i3,' not meaningful for ',a6,'-',a6,"
            "' interactions.',/,1x,'Execution stopped!')"),
          isub, chlh(mint(41)), chlh(mint(42));
      FEM_STOP(0);
    } else if (msub(isub) == 1 && iset(isub) == -1) {
      write(mstu(11),
            "(1x,'Error: requested subprocess',i4,' not implemented.',/,1x,"
            "'Execution stopped!')"),
          isub;
      FEM_STOP(0);
    } else if (msub(isub) == 1 && iset(isub) <= -2) {
      write(mstu(11),
            "(1x,'Error: requested subprocess',i4,' not existing.',/,1x,"
            "'Execution stopped!')"),
          isub;
      FEM_STOP(0);
    } else if (msub(isub) == 1) {
      mint(44)++;
    }
  }
  if (mint(44) == 0) {
    write(mstu(11),
          "(1x,'Error: no subprocess switched on.',/,1x,'Execution stopped.')");
    FEM_STOP(0);
  }
  mint(45) = mint(44) - msub(91) - msub(92) - msub(93) - msub(94);
  /// C
  /// C...Maximum 4 generations; set maximum number of allowed flavours.
  mstp(1) = fem::min(4, mstp(1));
  mstu(114) = fem::min(mstu(114), 2 * mstp(1));
  mstp(54) = fem::min(mstp(54), 2 * mstp(1));
  /// C
  /// C...Sum up Cabibbo-Kobayashi-Maskawa factors for each quark/lepton.
  int ia = fem::int0;
  int ib = fem::int0;
  int ipm = fem::int0;
  int idc = fem::int0;
  FEM_DO_SAFE(i, -20, 20) {
    vint(180 + i) = 0.f;
    ia = fem::iabs(i);
    if (ia >= 1 && ia <= 2 * mstp(1)) {
      FEM_DO_SAFE(j, 1, mstp(1)) {
        ib = 2 * j - 1 + fem::mod(ia, 2);
        ipm = (5 - fem::isign(1, i)) / 2;
        idc = j + mdcy(ia, 2) + 2;
        if (mdme(idc, 1) == 1 || mdme(idc, 1) == ipm) {
          vint(180 + i) += vckm((ia + 1) / 2, (ib + 1) / 2);
        }
      }
    } else if (ia >= 11 && ia <= 10 + 2 * mstp(1)) {
      vint(180 + i) = 1.f;
    }
  }
  /// C
  /// C...Choose Lambda value to use in alpha-strong.
  mstu(111) = mstp(2);
  float alam = fem::float0;
  if (mstp(3) >= 1) {
    alam = parp(1);
    if (mstp(51) == 1) {
      alam = 0.2f;
    }
    if (mstp(51) == 2) {
      alam = 0.29f;
    }
    if (mstp(51) == 3) {
      alam = 0.2f;
    }
    if (mstp(51) == 4) {
      alam = 0.4f;
    }
    if (mstp(51) == 11) {
      alam = 0.16f;
    }
    if (mstp(51) == 12) {
      alam = 0.26f;
    }
    if (mstp(51) == 13) {
      alam = 0.36f;
    }
    parp(1) = alam;
    parp(61) = alam;
    paru(112) = alam;
    parj(81) = alam;
  }
  /// C
  /// C...Initialize widths and partial widths for resonances.
  pyinre(cmn);
  /// C
  /// C...Reset variables for cross-section calculation.
  FEM_DO_SAFE(i, 0, 200) {
    FEM_DO_SAFE(j, 1, 3) {
      ngen(i, j) = 0;
      xsec(i, j) = 0.f;
    }
  }
  vint(108) = 0.f;
  /// C
  /// C...Find parametrized total cross-sections.
  if (mint(43) == 4) {
    pyxtot(cmn);
  }
  /// C
  /// C...Maxima of differential cross-sections.
  if (mstp(121) <= 0) {
    pymaxi(cmn);
  }
  /// C
  /// C...Initialize possibility of overlayed events.
  if (mstp(131) != 0) {
    pyovly(cmn, 1);
  }
  /// C
  /// C...Initialize multiple interactions with variable impact parameter.
  if (mint(43) == 4 && (mint(45) != 0 || mstp(131) != 0) && mstp(82) >= 2) {
    pymult(cmn, 1);
  }
  /// C      IF(MSTP(122).GE.1) WRITE(MSTU(11),1600)
  /// C
  /// C...Formats for initialization information.
  /// Clin 1000 FORMAT(////20X,'The Lund Monte Carlo - PYTHIA version
  /// ',I1,'.',I1/ Clin     &20X,'**  Last date of change:  ',I2,1X,A3,1X,I4,'
  /// **'/) Clin 1100 FORMAT('1',18('*'),1X,'PYINIT: initialization of PYTHIA ',
  /// Clin     &'routines',1X,17('*'))
  /// Clin 1600 FORMAT(/1X,22('*'),1X,'PYINIT: initialization completed',1X,
  /// Clin     &22('*'))
  /// C
}

struct jetini_save {
  fem::variant_bindings hstrng_bindings;
  fem::str<16> beam;
  arr<float, 3> coef0;
  int i;
  int ilast;
  arr<int> ini;
  int isel;
  int isub;
  int itype;
  int j;
  arr<int> mint44;
  arr<int> mint45;
  fem::str<16> targ;
  arr<float, 2> xsec0;

  jetini_save()
      : beam(fem::char0),
        coef0(dimension(8, 200, 20), fem::fill0),
        i(fem::int0),
        ilast(fem::int0),
        ini(dimension(8), fem::fill0),
        isel(fem::int0),
        isub(fem::int0),
        itype(fem::int0),
        j(fem::int0),
        mint44(dimension(8), fem::fill0),
        mint45(dimension(8), fem::fill0),
        targ(fem::char0),
        xsec0(dim1(8).dim2(0, 200), fem::fill0) {}
};

void jetini(common& cmn, int const& jp, int const& jt, int const& itrig) {
  FEM_CMN_SVE(jetini);
  common_write write(cmn);
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  arr_ref<int> ihnt2(cmn.ihnt2, dimension(50));
  int& mint4 = cmn.mint4;
  int& mint5 = cmn.mint5;
  arr_ref<float, 2> atco(cmn.atco, dimension(200, 20));
  arr_ref<float> atxs(cmn.atxs, dim1(0, 200));
  arr_cref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_ref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  int& msel = cmn.msel;
  arr_ref<int> msub(cmn.msub, dimension(200));
  arr_ref<float> ckin(cmn.ckin, dimension(200));
  arr_ref<int> mstp(cmn.mstp, dimension(200));
  arr_ref<float> parp(cmn.parp, dimension(200));
  arr_ref<int> mint(cmn.mint, dimension(400));
  arr_ref<float, 2> coef(cmn.coef, dimension(200, 20));
  arr_ref<float, 2> xsec(cmn.xsec, dim1(0, 200).dim2(3));
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  fem::str<16>& beam = sve.beam;
  arr_ref<float, 3> coef0(sve.coef0, dimension(8, 200, 20));
  int& i = sve.i;
  int& ilast = sve.ilast;
  arr_ref<int> ini(sve.ini, dimension(8));
  int& isel = sve.isel;
  int& isub = sve.isub;
  int& itype = sve.itype;
  int& j = sve.j;
  arr_ref<int> mint44(sve.mint44, dimension(8));
  arr_ref<int> mint45(sve.mint45, dimension(8));
  fem::str<16>& targ = sve.targ;
  arr_ref<float, 2> xsec0(sve.xsec0, dim1(8).dim2(0, 200));
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_cref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  /* arr_cref<float, 2> pp( */ hstrng.bind<float>() /* , dimension(300,
    15)) */
      ;
  arr_cref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  /* arr_cref<float, 2> pt( */ hstrng.bind<float>() /* , dimension(300,
    15)) */
      ;
  if (is_called_first_time) {
    fem::data((values, 8 * datum(0))), ini;
    ilast = -1;
  }
  /// C*******Initialize PYTHIA for jet production**********************
  /// C        itrig=0: for normal processes
  /// C        itrig=1: for triggered processes
  /// C       JP: sequence number of the projectile
  /// C       JT: sequence number of the target
  /// C     For A+A collisions, one has to initilize pythia
  /// C     separately for each type of collisions, pp, pn,np and nn,
  /// C     or hp and hn for hA collisions. In this subroutine we use the
  /// following C     catalogue for different type of collisions: C     h+h: h+h
  /// (itype=1) C     h+A: h+p (itype=1), h+n (itype=2) C     A+h: p+h
  /// (itype=1), n+h (itype=2) C     A+A: p+p (itype=1), p+n (itype=2), n+p
  /// (itype=3), n+n (itype=4)
  /// C***************************************************************** Cc SAVE
  /// /hjcrdn/ Cc      SAVE /HPARNT/ Cc      SAVE /HSTRNG/ Cc      SAVE /HPINT/
  /// C
  /// Cc      SAVE /LUDAT1/
  /// Cc      SAVE /LUDAT3/
  /// Cc      SAVE /PYSUBS/
  /// Cc      SAVE /PYPARS/
  /// Cc      SAVE /PYINT1/
  /// Cc      SAVE /PYINT2/
  /// Cc      SAVE /PYINT5/
  /// Clin        DATA INI/8*0/ilast/-1/
  /// C
  ihnt2(11) = jp;
  ihnt2(12) = jt;
  if (ihnt2(5) != 0 && ihnt2(6) != 0) {
    itype = 1;
  } else if (ihnt2(5) != 0 && ihnt2(6) == 0) {
    itype = 1;
    if (nft(jt, 4) == 2112) {
      itype = 2;
    }
  } else if (ihnt2(5) == 0 && ihnt2(6) != 0) {
    itype = 1;
    if (nfp(jp, 4) == 2112) {
      itype = 2;
    }
  } else {
    if (nfp(jp, 4) == 2212 && nft(jt, 4) == 2212) {
      itype = 1;
    } else if (nfp(jp, 4) == 2212 && nft(jt, 4) == 2112) {
      itype = 2;
    } else if (nfp(jp, 4) == 2112 && nft(jt, 4) == 2212) {
      itype = 3;
    } else {
      itype = 4;
    }
  }
  /// C
  /// Clin-12/2012 correct NN differential cross section in HIJING:
  /// C        write(94,*) 'In JETINI: ',jp,jt,NFP(JP,4),NFT(JT,4),itype
  /// C
  if (itrig != 0) {
    goto statement_160;
  }
  if (itrig == ilast) {
    goto statement_150;
  }
  mstp(2) = 2;
  /// C                        ********second order running alpha_strong
  mstp(33) = 1;
  parp(31) = hipr1(17);
  /// C                        ********inclusion of K factor
  mstp(51) = 3;
  /// C                        ********Duke-Owens set 1 structure functions
  mstp(61) = 1;
  /// C                        ********INITIAL STATE RADIATION
  mstp(71) = 1;
  /// C                        ********FINAL STATE RADIATION
  if (ihpr2(2) == 0 || ihpr2(2) == 2) {
    mstp(61) = 0;
  }
  if (ihpr2(2) == 0 || ihpr2(2) == 1) {
    mstp(71) = 0;
  }
  /// C
  mstp(81) = 0;
  /// C                        ******** NO MULTIPLE INTERACTION
  mstp(82) = 1;
  /// C                        *******STRUCTURE OF MUTLIPLE INTERACTION
  mstp(111) = 0;
  /// C                ********frag off(have to be done by local call)
  if (ihpr2(10) == 0) {
    mstp(122) = 0;
  }
  /// C                ********No printout of initialization information
  parp(81) = hipr1(8);
  ckin(5) = hipr1(8);
  ckin(3) = hipr1(8);
  ckin(4) = hipr1(9);
  if (hipr1(9) <= hipr1(8)) {
    ckin(4) = -1.0f;
  }
  ckin(9) = -10.0f;
  ckin(10) = 10.0f;
  msel = 0;
  FEM_DO_SAFE(isub, 1, 200) { msub(isub) = 0; }
  msub(11) = 1;
  msub(12) = 1;
  msub(13) = 1;
  msub(28) = 1;
  msub(53) = 1;
  msub(68) = 1;
  msub(81) = 1;
  msub(82) = 1;
  FEM_DO_SAFE(j, 1, fem::min(8, mdcy(21, 3))) {
    mdme(mdcy(21, 2) + j - 1, 1) = 0;
  }
  isel = 4;
  if (hint1(1) >= 20.0f && ihpr2(18) == 1) {
    isel = 5;
  }
  mdme(mdcy(21, 2) + isel - 1, 1) = 1;
  /// C                        ********QCD subprocesses
  msub(14) = 1;
  msub(18) = 1;
  msub(29) = 1;
/// C                       ******* direct photon production
statement_150:
  if (ini(itype) != 0) {
    goto statement_800;
  }
  goto statement_400;
/// C
/// C        *****triggered subprocesses, jet, photon, heavy quark and DY
/// C
statement_160:
  itype += 4;
  if (itrig == ilast) {
    goto statement_260;
  }
  parp(81) = fem::abs(hipr1(10)) - 0.25f;
  ckin(5) = fem::abs(hipr1(10)) - 0.25f;
  ckin(3) = fem::abs(hipr1(10)) - 0.25f;
  ckin(4) = fem::abs(hipr1(10)) + 0.25f;
  if (hipr1(10) < hipr1(8)) {
    ckin(4) = -1.0f;
  }
  /// C
  msel = 0;
  FEM_DO_SAFE(isub, 1, 200) { msub(isub) = 0; }
  if (ihpr2(3) == 1) {
    msub(11) = 1;
    msub(12) = 1;
    msub(13) = 1;
    msub(28) = 1;
    msub(53) = 1;
    msub(68) = 1;
    msub(81) = 1;
    msub(82) = 1;
    msub(14) = 1;
    msub(18) = 1;
    msub(29) = 1;
    FEM_DO_SAFE(j, 1, fem::min(8, mdcy(21, 3))) {
      mdme(mdcy(21, 2) + j - 1, 1) = 0;
    }
    isel = 4;
    if (hint1(1) >= 20.0f && ihpr2(18) == 1) {
      isel = 5;
    }
    mdme(mdcy(21, 2) + isel - 1, 1) = 1;
    /// C                        ********QCD subprocesses
  } else if (ihpr2(3) == 2) {
    msub(14) = 1;
    msub(18) = 1;
    msub(29) = 1;
    /// C                ********Direct photon production
    /// C                q+qbar->g+gamma,q+qbar->gamma+gamma, q+g->q+gamma
  } else if (ihpr2(3) == 3) {
    ckin(3) = fem::max(0.0f, hipr1(10));
    ckin(5) = hipr1(8);
    parp(81) = hipr1(8);
    msub(81) = 1;
    msub(82) = 1;
    FEM_DO_SAFE(j, 1, fem::min(8, mdcy(21, 3))) {
      mdme(mdcy(21, 2) + j - 1, 1) = 0;
    }
    isel = 4;
    if (hint1(1) >= 20.0f && ihpr2(18) == 1) {
      isel = 5;
    }
    mdme(mdcy(21, 2) + isel - 1, 1) = 1;
    /// C             **********Heavy quark production
  }
statement_260:
  if (ini(itype) != 0) {
    goto statement_800;
  }
/// C
statement_400:
  ini(itype) = 1;
  if (ihpr2(10) == 0) {
    mstp(122) = 0;
  }
  if (nfp(jp, 4) == 2212) {
    beam = "P";
  } else if (nfp(jp, 4) == -2212) {
    beam = "P~";
  } else if (nfp(jp, 4) == 2112) {
    beam = "N";
  } else if (nfp(jp, 4) == -2112) {
    beam = "N~";
  } else if (nfp(jp, 4) == 211) {
    beam = "PI+";
  } else if (nfp(jp, 4) == -211) {
    beam = "PI-";
  } else if (nfp(jp, 4) == 321) {
    beam = "PI+";
  } else if (nfp(jp, 4) == -321) {
    beam = "PI-";
  } else {
    write(6, star), "unavailable beam type", nfp(jp, 4);
  }
  if (nft(jt, 4) == 2212) {
    targ = "P";
  } else if (nft(jt, 4) == -2212) {
    targ = "P~";
  } else if (nft(jt, 4) == 2112) {
    targ = "N";
  } else if (nft(jt, 4) == -2112) {
    targ = "N~";
  } else if (nft(jt, 4) == 211) {
    targ = "PI+";
  } else if (nft(jt, 4) == -211) {
    targ = "PI-";
  } else if (nft(jt, 4) == 321) {
    targ = "PI+";
  } else if (nft(jt, 4) == -321) {
    targ = "PI-";
  } else {
    write(6, star), "unavailable target type", nft(jt, 4);
  }
  /// C
  ihnt2(16) = 1;
  /// C       ******************indicate for initialization use when
  /// C                         structure functions are called in PYTHIA
  /// C
  pyinit(cmn, "CMS", beam, targ, hint1(1));
  mint4 = mint(44);
  mint5 = mint(45);
  mint44(itype) = mint(44);
  mint45(itype) = mint(45);
  atxs(0) = xsec(0, 1);
  xsec0(itype, 0) = xsec(0, 1);
  FEM_DO_SAFE(i, 1, 200) {
    atxs(i) = xsec(i, 1);
    xsec0(itype, i) = xsec(i, 1);
    FEM_DO_SAFE(j, 1, 20) {
      atco(i, j) = coef(i, j);
      coef0(itype, i, j) = coef(i, j);
    }
  }
  /// C
  ihnt2(16) = 0;
  /// C
  return;
/// C                ********Store the initialization information for
/// C                                late use
/// C
statement_800:
  mint(44) = mint44(itype);
  mint(45) = mint45(itype);
  mint4 = mint(44);
  mint5 = mint(45);
  xsec(0, 1) = xsec0(itype, 0);
  atxs(0) = xsec(0, 1);
  FEM_DO_SAFE(i, 1, 200) {
    xsec(i, 1) = xsec0(itype, i);
    atxs(i) = xsec(i, 1);
    FEM_DO_SAFE(j, 1, 20) {
      coef(i, j) = coef0(itype, i, j);
      atco(i, j) = coef(i, j);
    }
  }
  ilast = itrig;
  mint(11) = nfp(jp, 4);
  mint(12) = nft(jt, 4);
}

struct attflv_save {
  int id0;
  int id00;
  int nsign;
  float x;

  attflv_save()
      : id0(fem::int0), id00(fem::int0), nsign(fem::int0), x(fem::float0) {}
};

void attflv(common& cmn, int const& id, int& idq, int& idqq) {
  FEM_CMN_SVE(attflv);
  int& id0 = sve.id0;
  int& id00 = sve.id00;
  int& nsign = sve.nsign;
  float& x = sve.x;
  /// Cc      SAVE /RNDF77/
  /// C
  if (fem::abs(id) < 100) {
    nsign = 1;
    idq = id / 100;
    idqq = -id / 10 + idq * 10;
    if (fem::abs(idq) == 3) {
      nsign = -1;
    }
    idq = nsign * idq;
    idqq = nsign * idqq;
    if (idq < 0) {
      id0 = idq;
      idq = idqq;
      idqq = id0;
    }
    return;
  }
  /// C                ********return ID of quark(IDQ) and anti-quark(IDQQ)
  /// C                        for pions and kaons
  /// C
  /// C        Return LU ID for quarks and diquarks for proton(ID=2212)
  /// C        anti-proton(ID=-2212) and nuetron(ID=2112)
  /// C        LU ID for d=1,u=2, (ud)0=2101, (ud)1=2103,
  /// C       (dd)1=1103,(uu)1=2203.
  /// C        Use SU(6)  weight  proton=1/3d(uu)1 + 1/6u(ud)1 + 1/2u(ud)0
  /// C                          nurtron=1/3u(dd)1 + 1/6d(ud)1 + 1/2d(ud)0
  /// C
  idq = 2;
  if (fem::abs(id) == 2112) {
    idq = 1;
  }
  idqq = 2101;
  x = ranart(cmn.nseed);
  if (x <= 0.5f) {
    goto statement_30;
  }
  if (x > 0.666667f) {
    goto statement_10;
  }
  idqq = 2103;
  goto statement_30;
statement_10:
  idq = 1;
  idqq = 2203;
  if (fem::abs(id) == 2112) {
    idq = 2;
    idqq = 1103;
  }
statement_30:
  if (id < 0) {
    id00 = idqq;
    idqq = -idq;
    idq = -id00;
  }
}

struct hijini_save {
  fem::variant_bindings hstrng_bindings;
  int i;
  int idq;
  int idqq;
  int ipp;
  int ipt;

  hijini_save()
      : i(fem::int0),
        idq(fem::int0),
        idqq(fem::int0),
        ipp(fem::int0),
        ipt(fem::int0) {}
};

void hijini(common& cmn) {
  FEM_CMN_SVE(hijini);
  /// COMMON hparnt
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  /// COMMON hjjet1
  arr_ref<int> npj(cmn.npj, dimension(300));
  arr_ref<int> ntj(cmn.ntj, dimension(300));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  /// SAVE
  int& i = sve.i;
  int& idq = sve.idq;
  int& idqq = sve.idqq;
  int& ipp = sve.ipp;
  int& ipt = sve.ipt;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_ref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_ref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// C        COMMON/HJJET4/NDR,IADR(900,2),KFDR(900),PDR(900,5)
  /// Cc      SAVE /HJJET4/
  /// Cc      SAVE /RNDF77/
  /// C****************Reset the momentum of initial particles************
  /// C             and assign flavors to the proj and targ string       *
  /// C*******************************************************************
  cmn.nsg = 0;
  cmn.ndr = 0;
  ipp = 2212;
  ipt = 2212;
  if (ihnt2(5) != 0) {
    ipp = ihnt2(5);
  }
  if (ihnt2(6) != 0) {
    ipt = ihnt2(6);
  }
  /// C                ********in case the proj or targ is a hadron.
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    pp(i, 1) = 0.0f;
    pp(i, 2) = 0.0f;
    pp(i, 3) = fem::sqrt(fem::pow2(hint1(1)) / 4.0f - fem::pow2(hint1(8)));
    pp(i, 4) = hint1(1) / 2;
    pp(i, 5) = hint1(8);
    pp(i, 6) = 0.0f;
    pp(i, 7) = 0.0f;
    pp(i, 8) = 0.0f;
    pp(i, 9) = 0.0f;
    pp(i, 10) = 0.0f;
    /// Cbzdbg2/22/99
    /// Ctest OFF
    pp(i, 11) = 0.0f;
    pp(i, 12) = 0.0f;
    /// Cbzdbg2/22/99end
    nfp(i, 3) = ipp;
    nfp(i, 4) = ipp;
    nfp(i, 5) = 0;
    nfp(i, 6) = 0;
    nfp(i, 7) = 0;
    nfp(i, 8) = 0;
    nfp(i, 9) = 0;
    nfp(i, 10) = 0;
    nfp(i, 11) = 0;
    npj(i) = 0;
    if (i > fem::abs(ihnt2(2))) {
      nfp(i, 3) = 2112;
    }
    /// C
    /// Clin-12/2012 correct NN differential cross section in HIJING:
    if (i > fem::abs(ihnt2(2))) {
      nfp(i, 4) = 2112;
    }
    /// C
    attflv(cmn, nfp(i, 3), idq, idqq);
    nfp(i, 1) = idq;
    nfp(i, 2) = idqq;
    nfp(i, 15) = -1;
    if (fem::abs(idq) > 1000 ||
        (fem::abs(idq * idqq) < 100 && ranart(nseed) < 0.5f)) {
      nfp(i, 15) = 1;
    }
    pp(i, 14) = ulmass(cmn, idq);
    pp(i, 15) = ulmass(cmn, idqq);
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    pt(i, 1) = 0.0f;
    pt(i, 2) = 0.0f;
    pt(i, 3) = -fem::sqrt(fem::pow2(hint1(1)) / 4.0f - fem::pow2(hint1(9)));
    pt(i, 4) = hint1(1) / 2.0f;
    pt(i, 5) = hint1(9);
    pt(i, 6) = 0.0f;
    pt(i, 7) = 0.0f;
    pt(i, 8) = 0.0f;
    pt(i, 9) = 0.0f;
    pt(i, 10) = 0.0f;
    /// Ctest OFF
    /// Cbzdbg2/22/99
    pt(i, 11) = 0.0f;
    pt(i, 12) = 0.0f;
    /// Cbzdbg2/22/99end
    nft(i, 3) = ipt;
    nft(i, 4) = ipt;
    nft(i, 5) = 0;
    nft(i, 6) = 0;
    nft(i, 7) = 0;
    nft(i, 8) = 0;
    nft(i, 9) = 0;
    nft(i, 10) = 0;
    nft(i, 11) = 0;
    ntj(i) = 0;
    if (i > fem::abs(ihnt2(4))) {
      nft(i, 3) = 2112;
    }
    /// C
    /// Clin-12/2012 correct NN differential cross section in HIJING:
    if (i > fem::abs(ihnt2(4))) {
      nft(i, 4) = 2112;
    }
    /// C
    attflv(cmn, nft(i, 3), idq, idqq);
    nft(i, 1) = idq;
    nft(i, 2) = idqq;
    nft(i, 15) = 1;
    if (fem::abs(idq) > 1000 ||
        (fem::abs(idq * idqq) < 100 && ranart(nseed) < 0.5f)) {
      nft(i, 15) = -1;
    }
    pt(i, 14) = ulmass(cmn, idq);
    pt(i, 15) = ulmass(cmn, idqq);
  }
}

struct hijels_save {
  float am1;
  float am2;
  float amm;
  float bb;
  float cc;
  double db;
  double dbp;
  double dbx;
  double dby;
  double dbz;
  double dga;
  double dgabp;
  double dp1;
  double dp2;
  double dp3;
  double dp4;
  float ecm;
  float els;
  float els0;
  float ep;
  float pcm1;
  float pcm2;
  float pcm3;
  float phi;
  float pmax;
  float rr;
  float tt;

  hijels_save()
      : am1(fem::float0),
        am2(fem::float0),
        amm(fem::float0),
        bb(fem::float0),
        cc(fem::float0),
        db(fem::double0),
        dbp(fem::double0),
        dbx(fem::double0),
        dby(fem::double0),
        dbz(fem::double0),
        dga(fem::double0),
        dgabp(fem::double0),
        dp1(fem::double0),
        dp2(fem::double0),
        dp3(fem::double0),
        dp4(fem::double0),
        ecm(fem::float0),
        els(fem::float0),
        els0(fem::float0),
        ep(fem::float0),
        pcm1(fem::float0),
        pcm2(fem::float0),
        pcm3(fem::float0),
        phi(fem::float0),
        pmax(fem::float0),
        rr(fem::float0),
        tt(fem::float0) {}
};

/// C
/// C*******************************************************************
/// CThis subroutine performs elastic scattering between two nucleons
/// C
/// C*******************************************************************
void hijels(common& cmn, arr_ref<float> psc1, arr_ref<float> psc2) {
  FEM_CMN_SVE(hijels);
  psc1(dimension(5));
  psc2(dimension(5));
  common_write write(cmn);
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  int& nseed = cmn.nseed;
  ///
  float& am1 = sve.am1;
  float& am2 = sve.am2;
  float& amm = sve.amm;
  float& bb = sve.bb;
  float& cc = sve.cc;
  double& db = sve.db;
  double& dbp = sve.dbp;
  double& dbx = sve.dbx;
  double& dby = sve.dby;
  double& dbz = sve.dbz;
  double& dga = sve.dga;
  double& dgabp = sve.dgabp;
  double& dp1 = sve.dp1;
  double& dp2 = sve.dp2;
  double& dp3 = sve.dp3;
  double& dp4 = sve.dp4;
  float& ecm = sve.ecm;
  float& els = sve.els;
  float& els0 = sve.els0;
  float& ep = sve.ep;
  float& pcm1 = sve.pcm1;
  float& pcm2 = sve.pcm2;
  float& pcm3 = sve.pcm3;
  float& phi = sve.phi;
  float& pmax = sve.pmax;
  float& rr = sve.rr;
  float& tt = sve.tt;
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /RNDF77/
  /// C
  cc = 1.0f - hint1(12) / hint1(13);
  rr = (1.0f - cc) * hint1(13) / hint1(12) / (1.0f - hipr1(33)) - 1.0f;
  bb = 0.5f * (3.0f + rr + fem::sqrt(9.0f + 10.0f * rr + fem::pow2(rr)));
  ep = fem::sqrt(fem::pow2((psc1(1) - psc2(1))) +
                 fem::pow2((psc1(2) - psc2(2))) +
                 fem::pow2((psc1(3) - psc2(3))));
  if (ep <= 0.1f) {
    return;
  }
  els0 = 98.0f / ep + 52.0f * fem::pow2((1.0f + rr));
  pcm1 = psc1(1) + psc2(1);
  pcm2 = psc1(2) + psc2(2);
  pcm3 = psc1(3) + psc2(3);
  ecm = psc1(4) + psc2(4);
  am1 = fem::pow2(psc1(5));
  am2 = fem::pow2(psc2(5));
  amm = fem::pow2(ecm) - fem::pow2(pcm1) - fem::pow2(pcm2) - fem::pow2(pcm3);
  if (amm <= psc1(5) + psc2(5)) {
    return;
  }
  /// C                ********elastic scattering only when approaching
  /// C                                to each other
  pmax = (fem::pow2(amm) + fem::pow2(am1) + fem::pow2(am2) - 2.0f * amm * am1 -
          2.0f * amm * am2 - 2.0f * am1 * am2) /
         4.0f / amm;
  pmax = fem::abs(pmax);
statement_20:
  tt = ranart(nseed) * fem::min(pmax, 1.5f);
  els = 98.0f * fem::exp(-2.8f * tt) / ep +
        52.0f * fem::exp(-9.2f * tt) *
            fem::pow2((1.0f + rr * fem::exp(-4.6f * (bb - 1.0f) * tt)));
  if (ranart(nseed) > els / els0) {
    goto statement_20;
  }
  phi = 2.0f * hipr1(40) * ranart(nseed);
  /// C
  dbx = fem::dble(pcm1 / ecm);
  dby = fem::dble(pcm2 / ecm);
  dbz = fem::dble(pcm3 / ecm);
  db = fem::dsqrt(fem::pow2(dbx) + fem::pow2(dby) + fem::pow2(dbz));
  if (db > 0.99999999e0) {
    dbx = dbx * (0.99999999e0 / db);
    dby = dby * (0.99999999e0 / db);
    dbz = dbz * (0.99999999e0 / db);
    db = 0.99999999e0;
    write(6, star), " (HIJELS) boost vector too large";
    /// C                ********Rescale boost vector if too close to unity.
  }
  dga = 1e0 / fem::sqrt(1e0 - fem::pow2(db));
  /// C
  dp1 = fem::dble(fem::sqrt(tt) * fem::sin(phi));
  dp2 = fem::dble(fem::sqrt(tt) * fem::cos(phi));
  dp3 = fem::dble(fem::sqrt(pmax - tt));
  dp4 = fem::dble(fem::sqrt(pmax + am1));
  dbp = dbx * dp1 + dby * dp2 + dbz * dp3;
  dgabp = dga * (dga * dbp / (1e0 + dga) + dp4);
  psc1(1) = fem::sngl(dp1 + dgabp * dbx);
  psc1(2) = fem::sngl(dp2 + dgabp * dby);
  psc1(3) = fem::sngl(dp3 + dgabp * dbz);
  psc1(4) = fem::sngl(dga * (dp4 + dbp));
  /// C
  dp1 = -fem::dble(fem::sqrt(tt) * fem::sin(phi));
  dp2 = -fem::dble(fem::sqrt(tt) * fem::cos(phi));
  dp3 = -fem::dble(fem::sqrt(pmax - tt));
  dp4 = fem::dble(fem::sqrt(pmax + am2));
  dbp = dbx * dp1 + dby * dp2 + dbz * dp3;
  dgabp = dga * (dga * dbp / (1e0 + dga) + dp4);
  psc2(1) = fem::sngl(dp1 + dgabp * dbx);
  psc2(2) = fem::sngl(dp2 + dgabp * dby);
  psc2(3) = fem::sngl(dp3 + dgabp * dbz);
  psc2(4) = fem::sngl(dga * (dp4 + dbp));
}

typedef float (*bk_function_pointer)(common&, float const&);

float bk(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// Cc      SAVE /BESEL/
  return_value = fem::exp(-x) *
                 fem::pow((fem::pow2(x) - fem::pow2(cmn.x4)), 2.50f) / 15.0f;
  return return_value;
}

struct gauss2_save {
  float aa;
  float bb;
  float c1;
  float c2;
  float identifier_const;
  float delta;
  int i;
  float s16;
  float s8;
  float u;
  arr<float> w;
  arr<float> x;
  float y;

  gauss2_save()
      : aa(fem::float0),
        bb(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        identifier_const(fem::float0),
        delta(fem::float0),
        i(fem::int0),
        s16(fem::float0),
        s8(fem::float0),
        u(fem::float0),
        w(dimension(12), fem::fill0),
        x(dimension(12), fem::fill0),
        y(fem::float0) {}
};

float gauss2(common& cmn, bk_function_pointer f, float const& a, float const& b,
             float const& eps) {
  float return_value = fem::float0;
  FEM_CMN_SVE(gauss2);
  common_write write(cmn);
  float& aa = sve.aa;
  float& bb = sve.bb;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& identifier_const = sve.identifier_const;
  float& delta = sve.delta;
  int& i = sve.i;
  float& s16 = sve.s16;
  float& s8 = sve.s8;
  float& u = sve.u;
  arr_ref<float> w(sve.w, dimension(12));
  arr_ref<float> x(sve.x, dimension(12));
  float& y = sve.y;
  if (is_called_first_time) {
    identifier_const = 1.0e-12f;
    {
      static const float values[] = {
          0.1012285f, .2223810f, .3137067f, .3623838f, .0271525f, .0622535f,
          0.0951585f, .1246290f, .1495960f, .1691565f, .1826034f, .1894506f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), w;
    }
    {
      static const float values[] = {
          0.9602899f, .7966665f, .5255324f, .1834346f, .9894009f, .9445750f,
          0.8656312f, .7554044f, .6178762f, .4580168f, .2816036f, .0950125f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), x;
    }
  }
  /// C
  delta = identifier_const * fem::abs(a - b);
  return_value = 0.0f;
  aa = a;
statement_5:
  y = b - aa;
  if (fem::abs(y) <= delta) {
    return return_value;
  }
statement_2:
  bb = aa + y;
  c1 = 0.5f * (aa + bb);
  c2 = c1 - aa;
  s8 = 0.0f;
  s16 = 0.0f;
  FEM_DO_SAFE(i, 1, 4) {
    u = x(i) * c2;
    s8 += w(i) * (f(cmn, c1 + u) + f(cmn, c1 - u));
  }
  FEM_DO_SAFE(i, 5, 12) {
    u = x(i) * c2;
    s16 += w(i) * (f(cmn, c1 + u) + f(cmn, c1 - u));
  }
  s8 = s8 * c2;
  s16 = s16 * c2;
  if (fem::abs(s16 - s8) > eps * (1.f + fem::abs(s16))) {
    goto statement_4;
  }
  return_value += s16;
  aa = bb;
  goto statement_5;
statement_4:
  y = 0.5f * y;
  if (fem::abs(y) > delta) {
    goto statement_2;
  }
  write(6, "(1x,'GAUSS2....TOO HIGH ACURACY REQUIRED')");
  return_value = 0.0f;
  return return_value;
}

float omg0(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  /// COMMON besel
  float& x4 = cmn.x4;
  ///
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /BESEL/
  x4 = hipr1(32) * fem::sqrt(x);
  return_value =
      fem::pow2(hipr1(32)) * gauss2(cmn, bk, x4, x4 + 20.0f, 0.01f) / 96.0f;
  return return_value;
}

struct romg_save {
  arr<float> fr;
  int i;
  int i0;
  int ix;
  float xr;

  romg_save()
      : fr(dim1(0, 1000), fem::fill0),
        i(fem::int0),
        i0(fem::int0),
        ix(fem::int0),
        xr(fem::float0) {}
};

float romg(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(romg);
  arr_ref<float> fr(sve.fr, dim1(0, 1000));
  int& i = sve.i;
  int& i0 = sve.i0;
  int& ix = sve.ix;
  float& xr = sve.xr;
  if (is_called_first_time) {
    i0 = 0;
  }
  /// C                ********This gives the eikonal function from a table
  /// C                        calculated in the first call
  /// Clin-10/29/02 unsaved FR causes wrong values for ROMG with f77 compiler:
  /// Cc        SAVE FR
  /// C
  if (i0 != 0) {
    goto statement_100;
  }
  FEM_DO_SAFE(i, 1, 1001) {
    xr = (i - 1) * 0.01f;
    fr(i - 1) = omg0(cmn, xr);
  }
statement_100:
  i0 = 1;
  if (x >= 10.0f) {
    return_value = 0.0f;
    return return_value;
  }
  ix = fem::fint(x * 100);
  return_value =
      (fr(ix) * ((ix + 1) * 0.01f - x) + fr(ix + 1) * (x - ix * 0.01f)) / 0.01f;
  return return_value;
}

struct hijcsc_save {
  fem::variant_bindings hstrng_bindings;
  float bb;
  float bx;
  float by;
  float bz;
  float dis;
  float dpp1;
  float dpp2;
  float dpt1;
  float dpt2;
  float dx;
  float dy;
  float dz;
  float gs;
  float gs0;
  int i;
  int k;
  float pabs;
  arr<float> psc1;
  arr<float> psc2;
  float r2;

  hijcsc_save()
      : bb(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        bz(fem::float0),
        dis(fem::float0),
        dpp1(fem::float0),
        dpp2(fem::float0),
        dpt1(fem::float0),
        dpt2(fem::float0),
        dx(fem::float0),
        dy(fem::float0),
        dz(fem::float0),
        gs(fem::float0),
        gs0(fem::float0),
        i(fem::int0),
        k(fem::int0),
        pabs(fem::float0),
        psc1(dimension(5), fem::fill0),
        psc2(dimension(5), fem::fill0),
        r2(fem::float0) {}
};

/// C
/// C*******************************************************************
/// C        This subroutine performs elastic scatterings and possible
/// C        elastic cascading within their own nuclei
/// C*******************************************************************
void hijcsc(common& cmn, int const& jp, int const& jt) {
  FEM_CMN_SVE(hijcsc);
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  int& nseed = cmn.nseed;
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  float& bb = sve.bb;
  float& bx = sve.bx;
  float& by = sve.by;
  float& bz = sve.bz;
  float& dis = sve.dis;
  float& dpp1 = sve.dpp1;
  float& dpp2 = sve.dpp2;
  float& dpt1 = sve.dpt1;
  float& dpt2 = sve.dpt2;
  float& dx = sve.dx;
  float& dy = sve.dy;
  float& dz = sve.dz;
  float& gs = sve.gs;
  float& gs0 = sve.gs0;
  int& i = sve.i;
  int& k = sve.k;
  float& pabs = sve.pabs;
  arr_ref<float> psc1(sve.psc1, dimension(5));
  arr_ref<float> psc2(sve.psc2, dimension(5));
  float& r2 = sve.r2;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_ref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_ref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /RNDF77/
  /// Cc      SAVE /HSTRNG/
  if (jp == 0 || jt == 0) {
    goto statement_25;
  }
  FEM_DO_SAFE(i, 1, 5) {
    psc1(i) = pp(jp, i);
    psc2(i) = pt(jt, i);
  }
  hijels(cmn, psc1, psc2);
  dpp1 = psc1(1) - pp(jp, 1);
  dpp2 = psc1(2) - pp(jp, 2);
  dpt1 = psc2(1) - pt(jt, 1);
  dpt2 = psc2(2) - pt(jt, 2);
  pp(jp, 6) += dpp1 / 2.0f;
  pp(jp, 7) += dpp2 / 2.0f;
  pp(jp, 8) += dpp1 / 2.0f;
  pp(jp, 9) += dpp2 / 2.0f;
  pt(jt, 6) += dpt1 / 2.0f;
  pt(jt, 7) += dpt2 / 2.0f;
  pt(jt, 8) += dpt1 / 2.0f;
  pt(jt, 9) += dpt2 / 2.0f;
  FEM_DO_SAFE(i, 1, 4) {
    pp(jp, i) = psc1(i);
    pt(jt, i) = psc2(i);
  }
  nfp(jp, 5) = fem::max(1, nfp(jp, 5));
  nft(jt, 5) = fem::max(1, nft(jt, 5));
  /// C                ********Perform elastic scattering between JP and JT
  return;
/// C                ********The following is for possible elastic cascade
/// C
statement_25:
  if (jp == 0) {
    goto statement_45;
  }
  pabs = fem::sqrt(fem::pow2(pp(jp, 1)) + fem::pow2(pp(jp, 2)) +
                   fem::pow2(pp(jp, 3)));
  bx = pp(jp, 1) / pabs;
  by = pp(jp, 2) / pabs;
  bz = pp(jp, 3) / pabs;
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    if (i == jp) {
      goto statement_40;
    }
    dx = yp(1, i) - yp(1, jp);
    dy = yp(2, i) - yp(2, jp);
    dz = yp(3, i) - yp(3, jp);
    dis = dx * bx + dy * by + dz * bz;
    if (dis <= 0) {
      goto statement_40;
    }
    bb = fem::pow2(dx) + fem::pow2(dy) + fem::pow2(dz) - fem::pow2(dis);
    r2 = bb * hipr1(40) / hipr1(31) / 0.1f;
    /// C                ********mb=0.1*fm, YP is in fm,HIPR1(31) is in mb
    gs = 1.0f - fem::pow2(fem::exp(-(hipr1(30) + hint1(11)) / hipr1(31) / 2.0f *
                                   romg(cmn, r2)));
    gs0 = 1.0f - fem::pow2(fem::exp(-(hipr1(30) + hint1(11)) / hipr1(31) /
                                    2.0f * romg(cmn, 0.0f)));
    if (ranart(nseed) > gs / gs0) {
      goto statement_40;
    }
    FEM_DO_SAFE(k, 1, 5) {
      psc1(k) = pp(jp, k);
      psc2(k) = pp(i, k);
    }
    hijels(cmn, psc1, psc2);
    dpp1 = psc1(1) - pp(jp, 1);
    dpp2 = psc1(2) - pp(jp, 2);
    dpt1 = psc2(1) - pp(i, 1);
    dpt2 = psc2(2) - pp(i, 2);
    pp(jp, 6) += dpp1 / 2.0f;
    pp(jp, 7) += dpp2 / 2.0f;
    pp(jp, 8) += dpp1 / 2.0f;
    pp(jp, 9) += dpp2 / 2.0f;
    pp(i, 6) += dpt1 / 2.0f;
    pp(i, 7) += dpt2 / 2.0f;
    pp(i, 8) += dpt1 / 2.0f;
    pp(i, 9) += dpt2 / 2.0f;
    FEM_DO_SAFE(k, 1, 5) {
      pp(jp, k) = psc1(k);
      pp(i, k) = psc2(k);
    }
    nfp(i, 5) = fem::max(1, nfp(i, 5));
    goto statement_45;
  statement_40:;
  }
statement_45:
  if (jt == 0) {
    goto statement_80;
  }
  /// Clin 50        PABS=SQRT(PT(JT,1)**2+PT(JT,2)**2+PT(JT,3)**2)
  pabs = fem::sqrt(fem::pow2(pt(jt, 1)) + fem::pow2(pt(jt, 2)) +
                   fem::pow2(pt(jt, 3)));
  bx = pt(jt, 1) / pabs;
  by = pt(jt, 2) / pabs;
  bz = pt(jt, 3) / pabs;
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    if (i == jt) {
      goto statement_70;
    }
    dx = yt(1, i) - yt(1, jt);
    dy = yt(2, i) - yt(2, jt);
    dz = yt(3, i) - yt(3, jt);
    dis = dx * bx + dy * by + dz * bz;
    if (dis <= 0) {
      goto statement_70;
    }
    bb = fem::pow2(dx) + fem::pow2(dy) + fem::pow2(dz) - fem::pow2(dis);
    r2 = bb * hipr1(40) / hipr1(31) / 0.1f;
    /// C                ********mb=0.1*fm, YP is in fm,HIPR1(31) is in mb
    gs = fem::pow2((1.0f - fem::exp(-(hipr1(30) + hint1(11)) / hipr1(31) /
                                    2.0f * romg(cmn, r2))));
    gs0 = fem::pow2((1.0f - fem::exp(-(hipr1(30) + hint1(11)) / hipr1(31) /
                                     2.0f * romg(cmn, 0.0f))));
    if (ranart(nseed) > gs / gs0) {
      goto statement_70;
    }
    FEM_DO_SAFE(k, 1, 5) {
      psc1(k) = pt(jt, k);
      psc2(k) = pt(i, k);
    }
    hijels(cmn, psc1, psc2);
    dpp1 = psc1(1) - pt(jt, 1);
    dpp2 = psc1(2) - pt(jt, 2);
    dpt1 = psc2(1) - pt(i, 1);
    dpt2 = psc2(2) - pt(i, 2);
    pt(jt, 6) += dpp1 / 2.0f;
    pt(jt, 7) += dpp2 / 2.0f;
    pt(jt, 8) += dpp1 / 2.0f;
    pt(jt, 9) += dpp2 / 2.0f;
    pt(i, 6) += dpt1 / 2.0f;
    pt(i, 7) += dpt2 / 2.0f;
    pt(i, 8) += dpt1 / 2.0f;
    pt(i, 9) += dpt2 / 2.0f;
    FEM_DO_SAFE(k, 1, 5) {
      pt(jt, k) = psc1(k);
      pt(i, k) = psc2(k);
    }
    nft(i, 5) = fem::max(1, nft(i, 5));
    goto statement_80;
  statement_70:;
  }
statement_80:;
}

struct hirnd2_save {
  int j;
  int jl;
  int jm;
  int jmax;
  int jmin;
  int ju;
  float rx;

  hirnd2_save()
      : j(fem::int0),
        jl(fem::int0),
        jm(fem::int0),
        jmax(fem::int0),
        jmin(fem::int0),
        ju(fem::int0),
        rx(fem::float0) {}
};

/// C
/// C        This generate random number between XMIN and XMAX
float hirnd2(common& cmn, int const& i, float& xmin, float& xmax) {
  float return_value = fem::float0;
  FEM_CMN_SVE(hirnd2);
  arr_cref<float, 2> rr(cmn.rr, dimension(10, 201));
  arr_cref<float, 2> xx(cmn.xx, dimension(10, 201));
  ///
  int& j = sve.j;
  int& jl = sve.jl;
  int& jm = sve.jm;
  int& jmax = sve.jmax;
  int& jmin = sve.jmin;
  int& ju = sve.ju;
  float& rx = sve.rx;
  /// Cc      SAVE /HIJHB/
  /// Cc      SAVE /RNDF77/
  if (xmin < xx(i, 1)) {
    xmin = xx(i, 1);
  }
  if (xmax > xx(i, 201)) {
    xmax = xx(i, 201);
  }
  jmin = 1 + fem::fint(200 * (xmin - xx(i, 1)) / (xx(i, 201) - xx(i, 1)));
  jmax = 1 + fem::fint(200 * (xmax - xx(i, 1)) / (xx(i, 201) - xx(i, 1)));
  rx = rr(i, jmin) + (rr(i, jmax) - rr(i, jmin)) * ranart(cmn.nseed);
  jl = 0;
  ju = 202;
statement_10:
  if (ju - jl > 1) {
    jm = (ju + jl) / 2;
    if ((rr(i, 201) > rr(i, 1)) == (rx > rr(i, jm))) {
      jl = jm;
    } else {
      ju = jm;
    }
    goto statement_10;
  }
  j = jl;
  if (j < 1) {
    j = 1;
  }
  if (j >= 201) {
    j = 200;
  }
  return_value = (xx(i, j) + xx(i, j + 1)) / 2.0f;
  return return_value;
}

struct hijsft_save {
  fem::variant_bindings hstrng_bindings;
  float ampd;
  float ampx;
  float amq;
  float amtd;
  float amtx;
  float amx;
  float bb;
  float bb1;
  float bb2;
  float bx;
  float by;
  float cc;
  float cthep;
  float cthet;
  float d1;
  float d2;
  float dd;
  float dd1;
  float dd2;
  float dd3;
  float dd4;
  float dp1;
  float dp2;
  float dpd;
  float dpe1;
  float dpe2;
  float dpkc11;
  float dpkc12;
  float dpkc21;
  float dpkc22;
  float dpm0;
  float dpn;
  float dpx;
  float dpx1;
  float dpx2;
  float dpy1;
  float dpy2;
  float dpz1;
  float dpz2;
  float dtd;
  float dtm0;
  float dtn;
  float dtx;
  float epm;
  float epmprm;
  float epp;
  float eppprm;
  float etm;
  float etmprm;
  float etp;
  float etpprm;
  int isng;
  int jsb;
  int kcdip;
  int kcdit;
  int miss;
  int miss4;
  int nfp3;
  int nfp5;
  int nft3;
  int nft5;
  int nsb;
  float phi;
  float phi0;
  float phi1;
  float phi2;
  float pkc;
  float pkc1;
  float pkc11;
  float pkc12;
  float pkc2;
  float pkc21;
  float pkc22;
  float pkcmx;
  float ppjet;
  float psb;
  float ptjet;
  float ptp02;
  float ptt02;
  float r1;
  float r2;
  float sdd;
  float snn;
  float spdtn;
  float spdtx;
  float spntd;
  float spntx;
  float spxtd;
  float spxtn;
  float swptd;
  float swptn;
  float swptx;
  float sxx;
  float x1;
  float x2;
  float xmax;
  float xmax1;
  float xmax2;
  float xmaxhi;
  float xmin;
  float xmin1;
  float xmin2;
  float xminhi;
  float xp0;
  float xt0;
  float xx1;
  float xx2;
  float xxp;
  float xxt;
  float yp0;
  float yt0;

  hijsft_save()
      : ampd(fem::float0),
        ampx(fem::float0),
        amq(fem::float0),
        amtd(fem::float0),
        amtx(fem::float0),
        amx(fem::float0),
        bb(fem::float0),
        bb1(fem::float0),
        bb2(fem::float0),
        bx(fem::float0),
        by(fem::float0),
        cc(fem::float0),
        cthep(fem::float0),
        cthet(fem::float0),
        d1(fem::float0),
        d2(fem::float0),
        dd(fem::float0),
        dd1(fem::float0),
        dd2(fem::float0),
        dd3(fem::float0),
        dd4(fem::float0),
        dp1(fem::float0),
        dp2(fem::float0),
        dpd(fem::float0),
        dpe1(fem::float0),
        dpe2(fem::float0),
        dpkc11(fem::float0),
        dpkc12(fem::float0),
        dpkc21(fem::float0),
        dpkc22(fem::float0),
        dpm0(fem::float0),
        dpn(fem::float0),
        dpx(fem::float0),
        dpx1(fem::float0),
        dpx2(fem::float0),
        dpy1(fem::float0),
        dpy2(fem::float0),
        dpz1(fem::float0),
        dpz2(fem::float0),
        dtd(fem::float0),
        dtm0(fem::float0),
        dtn(fem::float0),
        dtx(fem::float0),
        epm(fem::float0),
        epmprm(fem::float0),
        epp(fem::float0),
        eppprm(fem::float0),
        etm(fem::float0),
        etmprm(fem::float0),
        etp(fem::float0),
        etpprm(fem::float0),
        isng(fem::int0),
        jsb(fem::int0),
        kcdip(fem::int0),
        kcdit(fem::int0),
        miss(fem::int0),
        miss4(fem::int0),
        nfp3(fem::int0),
        nfp5(fem::int0),
        nft3(fem::int0),
        nft5(fem::int0),
        nsb(fem::int0),
        phi(fem::float0),
        phi0(fem::float0),
        phi1(fem::float0),
        phi2(fem::float0),
        pkc(fem::float0),
        pkc1(fem::float0),
        pkc11(fem::float0),
        pkc12(fem::float0),
        pkc2(fem::float0),
        pkc21(fem::float0),
        pkc22(fem::float0),
        pkcmx(fem::float0),
        ppjet(fem::float0),
        psb(fem::float0),
        ptjet(fem::float0),
        ptp02(fem::float0),
        ptt02(fem::float0),
        r1(fem::float0),
        r2(fem::float0),
        sdd(fem::float0),
        snn(fem::float0),
        spdtn(fem::float0),
        spdtx(fem::float0),
        spntd(fem::float0),
        spntx(fem::float0),
        spxtd(fem::float0),
        spxtn(fem::float0),
        swptd(fem::float0),
        swptn(fem::float0),
        swptx(fem::float0),
        sxx(fem::float0),
        x1(fem::float0),
        x2(fem::float0),
        xmax(fem::float0),
        xmax1(fem::float0),
        xmax2(fem::float0),
        xmaxhi(fem::float0),
        xmin(fem::float0),
        xmin1(fem::float0),
        xmin2(fem::float0),
        xminhi(fem::float0),
        xp0(fem::float0),
        xt0(fem::float0),
        xx1(fem::float0),
        xx2(fem::float0),
        xxp(fem::float0),
        xxt(fem::float0),
        yp0(fem::float0),
        yt0(fem::float0) {}
};

/// C
/// C*******************************************************************
/// C                                                                      *
/// C                Subroutine HIJSFT                                   *
/// C                                                                   *
/// C  Scatter two excited strings, JP from proj and JT from target    *
/// C*******************************************************************
void hijsft(common& cmn, int const& jp, int const& jt, int const& jout,
            int& ierror) {
  FEM_CMN_SVE(hijsft);
  common_write write(cmn);
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  arr_ref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_cref<float> hidat(cmn.hidat, dimension(10));
  int& nseed = cmn.nseed;
  arr_ref<int> npj(cmn.npj, dimension(300));
  arr_ref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_ref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_ref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_ref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_ref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_ref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_ref<int> ntj(cmn.ntj, dimension(300));
  arr_ref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_ref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_ref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_ref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_ref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_ref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  float& ampn = cmn.ampn;
  float& amtn = cmn.amtn;
  float& amp0 = cmn.amp0;
  float& amt0 = cmn.amt0;
  int& nfdp = cmn.nfdp;
  int& nfdt = cmn.nfdt;
  float& wp = cmn.wp;
  float& wm = cmn.wm;
  float& sw = cmn.sw;
  float& dpkc1 = cmn.dpkc1;
  float& dpkc2 = cmn.dpkc2;
  float& pp11 = cmn.pp11;
  float& pp12 = cmn.pp12;
  float& pt11 = cmn.pt11;
  float& pt12 = cmn.pt12;
  float& ptp2 = cmn.ptp2;
  float& ptt2 = cmn.ptt2;
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  float& ampd = sve.ampd;
  float& ampx = sve.ampx;
  float& amq = sve.amq;
  float& amtd = sve.amtd;
  float& amtx = sve.amtx;
  float& amx = sve.amx;
  float& bb = sve.bb;
  float& bb1 = sve.bb1;
  float& bb2 = sve.bb2;
  float& bx = sve.bx;
  float& by = sve.by;
  float& cc = sve.cc;
  float& cthep = sve.cthep;
  float& cthet = sve.cthet;
  float& d1 = sve.d1;
  float& d2 = sve.d2;
  float& dd = sve.dd;
  float& dd1 = sve.dd1;
  float& dd2 = sve.dd2;
  float& dd3 = sve.dd3;
  float& dd4 = sve.dd4;
  float& dp1 = sve.dp1;
  float& dp2 = sve.dp2;
  float& dpd = sve.dpd;
  float& dpe1 = sve.dpe1;
  float& dpe2 = sve.dpe2;
  float& dpkc11 = sve.dpkc11;
  float& dpkc12 = sve.dpkc12;
  float& dpkc21 = sve.dpkc21;
  float& dpkc22 = sve.dpkc22;
  float& dpm0 = sve.dpm0;
  float& dpn = sve.dpn;
  float& dpx = sve.dpx;
  float& dpx1 = sve.dpx1;
  float& dpx2 = sve.dpx2;
  float& dpy1 = sve.dpy1;
  float& dpy2 = sve.dpy2;
  float& dpz1 = sve.dpz1;
  float& dpz2 = sve.dpz2;
  float& dtd = sve.dtd;
  float& dtm0 = sve.dtm0;
  float& dtn = sve.dtn;
  float& dtx = sve.dtx;
  float& epm = sve.epm;
  float& epmprm = sve.epmprm;
  float& epp = sve.epp;
  float& eppprm = sve.eppprm;
  float& etm = sve.etm;
  float& etmprm = sve.etmprm;
  float& etp = sve.etp;
  float& etpprm = sve.etpprm;
  int& isng = sve.isng;
  int& jsb = sve.jsb;
  int& kcdip = sve.kcdip;
  int& kcdit = sve.kcdit;
  int& miss = sve.miss;
  int& miss4 = sve.miss4;
  int& nfp3 = sve.nfp3;
  int& nfp5 = sve.nfp5;
  int& nft3 = sve.nft3;
  int& nft5 = sve.nft5;
  int& nsb = sve.nsb;
  float& phi = sve.phi;
  float& phi0 = sve.phi0;
  float& phi1 = sve.phi1;
  float& phi2 = sve.phi2;
  float& pkc = sve.pkc;
  float& pkc1 = sve.pkc1;
  float& pkc11 = sve.pkc11;
  float& pkc12 = sve.pkc12;
  float& pkc2 = sve.pkc2;
  float& pkc21 = sve.pkc21;
  float& pkc22 = sve.pkc22;
  float& pkcmx = sve.pkcmx;
  float& ppjet = sve.ppjet;
  float& psb = sve.psb;
  float& ptjet = sve.ptjet;
  float& ptp02 = sve.ptp02;
  float& ptt02 = sve.ptt02;
  float& r1 = sve.r1;
  float& r2 = sve.r2;
  float& sdd = sve.sdd;
  float& snn = sve.snn;
  float& spdtn = sve.spdtn;
  float& spdtx = sve.spdtx;
  float& spntd = sve.spntd;
  float& spntx = sve.spntx;
  float& spxtd = sve.spxtd;
  float& spxtn = sve.spxtn;
  float& swptd = sve.swptd;
  float& swptn = sve.swptn;
  float& swptx = sve.swptx;
  float& sxx = sve.sxx;
  float& x1 = sve.x1;
  float& x2 = sve.x2;
  float& xmax = sve.xmax;
  float& xmax1 = sve.xmax1;
  float& xmax2 = sve.xmax2;
  float& xmaxhi = sve.xmaxhi;
  float& xmin = sve.xmin;
  float& xmin1 = sve.xmin1;
  float& xmin2 = sve.xmin2;
  float& xminhi = sve.xminhi;
  float& xp0 = sve.xp0;
  float& xt0 = sve.xt0;
  float& xx1 = sve.xx1;
  float& xx2 = sve.xx2;
  float& xxp = sve.xxp;
  float& xxt = sve.xxt;
  float& yp0 = sve.yp0;
  float& yt0 = sve.yt0;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_ref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_ref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HIJDAT/
  /// Cc      SAVE /RNDF77/
  /// Cc      SAVE /HJJET1/
  /// Clin-4/25/01
  /// C        COMMON/HJJET2/NSG,NJSG(900),IASG(900,3),K1SG(900,100),
  /// C     &                K2SG(900,100),PXSG(900,100),PYSG(900,100),
  /// C     &                PZSG(900,100),PESG(900,100),PMSG(900,100)
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /DPMCM1/
  /// Cc      SAVE /DPMCM2/
  /// C*******************************************************************
  /// C        JOUT-> the number
  /// C        of hard scatterings preceding this soft collision.
  /// C       IHNT2(13)-> 1=
  /// C        double diffrac 2=single diffrac, 3=non-single diffrac.
  /// C*******************************************************************
  ierror = 0;
  cmn.jjp = jp;
  cmn.jjt = jt;
  cmn.ndpm = 0;
  /// C        IOPMAIN=0
  if (jp > ihnt2(1) || jt > ihnt2(3)) {
    return;
  }
  /// C
  epp = pp(jp, 4) + pp(jp, 3);
  epm = pp(jp, 4) - pp(jp, 3);
  etp = pt(jt, 4) + pt(jt, 3);
  etm = pt(jt, 4) - pt(jt, 3);
  /// C
  wp = epp + etp;
  wm = epm + etm;
  sw = wp * wm;
  /// C                ********total W+,W- and center-of-mass energy
  /// C
  if (wp < 0.0f || wm < 0.0f) {
    goto statement_1000;
  }
  /// C
  if (jout == 0) {
    if (epp < 0.0f) {
      goto statement_1000;
    }
    if (epm < 0.0f) {
      goto statement_1000;
    }
    if (etp < 0.0f) {
      goto statement_1000;
    }
    if (etm < 0.0f) {
      goto statement_1000;
    }
    if (epp / (epm + 0.01f) <= etp / (etm + 0.01f)) {
      return;
    }
  }
  /// C                ********For strings which does not follow a jet-prod,
  /// C                        scatter only if Ycm(JP)>Ycm(JT). When jets
  /// C                        are produced just before this collision
  /// C                        this requirement has already be enforced
  /// C                        (see SUBROUTINE HIJHRD)
  ihnt2(11) = jp;
  ihnt2(12) = jt;
  /// C
  miss = 0;
  pkc1 = 0.0f;
  pkc2 = 0.0f;
  pkc11 = 0.0f;
  pkc12 = 0.0f;
  pkc21 = 0.0f;
  pkc22 = 0.0f;
  dpkc11 = 0.0f;
  dpkc12 = 0.0f;
  dpkc21 = 0.0f;
  dpkc22 = 0.0f;
  if (nfp(jp, 10) == 1 || nft(jt, 10) == 1) {
    if (nfp(jp, 10) == 1) {
      phi1 = ulangl(cmn, pp(jp, 10), pp(jp, 11));
      ppjet = fem::sqrt(fem::pow2(pp(jp, 10)) + fem::pow2(pp(jp, 11)));
      pkc1 = ppjet;
      pkc11 = pp(jp, 10);
      pkc12 = pp(jp, 11);
    }
    if (nft(jt, 10) == 1) {
      phi2 = ulangl(cmn, pt(jt, 10), pt(jt, 11));
      ptjet = fem::sqrt(fem::pow2(pt(jt, 10)) + fem::pow2(pt(jt, 11)));
      pkc2 = ptjet;
      pkc21 = pt(jt, 10);
      pkc22 = pt(jt, 11);
    }
    if (ihpr2(4) > 0 && ihnt2(1) > 1 && ihnt2(3) > 1) {
      if (nfp(jp, 10) == 0) {
        phi = -phi2;
      } else if (nft(jt, 10) == 0) {
        phi = phi1;
      } else {
        phi = (phi1 + phi2 - hipr1(40)) / 2.0f;
      }
      bx = hint1(19) * fem::cos(hint1(20));
      by = hint1(19) * fem::sin(hint1(20));
      xp0 = yp(1, jp);
      yp0 = yp(2, jp);
      xt0 = yt(1, jt) + bx;
      yt0 = yt(2, jt) + by;
      r1 = fem::max(1.2f * fem::pow(ihnt2(1), 0.3333333f),
                    fem::sqrt(fem::pow2(xp0) + fem::pow2(yp0)));
      r2 = fem::max(1.2f * fem::pow(ihnt2(3), 0.3333333f),
                    fem::sqrt(fem::pow2((xt0 - bx)) + fem::pow2((yt0 - by))));
      if (fem::abs(fem::cos(phi)) < 1.0e-5f) {
        dd1 = r1;
        dd2 = r1;
        dd3 = fem::abs(by + fem::sqrt(fem::pow2(r2) - fem::pow2((xp0 - bx))) -
                       yp0);
        dd4 = fem::abs(by - fem::sqrt(fem::pow2(r2) - fem::pow2((xp0 - bx))) -
                       yp0);
        goto statement_5;
      }
      bb = 2.0f * fem::sin(phi) * (fem::cos(phi) * yp0 - fem::sin(phi) * xp0);
      cc = (fem::pow2(yp0) - fem::pow2(r1)) * fem::pow2(fem::cos(phi)) +
           xp0 * fem::sin(phi) *
               (xp0 * fem::sin(phi) - 2.0f * yp0 * fem::cos(phi));
      dd = fem::pow2(bb) - 4.0f * cc;
      if (dd < 0.0f) {
        goto statement_10;
      }
      xx1 = (-bb + fem::sqrt(dd)) / 2.0f;
      xx2 = (-bb - fem::sqrt(dd)) / 2.0f;
      dd1 = fem::abs((xx1 - xp0) / fem::cos(phi));
      dd2 = fem::abs((xx2 - xp0) / fem::cos(phi));
      /// C
      bb = 2.0f * fem::sin(phi) *
               (fem::cos(phi) * (yt0 - by) - fem::sin(phi) * xt0) -
           2.0f * bx;
      cc = (fem::pow2(bx) + fem::pow2((yt0 - by)) - fem::pow2(r2)) *
               fem::pow2(fem::cos(phi)) +
           xt0 * fem::sin(phi) *
               (xt0 * fem::sin(phi) - 2.0f * fem::cos(phi) * (yt0 - by)) -
           2.0f * bx * fem::sin(phi) *
               (fem::cos(phi) * (yt0 - by) - fem::sin(phi) * xt0);
      dd = fem::pow2(bb) - 4.0f * cc;
      if (dd < 0.0f) {
        goto statement_10;
      }
      xx1 = (-bb + fem::sqrt(dd)) / 2.0f;
      xx2 = (-bb - fem::sqrt(dd)) / 2.0f;
      dd3 = fem::abs((xx1 - xt0) / fem::cos(phi));
      dd4 = fem::abs((xx2 - xt0) / fem::cos(phi));
    /// C
    statement_5:
      dd1 = fem::min(dd1, dd3);
      dd2 = fem::min(dd2, dd4);
      if (dd1 < hipr1(13)) {
        dd1 = 0.0f;
      }
      if (dd2 < hipr1(13)) {
        dd2 = 0.0f;
      }
      if (nfp(jp, 10) == 1 && ppjet > hipr1(11)) {
        dp1 = dd1 * hipr1(14) / 2.0f;
        dp1 = fem::min(dp1, ppjet - hipr1(11));
        pkc1 = ppjet - dp1;
        dpx1 = fem::cos(phi1) * dp1;
        dpy1 = fem::sin(phi1) * dp1;
        pkc11 = pp(jp, 10) - dpx1;
        pkc12 = pp(jp, 11) - dpy1;
        if (dp1 > 0.0f) {
          cthep =
              pp(jp, 12) / fem::sqrt(fem::pow2(pp(jp, 12)) + fem::pow2(ppjet));
          dpz1 = dp1 * cthep / fem::sqrt(1.0f - fem::pow2(cthep));
          dpe1 = fem::sqrt(fem::pow2(dpx1) + fem::pow2(dpy1) + fem::pow2(dpz1));
          eppprm = pp(jp, 4) + pp(jp, 3) - dpe1 - dpz1;
          epmprm = pp(jp, 4) - pp(jp, 3) - dpe1 + dpz1;
          if (eppprm <= 0.0f || epmprm <= 0.0f) {
            goto statement_15;
          }
          epp = eppprm;
          epm = epmprm;
          pp(jp, 10) = pkc11;
          pp(jp, 11) = pkc12;
          npj(jp)++;
          kfpj(jp, npj(jp)) = 21;
          pjpx(jp, npj(jp)) = dpx1;
          pjpy(jp, npj(jp)) = dpy1;
          pjpz(jp, npj(jp)) = dpz1;
          pjpe(jp, npj(jp)) = dpe1;
          pjpm(jp, npj(jp)) = 0.0f;
          pp(jp, 3) = pp(jp, 3) - dpz1;
          pp(jp, 4) = pp(jp, 4) - dpe1;
        }
      }
    statement_15:
      if (nft(jt, 10) == 1 && ptjet > hipr1(11)) {
        dp2 = dd2 * hipr1(14) / 2.0f;
        dp2 = fem::min(dp2, ptjet - hipr1(11));
        pkc2 = ptjet - dp2;
        dpx2 = fem::cos(phi2) * dp2;
        dpy2 = fem::sin(phi2) * dp2;
        pkc21 = pt(jt, 10) - dpx2;
        pkc22 = pt(jt, 11) - dpy2;
        if (dp2 > 0.0f) {
          cthet =
              pt(jt, 12) / fem::sqrt(fem::pow2(pt(jt, 12)) + fem::pow2(ptjet));
          dpz2 = dp2 * cthet / fem::sqrt(1.0f - fem::pow2(cthet));
          dpe2 = fem::sqrt(fem::pow2(dpx2) + fem::pow2(dpy2) + fem::pow2(dpz2));
          etpprm = pt(jt, 4) + pt(jt, 3) - dpe2 - dpz2;
          etmprm = pt(jt, 4) - pt(jt, 3) - dpe2 + dpz2;
          if (etpprm <= 0.0f || etmprm <= 0.0f) {
            goto statement_16;
          }
          etp = etpprm;
          etm = etmprm;
          pt(jt, 10) = pkc21;
          pt(jt, 11) = pkc22;
          ntj(jt)++;
          kftj(jt, ntj(jt)) = 21;
          pjtx(jt, ntj(jt)) = dpx2;
          pjty(jt, ntj(jt)) = dpy2;
          pjtz(jt, ntj(jt)) = dpz2;
          pjte(jt, ntj(jt)) = dpe2;
          pjtm(jt, ntj(jt)) = 0.0f;
          pt(jt, 3) = pt(jt, 3) - dpz2;
          pt(jt, 4) = pt(jt, 4) - dpe2;
        }
      }
    statement_16:
      dpkc11 = -(pp(jp, 10) - pkc11) / 2.0f;
      dpkc12 = -(pp(jp, 11) - pkc12) / 2.0f;
      dpkc21 = -(pt(jt, 10) - pkc21) / 2.0f;
      dpkc22 = -(pt(jt, 11) - pkc22) / 2.0f;
      wp = epp + etp;
      wm = epm + etm;
      sw = wp * wm;
    }
  }
/// C                ********If jet is quenched the pt from valence quark
/// C                        hard scattering has to reduced by d*kapa
/// C
statement_10:
  ptp02 = fem::pow2(pp(jp, 1)) + fem::pow2(pp(jp, 2));
  ptt02 = fem::pow2(pt(jt, 1)) + fem::pow2(pt(jt, 2));
  /// C
  amq = fem::max(pp(jp, 14) + pp(jp, 15), pt(jt, 14) + pt(jt, 15));
  amx = hipr1(1) + amq;
  /// C                ********consider mass cut-off for strings which
  /// C                        must also include quark's mass
  amp0 = amx;
  dpm0 = amx;
  nfdp = 0;
  if (nfp(jp, 5) <= 2 && nfp(jp, 3) != 0) {
    amp0 = ulmass(cmn, nfp(jp, 3));
    nfdp = nfp(jp, 3) + 2 * nfp(jp, 3) / fem::abs(nfp(jp, 3));
    dpm0 = ulmass(cmn, nfdp);
    if (dpm0 <= 0.0f) {
      nfdp = nfdp - 2 * nfdp / fem::abs(nfdp);
      dpm0 = ulmass(cmn, nfdp);
    }
  }
  amt0 = amx;
  dtm0 = amx;
  nfdt = 0;
  if (nft(jt, 5) <= 2 && nft(jt, 3) != 0) {
    amt0 = ulmass(cmn, nft(jt, 3));
    nfdt = nft(jt, 3) + 2 * nft(jt, 3) / fem::abs(nft(jt, 3));
    dtm0 = ulmass(cmn, nfdt);
    if (dtm0 <= 0.0f) {
      nfdt = nfdt - 2 * nfdt / fem::abs(nfdt);
      dtm0 = ulmass(cmn, nfdt);
    }
  }
  /// C
  ampn = fem::sqrt(fem::pow2(amp0) + ptp02);
  amtn = fem::sqrt(fem::pow2(amt0) + ptt02);
  snn = fem::pow2((ampn + amtn)) + 0.001f;
  /// C
  if (sw < snn + 0.001f) {
    goto statement_4000;
  }
  /// C                ********Scatter only if SW>SNN
  /// C*****give some PT kick to the two exited strings******************
  /// Clin 20        SWPTN=4.0*(MAX(AMP0,AMT0)**2+MAX(PTP02,PTT02))
  swptn = 4.0f * (fem::pow2(fem::max(amp0, amt0)) + fem::max(ptp02, ptt02));
  swptd = 4.0f * (fem::pow2(fem::max(dpm0, dtm0)) + fem::max(ptp02, ptt02));
  swptx = 4.0f * (fem::pow2(amx) + fem::max(ptp02, ptt02));
  if (sw <= swptn) {
    pkcmx = 0.0f;
  } else if (sw > swptn && sw <= swptd && npj(jp) == 0 && ntj(jt) == 0) {
    pkcmx = fem::sqrt(sw / 4.0f - fem::pow2(fem::max(amp0, amt0))) -
            fem::sqrt(fem::max(ptp02, ptt02));
  } else if (sw > swptd && sw <= swptx && npj(jp) == 0 && ntj(jt) == 0) {
    pkcmx = fem::sqrt(sw / 4.0f - fem::pow2(fem::max(dpm0, dtm0))) -
            fem::sqrt(fem::max(ptp02, ptt02));
  } else if (sw > swptx) {
    pkcmx = fem::sqrt(sw / 4.0f - fem::pow2(amx)) -
            fem::sqrt(fem::max(ptp02, ptt02));
  }
  /// C                ********maximun PT kick
  /// C*********************************************************
  /// C
  if (nfp(jp, 10) == 1 || nft(jt, 10) == 1) {
    if (pkc1 > pkcmx) {
      pkc1 = pkcmx;
      pkc11 = pkc1 * fem::cos(phi1);
      pkc12 = pkc1 * fem::sin(phi1);
      dpkc11 = -(pp(jp, 10) - pkc11) / 2.0f;
      dpkc12 = -(pp(jp, 11) - pkc12) / 2.0f;
    }
    if (pkc2 > pkcmx) {
      pkc2 = pkcmx;
      pkc21 = pkc2 * fem::cos(phi2);
      pkc22 = pkc2 * fem::sin(phi2);
      dpkc21 = -(pt(jt, 10) - pkc21) / 2.0f;
      dpkc22 = -(pt(jt, 11) - pkc22) / 2.0f;
    }
    dpkc1 = dpkc11 + dpkc21;
    dpkc2 = dpkc12 + dpkc22;
    nfp(jp, 10) = -nfp(jp, 10);
    nft(jt, 10) = -nft(jt, 10);
    goto statement_40;
  }
  /// C                ********If the valence quarks had a hard-collision
  /// C                        the pt kick is the pt from hard-collision.
  isng = 0;
  if (ihpr2(13) != 0 && ranart(nseed) <= hidat(4)) {
    isng = 1;
  }
  if ((nfp(jp, 5) == 3 || nft(jt, 5) == 3) ||
      (npj(jp) != 0 || nfp(jp, 10) != 0) ||
      (ntj(jt) != 0 || nft(jt, 10) != 0)) {
    isng = 0;
  }
  /// C
  /// C               ********decite whether to have single-diffractive
  if (ihpr2(5) == 0) {
    pkc = hipr1(2) *
          fem::sqrt(-fem::alog(
              1.0f - ranart(nseed) * (1.0f - fem::exp(-fem::pow2(pkcmx) /
                                                      fem::pow2(hipr1(2))))));
    goto statement_30;
  }
  /// C
  /// Clin-10/28/02 get rid of argument usage mismatch in HIRND2():
  /// C        PKC=HIRND2(3,0.0,PKCMX**2)
  xminhi = 0.0f;
  xmaxhi = fem::pow2(pkcmx);
  pkc = hirnd2(cmn, 3, xminhi, xmaxhi);
  /// C
  pkc = fem::sqrt(pkc);
  if (pkc > hipr1(20)) {
    pkc = hipr1(2) *
          fem::sqrt(-fem::alog(
              fem::exp(-fem::pow2(hipr1(20)) / fem::pow2(hipr1(2))) -
              ranart(nseed) *
                  (fem::exp(-fem::pow2(hipr1(20)) / fem::pow2(hipr1(2))) -
                   fem::exp(-fem::pow2(pkcmx) / fem::pow2(hipr1(2))))));
  }
  /// C
  if (isng == 1) {
    pkc = 0.65f *
          fem::sqrt(-fem::alog(1.0f - ranart(nseed) *
                                          (1.0f - fem::exp(-fem::pow2(pkcmx) /
                                                           fem::pow2(0.65f)))));
  }
/// C                        ********select PT kick
statement_30:
  phi0 = 2.0f * hipr1(40) * ranart(nseed);
  pkc11 = pkc * fem::sin(phi0);
  pkc12 = pkc * fem::cos(phi0);
  pkc21 = -pkc11;
  pkc22 = -pkc12;
  dpkc1 = 0.0f;
  dpkc2 = 0.0f;
statement_40:
  pp11 = pp(jp, 1) + pkc11 - dpkc1;
  pp12 = pp(jp, 2) + pkc12 - dpkc2;
  pt11 = pt(jt, 1) + pkc21 - dpkc1;
  pt12 = pt(jt, 2) + pkc22 - dpkc2;
  ptp2 = fem::pow2(pp11) + fem::pow2(pp12);
  ptt2 = fem::pow2(pt11) + fem::pow2(pt12);
  /// C
  ampn = fem::sqrt(fem::pow2(amp0) + ptp2);
  amtn = fem::sqrt(fem::pow2(amt0) + ptt2);
  snn = fem::pow2((ampn + amtn)) + 0.001f;
  /// C***************************************
  wp = epp + etp;
  wm = epm + etm;
  sw = wp * wm;
  /// C****************************************
  if (sw < snn) {
    miss++;
    if (miss <= 100) {
      pkc = 0.0f;
      goto statement_30;
    }
    if (ihpr2(10) != 0) {
      write(6, star), "Error occured in Pt kick section of HIJSFT";
    }
    goto statement_4000;
  }
  /// C******************************************************************
  ampd = fem::sqrt(fem::pow2(dpm0) + ptp2);
  amtd = fem::sqrt(fem::pow2(dtm0) + ptt2);
  /// C
  ampx = fem::sqrt(fem::pow2(amx) + ptp2);
  amtx = fem::sqrt(fem::pow2(amx) + ptt2);
  /// C
  dpn = fem::pow2(ampn) / sw;
  dtn = fem::pow2(amtn) / sw;
  dpd = fem::pow2(ampd) / sw;
  dtd = fem::pow2(amtd) / sw;
  dpx = fem::pow2(ampx) / sw;
  dtx = fem::pow2(amtx) / sw;
  /// C
  spntd = fem::pow2((ampn + amtd));
  spntx = fem::pow2((ampn + amtx));
  /// C                        ********CM energy if proj=N,targ=N*
  spdtn = fem::pow2((ampd + amtn));
  spxtn = fem::pow2((ampx + amtn));
  /// C                        ********CM energy if proj=N*,targ=N
  spdtx = fem::pow2((ampd + amtx));
  spxtd = fem::pow2((ampx + amtd));
  sdd = fem::pow2((ampd + amtd));
  sxx = fem::pow2((ampx + amtx));
  /// C
  /// C                ********CM energy if proj=delta, targ=delta
  /// C****************There are many different cases**********
  /// C        IF(IHPR2(15).EQ.1) GO TO 500
  /// C
  /// C                ********to have DPM type soft interactions
  /// C
  /// Clin 45        CONTINUE
  if (sw > sxx + 0.001f) {
    if (isng == 0) {
      d1 = dpx;
      d2 = dtx;
      nfp3 = 0;
      nft3 = 0;
      goto statement_400;
    } else {
      /// C**** 5/30/1998 this is identical to the above statement. Added to
      /// C**** avoid questional branching to block.
      if ((nfp(jp, 5) == 3 && nft(jt, 5) == 3) ||
          (npj(jp) != 0 || nfp(jp, 10) != 0) ||
          (ntj(jt) != 0 || nft(jt, 10) != 0)) {
        d1 = dpx;
        d2 = dtx;
        nfp3 = 0;
        nft3 = 0;
        goto statement_400;
      }
      /// C                ********do not allow excited strings to have
      /// C                        single-diffr
      if (ranart(nseed) > 0.5f ||
          (nft(jt, 5) > 2 || ntj(jt) != 0 || nft(jt, 10) != 0)) {
        d1 = dpn;
        d2 = dtx;
        nfp3 = nfp(jp, 3);
        nft3 = 0;
        goto statement_220;
      } else {
        d1 = dpx;
        d2 = dtn;
        nfp3 = 0;
        nft3 = nft(jt, 3);
        goto statement_240;
      }
      /// C                ********have single diffractive collision
    }
  } else if (sw > fem::max(spdtx, spxtd) + 0.001f && sw <= sxx + 0.001f) {
    if (((npj(jp) == 0 && ntj(jt) == 0 && ranart(nseed) > 0.5f) ||
         (npj(jp) == 0 && ntj(jt) != 0)) &&
        nfp(jp, 5) <= 2) {
      d1 = dpd;
      d2 = dtx;
      nfp3 = nfdp;
      nft3 = 0;
      goto statement_220;
    } else if (ntj(jt) == 0 && nft(jt, 5) <= 2) {
      d1 = dpx;
      d2 = dtd;
      nfp3 = 0;
      nft3 = nfdt;
      goto statement_240;
    }
    goto statement_4000;
  } else if (sw > fem::min(spdtx, spxtd) + 0.001f &&
             sw <= fem::max(spdtx, spxtd) + 0.001f) {
    if (spdtx <= spxtd && npj(jp) == 0 && nfp(jp, 5) <= 2) {
      d1 = dpd;
      d2 = dtx;
      nfp3 = nfdp;
      nft3 = 0;
      goto statement_220;
    } else if (spdtx > spxtd && ntj(jt) == 0 && nft(jt, 5) <= 2) {
      d1 = dpx;
      d2 = dtd;
      nfp3 = 0;
      nft3 = nfdt;
      goto statement_240;
    }
    /// C*** 5/30/1998 added to avoid questional branching to another block
    /// C*** this is identical to the statement following the next ELSE IF
    if (((npj(jp) == 0 && ntj(jt) == 0 && ranart(nseed) > 0.5f) ||
         (npj(jp) == 0 && ntj(jt) != 0)) &&
        nfp(jp, 5) <= 2) {
      d1 = dpn;
      d2 = dtx;
      nfp3 = nfp(jp, 3);
      nft3 = 0;
      goto statement_220;
    } else if (ntj(jt) == 0 && nft(jt, 5) <= 2) {
      d1 = dpx;
      d2 = dtn;
      nfp3 = 0;
      nft3 = nft(jt, 3);
      goto statement_240;
    }
    goto statement_4000;
  } else if (sw > fem::max(spntx, spxtn) + 0.001f &&
             sw <= fem::min(spdtx, spxtd) + 0.001f) {
    if (((npj(jp) == 0 && ntj(jt) == 0 && ranart(nseed) > 0.5f) ||
         (npj(jp) == 0 && ntj(jt) != 0)) &&
        nfp(jp, 5) <= 2) {
      d1 = dpn;
      d2 = dtx;
      nfp3 = nfp(jp, 3);
      nft3 = 0;
      goto statement_220;
    } else if (ntj(jt) == 0 && nft(jt, 5) <= 2) {
      d1 = dpx;
      d2 = dtn;
      nfp3 = 0;
      nft3 = nft(jt, 3);
      goto statement_240;
    }
    goto statement_4000;
  } else if (sw > fem::min(spntx, spxtn) + 0.001f &&
             sw <= fem::max(spntx, spxtn) + 0.001f) {
    if (spntx <= spxtn && npj(jp) == 0 && nfp(jp, 5) <= 2) {
      d1 = dpn;
      d2 = dtx;
      nfp3 = nfp(jp, 3);
      nft3 = 0;
      goto statement_220;
    } else if (spntx > spxtn && ntj(jt) == 0 && nft(jt, 5) <= 2) {
      d1 = dpx;
      d2 = dtn;
      nfp3 = 0;
      nft3 = nft(jt, 3);
      goto statement_240;
    }
    goto statement_4000;
  } else if (sw <= fem::min(spntx, spxtn) + 0.001f &&
             (npj(jp) != 0 || ntj(jt) != 0)) {
    goto statement_4000;
  } else if (sw <= fem::min(spntx, spxtn) + 0.001f && nfp(jp, 5) > 2 &&
             nft(jt, 5) > 2) {
    goto statement_4000;
  } else if (sw > sdd + 0.001f && sw <= fem::min(spntx, spxtn) + 0.001f) {
    d1 = dpd;
    d2 = dtd;
    nfp3 = nfdp;
    nft3 = nfdt;
    goto statement_100;
  } else if (sw > fem::max(spntd, spdtn) + 0.001f && sw <= sdd + 0.001f) {
    if (ranart(nseed) > 0.5f) {
      d1 = dpd;
      d2 = dtn;
      nfp3 = nfdp;
      nft3 = nft(jt, 3);
      goto statement_100;
    } else {
      d1 = dpn;
      d2 = dtd;
      nfp3 = nfp(jp, 3);
      nft3 = nfdt;
      goto statement_100;
    }
  } else if (sw > fem::min(spntd, spdtn) + 0.001f &&
             sw <= fem::max(spntd, spdtn) + 0.001f) {
    if (spntd > spdtn) {
      d1 = dpd;
      d2 = dtn;
      nfp3 = nfdp;
      nft3 = nft(jt, 3);
      goto statement_100;
    } else {
      d1 = dpn;
      d2 = dtd;
      nfp3 = nfp(jp, 3);
      nft3 = nfdt;
      goto statement_100;
    }
  } else if (sw <= fem::min(spntd, spdtn) + 0.001f) {
    d1 = dpn;
    d2 = dtn;
    nfp3 = nfp(jp, 3);
    nft3 = nft(jt, 3);
    goto statement_100;
  }
  write(6, star), " Error in HIJSFT: There is no path to here";
  return;
/// C
/// C***************  elastic scattering ***************
/// C        this is like elastic, both proj and targ mass
/// C        must be fixed
/// C***************************************************
statement_100:
  nfp5 = fem::max(2, nfp(jp, 5));
  nft5 = fem::max(2, nft(jt, 5));
  bb1 = 1.0f + d1 - d2;
  bb2 = 1.0f + d2 - d1;
  if (fem::pow2(bb1) < 4.0f * d1 || fem::pow2(bb2) < 4.0f * d2) {
    miss++;
    if (miss > 100 || pkc == 0.0f) {
      goto statement_3000;
    }
    pkc = pkc * 0.5f;
    goto statement_30;
  }
  if (ranart(nseed) < 0.5f) {
    x1 = (bb1 - fem::sqrt(fem::pow2(bb1) - 4.0f * d1)) / 2.0f;
    x2 = (bb2 - fem::sqrt(fem::pow2(bb2) - 4.0f * d2)) / 2.0f;
  } else {
    x1 = (bb1 + fem::sqrt(fem::pow2(bb1) - 4.0f * d1)) / 2.0f;
    x2 = (bb2 + fem::sqrt(fem::pow2(bb2) - 4.0f * d2)) / 2.0f;
  }
  ihnt2(13) = 2;
  goto statement_600;
/// C
/// C********** Single diffractive ***********************
/// C either proj or targ's mass is fixed
/// C*****************************************************
statement_220:
  nfp5 = fem::max(2, nfp(jp, 5));
  nft5 = 3;
  if (nfp3 == 0) {
    nfp5 = 3;
  }
  bb2 = 1.0f + d2 - d1;
  if (fem::pow2(bb2) < 4.0f * d2) {
    miss++;
    if (miss > 100 || pkc == 0.0f) {
      goto statement_3000;
    }
    pkc = pkc * 0.5f;
    goto statement_30;
  }
  xmin = (bb2 - fem::sqrt(fem::pow2(bb2) - 4.0f * d2)) / 2.0f;
  xmax = (bb2 + fem::sqrt(fem::pow2(bb2) - 4.0f * d2)) / 2.0f;
  miss4 = 0;
statement_222:
  x2 = hirnd2(cmn, 6, xmin, xmax);
  x1 = d1 / (1.0f - x2);
  if (x2 * (1.0f - x1) < (d2 + 1.e-4f / sw)) {
    miss4++;
    if (miss4 <= 1000) {
      goto statement_222;
    }
    goto statement_5000;
  }
  ihnt2(13) = 2;
  goto statement_600;
/// C                        ********Fix proj mass*********
statement_240:
  nfp5 = 3;
  nft5 = fem::max(2, nft(jt, 5));
  if (nft3 == 0) {
    nft5 = 3;
  }
  bb1 = 1.0f + d1 - d2;
  if (fem::pow2(bb1) < 4.0f * d1) {
    miss++;
    if (miss > 100 || pkc == 0.0f) {
      goto statement_3000;
    }
    pkc = pkc * 0.5f;
    goto statement_30;
  }
  xmin = (bb1 - fem::sqrt(fem::pow2(bb1) - 4.0f * d1)) / 2.0f;
  xmax = (bb1 + fem::sqrt(fem::pow2(bb1) - 4.0f * d1)) / 2.0f;
  miss4 = 0;
statement_242:
  x1 = hirnd2(cmn, 6, xmin, xmax);
  x2 = d2 / (1.0f - x1);
  if (x1 * (1.0f - x2) < (d1 + 1.e-4f / sw)) {
    miss4++;
    if (miss4 <= 1000) {
      goto statement_242;
    }
    goto statement_5000;
  }
  ihnt2(13) = 2;
  goto statement_600;
/// C                        ********Fix targ mass*********
/// C
/// C*************non-single diffractive**********************
/// C        both proj and targ may not be fixed in mass
/// C*********************************************************
/// C
statement_400:
  nfp5 = 3;
  nft5 = 3;
  bb1 = 1.0f + d1 - d2;
  bb2 = 1.0f + d2 - d1;
  if (fem::pow2(bb1) < 4.0f * d1 || fem::pow2(bb2) < 4.0f * d2) {
    miss++;
    if (miss > 100 || pkc == 0.0f) {
      goto statement_3000;
    }
    pkc = pkc * 0.5f;
    goto statement_30;
  }
  xmin1 = (bb1 - fem::sqrt(fem::pow2(bb1) - 4.0f * d1)) / 2.0f;
  xmax1 = (bb1 + fem::sqrt(fem::pow2(bb1) - 4.0f * d1)) / 2.0f;
  xmin2 = (bb2 - fem::sqrt(fem::pow2(bb2) - 4.0f * d2)) / 2.0f;
  xmax2 = (bb2 + fem::sqrt(fem::pow2(bb2) - 4.0f * d2)) / 2.0f;
  miss4 = 0;
statement_410:
  x1 = hirnd2(cmn, 4, xmin1, xmax1);
  x2 = hirnd2(cmn, 4, xmin2, xmax2);
  if (nfp(jp, 5) == 3 || nft(jt, 5) == 3) {
    x1 = hirnd2(cmn, 6, xmin1, xmax1);
    x2 = hirnd2(cmn, 6, xmin2, xmax2);
  }
  /// C                        ********
  if (fem::abs(nfp(jp, 1) * nfp(jp, 2)) > 1000000 ||
      fem::abs(nfp(jp, 1) * nfp(jp, 2)) < 100) {
    x1 = hirnd2(cmn, 5, xmin1, xmax1);
  }
  if (fem::abs(nft(jt, 1) * nft(jt, 2)) > 1000000 ||
      fem::abs(nft(jt, 1) * nft(jt, 2)) < 100) {
    x2 = hirnd2(cmn, 5, xmin2, xmax2);
  }
  /// C        IF(IOPMAIN.EQ.3) X1=HIRND2(6,XMIN1,XMAX1)
  /// C        IF(IOPMAIN.EQ.2) X2=HIRND2(6,XMIN2,XMAX2)
  /// C        ********For q-qbar or (qq)-(qq)bar system use symetric
  /// C                distribution, for q-(qq) or qbar-(qq)bar use
  /// C                unsymetrical distribution
  /// C
  if (fem::abs(nfp(jp, 1) * nfp(jp, 2)) > 1000000) {
    x1 = 1.0f - x1;
  }
  xxp = x1 * (1.0f - x2);
  xxt = x2 * (1.0f - x1);
  if (xxp < (d1 + 1.e-4f / sw) || xxt < (d2 + 1.e-4f / sw)) {
    miss4++;
    if (miss4 <= 1000) {
      goto statement_410;
    }
    goto statement_5000;
  }
  ihnt2(13) = 3;
/// C***************************************************
statement_600:
  if (x1 * (1.0f - x2) < (fem::pow2(ampn) - 1.e-4f) / sw ||
      x2 * (1.0f - x1) < (fem::pow2(amtn) - 1.e-4f) / sw) {
    miss++;
    if (miss > 100 || pkc == 0.0f) {
      goto statement_2000;
    }
    pkc = 0.0f;
    goto statement_30;
  }
  /// C
  epp = (1.0f - x2) * wp;
  epm = x1 * wm;
  etp = x2 * wp;
  etm = (1.0f - x1) * wm;
  pp(jp, 3) = (epp - epm) / 2.0f;
  pp(jp, 4) = (epp + epm) / 2.0f;
  if (epp * epm - ptp2 < 0.0f) {
    goto statement_6000;
  }
  pp(jp, 5) = fem::sqrt(epp * epm - ptp2);
  nfp(jp, 3) = nfp3;
  nfp(jp, 5) = nfp5;
  /// C
  pt(jt, 3) = (etp - etm) / 2.0f;
  pt(jt, 4) = (etp + etm) / 2.0f;
  if (etp * etm - ptt2 < 0.0f) {
    goto statement_6000;
  }
  pt(jt, 5) = fem::sqrt(etp * etm - ptt2);
  nft(jt, 3) = nft3;
  nft(jt, 5) = nft5;
  /// C*****recoil PT from hard-inter is shared by two end-partons
  /// C       so that pt=p1+p2
  pp(jp, 1) = pp11 - pkc11;
  pp(jp, 2) = pp12 - pkc12;
  /// C
  kcdip = 1;
  kcdit = 1;
  if (fem::abs(nfp(jp, 1) * nfp(jp, 2)) > 1000000 ||
      fem::abs(nfp(jp, 1) * nfp(jp, 2)) < 100) {
    kcdip = 0;
  }
  if (fem::abs(nft(jt, 1) * nft(jt, 2)) > 1000000 ||
      fem::abs(nft(jt, 1) * nft(jt, 2)) < 100) {
    kcdit = 0;
  }
  if ((kcdip == 0 && ranart(nseed) < 0.5f) ||
      (kcdip != 0 &&
       ranart(nseed) < 0.5f / (1.0f + (fem::pow2(pkc11) + fem::pow2(pkc12)) /
                                          fem::pow2(hipr1(22))))) {
    pp(jp, 6) += (pp(jp, 1) - pp(jp, 6) - pp(jp, 8) - dpkc1) / 2.0f;
    pp(jp, 7) += (pp(jp, 2) - pp(jp, 7) - pp(jp, 9) - dpkc2) / 2.0f;
    pp(jp, 8) =
        (pp(jp, 1) - pp(jp, 6) - pp(jp, 8) - dpkc1) / 2.0f + pp(jp, 8) + pkc11;
    pp(jp, 9) =
        (pp(jp, 2) - pp(jp, 7) - pp(jp, 9) - dpkc2) / 2.0f + pp(jp, 9) + pkc12;
  } else {
    pp(jp, 8) += (pp(jp, 1) - pp(jp, 6) - pp(jp, 8) - dpkc1) / 2.0f;
    pp(jp, 9) += (pp(jp, 2) - pp(jp, 7) - pp(jp, 9) - dpkc2) / 2.0f;
    pp(jp, 6) =
        (pp(jp, 1) - pp(jp, 6) - pp(jp, 8) - dpkc1) / 2.0f + pp(jp, 6) + pkc11;
    pp(jp, 7) =
        (pp(jp, 2) - pp(jp, 7) - pp(jp, 9) - dpkc2) / 2.0f + pp(jp, 7) + pkc12;
  }
  pp(jp, 1) = pp(jp, 6) + pp(jp, 8);
  pp(jp, 2) = pp(jp, 7) + pp(jp, 9);
  /// C                                ********pt kick for proj
  pt(jt, 1) = pt11 - pkc21;
  pt(jt, 2) = pt12 - pkc22;
  if ((kcdit == 0 && ranart(nseed) < 0.5f) ||
      (kcdit != 0 &&
       ranart(nseed) < 0.5f / (1.0f + (fem::pow2(pkc21) + fem::pow2(pkc22)) /
                                          fem::pow2(hipr1(22))))) {
    pt(jt, 6) += (pt(jt, 1) - pt(jt, 6) - pt(jt, 8) - dpkc1) / 2.0f;
    pt(jt, 7) += (pt(jt, 2) - pt(jt, 7) - pt(jt, 9) - dpkc2) / 2.0f;
    pt(jt, 8) =
        (pt(jt, 1) - pt(jt, 6) - pt(jt, 8) - dpkc1) / 2.0f + pt(jt, 8) + pkc21;
    pt(jt, 9) =
        (pt(jt, 2) - pt(jt, 7) - pt(jt, 9) - dpkc2) / 2.0f + pt(jt, 9) + pkc22;
  } else {
    pt(jt, 8) += (pt(jt, 1) - pt(jt, 6) - pt(jt, 8) - dpkc1) / 2.0f;
    pt(jt, 9) += (pt(jt, 2) - pt(jt, 7) - pt(jt, 9) - dpkc2) / 2.0f;
    pt(jt, 6) =
        (pt(jt, 1) - pt(jt, 6) - pt(jt, 8) - dpkc1) / 2.0f + pt(jt, 6) + pkc21;
    pt(jt, 7) =
        (pt(jt, 2) - pt(jt, 7) - pt(jt, 9) - dpkc2) / 2.0f + pt(jt, 7) + pkc22;
  }
  pt(jt, 1) = pt(jt, 6) + pt(jt, 8);
  pt(jt, 2) = pt(jt, 7) + pt(jt, 9);
  /// C                        ********pt kick for targ
  /// C
  if (npj(jp) != 0) {
    nfp(jp, 5) = 3;
  }
  if (ntj(jt) != 0) {
    nft(jt, 5) = 3;
  }
  /// C                        ********jets must be connected to string
  if (epp / (epm + 0.0001f) < etp / (etm + 0.0001f) &&
      fem::abs(nfp(jp, 1) * nfp(jp, 2)) < 1000000) {
    FEM_DO_SAFE(jsb, 1, 15) {
      psb = pp(jp, jsb);
      pp(jp, jsb) = pt(jt, jsb);
      pt(jt, jsb) = psb;
      nsb = nfp(jp, jsb);
      nfp(jp, jsb) = nft(jt, jsb);
      nft(jt, jsb) = nsb;
    }
    /// C                ********when Ycm(JP)<Ycm(JT) after the collision
    /// C                        exchange the positions of the two
  }
  /// C
  return;
/// C**************************************************
statement_1000:
  ierror = 1;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), "     Fatal HIJSFT start error,abandon this event";
  write(6, star), "     PROJ E+,E-,W+", epp, epm, wp;
  write(6, star), "     TARG E+,E-,W-", etp, etm, wm;
  write(6, star), "     W+*W-, (APN+ATN)^2", sw, snn;
  return;
statement_2000:
  ierror = 0;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), "     (2)energy partition fail,";
  write(6, star), "     HIJSFT not performed, but continue";
  write(6, star), "     MP1,MPN", x1*(1.0f - x2) * sw, fem::pow2(ampn);
  write(6, star), "     MT2,MTN", x2*(1.0f - x1) * sw, fem::pow2(amtn);
  return;
statement_3000:
  ierror = 0;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), "     (3)something is wrong with the pt kick, ";
  write(6, star), "     HIJSFT not performed, but continue";
  write(6, star), "     D1=", d1, " D2=", d2, " SW=", sw;
  write(6, star), "     HISTORY NFP5=", nfp(jp, 5), " NFT5=", nft(jt, 5);
  write(6, star), "     THIS COLLISON NFP5=", nfp5, " NFT5=", nft5;
  write(6, star), "     # OF JET IN PROJ", npj(jp), " IN TARG", ntj(jt);
  return;
statement_4000:
  ierror = 0;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), "     (4)unable to choose process, but not harmful";
  write(6, star), "     HIJSFT not performed, but continue";
  write(6, star), "     PTP=", fem::sqrt(ptp2), " PTT=", fem::sqrt(ptt2),
      " SW=", sw;
  write(6, star), "     AMCUT=", amx, " JP=", jp, " JT=", jt;
  write(6, star), "     HISTORY NFP5=", nfp(jp, 5), " NFT5=", nft(jt, 5);
  return;
statement_5000:
  ierror = 0;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), "     energy partition failed(5),for limited try";
  write(6, star), "     HIJSFT not performed, but continue";
  write(6, star), "     NFP5=", nfp5, " NFT5=", nft5;
  write(6, star), "     D1", d1, " X1(1-X2)", x1*(1.0f - x2);
  write(6, star), "     D2", d2, " X2(1-X1)", x2*(1.0f - x1);
  return;
statement_6000:
  pkc = 0.0f;
  miss++;
  if (miss < 100) {
    goto statement_30;
  }
  ierror = 1;
  if (ihpr2(10) == 0) {
    return;
  }
  write(6, star), " ERROR OCCURED, HIJSFT NOT PERFORMED";
  write(6, star), " Abort this event";
  write(6, star), "MTP,PTP2", epp *epm, ptp2, "  MTT,PTT2", etp *etm, ptt2;
}

struct hirnd_save {
  int j;
  int jl;
  int jm;
  int ju;
  float rx;

  hirnd_save()
      : j(fem::int0),
        jl(fem::int0),
        jm(fem::int0),
        ju(fem::int0),
        rx(fem::float0) {}
};

float hirnd(common& cmn, int const& i) {
  float return_value = fem::float0;
  FEM_CMN_SVE(hirnd);
  arr_cref<float, 2> rr(cmn.rr, dimension(10, 201));
  arr_cref<float, 2> xx(cmn.xx, dimension(10, 201));
  ///
  int& j = sve.j;
  int& jl = sve.jl;
  int& jm = sve.jm;
  int& ju = sve.ju;
  float& rx = sve.rx;
  /// Cc      SAVE /HIJHB/
  /// Cc      SAVE /RNDF77/
  rx = ranart(cmn.nseed);
  jl = 0;
  ju = 202;
statement_10:
  if (ju - jl > 1) {
    jm = (ju + jl) / 2;
    if ((rr(i, 201) > rr(i, 1)) == (rx > rr(i, jm))) {
      jl = jm;
    } else {
      ju = jm;
    }
    goto statement_10;
  }
  j = jl;
  if (j < 1) {
    j = 1;
  }
  if (j >= 201) {
    j = 200;
  }
  return_value = (xx(i, j) + xx(i, j + 1)) / 2.0f;
  return return_value;
}

struct lorenz_save {
  double beta2;
  double gam;

  lorenz_save() : beta2(fem::double0), gam(fem::double0) {}
};

/// C
/// C*****************************************************************************
/// C
void lorenz(common& cmn, double const& energy, double const& px,
            double const& py, double const& pz, double const& bex,
            double const& bey, double const& bez) {
  FEM_CMN_SVE(lorenz);
  common_write write(cmn);
  /// COMMON lor
  double& enenew = cmn.enenew;
  double& pxnew = cmn.pxnew;
  double& pynew = cmn.pynew;
  double& pznew = cmn.pznew;
  ///
  /// SAVE
  double& beta2 = sve.beta2;
  double& gam = sve.gam;
  ///
  /// C
  /// C     add in a cut for beta2 to prevent gam to be nan (infinity)
  /// C
  /// Cc      SAVE /lor/
  /// C
  beta2 = fem::pow2(bex) + fem::pow2(bey) + fem::pow2(bez);
  if (beta2 == 0e0) {
    enenew = energy;
    pxnew = px;
    pynew = py;
    pznew = pz;
  } else {
    if (beta2 > 0.999999999999999e0) {
      beta2 = 0.999999999999999e0;
      write(6, star), "beta2=0.999999999999999";
    }
    /// Clin-7/20/01:
    /// C         gam = 1.d0 / sqrt(1.d0 - beta2)
    gam = 1.e0 / fem::dsqrt(1.e0 - beta2);
    enenew = gam * (energy - bex * px - bey * py - bez * pz);
    pxnew = -gam * bex * energy +
            (1.e0 + (gam - 1.e0) * fem::pow2(bex) / beta2) * px +
            (gam - 1.e0) * bex * bey / beta2 * py +
            (gam - 1.e0) * bex * bez / beta2 * pz;
    pynew = -gam * bey * energy + (gam - 1.e0) * bex * bey / beta2 * px +
            (1.e0 + (gam - 1.e0) * fem::pow2(bey) / beta2) * py +
            (gam - 1.e0) * bey * bez / beta2 * pz;
    pznew = -gam * bez * energy + (gam - 1.e0) * bex * bez / beta2 * px +
            (gam - 1.e0) * bey * bez / beta2 * py +
            (1.e0 + (gam - 1.e0) * fem::pow2(bez) / beta2) * pz;
  }
  /// C
}

struct decomp_save {
  double beta2;
  double dbex;
  double dbey;
  double dbez;
  double dcth;
  double de0;
  double de1;
  double de2;
  double dpcm;
  double dphi;
  double dpx;
  double dpy;
  double dpz;
  double ds;
  double gam;

  decomp_save()
      : beta2(fem::double0),
        dbex(fem::double0),
        dbey(fem::double0),
        dbez(fem::double0),
        dcth(fem::double0),
        de0(fem::double0),
        de1(fem::double0),
        de2(fem::double0),
        dpcm(fem::double0),
        dphi(fem::double0),
        dpx(fem::double0),
        dpy(fem::double0),
        dpz(fem::double0),
        ds(fem::double0),
        gam(fem::double0) {}
};

/// C
/// C=======================================================================
void decomp(common& cmn, double const& px0, double const& py0,
            double const& pz0, double const& xm0, int const& i,
            int const& /* itq1 */) {
  FEM_CMN_SVE(decomp);
  common_write write(cmn);
  /// COMMON lor
  double& enenew = cmn.enenew;
  double& pxnew = cmn.pxnew;
  double& pynew = cmn.pynew;
  double& pznew = cmn.pznew;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  /// COMMON decom
  arr_ref<double, 2> ptwo(cmn.ptwo, dimension(2, 5));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON hmain1
  int& natt = cmn.natt;
  /// COMMON embed
  int& iembed = cmn.iembed;
  int& nsembd = cmn.nsembd;
  ///
  /// SAVE
  double& beta2 = sve.beta2;
  double& dbex = sve.dbex;
  double& dbey = sve.dbey;
  double& dbez = sve.dbez;
  double& dcth = sve.dcth;
  double& de0 = sve.de0;
  double& de1 = sve.de1;
  double& de2 = sve.de2;
  double& dpcm = sve.dpcm;
  double& dphi = sve.dphi;
  double& dpx = sve.dpx;
  double& dpy = sve.dpy;
  double& dpz = sve.dpz;
  double& ds = sve.ds;
  double& gam = sve.gam;
  ///
  /// C
  /// Clin-8/2015 changed ptwo(2,5) and related variables to double precision
  /// C     to avoid IEEE_DIVIDE_BY_ZERO or IEEE_INVALID or IEEE_OVERFLOW_FLAG:
  /// Cc      SAVE /lor/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /decom/
  /// Cc      SAVE /RNDF77/
  /// C
  dcth = fem::dble(ranart(nseed)) * 2.e0 - 1.e0;
  dphi = fem::dble(ranart(nseed) * hipr1(40)) * 2.e0;
  /// Clin-6/2009 Added if embedding a high-Pt quark pair after string melting:
  if (iembed >= 1 && iembed <= 4) {
    /// C     Decompose the parent high-Pt pion to q and qbar with an internal
    /// momentum C     parallel to the pion direction so that one parton has
    /// ~the same hight Pt C     and the other parton has a very soft Pt: C
    /// Note: htop() decomposes a meson to q as it(1) followed by qbar as it(2):
    if (i == (natt - 2 * nsembd) || i == (natt - 2 * nsembd - 1)) {
      dcth = 0.e0;
      dphi = fem::dble(cmn.phidecomp);
    }
  }
  /// C
  ds = fem::pow2(xm0);
  dpcm = fem::dsqrt((ds - fem::pow2((ptwo(1, 5) + ptwo(2, 5)))) *
                    (ds - fem::pow2((ptwo(1, 5) - ptwo(2, 5)))) / ds / 4e0);
  dpz = dpcm * dcth;
  dpx = dpcm * fem::dsqrt(1.e0 - fem::pow2(dcth)) * fem::dcos(dphi);
  dpy = dpcm * fem::dsqrt(1.e0 - fem::pow2(dcth)) * fem::dsin(dphi);
  de1 = fem::dsqrt(fem::pow2(ptwo(1, 5)) + fem::pow2(dpcm));
  de2 = fem::dsqrt(fem::pow2(ptwo(2, 5)) + fem::pow2(dpcm));
  /// C
  de0 = fem::dsqrt(fem::pow2(px0) + fem::pow2(py0) + fem::pow2(pz0) +
                   fem::pow2(xm0));
  dbex = px0 / de0;
  dbey = py0 / de0;
  dbez = pz0 / de0;
  /// C     boost the reference frame up by beta (pznew=gam(pz+beta e)):
  beta2 = fem::pow2(dbex) + fem::pow2(dbey) + fem::pow2(dbez);
  gam = 1.e0 / fem::dsqrt(1.e0 - beta2);
  if (beta2 >= 0.9999999999999e0) {
    write(6, star), "1", dbex, dbey, dbez, beta2, gam;
  }
  /// C
  lorenz(cmn, de1, dpx, dpy, dpz, -dbex, -dbey, -dbez);
  ptwo(1, 1) = pxnew;
  ptwo(1, 2) = pynew;
  ptwo(1, 3) = pznew;
  ptwo(1, 4) = enenew;
  lorenz(cmn, de2, -dpx, -dpy, -dpz, -dbex, -dbey, -dbez);
  ptwo(2, 1) = pxnew;
  ptwo(2, 2) = pynew;
  ptwo(2, 3) = pznew;
  ptwo(2, 4) = enenew;
  /// C
}

struct htop_save {
  float ftime;
  int i;
  int i1;
  int i2;
  int i3;
  int i4;
  int id;
  int idabs;
  int inozpc;
  int ipamax;
  int ipar;
  arr<int> it;
  int npar;
  double ptwox;
  double ptwoy;
  double ptwoz;
  float rnum;
  double xmdq;

  htop_save()
      : ftime(fem::float0),
        i(fem::int0),
        i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        i4(fem::int0),
        id(fem::int0),
        idabs(fem::int0),
        inozpc(fem::int0),
        ipamax(fem::int0),
        ipar(fem::int0),
        it(dimension(4), fem::fill0),
        npar(fem::int0),
        ptwox(fem::double0),
        ptwoy(fem::double0),
        ptwoz(fem::double0),
        rnum(fem::float0),
        xmdq(fem::double0) {}
};

/// C
/// C=======================================================================
void htop(common& cmn) {
  FEM_CMN_SVE(htop);
  common_write write(cmn);
  /// COMMON hmain2
  const int maxstr = 150001;
  arr_cref<float, 2> patt(cmn.patt, dimension(maxstr, 4));
  /// COMMON hmain1
  int& natt = cmn.natt;
  /// COMMON prec1
  const int maxptn = 400001;
  arr_ref<double> gx0(cmn.gx0, dimension(maxptn));
  arr_ref<double> gy0(cmn.gy0, dimension(maxptn));
  arr_ref<double> gz0(cmn.gz0, dimension(maxptn));
  arr_ref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_ref<double> px0(cmn.px0, dimension(maxptn));
  arr_ref<double> py0(cmn.py0, dimension(maxptn));
  arr_ref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_ref<double> e0(cmn.e0, dimension(maxptn));
  arr_ref<double> xmass0(cmn.xmass0, dimension(maxptn));
  arr_ref<int> ityp0(cmn.ityp0, dimension(maxptn));
  /// COMMON ilist7
  arr_ref<int> lstrg0(cmn.lstrg0, dimension(maxptn));
  arr_ref<int> lpart0(cmn.lpart0, dimension(maxptn));
  /// COMMON arprc
  arr_cref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_cref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_cref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_cref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_cref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_cref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_cref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_cref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_cref<float> pear(cmn.pear, dimension(maxstr));
  arr_cref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON decom
  arr_ref<double, 2> ptwo(cmn.ptwo, dimension(2, 5));
  /// COMMON noprec
  int& nnozpc = cmn.nnozpc;
  const int maxidl = 4001;
  arr_ref<int> itypn(cmn.itypn, dimension(maxidl));
  arr_ref<float> gxn(cmn.gxn, dimension(maxidl));
  arr_ref<float> gyn(cmn.gyn, dimension(maxidl));
  arr_ref<float> gzn(cmn.gzn, dimension(maxidl));
  arr_ref<float> ftn(cmn.ftn, dimension(maxidl));
  arr_ref<float> pxn(cmn.pxn, dimension(maxidl));
  arr_ref<float> pyn(cmn.pyn, dimension(maxidl));
  arr_ref<float> pzn(cmn.pzn, dimension(maxidl));
  arr_ref<float> een(cmn.een, dimension(maxidl));
  arr_ref<float> xmn(cmn.xmn, dimension(maxidl));
  /// COMMON soft
  arr_ref<int> njsgs(cmn.njsgs, dimension(maxstr));
  /// COMMON anim
  int& isoft = cmn.isoft;
  /// COMMON precpa
  arr_ref<double> vxp0(cmn.vxp0, dimension(maxptn));
  arr_ref<double> vyp0(cmn.vyp0, dimension(maxptn));
  arr_ref<double> vzp0(cmn.vzp0, dimension(maxptn));
  arr_cref<double> xstrg0(cmn.xstrg0, dimension(maxptn));
  arr_cref<double> ystrg0(cmn.ystrg0, dimension(maxptn));
  arr_ref<double> xstrg(cmn.xstrg, dimension(maxptn));
  arr_ref<double> ystrg(cmn.ystrg, dimension(maxptn));
  arr_cref<int> istrg0(cmn.istrg0, dimension(maxptn));
  arr_ref<int> istrg(cmn.istrg, dimension(maxptn));
  /// COMMON para7
  int& ioscar = cmn.ioscar;
  int& nsmbbbar = cmn.nsmbbbar;
  int& nsmmeson = cmn.nsmmeson;
  /// COMMON snn
  float& epsipz = cmn.epsipz;
  float& epsipt = cmn.epsipt;
  float& pzproj = cmn.pzproj;
  float& pztarg = cmn.pztarg;
  ///
  /// SAVE
  float& ftime = sve.ftime;
  int& i = sve.i;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& i4 = sve.i4;
  int& id = sve.id;
  int& idabs = sve.idabs;
  int& inozpc = sve.inozpc;
  int& ipamax = sve.ipamax;
  int& ipar = sve.ipar;
  arr_ref<int> it(sve.it, dimension(4));
  int& npar = sve.npar;
  double& ptwox = sve.ptwox;
  double& ptwoy = sve.ptwoy;
  double& ptwoz = sve.ptwoz;
  float& rnum = sve.rnum;
  double& xmdq = sve.xmdq;
  ///
  /// C
  /// Cc      SAVE /HMAIN2/
  /// Cc      SAVE /HMAIN1/
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /ilist7/
  /// Cc      SAVE /ARPRC/
  /// Cc      SAVE /decom/
  /// Cc      SAVE /RNDF77/
  /// Cc      SAVE /NOPREC/
  /// Cc      SAVE /HPARNT/
  /// C     7/20/01: use double precision
  /// C     otherwise sometimes beta>1 and gamma diverge in lorenz():
  /// Cc      SAVE /SOFT/
  /// Cc      SAVE /anim/
  /// Clin-8/2015:
  /// C      DOUBLE PRECISION  vxp0,vyp0,vzp0
  /// C      common /precpa/ vxp0(MAXPTN), vyp0(MAXPTN), vzp0(MAXPTN)
  /// Cc      SAVE /precpa/
  /// C
  npar = 0;
  nnozpc = 0;
  /// Clin-5b/2008 calculate the number of hadrons to be converted to q/qbar:
  if ((isoft == 4 || isoft == 5) && (ioscar == 2 || ioscar == 3)) {
    nsmbbbar = 0;
    nsmmeson = 0;
    FEM_DO_SAFE(i, 1, natt) {
      id = itypar(i);
      idabs = fem::iabs(id);
      i2 = fem::mod(idabs / 10, 10);
      /// Clin-9/2011 determine spectator nucleons consistently
      /// C              if(PXAR(i).eq.0.and.PYAR(i).eq.0.and.PEAR(i)
      /// C     1             .ge.(HINT1(1)/2*0.99).and.
      /// C     2             .and.(id.eq.2112.or.id.eq.2212)) then
      if (fem::abs(pxar(i)) <= epsipt && fem::abs(pyar(i)) <= epsipt &&
          (pzar(i) > fem::amax1(0.f, pzproj - epsipz) ||
           pzar(i) < (-pztarg + epsipz)) &&
          (id == 2112 || id == 2212)) {
        /// C     spectator proj or targ nucleons without interactions, do not
        /// enter ZPC:
      } else if (idabs > 1000 && i2 != 0) {
        /// C     baryons to be converted to q/qbar:
        nsmbbbar++;
      } else if ((idabs > 100 && idabs < 1000) || idabs > 10000) {
        /// C     mesons to be converted to q/qbar:
        nsmmeson++;
      }
    }
    /// C
    /// Clin-6/2009:
    if (ioscar == 2 || ioscar == 3) {
      write(92, star), cmn.iaevt, cmn.miss, 3 * nsmbbbar + 2 * nsmmeson,
          nsmbbbar, nsmmeson, natt, natt - nsmbbbar - nsmmeson;
    }
    /// C           write(92,*) iaevt, 3*nsmbbbar+2*nsmmeson
    /// C           write(92,*) ' event#, total # of initial partons after
    /// string C     1 melting' C           write(92,*) 'String melting converts
    /// ',nsmbbbar, ' baryons &' C     1, nsmmeson, ' mesons' C write(92,*)
    /// 'Total # of initial particles= ',natt C           write(92,*) 'Total #
    /// of initial particles (gamma,e,muon,...) C     1 not entering ZPC=
    /// ',natt-nsmbbbar-nsmmeson
  }
  /// Clin-5b/2008-over
  FEM_DO_SAFE(i, 1, natt) {
    id = itypar(i);
    idabs = fem::iabs(id);
    i4 = fem::mod(idabs / 1000, 10);
    i3 = fem::mod(idabs / 100, 10);
    i2 = fem::mod(idabs / 10, 10);
    i1 = fem::mod(idabs, 10);
    rnum = ranart(cmn.nseed);
    ftime = 0.197f * pear(i) /
            (fem::pow2(pxar(i)) + fem::pow2(pyar(i)) + fem::pow2(xmar(i)));
    inozpc = 0;
    it(1) = 0;
    it(2) = 0;
    it(3) = 0;
    it(4) = 0;
    /// C
    /// Clin-9/2011 determine spectator nucleons consistently
    /// C           if(PXAR(i).eq.0.and.PYAR(i).eq.0.and.PEAR(i)
    /// C     1 .ge.(HINT1(1)/2*0.99).and.((id.eq.2112).or.(id.eq.2212))) then
    if (fem::abs(pxar(i)) <= epsipt && fem::abs(pyar(i)) <= epsipt &&
        (pzar(i) > fem::amax1(0.f, pzproj - epsipz) ||
         pzar(i) < (-pztarg + epsipz)) &&
        (id == 2112 || id == 2212)) {
      /// C     spectator proj or targ nucleons without interactions, do not
      /// enter ZPC:
      inozpc = 1;
    } else if (idabs > 1000 && i2 != 0) {
      /// C     baryons:
      if (((i4 == 1 || i4 == 2) && i4 == i3) || (i4 == 3 && i3 == 3)) {
        if (i1 == 2) {
          if (rnum <= (1.f / 2.f)) {
            it(1) = i4;
            it(2) = i3 * 1000 + i2 * 100 + 1;
          } else if (rnum <= (2.f / 3.f)) {
            it(1) = i4;
            it(2) = i3 * 1000 + i2 * 100 + 3;
          } else {
            it(1) = i2;
            it(2) = i4 * 1000 + i3 * 100 + 3;
          }
        } else if (i1 == 4) {
          if (rnum <= (2.f / 3.f)) {
            it(1) = i4;
            it(2) = i3 * 1000 + i2 * 100 + 3;
          } else {
            it(1) = i2;
            it(2) = i4 * 1000 + i3 * 100 + 3;
          }
        }
      } else if (i4 == 1 || i4 == 2) {
        if (i1 == 2) {
          if (rnum <= (1.f / 2.f)) {
            it(1) = i2;
            it(2) = i4 * 1000 + i3 * 100 + 1;
          } else if (rnum <= (2.f / 3.f)) {
            it(1) = i2;
            it(2) = i4 * 1000 + i3 * 100 + 3;
          } else {
            it(1) = i4;
            it(2) = i3 * 1000 + i2 * 100 + 3;
          }
        } else if (i1 == 4) {
          if (rnum <= (2.f / 3.f)) {
            it(1) = i2;
            it(2) = i4 * 1000 + i3 * 100 + 3;
          } else {
            it(1) = i4;
            it(2) = i3 * 1000 + i2 * 100 + 3;
          }
        }
      } else if (i4 >= 3) {
        it(1) = i4;
        if (i3 < i2) {
          it(2) = i2 * 1000 + i3 * 100 + 1;
        } else {
          it(2) = i3 * 1000 + i2 * 100 + 3;
        }
      }
      /// C       antibaryons:
      if (id < 0) {
        it(1) = -it(1);
        it(2) = -it(2);
      }
      /// C     isoft=4or5 decompose diquark flavor it(2) to two quarks
      /// it(3)&(4):
      if (isoft == 4 || isoft == 5) {
        it(3) = fem::mod(it(2) / 1000, 10);
        it(4) = fem::mod(it(2) / 100, 10);
      }
      /// C
    } else if ((idabs > 100 && idabs < 1000) || idabs > 10000) {
      /// C     mesons:
      if (i3 == i2) {
        if (i3 == 1 || i3 == 2) {
          if (rnum <= 0.5f) {
            it(1) = 1;
            it(2) = -1;
          } else {
            it(1) = 2;
            it(2) = -2;
          }
        } else {
          it(1) = i3;
          it(2) = -i3;
        }
      } else {
        if ((fem::isign(1, id) * fem::pow((-1), i3)) == 1) {
          it(1) = i3;
          it(2) = -i2;
        } else {
          it(1) = i2;
          it(2) = -i3;
        }
      }
    } else {
      /// C     save other particles (leptons and photons) outside of ZPC:
      inozpc = 1;
    }
    /// C
    if (inozpc == 1) {
      njsgs(i) = 0;
      nnozpc++;
      itypn(nnozpc) = itypar(i);
      pxn(nnozpc) = pxar(i);
      pyn(nnozpc) = pyar(i);
      pzn(nnozpc) = pzar(i);
      een(nnozpc) = pear(i);
      xmn(nnozpc) = xmar(i);
      gxn(nnozpc) = gxar(i);
      gyn(nnozpc) = gyar(i);
      gzn(nnozpc) = gzar(i);
      ftn(nnozpc) = ftar(i);
    } else {
      njsgs(i) = 2;
      ptwo(1, 5) = fem::dble(ulmass(cmn, it(1)));
      ptwo(2, 5) = fem::dble(ulmass(cmn, it(2)));
      decomp(cmn, fem::dble(patt(i, 1)), fem::dble(patt(i, 2)),
             fem::dble(patt(i, 3)), fem::dble(xmar(i)), i, it(1));
      ipamax = 2;
      if ((isoft == 4 || isoft == 5) && fem::iabs(it(2)) > 1000) {
        ipamax = 1;
      }
      FEM_DO_SAFE(ipar, 1, ipamax) {
        npar++;
        ityp0(npar) = it(ipar);
        px0(npar) = ptwo(ipar, 1);
        py0(npar) = ptwo(ipar, 2);
        pz0(npar) = ptwo(ipar, 3);
        e0(npar) = ptwo(ipar, 4);
        xmass0(npar) = ptwo(ipar, 5);
        gx0(npar) = fem::dble(gxar(i));
        gy0(npar) = fem::dble(gyar(i));
        gz0(npar) = fem::dble(gzar(i));
        ft0(npar) = fem::dble(ftime);
        lstrg0(npar) = i;
        lpart0(npar) = ipar;
        vxp0(npar) = fem::dble(patt(i, 1) / patt(i, 4));
        vyp0(npar) = fem::dble(patt(i, 2) / patt(i, 4));
        vzp0(npar) = fem::dble(patt(i, 3) / patt(i, 4));
        /// Clin-8/2015: set parent string information for this parton:
        xstrg(npar) = xstrg0(i);
        ystrg(npar) = ystrg0(i);
        istrg(npar) = istrg0(i);
      }
      /// C
      if ((isoft == 4 || isoft == 5) && fem::iabs(it(2)) > 1000) {
        njsgs(i) = 3;
        xmdq = ptwo(2, 5);
        ptwo(1, 5) = fem::dble(ulmass(cmn, it(3)));
        ptwo(2, 5) = fem::dble(ulmass(cmn, it(4)));
        /// C     8/19/02 avoid actual argument in common blocks of DECOMP:
        /// C                 call decomp(ptwo(2,1),ptwo(2,2),ptwo(2,3),xmdq)
        ptwox = ptwo(2, 1);
        ptwoy = ptwo(2, 2);
        ptwoz = ptwo(2, 3);
        decomp(cmn, ptwox, ptwoy, ptwoz, xmdq, i, it(1));
        /// C
        FEM_DO_SAFE(ipar, 1, 2) {
          npar++;
          ityp0(npar) = it(ipar + 2);
          px0(npar) = ptwo(ipar, 1);
          py0(npar) = ptwo(ipar, 2);
          pz0(npar) = ptwo(ipar, 3);
          e0(npar) = ptwo(ipar, 4);
          xmass0(npar) = ptwo(ipar, 5);
          gx0(npar) = fem::dble(gxar(i));
          gy0(npar) = fem::dble(gyar(i));
          gz0(npar) = fem::dble(gzar(i));
          ft0(npar) = fem::dble(ftime);
          lstrg0(npar) = i;
          lpart0(npar) = ipar + 1;
          vxp0(npar) = fem::dble(patt(i, 1) / patt(i, 4));
          vyp0(npar) = fem::dble(patt(i, 2) / patt(i, 4));
          vzp0(npar) = fem::dble(patt(i, 3) / patt(i, 4));
          /// Clin-8/2015: set parent string information for this parton:
          xstrg(npar) = xstrg0(i);
          ystrg(npar) = ystrg0(i);
          istrg(npar) = istrg0(i);
        }
      }
      /// C
    }
  }
  cmn.mul = npar;
  /// C
  /// Clin-5b/2008:
  if ((isoft == 4 || isoft == 5) && (ioscar == 2 || ioscar == 3)) {
    if ((natt - nsmbbbar - nsmmeson) != nnozpc) {
      write(92, star),
          "Problem with the total # of initial particles (gamma,e,muon,...) "
          "not "
          "entering ZPC";
    }
    if ((3 * nsmbbbar + 2 * nsmmeson) != npar) {
      write(92, star),
          "Problem with the total # of initial partons after string melting";
    }
  }
  /// C
}

struct resmass_save {
  float amass;
  float dm;
  float dmax;
  float dmin;
  float fm;
  float fmass;
  int ntry1;
  float wid;

  resmass_save()
      : amass(fem::float0),
        dm(fem::float0),
        dmax(fem::float0),
        dmin(fem::float0),
        fm(fem::float0),
        fmass(fem::float0),
        ntry1(fem::int0),
        wid(fem::float0) {}
};

/// C
/// C=======================================================================
/// Clin-5/2011-add finite width to resonances (rho,omega,eta,K*,phi,Delta)
/// after formation:
float resmass(common& cmn, int const& kf) {
  float return_value = fem::float0;
  FEM_CMN_SVE(resmass);
  int& nseed = cmn.nseed;
  ///
  float& amass = sve.amass;
  float& dm = sve.dm;
  float& dmax = sve.dmax;
  float& dmin = sve.dmin;
  float& fm = sve.fm;
  float& fmass = sve.fmass;
  int& ntry1 = sve.ntry1;
  float& wid = sve.wid;
  const float arho = 0.775f;
  const float wrho = 0.149f;
  const float aeta = 0.548f;
  const float weta = 1.30e-6f;
  const float aomega = 0.783f;
  const float womega = 0.00849f;
  const float aks = 0.894f;
  const float wks = 0.0498f;
  const float aphi = 1.019f;
  const float wphi = 0.00426f;
  const float adelta = 1.232f;
  const float wdelta = 0.118f;
  /// C
  if (kf == 113 || fem::abs(kf) == 213) {
    amass = arho;
    wid = wrho;
  } else if (kf == 221) {
    amass = aeta;
    wid = weta;
  } else if (kf == 223) {
    amass = aomega;
    wid = womega;
  } else if (fem::abs(kf) == 313 || fem::abs(kf) == 323) {
    amass = aks;
    wid = wks;
  } else if (kf == 333) {
    amass = aphi;
    wid = wphi;
  } else if (fem::abs(kf) == 1114 || fem::abs(kf) == 2114 ||
             fem::abs(kf) == 2214 || fem::abs(kf) == 2224) {
    amass = adelta;
    wid = wdelta;
  }
  dmin = amass - 2 * wid;
  dmax = amass + 2 * wid;
  /// C     Delta mass needs to be big enough to decay to N+pi:
  if (amass == adelta) {
    dmin = 1.078f;
  }
  /// C
  fm = 1.f;
  ntry1 = 0;
statement_10:
  dm = ranart(nseed) * (dmax - dmin) + dmin;
  ntry1++;
  fmass = fem::pow2((amass * wid)) /
          (fem::pow2((fem::pow2(dm) - fem::pow2(amass))) +
           fem::pow2((amass * wid)));
  /// Check      write (99,*) ntry1,kf,amass,wid,fmass,DM
  if ((ranart(nseed) > fmass / fm) && (ntry1 <= 10)) {
    goto statement_10;
  }
  /// C
  return_value = dm;
  /// C
  return return_value;
}

struct exchge_save {
  double ft;
  double gx;
  double gy;
  double gz;
  int k1;
  int k2;
  double pe;
  double pm;
  double px;
  double py;
  double pz;

  exchge_save()
      : ft(fem::double0),
        gx(fem::double0),
        gy(fem::double0),
        gz(fem::double0),
        k1(fem::int0),
        k2(fem::int0),
        pe(fem::double0),
        pm(fem::double0),
        px(fem::double0),
        py(fem::double0),
        pz(fem::double0) {}
};

/// C
/// C=======================================================================
void exchge(common& cmn, int const& isg, int const& ipi, int const& jsg,
            int const& ipj) {
  FEM_CMN_SVE(exchge);
  /// COMMON soft
  const int maxstr = 150001;
  arr_ref<double, 2> pxsgs(cmn.pxsgs, dimension(maxstr, 3));
  arr_ref<double, 2> pysgs(cmn.pysgs, dimension(maxstr, 3));
  arr_ref<double, 2> pzsgs(cmn.pzsgs, dimension(maxstr, 3));
  arr_ref<double, 2> pesgs(cmn.pesgs, dimension(maxstr, 3));
  arr_ref<double, 2> pmsgs(cmn.pmsgs, dimension(maxstr, 3));
  arr_ref<double, 2> gxsgs(cmn.gxsgs, dimension(maxstr, 3));
  arr_ref<double, 2> gysgs(cmn.gysgs, dimension(maxstr, 3));
  arr_ref<double, 2> gzsgs(cmn.gzsgs, dimension(maxstr, 3));
  arr_ref<double, 2> ftsgs(cmn.ftsgs, dimension(maxstr, 3));
  arr_ref<int, 2> k1sgs(cmn.k1sgs, dimension(maxstr, 3));
  arr_ref<int, 2> k2sgs(cmn.k2sgs, dimension(maxstr, 3));
  ///
  /// SAVE
  double& ft = sve.ft;
  double& gx = sve.gx;
  double& gy = sve.gy;
  double& gz = sve.gz;
  int& k1 = sve.k1;
  int& k2 = sve.k2;
  double& pe = sve.pe;
  double& pm = sve.pm;
  double& px = sve.px;
  double& py = sve.py;
  double& pz = sve.pz;
  ///
  /// C
  /// Cc      SAVE /SOFT/
  /// C
  k1 = k1sgs(isg, ipi);
  k2 = k2sgs(isg, ipi);
  px = pxsgs(isg, ipi);
  py = pysgs(isg, ipi);
  pz = pzsgs(isg, ipi);
  pe = pesgs(isg, ipi);
  pm = pmsgs(isg, ipi);
  gx = gxsgs(isg, ipi);
  gy = gysgs(isg, ipi);
  gz = gzsgs(isg, ipi);
  ft = ftsgs(isg, ipi);
  k1sgs(isg, ipi) = k1sgs(jsg, ipj);
  k2sgs(isg, ipi) = k2sgs(jsg, ipj);
  pxsgs(isg, ipi) = pxsgs(jsg, ipj);
  pysgs(isg, ipi) = pysgs(jsg, ipj);
  pzsgs(isg, ipi) = pzsgs(jsg, ipj);
  pesgs(isg, ipi) = pesgs(jsg, ipj);
  pmsgs(isg, ipi) = pmsgs(jsg, ipj);
  gxsgs(isg, ipi) = gxsgs(jsg, ipj);
  gysgs(isg, ipi) = gysgs(jsg, ipj);
  gzsgs(isg, ipi) = gzsgs(jsg, ipj);
  ftsgs(isg, ipi) = ftsgs(jsg, ipj);
  k1sgs(jsg, ipj) = k1;
  k2sgs(jsg, ipj) = k2;
  pxsgs(jsg, ipj) = px;
  pysgs(jsg, ipj) = py;
  pzsgs(jsg, ipj) = pz;
  pesgs(jsg, ipj) = pe;
  pmsgs(jsg, ipj) = pm;
  gxsgs(jsg, ipj) = gx;
  gysgs(jsg, ipj) = gy;
  gzsgs(jsg, ipj) = gz;
  ftsgs(jsg, ipj) = ft;
  /// C
}

struct locldr_save {
  double beta2;
  double bex;
  double bey;
  double bez;
  double dt0;
  double etot;
  arr<double> ftp0;
  double gam;
  int iearly;
  int ilate;
  int imax;
  int imin;
  int istep;
  int j;
  arr<double> pep0;
  arr<double> pxp0;
  arr<double> pyp0;
  arr<double> pzp0;

  locldr_save()
      : beta2(fem::double0),
        bex(fem::double0),
        bey(fem::double0),
        bez(fem::double0),
        dt0(fem::double0),
        etot(fem::double0),
        ftp0(dimension(3), fem::fill0),
        gam(fem::double0),
        iearly(fem::int0),
        ilate(fem::int0),
        imax(fem::int0),
        imin(fem::int0),
        istep(fem::int0),
        j(fem::int0),
        pep0(dimension(3), fem::fill0),
        pxp0(dimension(3), fem::fill0),
        pyp0(dimension(3), fem::fill0),
        pzp0(dimension(3), fem::fill0) {}
};

/// C
/// C=======================================================================
void locldr(common& cmn, int const& icall, double& drlocl) {
  FEM_CMN_SVE(locldr);
  common_write write(cmn);
  /// COMMON loclco
  arr_cref<double> gxp(cmn.gxp, dimension(3));
  arr_cref<double> gyp(cmn.gyp, dimension(3));
  arr_cref<double> gzp(cmn.gzp, dimension(3));
  arr_cref<double> ftp(cmn.ftp, dimension(3));
  arr_cref<double> pxp(cmn.pxp, dimension(3));
  arr_cref<double> pyp(cmn.pyp, dimension(3));
  arr_cref<double> pzp(cmn.pzp, dimension(3));
  arr_cref<double> pep(cmn.pep, dimension(3));
  arr_cref<double> pmp(cmn.pmp, dimension(3));
  /// COMMON prtn23
  arr_ref<double> gxp0(cmn.gxp0, dimension(3));
  arr_ref<double> gyp0(cmn.gyp0, dimension(3));
  arr_ref<double> gzp0(cmn.gzp0, dimension(3));
  double& ft0fom = cmn.ft0fom;
  /// COMMON lor
  double& enenew = cmn.enenew;
  double& pxnew = cmn.pxnew;
  double& pynew = cmn.pynew;
  double& pznew = cmn.pznew;
  ///
  /// SAVE
  double& beta2 = sve.beta2;
  double& bex = sve.bex;
  double& bey = sve.bey;
  double& bez = sve.bez;
  double& dt0 = sve.dt0;
  double& etot = sve.etot;
  arr_ref<double> ftp0(sve.ftp0, dimension(3));
  double& gam = sve.gam;
  int& iearly = sve.iearly;
  int& ilate = sve.ilate;
  int& imax = sve.imax;
  int& imin = sve.imin;
  int& istep = sve.istep;
  int& j = sve.j;
  arr_ref<double> pep0(sve.pep0, dimension(3));
  arr_ref<double> pxp0(sve.pxp0, dimension(3));
  arr_ref<double> pyp0(sve.pyp0, dimension(3));
  arr_ref<double> pzp0(sve.pzp0, dimension(3));
  ///
  /// C
  /// Cc      SAVE /loclco/
  /// Cc      SAVE /prtn23/
  /// Cc      SAVE /lor/
  /// C     for 2-body kinematics:
  if (icall == 2) {
    etot = pep(1) + pep(2);
    bex = (pxp(1) + pxp(2)) / etot;
    bey = (pyp(1) + pyp(2)) / etot;
    bez = (pzp(1) + pzp(2)) / etot;
    /// C     boost the reference frame down by beta to get to the pair rest
    /// frame:
    FEM_DO_SAFE(j, 1, 2) {
      beta2 = fem::pow2(bex) + fem::pow2(bey) + fem::pow2(bez);
      gam = 1.e0 / fem::dsqrt(1.e0 - beta2);
      if (beta2 >= 0.9999999999999e0) {
        write(6, star), "4", pxp(1), pxp(2), pyp(1), pyp(2), pzp(1), pzp(2),
            pep(1), pep(2), pmp(1), pmp(2),
            fem::dsqrt(fem::pow2(pxp(1)) + fem::pow2(pyp(1)) +
                       fem::pow2(pzp(1)) + fem::pow2(pmp(1))) /
                pep(1),
            fem::dsqrt(fem::pow2(pxp(1)) + fem::pow2(pyp(1)) +
                       fem::pow2(pzp(1))) /
                pep(1);
        write(6, star), "4a", pxp(1) + pxp(2), pyp(1) + pyp(2), pzp(1) + pzp(2),
            etot;
        write(6, star), "4b", bex, bey, bez, beta2, gam;
      }
      /// C
      lorenz(cmn, ftp(j), gxp(j), gyp(j), gzp(j), bex, bey, bez);
      gxp0(j) = pxnew;
      gyp0(j) = pynew;
      gzp0(j) = pznew;
      ftp0(j) = enenew;
      lorenz(cmn, pep(j), pxp(j), pyp(j), pzp(j), bex, bey, bez);
      pxp0(j) = pxnew;
      pyp0(j) = pynew;
      pzp0(j) = pznew;
      pep0(j) = enenew;
    }
    /// C
    if (ftp0(1) >= ftp0(2)) {
      ilate = 1;
      iearly = 2;
    } else {
      ilate = 2;
      iearly = 1;
    }
    ft0fom = ftp0(ilate);
    /// C
    dt0 = ftp0(ilate) - ftp0(iearly);
    gxp0(iearly) += pxp0(iearly) / pep0(iearly) * dt0;
    gyp0(iearly) += pyp0(iearly) / pep0(iearly) * dt0;
    gzp0(iearly) += pzp0(iearly) / pep0(iearly) * dt0;
    drlocl = fem::dsqrt(fem::pow2((gxp0(ilate) - gxp0(iearly))) +
                        fem::pow2((gyp0(ilate) - gyp0(iearly))) +
                        fem::pow2((gzp0(ilate) - gzp0(iearly))));
    /// C     for 3-body kinematics, used for baryons formation:
  } else if (icall == 3) {
    etot = pep(1) + pep(2) + pep(3);
    bex = (pxp(1) + pxp(2) + pxp(3)) / etot;
    bey = (pyp(1) + pyp(2) + pyp(3)) / etot;
    bez = (pzp(1) + pzp(2) + pzp(3)) / etot;
    beta2 = fem::pow2(bex) + fem::pow2(bey) + fem::pow2(bez);
    gam = 1.e0 / fem::dsqrt(1.e0 - beta2);
    if (beta2 >= 0.9999999999999e0) {
      write(6, star), "5", bex, bey, bez, beta2, gam;
    }
    /// C     boost the reference frame down by beta to get to the 3-parton rest
    /// frame:
    FEM_DO_SAFE(j, 1, 3) {
      lorenz(cmn, ftp(j), gxp(j), gyp(j), gzp(j), bex, bey, bez);
      gxp0(j) = pxnew;
      gyp0(j) = pynew;
      gzp0(j) = pznew;
      ftp0(j) = enenew;
      lorenz(cmn, pep(j), pxp(j), pyp(j), pzp(j), bex, bey, bez);
      pxp0(j) = pxnew;
      pyp0(j) = pynew;
      pzp0(j) = pznew;
      pep0(j) = enenew;
    }
    /// C
    if (ftp0(1) > ftp0(2)) {
      ilate = 1;
      if (ftp0(3) > ftp0(1)) {
        ilate = 3;
      }
    } else {
      ilate = 2;
      if (ftp0(3) >= ftp0(2)) {
        ilate = 3;
      }
    }
    ft0fom = ftp0(ilate);
    /// C
    if (ilate == 1) {
      imin = 2;
      imax = 3;
      istep = 1;
    } else if (ilate == 2) {
      imin = 1;
      imax = 3;
      istep = 2;
    } else if (ilate == 3) {
      imin = 1;
      imax = 2;
      istep = 1;
    }
    /// C
    FEM_DOSTEP(iearly, imin, imax, istep) {
      dt0 = ftp0(ilate) - ftp0(iearly);
      gxp0(iearly) += pxp0(iearly) / pep0(iearly) * dt0;
      gyp0(iearly) += pyp0(iearly) / pep0(iearly) * dt0;
      gzp0(iearly) += pzp0(iearly) / pep0(iearly) * dt0;
    }
  }
  /// C
}

struct coales_save {
  static const int maxstr = 150001;

  double dp0;
  arr<double> dp1;
  double dplocl;
  double dr0;
  arr<double> dr1;
  double drlocl;
  int ibaryn;
  arr<int> iover;
  int ip;
  int ipi;
  int ipmax;
  int ipmin;
  int isg;
  int j;
  int jsg;

  coales_save()
      : dp0(fem::double0),
        dp1(dim1(2, 3), fem::fill0),
        dplocl(fem::double0),
        dr0(fem::double0),
        dr1(dim1(2, 3), fem::fill0),
        drlocl(fem::double0),
        ibaryn(fem::int0),
        iover(dimension(maxstr), fem::fill0),
        ip(fem::int0),
        ipi(fem::int0),
        ipmax(fem::int0),
        ipmin(fem::int0),
        isg(fem::int0),
        j(fem::int0),
        jsg(fem::int0) {}
};

const int coales_save::maxstr;

/// C
/// C=======================================================================
void coales(common& cmn) {
  FEM_CMN_SVE(coales);
  common_write write(cmn);
  const int maxstr = 150001;
  arr_cref<double, 2> pxsgs(cmn.pxsgs, dimension(maxstr, 3));
  arr_cref<double, 2> pysgs(cmn.pysgs, dimension(maxstr, 3));
  arr_cref<double, 2> pzsgs(cmn.pzsgs, dimension(maxstr, 3));
  arr_cref<double, 2> pesgs(cmn.pesgs, dimension(maxstr, 3));
  arr_cref<double, 2> pmsgs(cmn.pmsgs, dimension(maxstr, 3));
  arr_cref<double, 2> gxsgs(cmn.gxsgs, dimension(maxstr, 3));
  arr_cref<double, 2> gysgs(cmn.gysgs, dimension(maxstr, 3));
  arr_cref<double, 2> gzsgs(cmn.gzsgs, dimension(maxstr, 3));
  arr_cref<double, 2> ftsgs(cmn.ftsgs, dimension(maxstr, 3));
  arr_cref<int, 2> k2sgs(cmn.k2sgs, dimension(maxstr, 3));
  arr_cref<int> njsgs(cmn.njsgs, dimension(maxstr));
  double& dpcoal = cmn.dpcoal;
  double& drcoal = cmn.drcoal;
  arr_ref<double> gxp(cmn.gxp, dimension(3));
  arr_ref<double> gyp(cmn.gyp, dimension(3));
  arr_ref<double> gzp(cmn.gzp, dimension(3));
  arr_ref<double> ftp(cmn.ftp, dimension(3));
  arr_ref<double> pxp(cmn.pxp, dimension(3));
  arr_ref<double> pyp(cmn.pyp, dimension(3));
  arr_ref<double> pzp(cmn.pzp, dimension(3));
  arr_ref<double> pep(cmn.pep, dimension(3));
  arr_ref<double> pmp(cmn.pmp, dimension(3));
  int& nsg = cmn.nsg;
  ///
  double& dp0 = sve.dp0;
  arr_ref<double> dp1(sve.dp1, dim1(2, 3));
  double& dplocl = sve.dplocl;
  double& dr0 = sve.dr0;
  arr_ref<double> dr1(sve.dr1, dim1(2, 3));
  double& drlocl = sve.drlocl;
  int& ibaryn = sve.ibaryn;
  arr_ref<int> iover(sve.iover, dimension(maxstr));
  int& ip = sve.ip;
  int& ipi = sve.ipi;
  int& ipmax = sve.ipmax;
  int& ipmin = sve.ipmin;
  int& isg = sve.isg;
  int& j = sve.j;
  int& jsg = sve.jsg;
  /// C
  /// Cc      SAVE /SOFT/
  /// Cc      SAVE /coal/
  /// Cc      SAVE /loclco/
  /// Cc      SAVE /HJJET2/
  /// C
  FEM_DO_SAFE(isg, 1, nsg) { iover(isg) = 0; }
  /// C1     meson q coalesce with all available qbar:
  FEM_DO_SAFE(isg, 1, nsg) {
    if (njsgs(isg) != 2 || iover(isg) == 1) {
      goto statement_150;
    }
    /// C     DETERMINE CURRENT RELATIVE DISTANCE AND MOMENTUM:
    if (k2sgs(isg, 1) < 0) {
      write(6, star), "Antiquark appears in quark loop; stop";
      FEM_STOP(0);
    }
    /// C
    FEM_DO_SAFE(j, 1, 2) {
      ftp(j) = ftsgs(isg, j);
      gxp(j) = gxsgs(isg, j);
      gyp(j) = gysgs(isg, j);
      gzp(j) = gzsgs(isg, j);
      pxp(j) = pxsgs(isg, j);
      pyp(j) = pysgs(isg, j);
      pzp(j) = pzsgs(isg, j);
      pmp(j) = pmsgs(isg, j);
      pep(j) = pesgs(isg, j);
    }
    locldr(cmn, 2, drlocl);
    dr0 = drlocl;
    /// C     dp0^2 defined as (p1+p2)^2-(m1+m2)^2:
    dp0 = fem::dsqrt(2 * (pep(1) * pep(2) - pxp(1) * pxp(2) - pyp(1) * pyp(2) -
                          pzp(1) * pzp(2) - pmp(1) * pmp(2)));
    /// C
    FEM_DO_SAFE(jsg, 1, nsg) {
      /// C     skip default or unavailable antiquarks:
      if (jsg == isg || iover(jsg) == 1) {
        goto statement_120;
      }
      if (njsgs(jsg) == 2) {
        ipmin = 2;
        ipmax = 2;
      } else if (njsgs(jsg) == 3 && k2sgs(jsg, 1) < 0) {
        ipmin = 1;
        ipmax = 3;
      } else {
        goto statement_120;
      }
      FEM_DO_SAFE(ip, ipmin, ipmax) {
        dplocl =
            fem::dsqrt(2 * (pep(1) * pesgs(jsg, ip) - pxp(1) * pxsgs(jsg, ip) -
                            pyp(1) * pysgs(jsg, ip) - pzp(1) * pzsgs(jsg, ip) -
                            pmp(1) * pmsgs(jsg, ip)));
        /// C     skip if outside of momentum radius:
        if (dplocl > dpcoal) {
          goto statement_120;
        }
        ftp(2) = ftsgs(jsg, ip);
        gxp(2) = gxsgs(jsg, ip);
        gyp(2) = gysgs(jsg, ip);
        gzp(2) = gzsgs(jsg, ip);
        pxp(2) = pxsgs(jsg, ip);
        pyp(2) = pysgs(jsg, ip);
        pzp(2) = pzsgs(jsg, ip);
        pmp(2) = pmsgs(jsg, ip);
        pep(2) = pesgs(jsg, ip);
        locldr(cmn, 2, drlocl);
        /// C     skip if outside of spatial radius:
        if (drlocl > drcoal) {
          goto statement_120;
        }
        /// C     q_isg coalesces with qbar_jsg:
        if ((dp0 > dpcoal || dr0 > drcoal) || (drlocl < dr0)) {
          dp0 = dplocl;
          dr0 = drlocl;
          exchge(cmn, isg, 2, jsg, ip);
        }
      }
    statement_120:;
    }
    if (dp0 <= dpcoal && dr0 <= drcoal) {
      iover(isg) = 1;
    }
  statement_150:;
  }
  /// C
  /// C2     meson qbar coalesce with all available q:
  FEM_DO_SAFE(isg, 1, nsg) {
    if (njsgs(isg) != 2 || iover(isg) == 1) {
      goto statement_250;
    }
    /// C     DETERMINE CURRENT RELATIVE DISTANCE AND MOMENTUM:
    FEM_DO_SAFE(j, 1, 2) {
      ftp(j) = ftsgs(isg, j);
      gxp(j) = gxsgs(isg, j);
      gyp(j) = gysgs(isg, j);
      gzp(j) = gzsgs(isg, j);
      pxp(j) = pxsgs(isg, j);
      pyp(j) = pysgs(isg, j);
      pzp(j) = pzsgs(isg, j);
      pmp(j) = pmsgs(isg, j);
      pep(j) = pesgs(isg, j);
    }
    locldr(cmn, 2, drlocl);
    dr0 = drlocl;
    dp0 = fem::dsqrt(2 * (pep(1) * pep(2) - pxp(1) * pxp(2) - pyp(1) * pyp(2) -
                          pzp(1) * pzp(2) - pmp(1) * pmp(2)));
    /// C
    FEM_DO_SAFE(jsg, 1, nsg) {
      if (jsg == isg || iover(jsg) == 1) {
        goto statement_220;
      }
      if (njsgs(jsg) == 2) {
        ipmin = 1;
        ipmax = 1;
      } else if (njsgs(jsg) == 3 && k2sgs(jsg, 1) > 0) {
        ipmin = 1;
        ipmax = 3;
      } else {
        goto statement_220;
      }
      FEM_DO_SAFE(ip, ipmin, ipmax) {
        dplocl =
            fem::dsqrt(2 * (pep(2) * pesgs(jsg, ip) - pxp(2) * pxsgs(jsg, ip) -
                            pyp(2) * pysgs(jsg, ip) - pzp(2) * pzsgs(jsg, ip) -
                            pmp(2) * pmsgs(jsg, ip)));
        /// C     skip if outside of momentum radius:
        if (dplocl > dpcoal) {
          goto statement_220;
        }
        ftp(1) = ftsgs(jsg, ip);
        gxp(1) = gxsgs(jsg, ip);
        gyp(1) = gysgs(jsg, ip);
        gzp(1) = gzsgs(jsg, ip);
        pxp(1) = pxsgs(jsg, ip);
        pyp(1) = pysgs(jsg, ip);
        pzp(1) = pzsgs(jsg, ip);
        pmp(1) = pmsgs(jsg, ip);
        pep(1) = pesgs(jsg, ip);
        locldr(cmn, 2, drlocl);
        /// C     skip if outside of spatial radius:
        if (drlocl > drcoal) {
          goto statement_220;
        }
        /// C     qbar_isg coalesces with q_jsg:
        if ((dp0 > dpcoal || dr0 > drcoal) || (drlocl < dr0)) {
          dp0 = dplocl;
          dr0 = drlocl;
          exchge(cmn, isg, 1, jsg, ip);
        }
      }
    statement_220:;
    }
    if (dp0 <= dpcoal && dr0 <= drcoal) {
      iover(isg) = 1;
    }
  statement_250:;
  }
  /// C
  /// C3     baryon q (antibaryon qbar) coalesce with all available q (qbar):
  FEM_DO_SAFE(isg, 1, nsg) {
    if (njsgs(isg) != 3 || iover(isg) == 1) {
      goto statement_350;
    }
    ibaryn = k2sgs(isg, 1);
    /// C     DETERMINE CURRENT RELATIVE DISTANCE AND MOMENTUM:
    FEM_DO_SAFE(j, 1, 2) {
      ftp(j) = ftsgs(isg, j);
      gxp(j) = gxsgs(isg, j);
      gyp(j) = gysgs(isg, j);
      gzp(j) = gzsgs(isg, j);
      pxp(j) = pxsgs(isg, j);
      pyp(j) = pysgs(isg, j);
      pzp(j) = pzsgs(isg, j);
      pmp(j) = pmsgs(isg, j);
      pep(j) = pesgs(isg, j);
    }
    locldr(cmn, 2, drlocl);
    dr1(2) = drlocl;
    dp1(2) =
        fem::dsqrt(2 * (pep(1) * pep(2) - pxp(1) * pxp(2) - pyp(1) * pyp(2) -
                        pzp(1) * pzp(2) - pmp(1) * pmp(2)));
    /// C
    ftp(2) = ftsgs(isg, 3);
    gxp(2) = gxsgs(isg, 3);
    gyp(2) = gysgs(isg, 3);
    gzp(2) = gzsgs(isg, 3);
    pxp(2) = pxsgs(isg, 3);
    pyp(2) = pysgs(isg, 3);
    pzp(2) = pzsgs(isg, 3);
    pmp(2) = pmsgs(isg, 3);
    pep(2) = pesgs(isg, 3);
    locldr(cmn, 2, drlocl);
    dr1(3) = drlocl;
    dp1(3) =
        fem::dsqrt(2 * (pep(1) * pep(2) - pxp(1) * pxp(2) - pyp(1) * pyp(2) -
                        pzp(1) * pzp(2) - pmp(1) * pmp(2)));
    /// C
    FEM_DO_SAFE(jsg, 1, nsg) {
      if (jsg == isg || iover(jsg) == 1) {
        goto statement_320;
      }
      if (njsgs(jsg) == 2) {
        if (ibaryn > 0) {
          ipmin = 1;
        } else {
          ipmin = 2;
        }
        ipmax = ipmin;
      } else if (njsgs(jsg) == 3 && (ibaryn * k2sgs(jsg, 1)) > 0) {
        ipmin = 1;
        ipmax = 3;
      } else {
        goto statement_320;
      }
      FEM_DO_SAFE(ip, ipmin, ipmax) {
        dplocl =
            fem::dsqrt(2 * (pep(1) * pesgs(jsg, ip) - pxp(1) * pxsgs(jsg, ip) -
                            pyp(1) * pysgs(jsg, ip) - pzp(1) * pzsgs(jsg, ip) -
                            pmp(1) * pmsgs(jsg, ip)));
        /// C     skip if outside of momentum radius:
        if (dplocl > dpcoal) {
          goto statement_320;
        }
        ftp(2) = ftsgs(jsg, ip);
        gxp(2) = gxsgs(jsg, ip);
        gyp(2) = gysgs(jsg, ip);
        gzp(2) = gzsgs(jsg, ip);
        pxp(2) = pxsgs(jsg, ip);
        pyp(2) = pysgs(jsg, ip);
        pzp(2) = pzsgs(jsg, ip);
        pmp(2) = pmsgs(jsg, ip);
        pep(2) = pesgs(jsg, ip);
        locldr(cmn, 2, drlocl);
        /// C     skip if outside of spatial radius:
        if (drlocl > drcoal) {
          goto statement_320;
        }
        /// C     q_isg may coalesce with q_jsg for a baryon:
        ipi = 0;
        if (dp1(2) > dpcoal || dr1(2) > drcoal) {
          ipi = 2;
          if ((dp1(3) > dpcoal || dr1(3) > drcoal) && dr1(3) > dr1(2)) {
            ipi = 3;
          }
        } else if (dp1(3) > dpcoal || dr1(3) > drcoal) {
          ipi = 3;
        } else if (dr1(2) < dr1(3)) {
          if (drlocl < dr1(3)) {
            ipi = 3;
          }
        } else if (dr1(3) <= dr1(2)) {
          if (drlocl < dr1(2)) {
            ipi = 2;
          }
        }
        if (ipi != 0) {
          dp1(ipi) = dplocl;
          dr1(ipi) = drlocl;
          exchge(cmn, isg, ipi, jsg, ip);
        }
      }
    statement_320:;
    }
    if (dp1(2) <= dpcoal && dr1(2) <= drcoal && dp1(3) <= dpcoal &&
        dr1(3) <= drcoal) {
      iover(isg) = 1;
    }
  statement_350:;
  }
  /// C
}

struct index1_save {
  int i;
  int indxt;
  int ir;
  int j;
  int l;
  double q;

  index1_save()
      : i(fem::int0),
        indxt(fem::int0),
        ir(fem::int0),
        j(fem::int0),
        l(fem::int0),
        q(fem::double0) {}
};

void index1(common& cmn, int const& n, int const& m, arr_cref<double> arrin,
            arr_ref<int> indx) {
  FEM_CMN_SVE(index1);
  arrin(dimension(n));
  indx(dimension(n));
  int& i = sve.i;
  int& indxt = sve.indxt;
  int& ir = sve.ir;
  int& j = sve.j;
  int& l = sve.l;
  double& q = sve.q;
  /// C     indexes the first m elements of ARRIN of length n, i.e., outputs
  /// INDX C     such that ARRIN(INDEX(J)) is in ascending order for J=1,...,m
  /// C
  FEM_DO_SAFE(j, 1, m) { indx(j) = j; }
  l = m / 2 + 1;
  ir = m;
statement_10:
  if (l > 1) {
    l = l - 1;
    indxt = indx(l);
    q = arrin(indxt);
  } else {
    indxt = indx(ir);
    q = arrin(indxt);
    indx(ir) = indx(1);
    ir = ir - 1;
    if (ir == 1) {
      indx(1) = indxt;
      return;
    }
  }
  i = l;
  j = l + l;
statement_20:
  if (j <= ir) {
    if (j < ir) {
      if (arrin(indx(j)) < arrin(indx(j + 1))) {
        j++;
      }
    }
    if (q < arrin(indx(j))) {
      indx(i) = indx(j);
      i = j;
      j += j;
    } else {
      j = ir + 1;
    }
    goto statement_20;
  }
  indx(i) = indxt;
  goto statement_10;
  /// C
}

struct ptoh_save {
  static const int maxstr = 150001;

  double beta2;
  double bex;
  double bey;
  double bez;
  double drlocl;
  double e1;
  double e2;
  double e3;
  double etot;
  double ftavg0;
  double gam;
  double gxavg0;
  double gyavg0;
  double gzavg0;
  int i;
  int ibs;
  int idqspn;
  int imspin;
  int inatt;
  arr<int> indx;
  int ipartn;
  int isg;
  int iuudd;
  int ix;
  int k1;
  int k1abs;
  int k2;
  int k2abs;
  int k3;
  int k3abs;
  int kdq;
  int kf;
  int kf1;
  int kf2;
  int ki;
  int kj;
  int kk;
  int kmax;
  int kmin;
  int ktemp;
  int mstj24;
  arr<int> ndiag;
  int npi0;
  int npich;
  int nrhoch;
  int nuudd;
  double p1;
  double p2;
  double p3;
  float ppi0;
  float prho0;
  double px1;
  double px2;
  double px3;
  double py1;
  double py2;
  double py3;
  double pz1;
  double pz2;
  double pz3;
  float tau0;
  arr<double> xmdiag;
  double xmpair;

  ptoh_save()
      : beta2(fem::double0),
        bex(fem::double0),
        bey(fem::double0),
        bez(fem::double0),
        drlocl(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        e3(fem::double0),
        etot(fem::double0),
        ftavg0(fem::double0),
        gam(fem::double0),
        gxavg0(fem::double0),
        gyavg0(fem::double0),
        gzavg0(fem::double0),
        i(fem::int0),
        ibs(fem::int0),
        idqspn(fem::int0),
        imspin(fem::int0),
        inatt(fem::int0),
        indx(dimension(maxstr), fem::fill0),
        ipartn(fem::int0),
        isg(fem::int0),
        iuudd(fem::int0),
        ix(fem::int0),
        k1(fem::int0),
        k1abs(fem::int0),
        k2(fem::int0),
        k2abs(fem::int0),
        k3(fem::int0),
        k3abs(fem::int0),
        kdq(fem::int0),
        kf(fem::int0),
        kf1(fem::int0),
        kf2(fem::int0),
        ki(fem::int0),
        kj(fem::int0),
        kk(fem::int0),
        kmax(fem::int0),
        kmin(fem::int0),
        ktemp(fem::int0),
        mstj24(fem::int0),
        ndiag(dimension(maxstr), fem::fill0),
        npi0(fem::int0),
        npich(fem::int0),
        nrhoch(fem::int0),
        nuudd(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        ppi0(fem::float0),
        prho0(fem::float0),
        px1(fem::double0),
        px2(fem::double0),
        px3(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        py3(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        pz3(fem::double0),
        tau0(fem::float0),
        xmdiag(dimension(maxstr), fem::fill0),
        xmpair(fem::double0) {}
};

const int ptoh_save::maxstr;

/// C
/// C=======================================================================
void ptoh(common& cmn) {
  FEM_CMN_SVE(ptoh);
  common_write write(cmn);
  /// COMMON loclco
  arr_ref<double> gxp(cmn.gxp, dimension(3));
  arr_ref<double> gyp(cmn.gyp, dimension(3));
  arr_ref<double> gzp(cmn.gzp, dimension(3));
  arr_ref<double> ftp(cmn.ftp, dimension(3));
  arr_ref<double> pxp(cmn.pxp, dimension(3));
  arr_ref<double> pyp(cmn.pyp, dimension(3));
  arr_ref<double> pzp(cmn.pzp, dimension(3));
  arr_ref<double> pep(cmn.pep, dimension(3));
  arr_ref<double> pmp(cmn.pmp, dimension(3));
  /// COMMON hmain1
  float& eatt = cmn.eatt;
  int& natt = cmn.natt;
  /// COMMON hmain2
  const int maxstr = 150001;
  arr_ref<int, 2> katt(cmn.katt, dimension(maxstr, 4));
  arr_ref<float, 2> patt(cmn.patt, dimension(maxstr, 4));
  /// COMMON hjjet2
  int& nsg = cmn.nsg;
  /// COMMON arprnt
  arr_cref<float> arpar1(cmn.arpar1, dimension(100));
  /// COMMON arprc
  arr_ref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_ref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_ref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_ref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_ref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_ref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_ref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_ref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_ref<float> pear(cmn.pear, dimension(maxstr));
  arr_ref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON soft
  arr_cref<double, 2> pxsgs(cmn.pxsgs, dimension(maxstr, 3));
  arr_cref<double, 2> pysgs(cmn.pysgs, dimension(maxstr, 3));
  arr_cref<double, 2> pzsgs(cmn.pzsgs, dimension(maxstr, 3));
  arr_cref<double, 2> pesgs(cmn.pesgs, dimension(maxstr, 3));
  arr_cref<double, 2> pmsgs(cmn.pmsgs, dimension(maxstr, 3));
  arr_cref<double, 2> gxsgs(cmn.gxsgs, dimension(maxstr, 3));
  arr_cref<double, 2> gysgs(cmn.gysgs, dimension(maxstr, 3));
  arr_cref<double, 2> gzsgs(cmn.gzsgs, dimension(maxstr, 3));
  arr_cref<double, 2> ftsgs(cmn.ftsgs, dimension(maxstr, 3));
  arr_cref<int, 2> k2sgs(cmn.k2sgs, dimension(maxstr, 3));
  arr_cref<int> njsgs(cmn.njsgs, dimension(maxstr));
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON anim
  int& isoft = cmn.isoft;
  /// COMMON prtn23
  arr_cref<double> gxp0(cmn.gxp0, dimension(3));
  arr_cref<double> gyp0(cmn.gyp0, dimension(3));
  arr_cref<double> gzp0(cmn.gzp0, dimension(3));
  /// COMMON ludat1
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  /// COMMON para7
  int& ioscar = cmn.ioscar;
  int& nsmbbbar = cmn.nsmbbbar;
  int& nsmmeson = cmn.nsmmeson;
  ///
  /// SAVE
  double& beta2 = sve.beta2;
  double& bex = sve.bex;
  double& bey = sve.bey;
  double& bez = sve.bez;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  double& e3 = sve.e3;
  double& etot = sve.etot;
  double& ftavg0 = sve.ftavg0;
  double& gam = sve.gam;
  double& gxavg0 = sve.gxavg0;
  double& gyavg0 = sve.gyavg0;
  double& gzavg0 = sve.gzavg0;
  int& i = sve.i;
  int& ibs = sve.ibs;
  int& idqspn = sve.idqspn;
  int& imspin = sve.imspin;
  int& inatt = sve.inatt;
  arr_ref<int> indx(sve.indx, dimension(maxstr));
  int& ipartn = sve.ipartn;
  int& isg = sve.isg;
  int& iuudd = sve.iuudd;
  int& ix = sve.ix;
  int& k1 = sve.k1;
  int& k1abs = sve.k1abs;
  int& k2 = sve.k2;
  int& k2abs = sve.k2abs;
  int& k3 = sve.k3;
  int& k3abs = sve.k3abs;
  int& kdq = sve.kdq;
  int& kf = sve.kf;
  int& kf1 = sve.kf1;
  int& kf2 = sve.kf2;
  int& ki = sve.ki;
  int& kj = sve.kj;
  int& kk = sve.kk;
  int& kmax = sve.kmax;
  int& kmin = sve.kmin;
  int& ktemp = sve.ktemp;
  int& mstj24 = sve.mstj24;
  arr_ref<int> ndiag(sve.ndiag, dimension(maxstr));
  int& npi0 = sve.npi0;
  int& npich = sve.npich;
  int& nrhoch = sve.nrhoch;
  int& nuudd = sve.nuudd;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  float& ppi0 = sve.ppi0;
  float& prho0 = sve.prho0;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& px3 = sve.px3;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& py3 = sve.py3;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& pz3 = sve.pz3;
  float& tau0 = sve.tau0;
  arr_ref<double> xmdiag(sve.xmdiag, dimension(maxstr));
  double& xmpair = sve.xmpair;
  ///
  static const char* format_312 = "(i6,4(1x,f10.3),1x,i6,1x,i6)";
  /// C
  /// Clin-9/2012: improve precision for argument in sqrt():
  /// Cc      SAVE /loclco/
  /// Cc      SAVE /HMAIN1/
  /// Cc      SAVE /HMAIN2/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /ARPRNT/
  /// Cc      SAVE /ARPRC/
  /// Cc      SAVE /SOFT/
  /// Cc      SAVE /RNDF77/
  /// Cc      SAVE /anim/
  /// Cc      SAVE /prtn23/
  /// Cc      SAVE /nzpc/
  /// Cc      SAVE /lor/
  /// Cc      SAVE /LUDAT1/
  /// Clin 4/19/2006
  /// Clin-5/2011
  /// C
  coales(cmn);
  /// C     obtain particle mass here without broadening by Breit-Wigner width:
  mstj24 = mstj(24);
  mstj(24) = 0;
  nuudd = 0;
  npich = 0;
  nrhoch = 0;
  ppi0 = 1.f;
  prho0 = 0.f;
  /// C     determine hadron flavor except (pi0,rho0,eta,omega):
  FEM_DO_SAFE(isg, 1, nsg) {
    if (njsgs(isg) != 0) {
      natt++;
      k1 = k2sgs(isg, 1);
      k1abs = fem::iabs(k1);
      px1 = pxsgs(isg, 1);
      py1 = pysgs(isg, 1);
      pz1 = pzsgs(isg, 1);
      k2 = k2sgs(isg, 2);
      k2abs = fem::iabs(k2);
      px2 = pxsgs(isg, 2);
      py2 = pysgs(isg, 2);
      pz2 = pzsgs(isg, 2);
      /// C     5/02/01 try lowest spin states as first choices,
      /// C     i.e. octet baryons and pseudoscalar mesons (ibs=2*baryonspin+1):
      e1 = pesgs(isg, 1);
      e2 = pesgs(isg, 2);
      xmpair = fem::dsqrt(fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
                          fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2)));
      ibs = 2;
      imspin = 0;
      if (k1 == -k2 && fem::iabs(k1) <= 2 && njsgs(isg) == 2) {
        nuudd++;
        xmdiag(nuudd) = xmpair;
        ndiag(nuudd) = natt;
      }
      k3 = 0;
      if ((isoft == 4 || isoft == 5) && njsgs(isg) == 3) {
        k3 = k2sgs(isg, 3);
        k3abs = fem::iabs(k3);
        px3 = pxsgs(isg, 3);
        py3 = pysgs(isg, 3);
        pz3 = pzsgs(isg, 3);
        e3 = pesgs(isg, 3);
        xmpair = fem::dsqrt(
            fem::pow2((e1 + e2 + e3)) - fem::pow2((px1 + px2 + px3)) -
            fem::pow2((py1 + py2 + py3)) - fem::pow2((pz1 + pz2 + pz3)));
      }
      /// C*****     isoft=3 baryon decomposition is different:
      if (isoft == 3 && (k1abs > 1000 || k2abs > 1000)) {
        if (k1abs > 1000) {
          kdq = k1abs;
          kk = k2abs;
        } else {
          kdq = k2abs;
          kk = k1abs;
        }
        ki = fem::mod(kdq / 1000, 10);
        kj = fem::mod(kdq / 100, 10);
        if (fem::mod(kdq, 10) == 1) {
          idqspn = 0;
        } else {
          idqspn = 1;
        }
        /// C
        if (kk > ki) {
          ktemp = kk;
          kk = kj;
          kj = ki;
          ki = ktemp;
        } else if (kk > kj) {
          ktemp = kk;
          kk = kj;
          kj = ktemp;
        }
        /// C
        if (ki != kj && ki != kk && kj != kk) {
          if (idqspn == 0) {
            kf = 1000 * ki + 100 * kk + 10 * kj + ibs;
          } else {
            kf = 1000 * ki + 100 * kj + 10 * kk + ibs;
          }
        } else if (ki == kj && ki == kk) {
          /// C     can only be decuplet baryons:
          kf = 1000 * ki + 100 * kj + 10 * kk + 4;
        } else {
          kf = 1000 * ki + 100 * kj + 10 * kk + ibs;
        }
        /// C     form a decuplet baryon if the q+diquark mass is closer to its
        /// mass C     (and if the diquark has spin 1): Cc     for now only
        /// include Delta, which is present in ART: Cc
        /// if(idqspn.eq.1.and.MOD(kf,10).eq.2) then
        if (kf == 2112 || kf == 2212) {
          if (fem::abs(fem::sngl(xmpair) - ulmass(cmn, kf)) >
              fem::abs(fem::sngl(xmpair) - ulmass(cmn, kf + 2))) {
            kf += 2;
          }
        }
        if (k1 < 0) {
          kf = -kf;
        }
        /// Clin-6/22/01 isoft=4or5 baryons:
      } else if ((isoft == 4 || isoft == 5) && njsgs(isg) == 3) {
        if (k1abs > k2abs) {
          ki = k1abs;
          kk = k2abs;
        } else {
          ki = k2abs;
          kk = k1abs;
        }
        if (k3abs > ki) {
          kj = ki;
          ki = k3abs;
        } else if (k3abs < kk) {
          kj = kk;
          kk = k3abs;
        } else {
          kj = k3abs;
        }
        /// C
        if (ki == kj && ki == kk) {
          /// C     can only be decuplet baryons (Delta-,++, Omega):
          ibs = 4;
          kf = 1000 * ki + 100 * kj + 10 * kk + ibs;
        } else if (ki != kj && ki != kk && kj != kk) {
          /// C     form Lambda or Sigma according to 3-quark mass,
          /// C     for now neglect decuplet (Sigma*0 etc) which is absent in
          /// ART:
          ibs = 2;
          kf1 = 1000 * ki + 100 * kj + 10 * kk + ibs;
          kf2 = 1000 * ki + 100 * kk + 10 * kj + ibs;
          kf = kf1;
          if (fem::abs(fem::sngl(xmpair) - ulmass(cmn, kf1)) >
              fem::abs(fem::sngl(xmpair) - ulmass(cmn, kf2))) {
            kf = kf2;
          }
        } else {
          ibs = 2;
          kf = 1000 * ki + 100 * kj + 10 * kk + ibs;
          /// Cc     for now only include Delta0,+ as decuplets, which are
          /// present in ART:
          if (kf == 2112 || kf == 2212) {
            if (fem::abs(fem::sngl(xmpair) - ulmass(cmn, kf)) >
                fem::abs(fem::sngl(xmpair) - ulmass(cmn, kf + 2))) {
              kf += 2;
            }
          }
        }
        if (k1 < 0) {
          kf = -kf;
        }
        /// C*****     mesons:
      } else {
        if (k1abs == k2abs) {
          if (k1abs <= 2) {
            /// C     treat diagonal mesons later in the subroutine:
            kf = 0;
          } else if (k1abs <= 3) {
            /// C     do not form eta', only form phi from s-sbar, since no eta'
            /// in ART:
            kf = 333;
          } else {
            kf = 100 * k1abs + 10 * k1abs + 2 * imspin + 1;
          }
        } else {
          if (k1abs > k2abs) {
            kmax = k1abs;
            kmin = k2abs;
          } else if (k1abs < k2abs) {
            kmax = k2abs;
            kmin = k1abs;
          }
          kf = (100 * kmax + 10 * kmin + 2 * imspin + 1) *
               fem::isign(1, k1 + k2) * fem::pow((-1), kmax);
          /// C     form a vector meson if the q+qbar mass is closer to its
          /// mass:
          if (fem::mod(fem::iabs(kf), 10) == 1) {
            if (fem::abs(fem::sngl(xmpair) - ulmass(cmn, fem::iabs(kf))) >
                fem::abs(fem::sngl(xmpair) - ulmass(cmn, fem::iabs(kf) + 2))) {
              kf = (fem::iabs(kf) + 2) * fem::isign(1, kf);
            }
          }
        }
      }
      itypar(natt) = kf;
      katt(natt, 1) = kf;
      if (fem::iabs(kf) == 211) {
        npich++;
      } else if (fem::iabs(kf) == 213) {
        nrhoch++;
      }
    }
    /// Clin-7/2011-check charm hadron flavors:
    /// C           if(k1abs.eq.4.or.k2abs.eq.4) then
    /// C              if(k3.eq.0) then
    /// C                 write(99,*) iaevt,k1,k2,kf,xmpair,
    /// C     1                ULMASS(iabs(kf)),ULMASS(iabs(kf)+2),isg
    /// C              else
    /// C                 write(99,*) iaevt,k1,k2,k3,kf,xmpair,
    /// C     1                ULMASS(iabs(kf)),ULMASS(iabs(kf)+2),isg
    /// C              endif
    /// C           endif
    /// Clin-7/2011-end
  }
  /// C     assume Npi0=(Npi+ + Npi-)/2, Nrho0=(Nrho+ + Nrho-)/2 on the average:
  if (nuudd != 0) {
    ppi0 = fem::ffloat(npich / 2) / fem::ffloat(nuudd);
    prho0 = fem::ffloat(nrhoch / 2) / fem::ffloat(nuudd);
  }
  /// C     determine diagonal mesons (pi0,rho0,eta and omega) from uubar/ddbar:
  npi0 = 0;
  FEM_DO_SAFE(isg, 1, nsg) {
    if (k2sgs(isg, 1) == -k2sgs(isg, 2) && fem::iabs(k2sgs(isg, 1)) <= 2 &&
        njsgs(isg) == 2) {
      if (ranart(nseed) <= ppi0) {
        npi0++;
      }
    }
  }
  /// C
  if (nuudd > 1) {
    index1(cmn, maxstr, nuudd, xmdiag, indx);
  } else {
    indx(1) = 1;
  }
  /// C
  FEM_DO_SAFE(ix, 1, nuudd) {
    iuudd = indx(ix);
    inatt = ndiag(iuudd);
    if (ix <= npi0) {
      kf = 111;
    } else if (ranart(nseed) <= (prho0 / (1 - ppi0 + 0.00001f))) {
      kf = 113;
    } else {
      /// C     at T=150MeV, thermal weights for eta and omega(spin1) are about
      /// the same:
      if (ranart(nseed) <= 0.5f) {
        kf = 221;
      } else {
        kf = 223;
      }
    }
    itypar(inatt) = kf;
    katt(inatt, 1) = kf;
  }
  /// C  determine hadron formation time, position and momentum:
  inatt = 0;
  /// Clin-6/2009 write out parton info after coalescence:
  if (ioscar == 3) {
    write(85, "(4i8,f10.4,5i5)"), cmn.iaevt, 3 * nsmbbbar + 2 * nsmmeson,
        nsmbbbar, nsmmeson, cmn.bimp, cmn.nelp, cmn.ninp, cmn.nelt, cmn.ninthj,
        cmn.miss;
  }
  /// C
  FEM_DO_SAFE(isg, 1, nsg) {
    if (njsgs(isg) != 0) {
      inatt++;
      k1 = k2sgs(isg, 1);
      k1abs = fem::iabs(k1);
      px1 = pxsgs(isg, 1);
      py1 = pysgs(isg, 1);
      pz1 = pzsgs(isg, 1);
      k2 = k2sgs(isg, 2);
      k2abs = fem::iabs(k2);
      px2 = pxsgs(isg, 2);
      py2 = pysgs(isg, 2);
      pz2 = pzsgs(isg, 2);
      e1 = pesgs(isg, 1);
      e2 = pesgs(isg, 2);
      /// C
      if (njsgs(isg) == 2) {
        pxar(inatt) = fem::sngl(px1 + px2);
        pyar(inatt) = fem::sngl(py1 + py2);
        pzar(inatt) = fem::sngl(pz1 + pz2);
        patt(inatt, 1) = pxar(inatt);
        patt(inatt, 2) = pyar(inatt);
        patt(inatt, 3) = pzar(inatt);
        etot = e1 + e2;
        /// Clin-9/2012: improve precision for argument in sqrt():
        p1 = px1 + px2;
        p2 = py1 + py2;
        p3 = pz1 + pz2;
        /// C
      } else if ((isoft == 4 || isoft == 5) && njsgs(isg) == 3) {
        px3 = pxsgs(isg, 3);
        py3 = pysgs(isg, 3);
        pz3 = pzsgs(isg, 3);
        e3 = pesgs(isg, 3);
        pxar(inatt) = fem::sngl(px1 + px2 + px3);
        pyar(inatt) = fem::sngl(py1 + py2 + py3);
        pzar(inatt) = fem::sngl(pz1 + pz2 + pz3);
        patt(inatt, 1) = pxar(inatt);
        patt(inatt, 2) = pyar(inatt);
        patt(inatt, 3) = pzar(inatt);
        etot = e1 + e2 + e3;
        /// Clin-9/2012: improve precision for argument in sqrt():
        p1 = px1 + px2 + px3;
        p2 = py1 + py2 + py3;
        p3 = pz1 + pz2 + pz3;
        /// C
      }
      xmar(inatt) = ulmass(cmn, itypar(inatt));
      /// Clin-5/2011-add finite width to resonances
      /// (rho,omega,eta,K*,phi,Delta) after formation:
      kf = katt(inatt, 1);
      if (kf == 113 || fem::abs(kf) == 213 || kf == 221 || kf == 223 ||
          fem::abs(kf) == 313 || fem::abs(kf) == 323 || kf == 333 ||
          fem::abs(kf) == 1114 || fem::abs(kf) == 2114 ||
          fem::abs(kf) == 2214 || fem::abs(kf) == 2224) {
        xmar(inatt) = resmass(cmn, kf);
      }
      /// C
      pear(inatt) = fem::sqrt(fem::pow2(pxar(inatt)) + fem::pow2(pyar(inatt)) +
                              fem::pow2(pzar(inatt)) + fem::pow2(xmar(inatt)));
      patt(inatt, 4) = pear(inatt);
      eatt += pear(inatt);
      ipartn = njsgs(isg);
      FEM_DO_SAFE(i, 1, ipartn) {
        ftp(i) = ftsgs(isg, i);
        gxp(i) = gxsgs(isg, i);
        gyp(i) = gysgs(isg, i);
        gzp(i) = gzsgs(isg, i);
        pxp(i) = pxsgs(isg, i);
        pyp(i) = pysgs(isg, i);
        pzp(i) = pzsgs(isg, i);
        pmp(i) = pmsgs(isg, i);
        pep(i) = pesgs(isg, i);
      }
      locldr(cmn, ipartn, sve.drlocl);
      /// C
      tau0 = arpar1(1);
      ftavg0 = cmn.ft0fom + fem::dble(tau0);
      gxavg0 = 0e0;
      gyavg0 = 0e0;
      gzavg0 = 0e0;
      FEM_DO_SAFE(i, 1, ipartn) {
        gxavg0 += gxp0(i) / ipartn;
        gyavg0 += gyp0(i) / ipartn;
        gzavg0 += gzp0(i) / ipartn;
      }
      /// Clin-9/2012: improve precision for argument in sqrt():
      /// C            bex=dble(PXAR(inatt))/etot
      /// C            bey=dble(PYAR(inatt))/etot
      /// C            bez=dble(PZAR(inatt))/etot
      bex = p1 / etot;
      bey = p2 / etot;
      bez = p3 / etot;
      /// C
      beta2 = fem::pow2(bex) + fem::pow2(bey) + fem::pow2(bez);
      gam = 1.e0 / fem::dsqrt(1.e0 - beta2);
      if (beta2 >= 0.9999999999999e0) {
        write(6, star), "2", bex, bey, bez, beta2, gam;
      }
      /// C
      lorenz(cmn, ftavg0, gxavg0, gyavg0, gzavg0, -bex, -bey, -bez);
      gxar(inatt) = fem::sngl(cmn.pxnew);
      gyar(inatt) = fem::sngl(cmn.pynew);
      gzar(inatt) = fem::sngl(cmn.pznew);
      ftar(inatt) = fem::sngl(cmn.enenew);
      /// Clin 4/19/2006 write out parton info after coalescence:
      if (ioscar == 3) {
        write(85, "(i6,4(1x,f10.3),1x,i6,1x,i6,1x,f10.3)"), k2sgs(isg, 1), px1,
            py1, pz1, pmsgs(isg, 1), inatt, katt(inatt, 1), xmar(inatt);
        write(85, format_312), k2sgs(isg, 2), px2, py2, pz2, pmsgs(isg, 2),
            inatt, katt(inatt, 1);
        if (njsgs(isg) == 3) {
          write(85, format_312), k2sgs(isg, 3), px3, py3, pz3, pmsgs(isg, 3),
              inatt, katt(inatt, 1);
        }
      }
      /// Clin-5/02/2011
      /// C
    }
  }
  /// C     number of hadrons formed from partons inside ZPC:
  cmn.nattzp = natt;
  mstj(24) = mstj24;
  /// C
}

struct minijet_out_save {
  float ft;
  float gx;
  float gy;
  float gz;
  int i;
  int ityp;
  int j;
  float pt;
  float px;
  float py;
  float pz;
  float xmass;

  minijet_out_save()
      : ft(fem::float0),
        gx(fem::float0),
        gy(fem::float0),
        gz(fem::float0),
        i(fem::int0),
        ityp(fem::int0),
        j(fem::int0),
        pt(fem::float0),
        px(fem::float0),
        py(fem::float0),
        pz(fem::float0),
        xmass(fem::float0) {}
};

/// C
/// C=======================================================================
/// Clin-6/2009 write out initial minijet information
/// C     before propagating to its formation time:
/// Clin-2/2012:
/// C        subroutine minijet_out(BB)
void minijet_out(common& cmn, float const& bb, float const& phirp) {
  FEM_CMN_SVE(minijet_out);
  common_write write(cmn);
  /// COMMON hparnt
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  /// COMMON hjcrdn
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  /// COMMON hjjet1
  arr_cref<int> npj(cmn.npj, dimension(300));
  arr_cref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_cref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_cref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_cref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_cref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_cref<int> ntj(cmn.ntj, dimension(300));
  arr_cref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_cref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_cref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_cref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_cref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  /// COMMON hjjet2
  int& nsg = cmn.nsg;
  const int maxstr = 150001;
  arr_cref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_cref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_cref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_cref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_cref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_cref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_cref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  /// COMMON para7
  int& ioscar = cmn.ioscar;
  /// COMMON phidcy
  float& pttrig = cmn.pttrig;
  int& ntrig = cmn.ntrig;
  ///
  /// SAVE
  float& ft = sve.ft;
  float& gx = sve.gx;
  float& gy = sve.gy;
  float& gz = sve.gz;
  int& i = sve.i;
  int& ityp = sve.ityp;
  int& j = sve.j;
  float& pt = sve.pt;
  float& px = sve.px;
  float& py = sve.py;
  float& pz = sve.pz;
  float& xmass = sve.xmass;
  ///
  static const char* format_200 =
      "(i6,2(1x,f8.3),1x,f10.3,1x,f6.3,2(1x,f8.2),2(2x,f2.0),2x,i2)";
  static const char* format_201 =
      "(i6,2(1x,f8.3),1x,f10.3,1x,f6.3,2(1x,e8.2),2(2x,f2.0),2x,i2)";
  ntrig = 0;
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      pt = fem::sqrt(fem::pow2(pjpx(i, j)) + fem::pow2(pjpy(i, j)));
      if (pt >= pttrig) {
        ntrig++;
      }
    }
  }
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      pt = fem::sqrt(fem::pow2(pjtx(i, j)) + fem::pow2(pjty(i, j)));
      if (pt >= pttrig) {
        ntrig++;
      }
    }
  }
  FEM_DO_SAFE(i, 1, nsg) {
    FEM_DO_SAFE(j, 1, njsg(i)) {
      pt = fem::sqrt(fem::pow2(pxsg(i, j)) + fem::pow2(pysg(i, j)));
      if (pt >= pttrig) {
        ntrig++;
      }
    }
  }
  /// C     Require at least 1 initial minijet parton above the trigger Pt
  /// value:
  if (ntrig == 0) {
    return;
  }
  /// C
  /// C.....transfer data from HIJING to ZPC
  if (ioscar == 3) {
    write(96, star), cmn.iaevt, cmn.miss, ihnt2(1), ihnt2(3);
  }
  FEM_DO_SAFE(i, 1, ihnt2(1)) {
    FEM_DO_SAFE(j, 1, npj(i)) {
      ityp = kfpj(i, j);
      /// C     write out not only gluons:
      /// C              if(ityp.ne.21) goto 1007
      /// Clin-2/2012:
      /// C              gx=YP(1,I)+0.5*BB
      /// C              gy=YP(2,I)
      gx = yp(1, i) + 0.5f * bb * fem::cos(phirp);
      gy = yp(2, i) + 0.5f * bb * fem::sin(phirp);
      gz = 0.f;
      ft = 0.f;
      px = pjpx(i, j);
      py = pjpy(i, j);
      pz = pjpz(i, j);
      xmass = pjpm(i, j);
      if (ioscar == 3) {
        if (fem::amax1(fem::abs(gx), fem::abs(gy), fem::abs(gz), fem::abs(ft)) <
            9999) {
          write(96, format_200), ityp, px, py, pz, xmass, gx, gy, gz, ft, 1;
        } else {
          write(96, format_201), ityp, px, py, pz, xmass, gx, gy, gz, ft, 1;
        }
      }
    }
  }
  FEM_DO_SAFE(i, 1, ihnt2(3)) {
    FEM_DO_SAFE(j, 1, ntj(i)) {
      ityp = kftj(i, j);
      /// C              if(ityp.ne.21) goto 1009
      /// Clin-2/2012:
      /// C              gx=YT(1,I)-0.5*BB
      /// C              gy=YT(2,I)
      gx = yt(1, i) - 0.5f * bb * fem::cos(phirp);
      gy = yt(2, i) - 0.5f * bb * fem::sin(phirp);
      gz = 0.f;
      ft = 0.f;
      px = pjtx(i, j);
      py = pjty(i, j);
      pz = pjtz(i, j);
      xmass = pjtm(i, j);
      if (ioscar == 3) {
        if (fem::amax1(fem::abs(gx), fem::abs(gy), fem::abs(gz), fem::abs(ft)) <
            9999) {
          write(96, format_200), ityp, px, py, pz, xmass, gx, gy, gz, ft, 2;
        } else {
          write(96, format_201), ityp, px, py, pz, xmass, gx, gy, gz, ft, 2;
        }
      }
    }
  }
  FEM_DO_SAFE(i, 1, nsg) {
    FEM_DO_SAFE(j, 1, njsg(i)) {
      ityp = k2sg(i, j);
      /// C              if(ityp.ne.21) goto 1011
      gx = 0.5f * (yp(1, iasg(i, 1)) + yt(1, iasg(i, 2)));
      gy = 0.5f * (yp(2, iasg(i, 1)) + yt(2, iasg(i, 2)));
      gz = 0.f;
      ft = 0.f;
      px = pxsg(i, j);
      py = pysg(i, j);
      pz = pzsg(i, j);
      xmass = pmsg(i, j);
      if (ioscar == 3) {
        if (fem::amax1(fem::abs(gx), fem::abs(gy), fem::abs(gz), fem::abs(ft)) <
            9999) {
          write(96, format_200), ityp, px, py, pz, xmass, gx, gy, gz, ft, 3;
        } else {
          write(96, format_201), ityp, px, py, pz, xmass, gx, gy, gz, ft, 3;
        }
      }
    }
  }
  /// C
}

struct embedhighpt_save {
  int idpi;
  int idpi1;
  int idpis;
  int idqembd;
  int idqsoft;
  int idsart;
  int ipion;
  int ispion;
  int ixy;
  float phi;
  float pimass;
  float ptpi;
  float ptq;
  float pxpi;
  float pxpi1;
  float pxspi;
  float pypi;
  float pypi1;
  float pyspi;
  float pzpi;
  float pzpi1;
  float pzspi;
  float theta;
  float xjet;
  float xmq;
  float xmqsoft;
  float yjet;

  embedhighpt_save()
      : idpi(fem::int0),
        idpi1(fem::int0),
        idpis(fem::int0),
        idqembd(fem::int0),
        idqsoft(fem::int0),
        idsart(fem::int0),
        ipion(fem::int0),
        ispion(fem::int0),
        ixy(fem::int0),
        phi(fem::float0),
        pimass(fem::float0),
        ptpi(fem::float0),
        ptq(fem::float0),
        pxpi(fem::float0),
        pxpi1(fem::float0),
        pxspi(fem::float0),
        pypi(fem::float0),
        pypi1(fem::float0),
        pyspi(fem::float0),
        pzpi(fem::float0),
        pzpi1(fem::float0),
        pzspi(fem::float0),
        theta(fem::float0),
        xjet(fem::float0),
        xmq(fem::float0),
        xmqsoft(fem::float0),
        yjet(fem::float0) {}
};

/// C
/// C=======================================================================
/// Clin-6/2009 embed back-to-back high-Pt quark/antiquark pair
/// C     via embedding back-to-back high-Pt pion pair then melting the pion
/// pair C     by generating the internal quark and antiquark momentum parallel
/// to C      the pion momentum (in order to produce a high-Pt and a low Pt
/// parton):
void embedhighpt(common& cmn) {
  FEM_CMN_SVE(embedhighpt);
  common_read read(cmn);
  common_write write(cmn);
  /// COMMON embed
  int& iembed = cmn.iembed;
  int& nsembd = cmn.nsembd;
  float& pxqembd = cmn.pxqembd;
  float& pyqembd = cmn.pyqembd;
  float& psembd = cmn.psembd;
  float& phidecomp = cmn.phidecomp;
  /// COMMON rndf77
  int& nseed = cmn.nseed;
  /// COMMON hmain1
  float& eatt = cmn.eatt;
  int& natt = cmn.natt;
  /// COMMON hmain2
  const int maxstr = 150001;
  arr_ref<int, 2> katt(cmn.katt, dimension(maxstr, 4));
  arr_ref<float, 2> patt(cmn.patt, dimension(maxstr, 4));
  /// COMMON arprc
  arr_ref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_ref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_ref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_ref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_ref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_ref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_ref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_ref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_ref<float> pear(cmn.pear, dimension(maxstr));
  arr_ref<float> xmar(cmn.xmar, dimension(maxstr));
  /// COMMON xyembed
  int& nxyjet = cmn.nxyjet;
  const int nxymax = 10001;
  arr_cref<float, 2> xyjet(cmn.xyjet, dimension(nxymax, 2));
  ///
  /// SAVE
  int& idpi = sve.idpi;
  int& idpi1 = sve.idpi1;
  int& idpis = sve.idpis;
  int& idqembd = sve.idqembd;
  int& idqsoft = sve.idqsoft;
  int& idsart = sve.idsart;
  int& ipion = sve.ipion;
  int& ixy = sve.ixy;
  float& phi = sve.phi;
  float& pimass = sve.pimass;
  float& ptpi = sve.ptpi;
  float& ptq = sve.ptq;
  float& pxpi = sve.pxpi;
  float& pxpi1 = sve.pxpi1;
  float& pxspi = sve.pxspi;
  float& pypi = sve.pypi;
  float& pypi1 = sve.pypi1;
  float& pyspi = sve.pyspi;
  float& pzpi = sve.pzpi;
  float& pzpi1 = sve.pzpi1;
  float& pzspi = sve.pzspi;
  float& theta = sve.theta;
  float& xjet = sve.xjet;
  float& xmq = sve.xmq;
  float& xmqsoft = sve.xmqsoft;
  float& yjet = sve.yjet;
  ///
  /// C
  if (iembed == 1 || iembed == 2) {
    xjet = cmn.xembd;
    yjet = cmn.yembd;
  } else if (iembed == 3 || iembed == 4) {
    if (cmn.nevent <= nxyjet) {
      read(97, star), xjet, yjet;
    } else {
      ixy = fem::mod(cmn.iaevt, nxyjet);
      if (ixy == 0) {
        ixy = nxyjet;
      }
      xjet = xyjet(ixy, 1);
      yjet = xyjet(ixy, 2);
    }
  } else {
    return;
  }
  /// C
  ptq = fem::sqrt(fem::pow2(pxqembd) + fem::pow2(pyqembd));
  const float pichmass = 0.140f;
  if (ptq < (pichmass / 2.f)) {
    write(6, star), "Embedded quark transverse momentum is too small";
    FEM_STOP(0);
  }
  /// C     Randomly embed u/ubar or d/dbar at high Pt:
  idqembd = 1 + fem::fint(2 * ranart(nseed));
  /// C     Flavor content for the charged pion that contains the leading quark:
  if (idqembd == 1) {
    idqsoft = -2;
    idpi1 = -211;
  } else if (idqembd == 2) {
    idqsoft = -1;
    idpi1 = 211;
  } else {
    write(6, star), "Wrong quark flavor embedded";
    FEM_STOP(0);
  }
  /// C     Caculate transverse momentum of the parent charged pion:
  xmq = ulmass(cmn, idqembd);
  xmqsoft = ulmass(cmn, idqsoft);
  ptpi = ((fem::pow2(pichmass) + fem::pow2(xmq) - fem::pow2(xmqsoft)) * ptq -
          fem::sqrt((fem::pow2(xmq) + fem::pow2(ptq)) *
                    (fem::pow4(pichmass) -
                     2.f * fem::pow2(pichmass) *
                         (fem::pow2(xmq) + fem::pow2(xmqsoft)) +
                     fem::pow2((fem::pow2(xmq) - fem::pow2(xmqsoft)))))) /
         (2.f * fem::pow2(xmq));
  const float pi = 3.1415926f;
  if (iembed == 1 || iembed == 3) {
    pxpi1 = ptpi * pxqembd / ptq;
    pypi1 = ptpi * pyqembd / ptq;
    phidecomp = fem::acos(pxqembd / ptq);
    if (pyqembd < 0) {
      phidecomp = 2.f * pi - phidecomp;
    }
  } else {
    phidecomp = 2.f * pi * ranart(nseed);
    pxpi1 = ptpi * fem::cos(phidecomp);
    pypi1 = ptpi * fem::sin(phidecomp);
  }
  /// C     Embedded quark/antiquark are assumed to have pz=0:
  pzpi1 = 0.f;
  /// C     Insert the two parent charged pions,
  /// C     ipion=1 for the pion containing the leading quark,
  /// C     ipion=2 for the pion containing the leading antiquark of the same
  /// flavor:
  FEM_DO_SAFE(ipion, 1, 2) {
    if (ipion == 1) {
      idpi = idpi1;
      pxpi = pxpi1;
      pypi = pypi1;
      pzpi = pzpi1;
    } else if (ipion == 2) {
      idpi = -idpi1;
      pxpi = -pxpi1;
      pypi = -pypi1;
      pzpi = -pzpi1;
    }
    natt++;
    katt(natt, 1) = idpi;
    katt(natt, 2) = 40;
    katt(natt, 3) = 0;
    patt(natt, 1) = pxpi;
    patt(natt, 2) = pypi;
    patt(natt, 3) = pzpi;
    patt(natt, 4) = fem::sqrt(fem::pow2(pxpi) + fem::pow2(pypi) +
                              fem::pow2(pzpi) + fem::pow2(pichmass));
    eatt += patt(natt, 4);
    gxar(natt) = xjet;
    gyar(natt) = yjet;
    gzar(natt) = 0.f;
    ftar(natt) = 0.f;
    itypar(natt) = katt(natt, 1);
    pxar(natt) = patt(natt, 1);
    pyar(natt) = patt(natt, 2);
    pzar(natt) = patt(natt, 3);
    pear(natt) = patt(natt, 4);
    xmar(natt) = pichmass;
  }
  /// C
  /// Clin-8/2009
  /// C     Randomly embed a number of soft pions around each high-Pt quark in
  /// pair:
  const float pi0mass = 0.135f;
  if (nsembd > 0) {
    FEM_DO_SAFE(ipion, 1, 2) {
      FEM_DO_SAFE(sve.ispion, 1, nsembd) {
        idsart = 3 + fem::fint(3 * ranart(nseed));
        if (idsart == 3) {
          pimass = pichmass;
          idpis = -211;
        } else if (idsart == 4) {
          pimass = pi0mass;
          idpis = 111;
        } else {
          pimass = pichmass;
          idpis = 211;
        }
        natt++;
        katt(natt, 1) = idpis;
        katt(natt, 2) = 40;
        katt(natt, 3) = 0;
        /// C     theta: relative angle between soft pion & associated high-Pt q
        /// or qbar, C     generate theta and phi uniformly: C     Note: it is
        /// not generated uniformly in solid angle because that gives C     a
        /// valley at theta=0, unlike the jet-like correlation (a peak at
        /// theta=0).
        theta = cmn.tmaxembd * ranart(nseed);
        phi = 2.f * pi * ranart(nseed);
        pxspi = psembd * fem::sin(theta) * fem::cos(phi);
        pyspi = psembd * fem::sin(theta) * fem::sin(phi);
        pzspi = psembd * fem::cos(theta);
        if (ipion == 1) {
          rotate(cmn, pxpi1, pypi1, pzpi1, pxspi, pyspi, pzspi);
        } else {
          rotate(cmn, -pxpi1, -pypi1, -pzpi1, pxspi, pyspi, pzspi);
        }
        /// Ctest off
        /// C               write(99,*) "2  ",pxspi,pyspi,pzspi
        patt(natt, 1) = pxspi;
        patt(natt, 2) = pyspi;
        patt(natt, 3) = pzspi;
        patt(natt, 4) = fem::sqrt(fem::pow2(psembd) + fem::pow2(pimass));
        eatt += patt(natt, 4);
        gxar(natt) = xjet;
        gyar(natt) = yjet;
        gzar(natt) = 0.f;
        ftar(natt) = 0.f;
        itypar(natt) = katt(natt, 1);
        pxar(natt) = patt(natt, 1);
        pyar(natt) = patt(natt, 2);
        pzar(natt) = patt(natt, 3);
        pear(natt) = patt(natt, 4);
        xmar(natt) = pimass;
      }
    }
  }
  /// Clin-8/2009-end
  /// C
}

struct zpstrg_save {
  fem::variant_bindings prec2_bindings;
  float bb;
  double diff2;
  int i;
  int istrg;
  int j;
  int nstr;
  double shift;
  double tau7;

  zpstrg_save()
      : bb(fem::float0),
        diff2(fem::double0),
        i(fem::int0),
        istrg(fem::int0),
        j(fem::int0),
        nstr(fem::int0),
        shift(fem::double0),
        tau7(fem::double0) {}
};

/// C
/// C=======================================================================
/// C
/// C.....subroutine to get average values for different strings
/// C
void zpstrg(common& cmn) {
  FEM_CMN_SVE(zpstrg);
  common_write write(cmn);
  /// COMMON para1
  int& mul = cmn.mul;
  /// COMMON ilist8
  const int maxptn = 400001;
  arr_cref<int> lstrg1(cmn.lstrg1, dimension(maxptn));
  /// COMMON srec1
  int& nsp = cmn.nsp;
  int& nst = cmn.nst;
  /// COMMON srec2
  const int maxstr = 150001;
  arr_ref<double> ataui(cmn.ataui, dimension(maxstr));
  arr_ref<double> zt1(cmn.zt1, dimension(maxstr));
  arr_ref<double> zt2(cmn.zt2, dimension(maxstr));
  arr_ref<double> zt3(cmn.zt3, dimension(maxstr));
  /// COMMON hjcrdn
  arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
  /// COMMON hjjet2
  arr_cref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  /// COMMON hparnt
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  /// COMMON anim
  int& isoft = cmn.isoft;
  /// COMMON strg
  arr_ref<int> np(static_cast<common_strg&>(cmn).np, dimension(maxstr));
  /// COMMON frzprc
  arr_cref<double> gxfrz(cmn.gxfrz, dimension(maxptn));
  arr_cref<double> gyfrz(cmn.gyfrz, dimension(maxptn));
  arr_cref<double> gzfrz(cmn.gzfrz, dimension(maxptn));
  arr_cref<double> ftfrz(cmn.ftfrz, dimension(maxptn));
  arr_cref<double> pxfrz(cmn.pxfrz, dimension(maxptn));
  arr_cref<double> pyfrz(cmn.pyfrz, dimension(maxptn));
  arr_cref<double> pzfrz(cmn.pzfrz, dimension(maxptn));
  arr_cref<double> efrz(cmn.efrz, dimension(maxptn));
  arr_cref<double> xmfrz(cmn.xmfrz, dimension(maxptn));
  arr_cref<int> idfrz(cmn.idfrz, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  float& bb = sve.bb;
  double& diff2 = sve.diff2;
  int& i = sve.i;
  int& istrg = sve.istrg;
  int& j = sve.j;
  int& nstr = sve.nstr;
  double& shift = sve.shift;
  double& tau7 = sve.tau7;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx5(dimension(maxptn));
      mbr<double> gy5(dimension(maxptn));
      mbr<double> gz5(dimension(maxptn));
      mbr<double> ft5(dimension(maxptn));
      mbr<double> px5(dimension(maxptn));
      mbr<double> py5(dimension(maxptn));
      mbr<double> pz5(dimension(maxptn));
      mbr<double> e5(dimension(maxptn));
      mbr<double> xmass5(dimension(maxptn));
      mbr<int> ityp5(dimension(maxptn));
      prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5, ityp5;
    }
  }
  arr_ref<double> gx5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gy5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gz5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> ft5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> px5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> py5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> pz5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> e5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> xmass5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<int> ityp5(prec2.bind<int>(), dimension(maxptn));
  /// C
  /// C      REAL*4 YP, YT, PXSG, PYSG, PZSG, PESG, PMSG, HIPR1, HINT1, BB
  /// C
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /ilist8/
  /// Cc      SAVE /SREC1/
  /// Cc      SAVE /SREC2/
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HJJET2/
  /// Cbz6/28/99 flow1
  /// Cc      SAVE /HPARNT/
  /// Cbz6/28/99 flow1 end
  /// Cc      SAVE /anim/
  /// Cc      SAVE /strg/
  /// Clin-6/06/02 test local freezeout:
  /// Cc      SAVE /frzprc/
  /// C
  /// Clin-6/06/02 test local freezeout for string melting,
  /// C     use space-time values at local freezeout saved in /frzprc/:
  if (isoft == 5) {
    FEM_DO_SAFE(i, 1, mul) {
      ityp5(i) = idfrz(i);
      gx5(i) = gxfrz(i);
      gy5(i) = gyfrz(i);
      gz5(i) = gzfrz(i);
      ft5(i) = ftfrz(i);
      px5(i) = pxfrz(i);
      py5(i) = pyfrz(i);
      pz5(i) = pzfrz(i);
      e5(i) = efrz(i);
      xmass5(i) = xmfrz(i);
    }
  }
  /// Clin-6/06/02-end
  /// C
  FEM_DO_SAFE(i, 1, maxstr) {
    ataui(i) = 0e0;
    zt1(i) = 0e0;
    zt2(i) = 0e0;
    /// Clin-4/25/03 add zt3(I) to track longitudinal positions of
    /// partons/strings:
    zt3(i) = 0e0;
    np(i) = 0;
  }
  FEM_DO_SAFE(i, 1, mul) {
    istrg = lstrg1(i);
    /// Clin-9/2015 to avoid Floating-Point Exception:
    /// C         TAU7 = SQRT(FT5(I) ** 2 - GZ5(I) ** 2)
    diff2 = fem::pow2(ft5(i)) - fem::pow2(gz5(i));
    if (diff2 < 0e0) {
      write(6, star), "2:I,ft5,gz5,diff2=", i, ft5(i), gz5(i), diff2;
      tau7 = 1e-6;
    } else {
      tau7 = fem::dsqrt(diff2);
    }
    /// C
    ataui(istrg) += tau7;
    zt1(istrg) += gx5(i);
    zt2(istrg) += gy5(i);
    zt3(istrg) += gz5(i);
    np(istrg)++;
  }
  /// C
  nstr = nsp + nst + cmn.nsi;
  /// C
  /// Clin-7/03/01 correct averaging on transverse coordinates, no shift needed:
  if (isoft == 3 || isoft == 4 || isoft == 5) {
    FEM_DO_SAFE(i, 1, nstr) {
      if (np(i) != 0) {
        ataui(i) = ataui(i) / np(i);
        zt1(i) = zt1(i) / np(i);
        zt2(i) = zt2(i) / np(i);
        zt3(i) = zt3(i) / np(i);
      }
    }
    return;
  }
  /// Clin-7/03/01-end
  /// C
  FEM_DO_SAFE(i, 1, nstr) {
    if (np(i) != 0) {
      ataui(i) = ataui(i) / np(i);
      zt1(i) = zt1(i) / np(i);
      zt2(i) = zt2(i) / np(i);
      zt3(i) = zt3(i) / np(i);
    } else {
      if (i <= nsp) {
        j = i;
        zt1(i) = fem::dble(yp(1, j));
        zt2(i) = fem::dble(yp(2, j));
        zt3(i) = 0e0;
      } else if (i > nsp && i <= nsp + nst) {
        j = i - nsp;
        zt1(i) = fem::dble(yt(1, j));
        zt2(i) = fem::dble(yt(2, j));
        zt3(i) = 0e0;
      } else {
        j = i - nsp - nst;
        zt1(i) = 0.5e0 * fem::dble((yp(1, iasg(j, 1)) + yt(1, iasg(j, 2))));
        zt2(i) = 0.5e0 * fem::dble((yp(2, iasg(j, 1)) + yt(2, iasg(j, 2))));
        zt3(i) = 0e0;
      }
    }
  }
  /// C
  /// Cbz6/28/99 flow1
  bb = hint1(19);
  FEM_DO_SAFE(i, 1, nstr) {
    if (np(i) != 0) {
      shift = 0e0;
    } else {
      shift = 0.5e0 * fem::dble(bb);
    }
    if (i <= nsp) {
      zt1(i) += shift;
    } else if (i > nsp && i <= nsp + nst) {
      zt1(i) = zt1(i) - shift;
    }
  }
  /// Cbz6/28/99 flow1 end
  /// C
}

struct readi_save {
  arr<double> field;
  int i;
  int neve;
  int ntyp;

  readi_save()
      : field(dimension(9), fem::fill0),
        i(fem::int0),
        neve(fem::int0),
        ntyp(fem::int0) {}
};

void readi(common& cmn) {
  FEM_CMN_SVE(readi);
  common_read read(cmn);
  int& mul = cmn.mul;
  int& nsevt = cmn.nsevt;
  int& ievt = cmn.ievt;
  const int maxptn = 400001;
  arr_ref<double> gx0(cmn.gx0, dimension(maxptn));
  arr_ref<double> gy0(cmn.gy0, dimension(maxptn));
  arr_ref<double> gz0(cmn.gz0, dimension(maxptn));
  arr_ref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_ref<double> px0(cmn.px0, dimension(maxptn));
  arr_ref<double> py0(cmn.py0, dimension(maxptn));
  arr_ref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_ref<double> e0(cmn.e0, dimension(maxptn));
  arr_ref<double> xmass0(cmn.xmass0, dimension(maxptn));
  arr_ref<int> ityp0(cmn.ityp0, dimension(maxptn));
  ///
  arr_ref<double> field(sve.field, dimension(9));
  int& i = sve.i;
  int& neve = sve.neve;
  int& ntyp = sve.ntyp;
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para3/
  /// Cc      SAVE /prec1/
  FEM_DO_SAFE(i, 1, maxptn) {
    if (ievt != 1 && i == 1) {
      ityp0(i) = ntyp;
      gx0(1) = field(1);
      gy0(1) = field(2);
      gz0(1) = field(3);
      ft0(1) = field(4);
      px0(1) = field(5);
      py0(1) = field(6);
      pz0(1) = field(7);
      e0(1) = field(8);
      xmass0(i) = field(9);
      mul = 1;
    } else {
    statement_900:
      try {
        read(27, star), neve, ntyp, field;
      } catch (fem::read_end const&) {
        goto statement_1000;
      }
      if (neve < nsevt) {
        goto statement_900;
      }
      if (neve > nsevt + ievt - 1) {
        goto statement_1000;
      }
      ityp0(i) = ntyp;
      gx0(i) = field(1);
      gy0(i) = field(2);
      gz0(i) = field(3);
      ft0(i) = field(4);
      px0(i) = field(5);
      py0(i) = field(6);
      pz0(i) = field(7);
      e0(i) = field(8);
      xmass0(i) = field(9);
      mul++;
    }
  }
/// C
statement_1000:;
  /// C
}

struct ran1_save {
  int iff;
  int ix1;
  int ix2;
  int ix3;
  int j;
  arr<double> r;

  ran1_save()
      : iff(fem::int0),
        ix1(fem::int0),
        ix2(fem::int0),
        ix3(fem::int0),
        j(fem::int0),
        r(dimension(97), fem::fill0) {}
};

double ran1(common& cmn, int& idum) {
  double return_value = fem::double0;
  FEM_CMN_SVE(ran1);
  common_write write(cmn);
  /// COMMON rndm1
  int& number = cmn.number;
  ///
  /// SAVE
  int& iff = sve.iff;
  int& ix1 = sve.ix1;
  int& ix2 = sve.ix2;
  int& ix3 = sve.ix3;
  int& j = sve.j;
  arr_ref<double> r(sve.r, dimension(97));
  ///
  if (is_called_first_time) {
    iff = 0;
  }
  /// C
  /// C     return a uniform random deviate between 0.0 and 1.0. set idum to
  /// C     any negative value to initialize or reinitialize the sequence.
  /// C
  /// Cc      SAVE /rndm1/
  /// Clin-6/23/00 save ix1-3:
  /// Clin-10/30/02 r unsaved, causing wrong values for ran1 when compiled with
  /// f77: Cc      SAVE ix1,ix2,ix3,r
  /// C
  const int ic1 = 54773;
  const int m1 = 259200;
  const int ia1 = 7141;
  const int m2 = 134456;
  const int m3 = 243000;
  const int ia2 = 8121;
  const int ic2 = 28411;
  const double rm2 = 1e0 / m2;
  const double rm1 = 1e0 / m1;
  if (idum < 0 || iff == 0) {
    iff = 1;
    ix1 = fem::mod(ic1 - idum, m1);
    ix1 = fem::mod(ia1 * ix1 + ic1, m1);
    ix2 = fem::mod(ix1, m2);
    ix1 = fem::mod(ia1 * ix1 + ic1, m1);
    ix3 = fem::mod(ix1, m3);
    FEM_DO_SAFE(j, 1, 97) {
      ix1 = fem::mod(ia1 * ix1 + ic1, m1);
      ix2 = fem::mod(ia2 * ix2 + ic2, m2);
      r(j) = (fem::dble(ix1) + fem::dble(ix2) * rm2) * rm1;
    }
    idum = 1;
  }
  ix1 = fem::mod(ia1 * ix1 + ic1, m1);
  ix2 = fem::mod(ia2 * ix2 + ic2, m2);
  const int ia3 = 4561;
  const int ic3 = 51349;
  ix3 = fem::mod(ia3 * ix3 + ic3, m3);
  /// Clin-7/01/02       j = 1 + (97 * i x 3) / m3
  j = 1 + (97 * ix3) / m3;
  /// Clin-4/2008:
  /// C      if (j .gt. 97 .or. j .lt. 1) pause
  if (j > 97 || j < 1) {
    write(6, star), "In zpc ran1, j<1 or j>97", j;
  }
  return_value = r(j);
  r(j) = (fem::dble(ix1) + fem::dble(ix2) * rm2) * rm1;
  /// C
  /// Clin-6/23/00 check random number generator:
  number++;
  /// C      if(number.le.100000) write(99,*) 'number, ran1=', number,ran1
  /// C
  return return_value;
}

struct posit1_save {
  int iseed;

  posit1_save() : iseed(fem::int0) {}
};

void posit1(common& cmn, double& x, double& y, double const& r0) {
  FEM_CMN_SVE(posit1);
  int& iseed = sve.iseed;
  /// C
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
statement_10:
  x = 2e0 * ran1(cmn, iseed) - 1e0;
  y = 2e0 * ran1(cmn, iseed) - 1e0;
  if (fem::pow2(x) + fem::pow2(y) > 1e0) {
    goto statement_10;
  }
  x = x * r0;
  y = y * r0;
  /// C
}

struct posit2_save {
  int iseed;

  posit2_save() : iseed(fem::int0) {}
};

void posit2(common& cmn, double& x, double& y) {
  FEM_CMN_SVE(posit2);
  /// SAVE
  int& iseed = sve.iseed;
  ///
  /// C
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /rndm3/
  iseed = cmn.iseedp;
  x = 2e0 * ran1(cmn, iseed) - 1e0;
  y = 2e0 * ran1(cmn, iseed) - 1e0;
  x = x * 5e0 * cmn.size1;
  y = y * 5e0 * cmn.size2;
  /// C
}

struct posit3_save {
  int iseed;

  posit3_save() : iseed(fem::int0) {}
};

void posit3(common& cmn, double& x, double& y, double& z) {
  FEM_CMN_SVE(posit3);
  /// SAVE
  int& iseed = sve.iseed;
  ///
  /// C
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
  x = 2e0 * ran1(cmn, iseed) - 1e0;
  y = 2e0 * ran1(cmn, iseed) - 1e0;
  z = 2e0 * ran1(cmn, iseed) - 1e0;
  x = x * 5e0 * cmn.size1;
  y = y * 5e0 * cmn.size2;
  z = z * 5e0 * cmn.size3;
  /// C
}

struct energy_save {
  int iseed;

  energy_save() : iseed(fem::int0) {}
};

void energy(common& cmn, double& e, double const& temp) {
  FEM_CMN_SVE(energy);
  int& iseed = sve.iseed;
  /// C
  /// C       to generate the magnitude of the momentum e,
  /// C       knowing the temperature of the local thermal distribution temp
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
statement_1000:
  /// C
  e = ran1(cmn, iseed);
  e = e * ran1(cmn, iseed);
  e = e * ran1(cmn, iseed);
  /// C
  if (e <= 0e0) {
    goto statement_1000;
  }
  e = -temp * fem::log(e);
  if (ran1(cmn, iseed) >
      fem::exp((e - fem::dsqrt(fem::pow2(e) + fem::pow2(cmn.xmp))) / temp)) {
    goto statement_1000;
  }
  /// C
}

struct momntm_save {
  double cost;
  int iseed;
  double phi;
  double sint;

  momntm_save()
      : cost(fem::double0),
        iseed(fem::int0),
        phi(fem::double0),
        sint(fem::double0) {}
};

void momntm(common& cmn, double& px, double& py, double& pz, double const& e) {
  FEM_CMN_SVE(momntm);
  /// SAVE
  double& cost = sve.cost;
  int& iseed = sve.iseed;
  double& phi = sve.phi;
  double& sint = sve.sint;
  ///
  /// C
  /// C       to generate the 3 components of the momentum px, py, pz,
  /// C       from the magnitude of the momentum e
  /// C
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
  cost = 2e0 * ran1(cmn, iseed) - 1e0;
  /// C     7/20/01:
  /// C        sint = sqrt(1d0 - cost ** 2)
  sint = fem::dsqrt(1e0 - fem::pow2(cost));
  const double pi = 3.14159265358979e0;
  phi = 2e0 * pi * ran1(cmn, iseed);
  /// C
  px = e * sint * fem::cos(phi);
  py = e * sint * fem::sin(phi);
  pz = e * cost;
  /// C
}

struct genei_save {
  double bex;
  double bey;
  double bez;
  double deta;
  double e;
  double etamax;
  double etamin;
  int i;
  int incmul;
  int iseed;
  double px;
  double py;
  double pz;
  double r0;
  double tau0;
  double temp;
  double x;
  double y;
  double z;

  genei_save()
      : bex(fem::double0),
        bey(fem::double0),
        bez(fem::double0),
        deta(fem::double0),
        e(fem::double0),
        etamax(fem::double0),
        etamin(fem::double0),
        i(fem::int0),
        incmul(fem::int0),
        iseed(fem::int0),
        px(fem::double0),
        py(fem::double0),
        pz(fem::double0),
        r0(fem::double0),
        tau0(fem::double0),
        temp(fem::double0),
        x(fem::double0),
        y(fem::double0),
        z(fem::double0) {}
};

void genei(common& cmn) {
  FEM_CMN_SVE(genei);
  common_write write(cmn);
  /// COMMON para1
  int& mul = cmn.mul;
  /// COMMON para2
  double& xmp = cmn.xmp;
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON prec1
  const int maxptn = 400001;
  arr_ref<double> gx0(cmn.gx0, dimension(maxptn));
  arr_ref<double> gy0(cmn.gy0, dimension(maxptn));
  arr_ref<double> gz0(cmn.gz0, dimension(maxptn));
  arr_ref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_ref<double> px0(cmn.px0, dimension(maxptn));
  arr_ref<double> py0(cmn.py0, dimension(maxptn));
  arr_ref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_ref<double> e0(cmn.e0, dimension(maxptn));
  arr_ref<double> xmass0(cmn.xmass0, dimension(maxptn));
  arr_ref<int> ityp0(cmn.ityp0, dimension(maxptn));
  /// COMMON prec5
  arr_ref<double> eta(cmn.eta, dimension(maxptn));
  ///
  /// SAVE
  double& bex = sve.bex;
  double& bey = sve.bey;
  double& bez = sve.bez;
  double& deta = sve.deta;
  double& e = sve.e;
  double& etamax = sve.etamax;
  double& etamin = sve.etamin;
  int& i = sve.i;
  int& incmul = sve.incmul;
  int& iseed = sve.iseed;
  double& px = sve.px;
  double& py = sve.py;
  double& pz = sve.pz;
  double& r0 = sve.r0;
  double& tau0 = sve.tau0;
  double& temp = sve.temp;
  double& x = sve.x;
  double& y = sve.y;
  double& z = sve.z;
  ///
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para3/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /lor/
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
  incmul = 4000;
  temp = 0.5e0;
  etamin = -5e0;
  etamax = 5e0;
  r0 = 5e0;
  tau0 = 0.1e0;
  deta = etamax - etamin;
  /// C
  FEM_DO_SAFE(i, mul + 1, mul + incmul) {
    ityp0(i) = 21;
    xmass0(i) = xmp;
    energy(cmn, e, temp);
    momntm(cmn, px, py, pz, e);
    /// C     7/20/01:
    /// C           e = sqrt(e ** 2 + xmp ** 2)
    e = fem::dsqrt(fem::pow2(e) + fem::pow2(xmp));
    if (iconfg <= 3) {
      eta(i) = etamin + deta * ran1(cmn, iseed);
      bex = 0e0;
      bey = 0e0;
      bez = -fem::tanh(eta(i));
      lorenz(cmn, e, px, py, pz, bex, bey, bez);
      px0(i) = cmn.pxnew;
      py0(i) = cmn.pynew;
      pz0(i) = cmn.pznew;
      e0(i) = cmn.enenew;
    } else {
      px0(i) = px;
      py0(i) = py;
      pz0(i) = pz;
      e0(i) = e;
    }
  }
  /// C
  FEM_DO_SAFE(i, mul + 1, mul + incmul) {
    if (iconfg <= 3) {
      gz0(i) = tau0 * fem::sinh(eta(i));
      ft0(i) = tau0 * fem::cosh(eta(i));
      if (iconfg == 1) {
        posit1(cmn, x, y, r0);
        gx0(i) = x + px0(i) * ft0(i) / e0(i);
        gy0(i) = y + py0(i) * ft0(i) / e0(i);
      } else if (iconfg == 2 || iconfg == 3) {
        posit2(cmn, x, y);
        gx0(i) = x;
        gy0(i) = y;
      }
    } else {
      ft0(i) = 0e0;
      posit3(cmn, x, y, z);
      gx0(i) = x;
      gy0(i) = y;
      gz0(i) = z;
    }
  }
  /// C
  mul += incmul;
  /// C
  /// C       check if it's necessary to adjust array size 'adarr'
  if (mul >= maxptn || mul == 0) {
    write(6, star), "event", cmn.ievt, "has", mul, "number of gluon",
        "adjusting counting is necessary";
    FEM_STOP("adarr");
  }
  /// C
}

struct boosti_save {
  double bex;
  double bey;
  double bez;
  double e1;
  int i;
  double px1;
  double py1;
  double pz1;

  boosti_save()
      : bex(fem::double0),
        bey(fem::double0),
        bez(fem::double0),
        e1(fem::double0),
        i(fem::int0),
        px1(fem::double0),
        py1(fem::double0),
        pz1(fem::double0) {}
};

void boosti(common& cmn) {
  FEM_CMN_SVE(boosti);
  /// COMMON prec1
  const int maxptn = 400001;
  arr_ref<double> gx0(cmn.gx0, dimension(maxptn));
  arr_ref<double> gy0(cmn.gy0, dimension(maxptn));
  arr_ref<double> gz0(cmn.gz0, dimension(maxptn));
  arr_ref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_ref<double> px0(cmn.px0, dimension(maxptn));
  arr_ref<double> py0(cmn.py0, dimension(maxptn));
  arr_ref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_ref<double> e0(cmn.e0, dimension(maxptn));
  /// COMMON lor
  double& enenew = cmn.enenew;
  double& pxnew = cmn.pxnew;
  double& pynew = cmn.pynew;
  double& pznew = cmn.pznew;
  ///
  /// SAVE
  double& bex = sve.bex;
  double& bey = sve.bey;
  double& bez = sve.bez;
  double& e1 = sve.e1;
  int& i = sve.i;
  double& px1 = sve.px1;
  double& py1 = sve.py1;
  double& pz1 = sve.pz1;
  ///
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para6/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /lor/
  /// C
  bex = 0e0;
  bey = 0e0;
  bez = -fem::tanh(cmn.centy);
  /// C
  /// C       save data for many runs of the same initial condition
  FEM_DO_SAFE(i, 1, cmn.mul) {
    px1 = gx0(i);
    py1 = gy0(i);
    pz1 = gz0(i);
    e1 = ft0(i);
    lorenz(cmn, e1, px1, py1, pz1, bex, bey, bez);
    gx0(i) = pxnew;
    gy0(i) = pynew;
    gz0(i) = pznew;
    ft0(i) = enenew;
    px1 = px0(i);
    py1 = py0(i);
    pz1 = pz0(i);
    e1 = e0(i);
    lorenz(cmn, e1, px1, py1, pz1, bex, bey, bez);
    px0(i) = pxnew;
    py0(i) = pynew;
    pz0(i) = pznew;
    e0(i) = enenew;
  }
  /// C
}

/// C
/// C*****************************************************************************
/// C
void inievt(common& cmn) {
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para4/
  /// C
  /// Cbz1/25/99
  /// C        mul = 0
  /// Cbz1/25/99
  if (cmn.ireflg == 0) {
    readi(cmn);
  }
  if (cmn.igeflg != 0) {
    genei(cmn);
  }
  if (cmn.ibstfg != 0) {
    boosti(cmn);
  }
  /// C
}

struct ftime1_save {
  double aa;

  ftime1_save() : aa(fem::double0) {}
};

double ftime1(common& cmn, int& iseed) {
  double return_value = fem::double0;
  FEM_CMN_SVE(ftime1);
  /// SAVE
  double& aa = sve.aa;
  ///
  /// C
  /// C       this program is used to generate formation time
  /// C       the calling program needs a common /par1/
  /// C       and declare external ftime1
  /// C
  /// Clin-8/19/02
  /// C
  /// Cc      SAVE /par1/
  /// C
  const double hbarc = 0.197327054e0;
  aa = hbarc / cmn.formt;
  /// C
  /// Clin7/20/01:
  /// C        ftime1 = aa * sqrt(1d0 / ran1(iseed) - 1d0)
  return_value = aa * fem::dsqrt(1e0 / ran1(cmn, iseed) - 1e0);
  return return_value;
}

struct ftime_save {
  int i;
  int iseed;
  double xmt2;

  ftime_save() : i(fem::int0), iseed(fem::int0), xmt2(fem::double0) {}
};

void ftime(common& cmn) {
  FEM_CMN_SVE(ftime);
  int& mul = cmn.mul;
  const int maxptn = 400001;
  arr_ref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_cref<double> px0(cmn.px0, dimension(maxptn));
  arr_cref<double> py0(cmn.py0, dimension(maxptn));
  arr_cref<double> e0(cmn.e0, dimension(maxptn));
  arr_ref<int> indx(cmn.indx, dimension(maxptn));
  arr_ref<double> ct(cmn.ct, dimension(maxptn));
  arr_ref<double> ot(cmn.ot, dimension(maxptn));
  double& tlarge = cmn.tlarge;
  int& isoft = cmn.isoft;
  ///
  int& i = sve.i;
  int& iseed = sve.iseed;
  double& xmt2 = sve.xmt2;
  /// C       this subroutine generates formation time for the particles
  /// C       indexing ft(i)
  /// C       input e(i)
  /// C       output ft(i), indx(i)
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para4/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// Cc      SAVE /par1/
  /// Cc      SAVE /anim/
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
  /// Clin-6/07/02 initialize here to expedite compiling, instead in zpcbdt:
  FEM_DO_SAFE(i, 1, maxptn) {
    ct(i) = 0e0;
    ot(i) = 0e0;
  }
  tlarge = 1000000.e0;
  /// Clin-6/07/02-end
  /// C
  if (cmn.iftflg == 0) {
    /// C     5/01/01 different prescription for parton initial formation time:
    if (isoft == 3 || isoft == 4 || isoft == 5) {
      FEM_DO_SAFE(i, 1, mul) {
        if (ft0(i) > tlarge) {
          ft0(i) = tlarge;
        }
      }
      goto statement_150;
    } else {
      /// C     5/01/01-end
      /// C
      FEM_DO_SAFE(i, 1, maxptn) { ft0(i) = tlarge; }
      FEM_DO_SAFE(i, 1, mul) {
        xmt2 = fem::pow2(px0(i)) + fem::pow2(py0(i)) + fem::pow2(cmn.xmp);
        cmn.formt = xmt2 / e0(i);
        ft0(i) = ftime1(cmn, iseed);
        if (ft0(i) > tlarge) {
          ft0(i) = tlarge;
        }
      }
      /// C     5/01/01:
    }
    /// C
  }
/// C
/// C     5/01/01:
statement_150:
  /// C
  /// C        call index1(MAXPTN, mul, ft0, indx)
  if (mul > 1) {
    index1(cmn, maxptn, mul, ft0, indx);
  } else {
    /// Clin-7/09/03: need to set value for mul=1:
    indx(1) = 1;
  }
  /// C
}

struct inifrz_save {
  int it;
  double step1;
  double step2;
  double step3;
  double step4;

  inifrz_save()
      : it(fem::int0),
        step1(fem::double0),
        step2(fem::double0),
        step3(fem::double0),
        step4(fem::double0) {}
};

/// C
/// C=======================================================================
/// Clin-6/06/02 initialization for local parton freezeout
void inifrz(common& cmn) {
  FEM_CMN_SVE(inifrz);
  /// COMMON frzprc
  arr_ref<double> tfrz(cmn.tfrz, dimension(302));
  ///
  /// SAVE
  int& it = sve.it;
  double& step1 = sve.step1;
  double& step2 = sve.step2;
  double& step3 = sve.step3;
  double& step4 = sve.step4;
  ///
  /// C
  /// Cc      SAVE /ilist5/
  /// Cc      SAVE /frzprc/
  /// C
  /// C     for freezeout time 0-10fm, use interval of 0.1fm;
  /// C     for 10-100fm, use interval of 1fm;
  /// C     for 100-1000fm, use interval of 10fm;
  /// C     for 1000-3000fm, use interval of 100fm:
  step1 = 0.1e0;
  step2 = 1e0;
  step3 = 10e0;
  step4 = 100e0;
  /// C
  FEM_DO_SAFE(it, 1, 101) { tfrz(it) = 0e0 + fem::dble(it - 1) * step1; }
  FEM_DO_SAFE(it, 102, 191) { tfrz(it) = 10e0 + fem::dble(it - 101) * step2; }
  FEM_DO_SAFE(it, 192, 281) { tfrz(it) = 100e0 + fem::dble(it - 191) * step3; }
  FEM_DO_SAFE(it, 282, 301) { tfrz(it) = 1000e0 + fem::dble(it - 281) * step4; }
  tfrz(302) = cmn.tlarge;
  /// C
}

struct inirec_save {
  fem::variant_bindings prec2_bindings;
  double energy;
  double formt;
  int i;
  int indxi;
  int iseed;

  inirec_save()
      : energy(fem::double0),
        formt(fem::double0),
        i(fem::int0),
        indxi(fem::int0),
        iseed(fem::int0) {}
};

void inirec(common& cmn) {
  FEM_CMN_SVE(inirec);
  common_write write(cmn);
  /// COMMON para1
  int& mul = cmn.mul;
  /// COMMON prec1
  const int maxptn = 400001;
  arr_cref<double> gx0(cmn.gx0, dimension(maxptn));
  arr_cref<double> gy0(cmn.gy0, dimension(maxptn));
  arr_cref<double> gz0(cmn.gz0, dimension(maxptn));
  arr_cref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_cref<double> px0(cmn.px0, dimension(maxptn));
  arr_cref<double> py0(cmn.py0, dimension(maxptn));
  arr_cref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_cref<double> e0(cmn.e0, dimension(maxptn));
  arr_cref<double> xmass0(cmn.xmass0, dimension(maxptn));
  arr_cref<int> ityp0(cmn.ityp0, dimension(maxptn));
  /// COMMON prec3
  arr_ref<double> gxs(cmn.gxs, dimension(maxptn));
  arr_ref<double> gys(cmn.gys, dimension(maxptn));
  arr_ref<double> gzs(cmn.gzs, dimension(maxptn));
  arr_ref<double> fts(cmn.fts, dimension(maxptn));
  arr_ref<double> pxs(cmn.pxs, dimension(maxptn));
  arr_ref<double> pys(cmn.pys, dimension(maxptn));
  arr_ref<double> pzs(cmn.pzs, dimension(maxptn));
  arr_ref<double> es(cmn.es, dimension(maxptn));
  arr_ref<double> xmasss(cmn.xmasss, dimension(maxptn));
  arr_ref<int> ityps(cmn.ityps, dimension(maxptn));
  /// COMMON prec4
  arr_ref<double> vx(cmn.vx, dimension(maxptn));
  arr_ref<double> vy(cmn.vy, dimension(maxptn));
  arr_ref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON prec5
  arr_ref<double> eta(cmn.eta, dimension(maxptn));
  arr_ref<double> rap(cmn.rap, dimension(maxptn));
  arr_ref<double> tau(cmn.tau, dimension(maxptn));
  /// COMMON prec6
  arr_ref<double> etas(cmn.etas, dimension(maxptn));
  arr_ref<double> raps(cmn.raps, dimension(maxptn));
  arr_ref<double> taus(cmn.taus, dimension(maxptn));
  /// COMMON ilist4
  arr_cref<int> indx(cmn.indx, dimension(maxptn));
  /// COMMON ilist7
  arr_cref<int> lstrg0(cmn.lstrg0, dimension(maxptn));
  arr_cref<int> lpart0(cmn.lpart0, dimension(maxptn));
  /// COMMON ilist8
  arr_ref<int> lstrg1(cmn.lstrg1, dimension(maxptn));
  arr_ref<int> lpart1(cmn.lpart1, dimension(maxptn));
  /// COMMON precpb
  arr_ref<double> vxp(cmn.vxp, dimension(maxptn));
  arr_ref<double> vyp(cmn.vyp, dimension(maxptn));
  arr_ref<double> vzp(cmn.vzp, dimension(maxptn));
  /// COMMON precpa
  arr_cref<double> vxp0(cmn.vxp0, dimension(maxptn));
  arr_cref<double> vyp0(cmn.vyp0, dimension(maxptn));
  arr_cref<double> vzp0(cmn.vzp0, dimension(maxptn));
  arr_ref<double> xstrg0(cmn.xstrg0, dimension(maxptn));
  arr_ref<double> ystrg0(cmn.ystrg0, dimension(maxptn));
  arr_cref<double> xstrg(cmn.xstrg, dimension(maxptn));
  arr_cref<double> ystrg(cmn.ystrg, dimension(maxptn));
  arr_ref<int> istrg0(cmn.istrg0, dimension(maxptn));
  arr_cref<int> istrg(cmn.istrg, dimension(maxptn));
  /// COMMON anim
  int& isoft = cmn.isoft;
  /// COMMON frzprc
  arr_ref<double> gxfrz(cmn.gxfrz, dimension(maxptn));
  arr_ref<double> gyfrz(cmn.gyfrz, dimension(maxptn));
  arr_ref<double> gzfrz(cmn.gzfrz, dimension(maxptn));
  arr_ref<double> ftfrz(cmn.ftfrz, dimension(maxptn));
  arr_ref<double> pxfrz(cmn.pxfrz, dimension(maxptn));
  arr_ref<double> pyfrz(cmn.pyfrz, dimension(maxptn));
  arr_ref<double> pzfrz(cmn.pzfrz, dimension(maxptn));
  arr_ref<double> efrz(cmn.efrz, dimension(maxptn));
  arr_ref<double> xmfrz(cmn.xmfrz, dimension(maxptn));
  arr_ref<int> ifrz(cmn.ifrz, dimension(maxptn));
  arr_ref<int> idfrz(cmn.idfrz, dimension(maxptn));
  /// COMMON para7
  int& ioscar = cmn.ioscar;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& energy = sve.energy;
  double& formt = sve.formt;
  int& i = sve.i;
  int& indxi = sve.indxi;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_ref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> e(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> xmass(prec2.bind<double>(), dimension(maxptn));
  arr_ref<int> ityp(prec2.bind<int>(), dimension(maxptn));
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para4/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec3/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /prec6/
  /// Cc      SAVE /ilist4/
  /// Cbz1/25/99
  /// Cc      SAVE /ilist7/
  /// Cc      SAVE /ilist8/
  /// Cbz1/25/99end
  /// Cc      SAVE /smearz/
  /// Clin-8/2015:
  /// C        dimension vxp(MAXPTN), vyp(MAXPTN), vzp(MAXPTN)
  /// Clin-8/2015:
  /// C        common /precpa/ vxp0(MAXPTN), vyp0(MAXPTN), vzp0(MAXPTN)
  /// Cc      SAVE /precpa/
  /// Cc      SAVE /anim/
  /// Clin-6/06/02 local parton freezeout:
  /// Cc      SAVE /frzprc/
  /// Cc      SAVE /rndm3/
  sve.iseed = cmn.iseedp;
  /// Clin-6/06/02 local freezeout initialization:
  if (isoft == 5) {
    cmn.itlast = 0;
    inifrz(cmn);
  }
  /// C
  FEM_DO_SAFE(i, 1, mul) {
    /// Clin-7/09/01 define indx(i) to save time:
    /// C           ityp(i) = ityp0(indx(i))
    /// C           gx(i) = gx0(indx(i))
    /// C           gy(i) = gy0(indx(i))
    /// C           gz(i) = gz0(indx(i))
    /// C           ft(i) = ft0(indx(i))
    /// C           px(i) = px0(indx(i))
    /// C           py(i) = py0(indx(i))
    /// C           pz(i) = pz0(indx(i))
    /// C           e(i) = e0(indx(i))
    /// C           xmass(i) = xmass0(indx(i))
    /// Ccbz1/25/99
    /// C           LSTRG1(I) = LSTRG0(INDX(I))
    /// C           LPART1(I) = LPART0(INDX(I))
    /// Ccbz1/25/99end
    indxi = indx(i);
    ityp(i) = ityp0(indxi);
    gx(i) = gx0(indxi);
    gy(i) = gy0(indxi);
    gz(i) = gz0(indxi);
    ft(i) = ft0(indxi);
    px(i) = px0(indxi);
    py(i) = py0(indxi);
    pz(i) = pz0(indxi);
    e(i) = e0(indxi);
    xmass(i) = xmass0(indxi);
    lstrg1(i) = lstrg0(indxi);
    lpart1(i) = lpart0(indxi);
    vxp(i) = vxp0(indxi);
    vyp(i) = vyp0(indxi);
    vzp(i) = vzp0(indxi);
    /// Clin-8/2015:
    xstrg0(i) = xstrg(indxi);
    ystrg0(i) = ystrg(indxi);
    istrg0(i) = istrg(indxi);
    /// Clin-7/09/01-end
    /// C
    /// Clin-6/06/02 local freezeout initialization:
    if (isoft == 5) {
      idfrz(i) = ityp(i);
      gxfrz(i) = gx(i);
      gyfrz(i) = gy(i);
      gzfrz(i) = gz(i);
      ftfrz(i) = ft(i);
      pxfrz(i) = px(i);
      pyfrz(i) = py(i);
      pzfrz(i) = pz(i);
      efrz(i) = e(i);
      xmfrz(i) = xmass(i);
      ifrz(i) = 0;
    }
    /// Clin-6/06/02-end
  }
  /// C
  /// C       save particle info for fixed time analysis
  FEM_DO_SAFE(i, 1, mul) {
    ityps(i) = ityp(i);
    gxs(i) = gx(i);
    gys(i) = gy(i);
    gzs(i) = gz(i);
    fts(i) = ft(i);
    pxs(i) = px(i);
    pys(i) = py(i);
    pzs(i) = pz(i);
    es(i) = e(i);
    xmasss(i) = xmass(i);
  }
  /// C
  /// Clin-6/2009
  if (isoft == 1 && (ioscar == 2 || ioscar == 3)) {
    write(92, star), cmn.iaevt, cmn.miss, mul;
  }
  /// C
  FEM_DO_SAFE(i, 1, mul) {
    energy = e(i);
    vx(i) = px(i) / energy;
    vy(i) = py(i) / energy;
    vz(i) = pz(i) / energy;
    if (cmn.iftflg == 0) {
      formt = ft(i);
      /// C     7/09/01 propagate partons with parent velocity till formation
      /// C     so that partons in same hadron have 0 distance:
      /// C            gx(i) = gx(i) + vx(i) * formt
      /// C            gy(i) = gy(i) + vy(i) * formt
      /// C            gz(i) = gz(i) + vz(i) * formt
      if (isoft == 3 || isoft == 4 || isoft == 5) {
        gx(i) += vxp(i) * formt;
        gy(i) += vyp(i) * formt;
        gz(i) += vzp(i) * formt;
      } else {
        gx(i) += vx(i) * formt;
        gy(i) += vy(i) * formt;
        gz(i) += vz(i) * formt;
      }
      /// C     7/09/01-end
      /// C
      /// C     3/27/00-ctest off no smear z on partons to avoid eta overflow:
      /// C              gz(i) = gz(i)+smearp*(2d0 * ran1(iseed) - 1d0)
      /// C     to give eta=y +- smearp*random:
      /// C              smeary=smearp*(2d0 * ran1(iseed) - 1d0)
      /// C              smearf=dexp(2*smeary)*(1+vz(i))/(1-vz(i)+1.d-8)
      /// C              gz(i) = gz(i)+formt*(smearf-1)/(smearf+1)
      /// C     3/27/00-end
    }
    /// C
    /// Clin-6/2009 write out initial parton information after string melting
    /// C     and after propagating to its format time:
    if (ioscar == 2 || ioscar == 3) {
      if (fem::dmax1(fem::abs(gx(i)), fem::abs(gy(i)), fem::abs(gz(i)),
                     fem::abs(ft(i))) < 9999) {
        /// Clin-8/2015:
        write(92,
              "(i3,2(1x,f7.2),1x,f8.2,1x,f6.3,4(1x,f8.2),1x,i5,2(1x,f7.2))"),
            ityp(i), px(i), py(i), pz(i), xmass(i), gx(i), gy(i), gz(i), ft(i),
            istrg0(i), xstrg0(i), ystrg0(i);
      } else {
        /// Clin-8/2015:
        write(92,
              "(i3,2(1x,f7.2),1x,f8.2,1x,f6.3,4(1x,e8.2),1x,i5,2(1x,f7.2))"),
            ityp(i), px(i), py(i), pz(i), xmass(i), gx(i), gy(i), gz(i), ft(i),
            istrg0(i), xstrg0(i), ystrg0(i);
      }
    }
    /// Clin-8/2015:
    /// C 200       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))
    /// C 201       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))
    /// C     reduce file size:
    /// C 200       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f9.3),
    /// C     1          1x,I6,2(1x,f8.3))
    /// C 201       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e9.3),
    /// C     1          1x,I6,2(1x,f8.3))
    /// C
  }
  /// C
  if (cmn.iconfg <= 3) {
    FEM_DO_SAFE(i, 1, mul) {
      if (ft(i) <= fem::abs(gz(i))) {
        eta(i) = 1000000.e0;
      } else {
        eta(i) = 0.5e0 * fem::log((ft(i) + gz(i)) / (ft(i) - gz(i)));
      }
      if (e(i) <= fem::abs(pz(i))) {
        rap(i) = 1000000.e0;
      } else {
        rap(i) = 0.5e0 * fem::log((e(i) + pz(i)) / (e(i) - pz(i)));
      }
      /// Clin-8/2015 to avoid IEEE_OVERFLOW_FLAG:
      /// C              tau(i) = ft(i) / cosh(eta(i))
      if (eta(i) < 1000000.e0) {
        tau(i) = ft(i) / fem::cosh(eta(i));
      } else {
        tau(i) = 1e-10;
      }
      /// C
    }
    /// C
    FEM_DO_SAFE(i, 1, mul) {
      etas(i) = eta(i);
      raps(i) = rap(i);
      taus(i) = tau(i);
    }
  }
  /// C
}

struct iilist_save {
  int i;
  int i1;
  int i2;
  int i3;

  iilist_save() : i(fem::int0), i1(fem::int0), i2(fem::int0), i3(fem::int0) {}
};

void iilist(common& cmn) {
  FEM_CMN_SVE(iilist);
  /// COMMON para1
  int& mul = cmn.mul;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_ref<int> next(cmn.next, dimension(maxptn));
  arr_ref<int> last(cmn.last, dimension(maxptn));
  arr_ref<int> icsta(cmn.icsta, dimension(maxptn));
  arr_ref<int> nic(cmn.nic, dimension(maxptn));
  arr_ref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist2
  arr_ref<int, 3> icel(cmn.icel, dimension(10, 10, 10));
  /// COMMON ilist5
  arr_ref<double> ct(cmn.ct, dimension(maxptn));
  arr_ref<double> ot(cmn.ot, dimension(maxptn));
  double& tlarge = cmn.tlarge;
  ///
  /// SAVE
  int& i = sve.i;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  ///
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist2/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// Cc      SAVE /ilist6/
  /// C
  cmn.iscat = maxptn;
  cmn.jscat = maxptn;
  /// C
  FEM_DO_SAFE(i, 1, mul) {
    next(i) = 0;
    last(i) = 0;
    icsta(i) = 0;
    nic(i) = 0;
    icels(i) = 0;
  }
  /// C
  cmn.icell = 0;
  FEM_DO_SAFE(i1, 1, 10) {
    FEM_DO_SAFE(i2, 1, 10) {
      FEM_DO_SAFE(i3, 1, 10) { icel(i1, i2, i3) = 0; }
    }
  }
  /// C
  cmn.ichkpt = 0;
  cmn.ifmpt = 1;
  /// C
  FEM_DO_SAFE(i, 1, mul) {
    ct(i) = tlarge;
    ot(i) = tlarge;
  }
  /// C
  cmn.iopern = 0;
  cmn.icolln = 0;
  cmn.t = 0.e0;
  /// C
}

struct inian2_save {
  int i;

  inian2_save() : i(fem::int0) {}
};

void inian2(common& cmn) {
  FEM_CMN_SVE(inian2);
  /// COMMON ana2
  arr_ref<double> det(cmn.det, dimension(12));
  arr_ref<double> dn(cmn.dn, dimension(12));
  arr_ref<double> det1(cmn.det1, dimension(12));
  arr_ref<double> dn1(cmn.dn1, dimension(12));
  arr_ref<double> det2(cmn.det2, dimension(12));
  arr_ref<double> dn2(cmn.dn2, dimension(12));
  ///
  /// SAVE
  int& i = sve.i;
  ///
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /ana2/
  /// C
  if (cmn.iconfg <= 3) {
    FEM_DO_SAFE(i, 1, 12) {
      det(i) = 0e0;
      dn(i) = 0e0;
      det1(i) = 0e0;
      dn1(i) = 0e0;
      det2(i) = 0e0;
      dn2(i) = 0e0;
    }
  }
  /// C
}

/// C
/// C*****************************************************************************
/// C
void inirun(common& cmn) {
  /// C
  /// C       sort prec2 according to increasing formation time
  ftime(cmn);
  inirec(cmn);
  iilist(cmn);
  inian2(cmn);
  /// C
}

struct local_save {
  fem::variant_bindings prec2_bindings;
  double detdy;
  double drt;
  double eta0;
  double etcrit;
  double ettest;
  int ip;
  int it;
  int itest;
  double rap0;
  double x0;
  double xtest;
  double y0;
  double ytest;

  local_save()
      : detdy(fem::double0),
        drt(fem::double0),
        eta0(fem::double0),
        etcrit(fem::double0),
        ettest(fem::double0),
        ip(fem::int0),
        it(fem::int0),
        itest(fem::int0),
        rap0(fem::double0),
        x0(fem::double0),
        xtest(fem::double0),
        y0(fem::double0),
        ytest(fem::double0) {}
};

/// C
/// C=======================================================================
/// Clin-6/06/02 local parton freezeout motivated from critical density:
void local(common& cmn, double const& t) {
  FEM_CMN_SVE(local);
  common_write write(cmn);
  int& mul = cmn.mul;
  const int maxptn = 400001;
  arr_ref<double> gxfrz(cmn.gxfrz, dimension(maxptn));
  arr_ref<double> gyfrz(cmn.gyfrz, dimension(maxptn));
  arr_ref<double> gzfrz(cmn.gzfrz, dimension(maxptn));
  arr_ref<double> ftfrz(cmn.ftfrz, dimension(maxptn));
  arr_ref<double> pxfrz(cmn.pxfrz, dimension(maxptn));
  arr_ref<double> pyfrz(cmn.pyfrz, dimension(maxptn));
  arr_ref<double> pzfrz(cmn.pzfrz, dimension(maxptn));
  arr_ref<double> efrz(cmn.efrz, dimension(maxptn));
  arr_ref<double> xmfrz(cmn.xmfrz, dimension(maxptn));
  arr_cref<double> tfrz(cmn.tfrz, dimension(302));
  arr_ref<int> ifrz(cmn.ifrz, dimension(maxptn));
  arr_ref<int> idfrz(cmn.idfrz, dimension(maxptn));
  int& itlast = cmn.itlast;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  arr_cref<double> eta(cmn.eta, dimension(maxptn));
  arr_cref<double> rap(cmn.rap, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  double& detdy = sve.detdy;
  double& drt = sve.drt;
  double& eta0 = sve.eta0;
  double& etcrit = sve.etcrit;
  double& ettest = sve.ettest;
  int& ip = sve.ip;
  int& it = sve.it;
  int& itest = sve.itest;
  double& rap0 = sve.rap0;
  double& x0 = sve.x0;
  double& xtest = sve.xtest;
  double& y0 = sve.y0;
  double& ytest = sve.ytest;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx5(dimension(maxptn));
      mbr<double> gy5(dimension(maxptn));
      mbr<double> gz5(dimension(maxptn));
      mbr<double> ft5(dimension(maxptn));
      mbr<double> px5(dimension(maxptn));
      mbr<double> py5(dimension(maxptn));
      mbr<double> pz5(dimension(maxptn));
      mbr<double> e5(dimension(maxptn));
      mbr<double> xmass5(dimension(maxptn));
      mbr<int> ityp5(dimension(maxptn));
      prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5, ityp5;
    }
  }
  arr_cref<double> gx5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> xmass5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<int> ityp5(prec2.bind<int>(), dimension(maxptn));
  const double r0 = 1e0;
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /frzprc/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /coal/
  /// C
  FEM_DO_SAFE(it, 1, 301) {
    if (t >= tfrz(it) && t < tfrz(it + 1)) {
      if (it == itlast) {
        return;
      } else {
        itlast = it;
        goto statement_50;
      }
    }
  }
  write(1, star), "local time out of range in LOCAL, stop", t, it;
  FEM_STOP(0);
statement_50:
  /// C
  FEM_DO_SAFE(ip, 1, mul) {
    /// C     skip partons which have frozen out:
    if (ifrz(ip) == 1) {
      goto statement_200;
    }
    if (it == 301) {
      /// C     freezeout all the left partons beyond the time of 3000 fm:
      etcrit = 1e6;
      goto statement_150;
    } else {
      /// C     freezeout when transverse energy density < etcrit:
      etcrit = (cmn.ecritl * 2e0 / 3e0);
    }
    /// C     skip partons which have not yet formed:
    if (t < ft5(ip)) {
      goto statement_200;
    }
    rap0 = rap(ip);
    eta0 = eta(ip);
    x0 = gx5(ip) + vx(ip) * (t - ft5(ip));
    y0 = gy5(ip) + vy(ip) * (t - ft5(ip));
    detdy = 0e0;
    FEM_DO_SAFE(itest, 1, mul) {
      /// C     skip self and partons which have not yet formed:
      if (itest == ip || t < ft5(itest)) {
        goto statement_100;
      }
      ettest = eta(itest);
      xtest = gx5(itest) + vx(itest) * (t - ft5(itest));
      ytest = gy5(itest) + vy(itest) * (t - ft5(itest));
      drt = fem::sqrt(fem::pow2((xtest - x0)) + fem::pow2((ytest - y0)));
      /// C     count partons within drt<1 and -1<(eta-eta0)<1:
      if (fem::dabs(ettest - eta0) <= 1e0 && drt <= r0) {
        detdy += fem::dsqrt(fem::pow2(px5(itest)) + fem::pow2(py5(itest)) +
                            fem::pow2(xmass5(itest))) *
                 0.5e0;
      }
    statement_100:;
    }
    detdy = detdy * (fem::pow2(dcosh(eta0))) /
            (t * 3.1416e0 * fem::pow2(r0) * dcosh(rap0));
  /// C     when density is below critical density for phase transition, freeze
  /// out:
  statement_150:
    if (detdy <= etcrit) {
      ifrz(ip) = 1;
      idfrz(ip) = ityp5(ip);
      pxfrz(ip) = px5(ip);
      pyfrz(ip) = py5(ip);
      pzfrz(ip) = pz5(ip);
      efrz(ip) = e5(ip);
      xmfrz(ip) = xmass5(ip);
      if (t > ft5(ip)) {
        gxfrz(ip) = x0;
        gyfrz(ip) = y0;
        gzfrz(ip) = gz5(ip) + vz(ip) * (t - ft5(ip));
        ftfrz(ip) = t;
      } else {
        /// C     if this freezeout time < formation time, use formation time &
        /// positions. C     This ensures the recovery of default hadron when
        /// e_crit=infty:
        gxfrz(ip) = gx5(ip);
        gyfrz(ip) = gy5(ip);
        gzfrz(ip) = gz5(ip);
        ftfrz(ip) = ft5(ip);
      }
    }
  statement_200:;
  }
  /// C
}

struct savrec_save {
  fem::variant_bindings prec2_bindings;
};

void savrec(common& cmn, int const& i) {
  FEM_CMN_SVE(savrec);
  /// COMMON prec3
  const int maxptn = 400001;
  arr_ref<double> gxs(cmn.gxs, dimension(maxptn));
  arr_ref<double> gys(cmn.gys, dimension(maxptn));
  arr_ref<double> gzs(cmn.gzs, dimension(maxptn));
  arr_ref<double> fts(cmn.fts, dimension(maxptn));
  arr_ref<double> pxs(cmn.pxs, dimension(maxptn));
  arr_ref<double> pys(cmn.pys, dimension(maxptn));
  arr_ref<double> pzs(cmn.pzs, dimension(maxptn));
  arr_ref<double> es(cmn.es, dimension(maxptn));
  arr_ref<double> xmasss(cmn.xmasss, dimension(maxptn));
  arr_ref<int> ityps(cmn.ityps, dimension(maxptn));
  /// COMMON prec5
  arr_cref<double> eta(cmn.eta, dimension(maxptn));
  arr_cref<double> rap(cmn.rap, dimension(maxptn));
  arr_cref<double> tau(cmn.tau, dimension(maxptn));
  /// COMMON prec6
  arr_ref<double> etas(cmn.etas, dimension(maxptn));
  arr_ref<double> raps(cmn.raps, dimension(maxptn));
  arr_ref<double> taus(cmn.taus, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> xmass(prec2.bind<double>(), dimension(maxptn));
  arr_cref<int> ityp(prec2.bind<int>(), dimension(maxptn));
  /// C
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec3/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /prec6/
  /// C
  ityps(i) = ityp(i);
  gxs(i) = gx(i);
  gys(i) = gy(i);
  gzs(i) = gz(i);
  fts(i) = ft(i);
  pxs(i) = px(i);
  pys(i) = py(i);
  pzs(i) = pz(i);
  es(i) = e(i);
  xmasss(i) = xmass(i);
  etas(i) = eta(i);
  raps(i) = rap(i);
  taus(i) = tau(i);
  /// C
}

struct getict_save {
  fem::variant_bindings prec2_bindings;
  int i;

  getict_save() : i(fem::int0) {}
};

void getict(common& cmn, double& t1) {
  FEM_CMN_SVE(getict);
  /// COMMON ilist1
  int& iscat = cmn.iscat;
  int& jscat = cmn.jscat;
  const int maxptn = 400001;
  arr_cref<int> next(cmn.next, dimension(maxptn));
  int& ictype = cmn.ictype;
  arr_cref<int> icsta(cmn.icsta, dimension(maxptn));
  /// COMMON ilist4
  int& ifmpt = cmn.ifmpt;
  /// COMMON ilist5
  arr_cref<double> ot(cmn.ot, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  int& i = sve.i;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  /* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// Cc      SAVE /para1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       neglect possibility of 2 collisions at the same time
  /// C0       set initial conditions
  /// C
  t1 = cmn.tlarge;
  iscat = 0;
  jscat = 0;
  /// C
  /// C1      get next collision between particles
  FEM_DO_SAFE(i, 1, cmn.ichkpt) {
    if (ot(i) < t1) {
      t1 = ot(i);
      iscat = i;
    }
  }
  if (iscat != 0) {
    jscat = next(iscat);
  }
  /// C
  /// C2      get ictype
  /// C     10/30/02 ictype=0:collision; 1:parton formation
  if (iscat != 0 && jscat != 0) {
    if (icsta(iscat) == 0 && icsta(jscat) == 0) {
      ictype = 0;
    } else {
      ictype = 4;
    }
  } else if (iscat != 0 || jscat != 0) {
    ictype = 3;
  }
  /// C
  if (ifmpt <= cmn.mul) {
    if (ft(ifmpt) < t1) {
      ictype = 1;
      t1 = ft(ifmpt);
    } else if (ft(ifmpt) == t1) {
      if (ictype == 0) {
        ictype = 2;
      }
      if (ictype == 3) {
        ictype = 5;
      }
      if (ictype == 4) {
        ictype = 6;
      }
    }
  }
  /// C
}

int integ(double const& x) {
  int return_value = fem::int0;
  /// C       this function is used to get the largest integer that is smaller
  /// than C       x
  /// C
  if (x < 0e0) {
    return_value = fem::fint(x - 1e0);
  } else {
    return_value = fem::fint(x);
  }
  /// C
  return return_value;
}

struct newcre_save {
  int j;

  newcre_save() : j(fem::int0) {}
};

void newcre(common& cmn, int const& i, int& k) {
  FEM_CMN_SVE(newcre);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_ref<int> nic(cmn.nic, dimension(maxptn));
  ///
  /// SAVE
  int& j = sve.j;
  ///
  /// C       this subroutine is used to mk rearrange of the new cell a particle
  /// C       enters,
  /// C       input i
  /// C       output nic(i)
  /// C
  /// Cc      SAVE /ilist1/
  /// C
  if (k == 0) {
    k = i;
    nic(i) = 0;
  } else if (nic(k) == 0) {
    nic(k) = i;
    nic(i) = k;
  } else {
    j = k;
    while (nic(j) != k) {
      j = nic(j);
    }
    /// C
    nic(j) = i;
    nic(i) = k;
    /// C
  }
  /// C
}

struct celasn_save {
  fem::variant_bindings prec2_bindings;
  int i;
  int i1;
  int i2;
  int i3;
  int j;
  double td;
  double tt;

  celasn_save()
      : i(fem::int0),
        i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        j(fem::int0),
        td(fem::double0),
        tt(fem::double0) {}
};

void celasn(common& cmn) {
  FEM_CMN_SVE(celasn);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_ref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist2
  int& icell = cmn.icell;
  arr_ref<int, 3> icel(cmn.icel, dimension(10, 10, 10));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  double& v1 = cmn.v1;
  double& v2 = cmn.v2;
  double& v3 = cmn.v3;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  int& i = sve.i;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& j = sve.j;
  double& td = sve.td;
  double& tt = sve.tt;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to assign a cell for a newly formed
  /// particle C       output: nic(MAXPTN) icels(MAXPTN) in the common /ilist1/
  /// C icell, and icel(10,10,10) in the common /ilist2/
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist2/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist4/
  /// C
  i = cmn.ifmpt;
  tt = ft(i);
  td = tt - cmn.size;
  if (iconfg == 1 && (size1 == 0e0 || size2 == 0e0 || size3 == 0e0)) {
    i1 = 11;
    i2 = 11;
    i3 = 11;
  } else if (iconfg == 4 || td <= 0e0) {
    i1 = integ(gx(i) / size1) + 6;
    i2 = integ(gy(i) / size2) + 6;
    i3 = integ(gz(i) / size3) + 6;
    if (integ(gx(i) / size1) == gx(i) / size1 && vx(i) < 0e0) {
      i1 = i1 - 1;
    }
    if (integ(gy(i) / size2) == gy(i) / size2 && vy(i) < 0e0) {
      i2 = i2 - 1;
    }
    if (integ(gz(i) / size3) == gz(i) / size3 && vz(i) < 0e0) {
      i3 = i3 - 1;
    }
  } else {
    i1 = integ(gx(i) / (size1 + v1 * td)) + 6;
    i2 = integ(gy(i) / (size2 + v2 * td)) + 6;
    i3 = integ(gz(i) / (size3 + v3 * td)) + 6;
    if (integ(gx(i) / (size1 + v1 * td)) == gx(i) / (size1 + v1 * td) &&
        vx(i) < (i1 - 6) * v1) {
      i1 = i1 - 1;
    }
    if (integ(gy(i) / (size2 + v2 * td)) == gy(i) / (size2 + v2 * td) &&
        vy(i) < (i2 - 6) * v2) {
      i2 = i2 - 1;
    }
    if (integ(gz(i) / (size3 + v3 * td)) == gz(i) / (size3 + v3 * td) &&
        vz(i) < (i3 - 6) * v3) {
      i3 = i3 - 1;
    }
  }
  /// C
  if (i1 <= 0 || i1 >= 11 || i2 <= 0 || i2 >= 11 || i3 <= 0 || i3 >= 11) {
    i1 = 11;
    i2 = 11;
    i3 = 11;
  }
  /// C
  if (i1 == 11) {
    j = icell;
    newcre(cmn, i, j);
    icell = j;
    icels(i) = 111111;
  } else {
    j = icel(i1, i2, i3);
    newcre(cmn, i, j);
    icel(i1, i2, i3) = j;
    icels(i) = i1 * 10000 + i2 * 100 + i3;
  }
  /// C
}

struct oldcre_save {
  int j;

  oldcre_save() : j(fem::int0) {}
};

void oldcre(common& cmn, int const& i) {
  FEM_CMN_SVE(oldcre);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_ref<int> nic(cmn.nic, dimension(maxptn));
  ///
  /// SAVE
  int& j = sve.j;
  ///
  /// C       this subroutine is used to rearrange the old cell nic when a
  /// particle C       goes out of the cell
  /// C
  /// Cc      SAVE /ilist1/
  /// C
  if (nic(i) == 0) {
    return;
  }
  /// C
  j = nic(i);
  /// C
  if (nic(j) == i) {
    nic(j) = 0;
    return;
  }
  /// C
  while (nic(j) != i) {
    j = nic(j);
  }
  /// C
  nic(j) = nic(i);
  /// C
}

struct wallc1_save {
  fem::variant_bindings prec2_bindings;
  double t1;
  double t2;
  double t3;
  double tf;
  double v1p;
  double v2p;
  double v3p;
  double x1p;
  double x2p;
  double x3p;

  wallc1_save()
      : t1(fem::double0),
        t2(fem::double0),
        t3(fem::double0),
        tf(fem::double0),
        v1p(fem::double0),
        v2p(fem::double0),
        v3p(fem::double0),
        x1p(fem::double0),
        x2p(fem::double0),
        x3p(fem::double0) {}
};

void wallc1(common& cmn, int const& i, int const& i1, int const& i2,
            int const& i3, double const& t, double& tmin) {
  FEM_CMN_SVE(wallc1);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_ref<int> icsta(cmn.icsta, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  double& v1 = cmn.v1;
  double& v2 = cmn.v2;
  double& v3 = cmn.v3;
  double& size = cmn.size;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  double& t3 = sve.t3;
  double& tf = sve.tf;
  double& v1p = sve.v1p;
  double& v2p = sve.v2p;
  double& v3p = sve.v3p;
  double& x1p = sve.x1p;
  double& x2p = sve.x2p;
  double& x3p = sve.x3p;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to get wall collision time
  /// C       when particle is inside the cube, it sets the icsta at the same
  /// time C       input i,i1,i2,i3,t C       output tmin, icsta(i) C       note
  /// the icsta is not finally set. we need further judgement in C       fixtim
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  x1p = gx(i);
  x2p = gy(i);
  x3p = gz(i);
  tf = ft(i);
  v1p = vx(i);
  v2p = vy(i);
  v3p = vz(i);
  /// C
  if (t < size && tf < size) {
    /// C
    if (v1p > 0e0) {
      t1 = ((fem::dble(i1) - 5e0) * size1 - x1p) / v1p + tf;
    } else if (v1p < 0e0) {
      t1 = ((fem::dble(i1) - 6e0) * size1 - x1p) / v1p + tf;
    } else {
      t1 = tlarge;
    }
    /// C
    if (v2p > 0e0) {
      t2 = ((fem::dble(i2) - 5e0) * size2 - x2p) / v2p + tf;
    } else if (v2p < 0e0) {
      t2 = ((fem::dble(i2) - 6e0) * size2 - x2p) / v2p + tf;
    } else {
      t2 = tlarge;
    }
    /// C
    if (v3p > 0e0) {
      t3 = ((fem::dble(i3) - 5e0) * size3 - x3p) / v3p + tf;
    } else if (v3p < 0e0) {
      t3 = ((fem::dble(i3) - 6e0) * size3 - x3p) / v3p + tf;
    } else {
      t3 = tlarge;
    }
    /// C
    /// C       if a particle is on the wall, we don't collide it on the same
    /// wall
    /// C
    /// C        if (t1 .eq. 0d0) t1 = tlarge
    /// C        if (t2 .eq. 0d0) t2 = tlarge
    /// C        if (t3 .eq. 0d0) t3 = tlarge
    /// C
    tmin = fem::min(t1, t2, t3);
    /// C
    /// C       set icsta,
    /// C       after checking this is not an earlier collision comparing with
    /// C       a collision with another particle, we need to set icsta=0
    /// C       after checking whether there is also a particle collision
    /// C       at the same time, we need to reset the second bit of icsta
    /// C
    if (tmin == t1) {
      if (v1p > 0e0) {
        icsta(i) = 101;
      } else {
        icsta(i) = 102;
      }
    }
    /// C
    if (tmin == t2) {
      if (v2p > 0e0) {
        icsta(i) = 103;
      } else {
        icsta(i) = 104;
      }
    }
    /// C
    if (tmin == t3) {
      if (v3p > 0e0) {
        icsta(i) = 105;
      } else {
        icsta(i) = 106;
      }
    }
    /// C
    if (tmin <= size) {
      return;
    }
    /// C
  }
  /// C
  if (v1p > (i1 - 5) * v1) {
    t1 = ((i1 - 5) * (size1 - v1 * size) + v1p * tf - x1p) /
         (v1p - (i1 - 5) * v1);
  } else if (v1p < (i1 - 6) * v1) {
    t1 = ((i1 - 6) * (size1 - v1 * size) + v1p * tf - x1p) /
         (v1p - (i1 - 6) * v1);
  } else {
    t1 = tlarge;
  }
  /// C
  if (v2p > (i2 - 5) * v2) {
    t2 = ((i2 - 5) * (size2 - v2 * size) + v2p * tf - x2p) /
         (v2p - (i2 - 5) * v2);
  } else if (v2p < (i2 - 6) * v2) {
    t2 = ((i2 - 6) * (size2 - v2 * size) + v2p * tf - x2p) /
         (v2p - (i2 - 6) * v2);
  } else {
    t2 = tlarge;
  }
  /// C
  if (v3p > (i3 - 5) * v3) {
    t3 = ((i3 - 5) * (size3 - v3 * size) + v3p * tf - x3p) /
         (v3p - (i3 - 5) * v3);
  } else if (v3p < (i3 - 6) * v3) {
    t3 = ((i3 - 6) * (size3 - v3 * size) + v3p * tf - x3p) /
         (v3p - (i3 - 6) * v3);
  } else {
    t3 = tlarge;
  }
  /// C
  /// C       if a particle is on the wall, we don't collide it on the same wall
  /// C
  /// C        if (t1 .eq. 0d0) t1 = tlarge
  /// C        if (t2 .eq. 0d0) t2 = tlarge
  /// C        if (t3 .eq. 0d0) t3 = tlarge
  /// C
  tmin = fem::min(t1, t2, t3);
  /// C
  /// C       set icsta,
  /// C       after checking this is not an earlier collision comparing with
  /// C       a collision with another particle, we need to set icsta=0
  /// C       after checking whether there is also a particle collision
  /// C       at the same time, we need to reset the second bit of icsta
  /// C
  if (tmin == t1) {
    if (v1p > (i1 - 5) * v1) {
      icsta(i) = 101;
    } else {
      icsta(i) = 102;
    }
  }
  /// C
  if (tmin == t2) {
    if (v2p > (i2 - 5) * v2) {
      icsta(i) = 103;
    } else {
      icsta(i) = 104;
    }
  }
  /// C
  if (tmin == t3) {
    if (v3p > (i3 - 5) * v3) {
      icsta(i) = 105;
    } else {
      icsta(i) = 106;
    }
  }
  /// C
}

struct wallc2_save {
  fem::variant_bindings prec2_bindings;
  double t1;
  double t2;
  double t3;
  double tf;
  double v1p;
  double v2p;
  double v3p;
  double x1p;
  double x2p;
  double x3p;

  wallc2_save()
      : t1(fem::double0),
        t2(fem::double0),
        t3(fem::double0),
        tf(fem::double0),
        v1p(fem::double0),
        v2p(fem::double0),
        v3p(fem::double0),
        x1p(fem::double0),
        x2p(fem::double0),
        x3p(fem::double0) {}
};

void wallc2(common& cmn, int const& i, int const& /* i1 */, int const& /* i2 */,
            int const& /* i3 */, double const& /* t */, double& tmin) {
  FEM_CMN_SVE(wallc2);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_ref<int> icsta(cmn.icsta, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  double& t3 = sve.t3;
  double& tf = sve.tf;
  double& v1p = sve.v1p;
  double& v2p = sve.v2p;
  double& v3p = sve.v3p;
  double& x1p = sve.x1p;
  double& x2p = sve.x2p;
  double& x3p = sve.x3p;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to get wall collision time
  /// C       when particle is inside the cube, it sets the icsta at the same
  /// time C       input i,i1,i2,i3,t C       output tmin, icsta(i) C       note
  /// the icsta is not finally set. we need further judgement in C       fixtim
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  x1p = gx(i);
  x2p = gy(i);
  x3p = gz(i);
  tf = ft(i);
  v1p = vx(i);
  v2p = vy(i);
  v3p = vz(i);
  /// C
  if (v1p > 0e0) {
    t1 = (5e0 * size1 - x1p) / v1p + tf;
  } else if (v1p < 0e0) {
    t1 = (-5e0 * size1 - x1p) / v1p + tf;
  } else {
    t1 = tlarge;
  }
  /// C
  if (v2p > 0e0) {
    t2 = (5e0 * size2 - x2p) / v2p + tf;
  } else if (v2p < 0e0) {
    t2 = (-5e0 * size2 - x2p) / v2p + tf;
  } else {
    t2 = tlarge;
  }
  /// C
  if (cmn.iconfg == 5) {
    if (v3p > 0e0) {
      t3 = (5e0 * size3 - x3p) / v3p + tf;
    } else if (v3p < 0e0) {
      t3 = (-5e0 * size3 - x3p) / v3p + tf;
    } else {
      t3 = tlarge;
    }
  } else {
    t3 = tlarge;
  }
  /// C
  tmin = fem::min(t1, t2, t3);
  /// C
  /// C       set icsta,
  /// C       after checking this is not an earlier collision comparing with
  /// C       a collision with another particle, we need to set icsta=0
  /// C       after checking whether there is also a particle collision
  /// C       at the same time, we need to reset the second bit of icsta
  /// C
  if (tmin == t1) {
    if (v1p > 0e0) {
      icsta(i) = 101;
    } else {
      icsta(i) = 102;
    }
  }
  /// C
  if (tmin == t2) {
    if (v2p > 0e0) {
      icsta(i) = 103;
    } else {
      icsta(i) = 104;
    }
  }
  /// C
  if (tmin == t3) {
    if (v3p > 0e0) {
      icsta(i) = 105;
    } else {
      icsta(i) = 106;
    }
  }
  /// C
}

struct wallcb_save {
  fem::variant_bindings prec2_bindings;
  int icsta1;
  int icsta2;
  int icsta3;
  double t1;
  double t2;
  double t3;
  double tf;
  double v1p;
  double v2p;
  double v3p;
  double x1p;
  double x1pp;
  double x1q;
  double x2p;
  double x2pp;
  double x2q;
  double x3p;
  double x3pp;
  double x3q;

  wallcb_save()
      : icsta1(fem::int0),
        icsta2(fem::int0),
        icsta3(fem::int0),
        t1(fem::double0),
        t2(fem::double0),
        t3(fem::double0),
        tf(fem::double0),
        v1p(fem::double0),
        v2p(fem::double0),
        v3p(fem::double0),
        x1p(fem::double0),
        x1pp(fem::double0),
        x1q(fem::double0),
        x2p(fem::double0),
        x2pp(fem::double0),
        x2q(fem::double0),
        x3p(fem::double0),
        x3pp(fem::double0),
        x3q(fem::double0) {}
};

void wallcb(common& cmn, int const& i, double const& t, double& tmin) {
  FEM_CMN_SVE(wallcb);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_ref<int> icsta(cmn.icsta, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  double& v1 = cmn.v1;
  double& v2 = cmn.v2;
  double& v3 = cmn.v3;
  double& size = cmn.size;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  int& icsta1 = sve.icsta1;
  int& icsta2 = sve.icsta2;
  int& icsta3 = sve.icsta3;
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  double& t3 = sve.t3;
  double& tf = sve.tf;
  double& v1p = sve.v1p;
  double& v2p = sve.v2p;
  double& v3p = sve.v3p;
  double& x1p = sve.x1p;
  double& x1pp = sve.x1pp;
  double& x1q = sve.x1q;
  double& x2p = sve.x2p;
  double& x2pp = sve.x2pp;
  double& x2q = sve.x2q;
  double& x3p = sve.x3p;
  double& x3pp = sve.x3pp;
  double& x3q = sve.x3q;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to calculate the wall collision time
  /// C       when the particle is outside the cube
  /// C       input i,t
  /// C       output tmin,icsta(i)
  /// C       note the icsta is not finally set. we need further judgement in
  /// C       fixtim
  /// C
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       check if there is a collision by looking at the closest approach
  /// point C       and see if it's inside the cube
  /// C
  if (size1 == 0e0 || size2 == 0e0 || size3 == 0e0) {
    return;
  }
  /// C
  x1p = gx(i);
  x2p = gy(i);
  x3p = gz(i);
  v1p = vx(i);
  v2p = vy(i);
  v3p = vz(i);
  tf = ft(i);
  /// C
  if (t < size && tf < size) {
    if (x1p < -5e0 * size1 && v1p > 0e0) {
      t1 = (-5e0 * size1 - x1p) / v1p + tf;
    } else if (x1p > 5e0 * size1 && v1p < 0e0) {
      t1 = -(x1p - 5e0 * size1) / v1p + tf;
    } else {
      t1 = tlarge;
    }
    /// C
    if (t1 != tlarge) {
      x2pp = x2p + v2p * (t1 - tf);
      x3pp = x3p + v3p * (t1 - tf);
      if (x2pp <= -5e0 * size2 || x2pp >= 5e0 * size2 || x3pp <= -5e0 * size3 ||
          x3pp >= 5e0 * size3) {
        t1 = tlarge;
      }
    }
    /// C
    if (x2p < -5e0 * size2 && v2p > 0e0) {
      t2 = (-5e0 * size2 - x2p) / v2p + tf;
    } else if (x2p > 5e0 * size2 && v2p < 0e0) {
      t2 = -(x2p - 5e0 * size2) / v2p + tf;
    } else {
      t2 = tlarge;
    }
    /// C
    if (t2 != tlarge) {
      x1pp = x1p + v1p * (t2 - tf);
      x3pp = x3p + v3p * (t2 - tf);
      if (x1pp <= -5e0 * size1 || x1pp >= 5e0 * size1 || x3pp <= -5e0 * size3 ||
          x3pp >= 5e0 * size3) {
        t2 = tlarge;
      }
    }
    /// C
    if (x3p < -5e0 * size3 && v3p > 0e0) {
      t3 = (-5e0 * size3 - x3p) / v3p + tf;
    } else if (x3p > 5e0 * size3 && v3p < 0e0) {
      t3 = -(x3p - 5e0 * size3) / v3p + tf;
    } else {
      t3 = tlarge;
    }
    /// C
    if (t3 != tlarge) {
      x1pp = x1p + v1p * (t3 - tf);
      x2pp = x2p + v2p * (t3 - tf);
      if (x1pp <= -5e0 * size1 || x1pp >= 5e0 * size1 || x2pp <= -5e0 * size2 ||
          x2pp >= 5e0 * size2) {
        t3 = tlarge;
      }
    }
    /// C
    tmin = fem::min(t1, t2, t3);
    /// C
    /// C       set icsta,
    /// C       after checking this is not an earlier collision comparing with
    /// C       a collision with another particle, we need to set icsta=0
    /// C       after checking whether there is also a particle collision
    /// C       at the same time, we need to reset the second bit of icsta
    /// C
    if (tmin == t1) {
      if (v1p > 0e0) {
        icsta(i) = 101;
      } else {
        icsta(i) = 102;
      }
    }
    /// C
    if (tmin == t2) {
      if (v2p > 0e0) {
        icsta(i) = 103;
      } else {
        icsta(i) = 104;
      }
    }
    /// C
    if (tmin == t3) {
      if (v3p > 0e0) {
        icsta(i) = 105;
      } else {
        icsta(i) = 106;
      }
    }
    /// C
    if (tmin <= size) {
      return;
    }
    /// C
  }
  /// C
  /// C       notice now x1q, x2q, x3q are coordinates at time t
  x1q = x1p + v1p * (t - tf);
  x2q = x2p + v2p * (t - tf);
  x3q = x3p + v3p * (t - tf);
  /// C
  if (x1q < -5e0 * (size1 + v1 * (t - size)) && v1p > -5e0 * v1) {
    t1 = (-5e0 * (size1 - v1 * size) + v1p * tf - x1p) / (v1p - (-5e0) * v1);
    icsta1 = 101;
  } else if (x1q > 5e0 * (size1 + v1 * (t - size)) && v1p < 5e0 * v1) {
    t1 = (5e0 * (size1 - v1 * size) + v1p * tf - x1p) / (v1p - 5e0 * v1);
    icsta1 = 102;
  } else {
    t1 = tlarge;
  }
  /// C
  if (t1 != tlarge) {
    x2pp = x2p + v2p * (t1 - tf);
    x3pp = x3p + v3p * (t1 - tf);
    if (x2pp <= -5e0 * (size2 + v2 * (t1 - size)) ||
        x2pp >= 5e0 * (size2 + v2 * (t1 - size)) ||
        x3pp <= -5e0 * (size3 + v3 * (t1 - size)) ||
        x3pp >= 5e0 * (size3 + v3 * (t1 - size))) {
      t1 = tlarge;
    }
  }
  /// C
  if (x2q < -5e0 * (size2 + v2 * (t - size)) && v2p > -5e0 * v2) {
    t2 = (-5e0 * (size2 - v2 * size) + v2p * tf - x2p) / (v2p - (-5e0) * v2);
    icsta2 = 103;
  } else if (x2q > 5e0 * (size2 + v2 * (t - size)) && v2p < 5e0 * v2) {
    t2 = (5e0 * (size2 - v2 * size) + v2p * tf - x2p) / (v2p - 5e0 * v2);
    icsta2 = 104;
  } else {
    t2 = tlarge;
  }
  /// C
  if (t2 != tlarge) {
    x1pp = x1p + v1p * (t2 - tf);
    x3pp = x3p + v3p * (t2 - tf);
    if (x1pp <= -5e0 * (size1 + v1 * (t2 - size)) ||
        x1pp >= 5e0 * (size1 + v1 * (t2 - size)) ||
        x3pp <= -5e0 * (size3 + v3 * (t2 - size)) ||
        x3pp >= 5e0 * (size3 + v3 * (t2 - size))) {
      t2 = tlarge;
    }
  }
  /// C
  if (x3q < -5e0 * (size3 + v3 * (t - size)) && v3p > -5e0 * v3) {
    t3 = (-5e0 * (size3 - v3 * size) + v3p * tf - x3p) / (v3p - (-5e0) * v3);
    icsta3 = 105;
  } else if (x3q > 5e0 * (size3 + v3 * (t - size)) && v3p < 5e0 * v3) {
    t3 = (5e0 * (size3 - v3 * size) + v3p * tf - x3p) / (v3p - 5e0 * v3);
    icsta3 = 106;
  } else {
    t3 = tlarge;
  }
  /// C
  if (t3 != tlarge) {
    x2pp = x2p + v2p * (t3 - tf);
    x1pp = x1p + v1p * (t3 - tf);
    if (x2pp <= -5e0 * (size2 + v2 * (t3 - size)) ||
        x2pp >= 5e0 * (size2 + v2 * (t3 - size)) ||
        x1pp <= -5e0 * (size1 + v1 * (t3 - size)) ||
        x1pp >= 5e0 * (size1 + v1 * (t3 - size))) {
      t3 = tlarge;
    }
  }
  /// C
  tmin = fem::min(t1, t2, t3);
  /// C
  /// C       set icsta,
  /// C       after checking this is not an earlier collision comparing with
  /// C       a collision with another particle, we need to set icsta=0
  /// C       after checking whether there is also a particle collision
  /// C       at the same time, we need to reset the second bit of icsta
  /// C
  if (tmin == t1) {
    icsta(i) = icsta1;
  } else if (tmin == t2) {
    icsta(i) = icsta2;
  } else if (tmin == t3) {
    icsta(i) = icsta3;
  }
  /// C
}

void wallc(common& cmn, int const& i, int const& i1, int const& i2,
           int const& i3, double const& t, double& tmin) {
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  ///
  /// C       this subroutine calculates the next time for collision with wall
  /// C       for particle i
  /// C       input particle label i,t
  /// C       output tmin collision time with wall, icsta(i) wall collision
  /// C       information
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /ilist5/
  /// C
  tmin = cmn.tlarge;
  /// C
  if (iconfg <= 2 || iconfg == 4) {
    /// C       if particle is inside the cube
    if ((i1 >= 1 && i1 <= 10) || (i2 >= 1 && i2 <= 10) ||
        (i3 >= 1 && i3 <= 10)) {
      wallc1(cmn, i, i1, i2, i3, t, tmin);
      /// C       if particle is outside the cube
    } else {
      wallcb(cmn, i, t, tmin);
    }
  } else if (iconfg == 3 || iconfg == 5) {
    wallc2(cmn, i, i1, i2, i3, t, tmin);
  }
  /// C
}

struct fixtim_save {
  int k;

  fixtim_save() : k(fem::int0) {}
};

void fixtim(common& cmn, int const& l, double const& /* t */,
            double const& tmin1, double const& tmin, int const& nc) {
  FEM_CMN_SVE(fixtim);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_ref<int> next(cmn.next, dimension(maxptn));
  arr_ref<int> icsta(cmn.icsta, dimension(maxptn));
  /// COMMON ilist5
  arr_cref<double> ct(cmn.ct, dimension(maxptn));
  arr_ref<double> ot(cmn.ot, dimension(maxptn));
  ///
  /// SAVE
  int& k = sve.k;
  ///
  /// C       this subroutine is used to compare the collision time with wall
  /// tmin1 C       and new collision time with particles for particle l C when
  /// used in ulist, input nc may be 0, which indicates no particle C collisions
  /// happen before wall collision, of course, then tmin=tmin1
  /// C
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist5/
  /// C
  k = nc;
  if (tmin < tmin1) {
    ot(l) = tmin;
    if (ct(l) < tmin1) {
      icsta(l) = 0;
    } else {
      icsta(l) += 10;
    }
    next(l) = k;
  } else if (tmin == tmin1) {
    ot(l) = tmin;
    if (nc == 0) {
      next(l) = 0;
    } else {
      icsta(l) += 10;
      next(l) = k;
    }
  } else {
    ot(l) = tmin1;
    next(l) = 0;
  }
  /// C
}

struct isco1_save {
  fem::variant_bindings prec2_bindings;
  double a;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  int i1;
  int i2;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc2;
  double vp;

  isco1_save()
      : a(fem::double0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc2(fem::double0),
        vp(fem::double0) {}
};

void isco1(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco1);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc2 = sve.tc2;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  i1 = i;
  i2 = j;
  /// C
  p4 = ft(i2) - ft(i1);
  p1 = gx(i2) - gx(i1);
  p2 = gy(i2) - gy(i1);
  p3 = gz(i2) - gz(i1);
  /// C
  q4 = e(i1);
  q1 = px(i1);
  q2 = py(i1);
  q3 = pz(i1);
  /// C
  r4 = e(i2);
  r1 = px(i2);
  r2 = py(i2);
  r3 = pz(i2);
  /// C
  a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
  b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
  c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
  d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
  ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
  f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
  /// C
  /// C       make sure particle 2 formed early
  h = a + b;
  if (h > 0e0) {
    g = a;
    a = -b;
    b = -g;
    /// C
    g = c;
    c = d;
    d = g;
    /// C
    i1 = j;
    i2 = i;
  }
  /// C
  /// C       check the approaching criteria
  if (allok) {
    /// C
    vp = a * d - b * ee;
    /// C
    allok = allok && vp < 0e0;
    /// C
  }
  /// C
  /// C       check the closest approach distance criteria
  if (allok) {
    /// C
    dm2 = -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                   (fem::pow2(ee) - c * d);
    /// C
    allok = allok && dm2 < cmn.cutof2;
    /// C
  }
  /// C
  /// C       check the time criteria
  if (allok) {
    /// C
    tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
    tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
    tm = 0.5e0 * (tc1 + tc2);
    /// C
    allok = allok && tm > ft(i) && tm > ft(j);
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (h > 0e0) {
    t1 = tm;
    t2 = tm;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco2_save {
  fem::variant_bindings prec2_bindings;
  double a;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  int i1;
  int i2;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc2;
  double vp;

  isco2_save()
      : a(fem::double0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc2(fem::double0),
        vp(fem::double0) {}
};

void isco2(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco2);
  /// COMMON para5
  int& iordsc = cmn.iordsc;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc2 = sve.tc2;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  i1 = i;
  i2 = j;
  /// C
  p4 = ft(i2) - ft(i1);
  p1 = gx(i2) - gx(i1);
  p2 = gy(i2) - gy(i1);
  p3 = gz(i2) - gz(i1);
  /// C
  q4 = e(i1);
  q1 = px(i1);
  q2 = py(i1);
  q3 = pz(i1);
  /// C
  r4 = e(i2);
  r1 = px(i2);
  r2 = py(i2);
  r3 = pz(i2);
  /// C
  a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
  b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
  c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
  d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
  ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
  f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
  /// C
  /// C       make sure particle 2 formed early
  h = a + b;
  if (h > 0e0) {
    g = a;
    a = -b;
    b = -g;
    /// C
    g = c;
    c = d;
    d = g;
    /// C
    i1 = j;
    i2 = i;
  }
  /// C
  /// C       check the approaching criteria
  if (allok) {
    /// C
    vp = a * d - b * ee;
    /// C
    allok = allok && vp < 0e0;
    /// C
  }
  /// C
  /// C       check the closest approach distance criteria
  if (allok) {
    /// C
    dm2 = -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                   (fem::pow2(ee) - c * d);
    /// C
    allok = allok && dm2 < cmn.cutof2;
    /// C
  }
  /// C
  /// C       check the time criteria
  if (allok) {
    /// C
    tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
    tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
    if (iordsc == 20) {
      tm = fem::min(tc1, tc2);
    } else if (iordsc == 21) {
      tm = 0.5e0 * (tc1 + tc2);
    } else {
      tm = fem::max(tc1, tc2);
    }
    /// C
    allok = allok && tm > ft(i) && tm > ft(j);
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (h > 0e0) {
    t1 = tc2;
    t2 = tc1;
  } else {
    t1 = tc1;
    t2 = tc2;
  }
  /// C
}

struct isco3_save {
  fem::variant_bindings prec2_bindings;
  double dgx;
  double dgy;
  double dgz;
  double dm2;
  double dt;
  double dvx;
  double dvy;
  double dvz;
  double dx;
  double dy;
  double dz;
  double e1;
  double e2;
  int i1;
  int i2;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double rts2;
  double v2;
  double vp;
  double vx1;
  double vy1;
  double vz1;

  isco3_save()
      : dgx(fem::double0),
        dgy(fem::double0),
        dgz(fem::double0),
        dm2(fem::double0),
        dt(fem::double0),
        dvx(fem::double0),
        dvy(fem::double0),
        dvz(fem::double0),
        dx(fem::double0),
        dy(fem::double0),
        dz(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        rts2(fem::double0),
        v2(fem::double0),
        vp(fem::double0),
        vx1(fem::double0),
        vy1(fem::double0),
        vz1(fem::double0) {}
};

void isco3(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco3);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& dgx = sve.dgx;
  double& dgy = sve.dgy;
  double& dgz = sve.dgz;
  double& dm2 = sve.dm2;
  double& dt = sve.dt;
  double& dvx = sve.dvx;
  double& dvy = sve.dvy;
  double& dvz = sve.dvz;
  double& dx = sve.dx;
  double& dy = sve.dy;
  double& dz = sve.dz;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& rts2 = sve.rts2;
  double& v2 = sve.v2;
  double& vp = sve.vp;
  double& vx1 = sve.vx1;
  double& vy1 = sve.vy1;
  double& vz1 = sve.vz1;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  if (ft(i) >= ft(j)) {
    i1 = j;
    i2 = i;
  } else {
    i1 = i;
    i2 = j;
  }
  /// C
  if (allok) {
    /// C
    t1 = ft(i1);
    vx1 = vx(i1);
    vy1 = vy(i1);
    vz1 = vz(i1);
    /// C
    t2 = ft(i2);
    /// C
    dvx = vx(i2) - vx1;
    dvy = vy(i2) - vy1;
    dvz = vz(i2) - vz1;
    /// C
    dt = t2 - t1;
    /// C
    dx = gx(i2) - gx(i1) - vx1 * dt;
    dy = gy(i2) - gy(i1) - vy1 * dt;
    dz = gz(i2) - gz(i1) - vz1 * dt;
    /// C
    vp = dvx * dx + dvy * dy + dvz * dz;
    /// C
    allok = allok && vp < 0e0;
    /// C
  }
  /// C
  if (allok) {
    /// C
    v2 = dvx * dvx + dvy * dvy + dvz * dvz;
    /// C
    if (v2 == 0e0) {
      tm = tlarge;
    } else {
      tm = t2 - vp / v2;
    }
    /// C
    /// C       note now tm is the absolute time
    /// C
    allok = allok && tm > t1 && tm > t2;
    /// C
  }
  /// C
  if (allok) {
    /// C
    dgx = dx - dvx * t2;
    dgy = dy - dvy * t2;
    dgz = dz - dvz * t2;
    /// C
    dm2 = -v2 * fem::pow2(tm) + dgx * dgx + dgy * dgy + dgz * dgz;
    /// C
    allok = allok && dm2 < cmn.cutof2;
    /// C
  }
  /// C
  if (allok) {
    /// C
    e1 = e(i1);
    px1 = px(i1);
    py1 = py(i1);
    pz1 = pz(i1);
    e2 = e(i2);
    px2 = px(i2);
    py2 = py(i2);
    pz2 = pz(i2);
    /// C
    rts2 = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
           fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco4_save {
  fem::variant_bindings prec2_bindings;
  double a;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  int i1;
  int i2;
  int icels1;
  int icels2;
  int ii1;
  int ii2;
  int jj1;
  int jj2;
  int kk1;
  int kk2;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc2;
  double vp;

  isco4_save()
      : a(fem::double0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        icels1(fem::int0),
        icels2(fem::int0),
        ii1(fem::int0),
        ii2(fem::int0),
        jj1(fem::int0),
        jj2(fem::int0),
        kk1(fem::int0),
        kk2(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc2(fem::double0),
        vp(fem::double0) {}
};

void isco4(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco4);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& icels1 = sve.icels1;
  int& icels2 = sve.icels2;
  int& ii1 = sve.ii1;
  int& ii2 = sve.ii2;
  int& jj1 = sve.jj1;
  int& jj2 = sve.jj2;
  int& kk1 = sve.kk1;
  int& kk2 = sve.kk2;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc2 = sve.tc2;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  /// C
  icels1 = icels(i);
  ii1 = icels1 / 10000;
  jj1 = (icels1 - ii1 * 10000) / 100;
  kk1 = icels1 - ii1 * 10000 - jj1 * 100;
  icels2 = icels(j);
  ii2 = icels2 / 10000;
  jj2 = (icels2 - ii2 * 10000) / 100;
  kk2 = icels2 - ii2 * 10000 - jj2 * 100;
  /// C
  i1 = i;
  i2 = j;
  /// C
  p4 = ft(i2) - ft(i1);
  p1 = gx(i2) - gx(i1);
  p2 = gy(i2) - gy(i1);
  p3 = gz(i2) - gz(i1);
  /// C
  if (ii1 - ii2 > 5) {
    p1 += 10e0 * size1;
  } else if (ii1 - ii2 < -5) {
    p1 = p1 - 10e0 * size1;
  }
  if (jj1 - jj2 > 5) {
    p2 += 10e0 * size2;
  } else if (jj1 - jj2 < -5) {
    p2 = p2 - 10e0 * size2;
  }
  if (kk1 - kk2 > 5) {
    p3 += 10e0 * size3;
  } else if (kk1 - kk2 < -5) {
    p3 = p3 - 10e0 * size3;
  }
  /// C
  q4 = e(i1);
  q1 = px(i1);
  q2 = py(i1);
  q3 = pz(i1);
  /// C
  r4 = e(i2);
  r1 = px(i2);
  r2 = py(i2);
  r3 = pz(i2);
  /// C
  a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
  b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
  c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
  d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
  ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
  f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
  /// C
  /// C       make sure particle 2 formed early
  h = a + b;
  if (h > 0e0) {
    g = a;
    a = -b;
    b = -g;
    /// C
    g = c;
    c = d;
    d = g;
    /// C
    i1 = j;
    i2 = i;
  }
  /// C
  /// C       check the approaching criteria
  if (allok) {
    /// C
    vp = a * d - b * ee;
    /// C
    allok = allok && vp < 0e0;
    /// C
  }
  /// C
  /// C       check the closest approach distance criteria
  if (allok) {
    /// C
    dm2 = -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                   (fem::pow2(ee) - c * d);
    /// C
    allok = allok && dm2 < cmn.cutof2;
    /// C
  }
  /// C
  /// C       check the time criteria
  if (allok) {
    /// C
    tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
    tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
    tm = 0.5e0 * (tc1 + tc2);
    /// C
    allok = allok && tm > ft(i) && tm > ft(j);
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (h > 0e0) {
    t1 = tm;
    t2 = tm;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco5_save {
  fem::variant_bindings prec2_bindings;
  double a;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  int i1;
  int i2;
  int icels1;
  int icels2;
  int ii1;
  int ii2;
  int jj1;
  int jj2;
  int kk1;
  int kk2;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc2;
  double vp;

  isco5_save()
      : a(fem::double0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        icels1(fem::int0),
        icels2(fem::int0),
        ii1(fem::int0),
        ii2(fem::int0),
        jj1(fem::int0),
        jj2(fem::int0),
        kk1(fem::int0),
        kk2(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc2(fem::double0),
        vp(fem::double0) {}
};

void isco5(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco5);
  /// COMMON para5
  int& iordsc = cmn.iordsc;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& icels1 = sve.icels1;
  int& icels2 = sve.icels2;
  int& ii1 = sve.ii1;
  int& ii2 = sve.ii2;
  int& jj1 = sve.jj1;
  int& jj2 = sve.jj2;
  int& kk1 = sve.kk1;
  int& kk2 = sve.kk2;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc2 = sve.tc2;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  /// C
  icels1 = icels(i);
  ii1 = icels1 / 10000;
  jj1 = (icels1 - ii1 * 10000) / 100;
  kk1 = icels1 - ii1 * 10000 - jj1 * 100;
  icels2 = icels(j);
  ii2 = icels2 / 10000;
  jj2 = (icels2 - ii2 * 10000) / 100;
  kk2 = icels2 - ii2 * 10000 - jj2 * 100;
  /// C
  i1 = i;
  i2 = j;
  /// C
  p4 = ft(i2) - ft(i1);
  p1 = gx(i2) - gx(i1);
  p2 = gy(i2) - gy(i1);
  p3 = gz(i2) - gz(i1);
  /// C
  if (ii1 - ii2 > 5) {
    p1 += 10e0 * size1;
  } else if (ii1 - ii2 < -5) {
    p1 = p1 - 10e0 * size1;
  }
  if (jj1 - jj2 > 5) {
    p2 += 10e0 * size2;
  } else if (jj1 - jj2 < -5) {
    p2 = p2 - 10e0 * size2;
  }
  if (kk1 - kk2 > 5) {
    p3 += 10e0 * size3;
  } else if (kk1 - kk2 < -5) {
    p3 = p3 - 10e0 * size3;
  }
  /// C
  q4 = e(i1);
  q1 = px(i1);
  q2 = py(i1);
  q3 = pz(i1);
  /// C
  r4 = e(i2);
  r1 = px(i2);
  r2 = py(i2);
  r3 = pz(i2);
  /// C
  a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
  b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
  c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
  d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
  ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
  f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
  /// C
  /// C       make sure particle 2 formed early
  h = a + b;
  if (h > 0e0) {
    g = a;
    a = -b;
    b = -g;
    /// C
    g = c;
    c = d;
    d = g;
    /// C
    i1 = j;
    i2 = i;
  }
  /// C
  /// C       check the approaching criteria
  if (allok) {
    /// C
    vp = a * d - b * ee;
    /// C
    allok = allok && vp < 0e0;
    /// C
  }
  /// C
  /// C       check the closest approach distance criteria
  if (allok) {
    /// C
    dm2 = -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                   (fem::pow2(ee) - c * d);
    /// C
    allok = allok && dm2 < cmn.cutof2;
    /// C
  }
  /// C
  /// C       check the time criteria
  if (allok) {
    /// C
    tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
    tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
    if (iordsc == 20) {
      tm = fem::min(tc1, tc2);
    } else if (iordsc == 21) {
      tm = 0.5e0 * (tc1 + tc2);
    } else {
      tm = fem::max(tc1, tc2);
    }
    /// C
    allok = allok && tm > ft(i) && tm > ft(j);
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (h > 0e0) {
    t1 = tc2;
    t2 = tc1;
  } else {
    t1 = tc1;
    t2 = tc2;
  }
  /// C
}

struct isco6_save {
  fem::variant_bindings prec2_bindings;
  double dgx;
  double dgy;
  double dgz;
  double dm2;
  double dt;
  double dvx;
  double dvy;
  double dvz;
  double dx;
  double dy;
  double dz;
  double e1;
  double e2;
  int i1;
  int i2;
  int icels1;
  int icels2;
  int ii1;
  int ii2;
  int jj1;
  int jj2;
  int kk1;
  int kk2;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double rts2;
  double v2p;
  double vp;
  double vx1;
  double vy1;
  double vz1;

  isco6_save()
      : dgx(fem::double0),
        dgy(fem::double0),
        dgz(fem::double0),
        dm2(fem::double0),
        dt(fem::double0),
        dvx(fem::double0),
        dvy(fem::double0),
        dvz(fem::double0),
        dx(fem::double0),
        dy(fem::double0),
        dz(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        icels1(fem::int0),
        icels2(fem::int0),
        ii1(fem::int0),
        ii2(fem::int0),
        jj1(fem::int0),
        jj2(fem::int0),
        kk1(fem::int0),
        kk2(fem::int0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        rts2(fem::double0),
        v2p(fem::double0),
        vp(fem::double0),
        vx1(fem::double0),
        vy1(fem::double0),
        vz1(fem::double0) {}
};

void isco6(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco6);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_cref<int> last(cmn.last, dimension(maxptn));
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& dgx = sve.dgx;
  double& dgy = sve.dgy;
  double& dgz = sve.dgz;
  double& dm2 = sve.dm2;
  double& dt = sve.dt;
  double& dvx = sve.dvx;
  double& dvy = sve.dvy;
  double& dvz = sve.dvz;
  double& dx = sve.dx;
  double& dy = sve.dy;
  double& dz = sve.dz;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& icels1 = sve.icels1;
  int& icels2 = sve.icels2;
  int& ii1 = sve.ii1;
  int& ii2 = sve.ii2;
  int& jj1 = sve.jj1;
  int& jj2 = sve.jj2;
  int& kk1 = sve.kk1;
  int& kk2 = sve.kk2;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& rts2 = sve.rts2;
  double& v2p = sve.v2p;
  double& vp = sve.vp;
  double& vx1 = sve.vx1;
  double& vy1 = sve.vy1;
  double& vz1 = sve.vz1;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  if (ft(i) >= ft(j)) {
    i1 = j;
    i2 = i;
  } else {
    i1 = i;
    i2 = j;
  }
  /// C
  icels1 = icels(i1);
  ii1 = icels1 / 10000;
  jj1 = (icels1 - ii1 * 10000) / 100;
  kk1 = icels1 - ii1 * 10000 - jj1 * 100;
  icels2 = icels(i2);
  ii2 = icels2 / 10000;
  jj2 = (icels2 - ii2 * 10000) / 100;
  kk2 = icels2 - ii2 * 10000 - jj2 * 100;
  /// C
  if (allok) {
    /// C
    t1 = ft(i1);
    vx1 = vx(i1);
    vy1 = vy(i1);
    vz1 = vz(i1);
    /// C
    t2 = ft(i2);
    /// C
    dvx = vx(i2) - vx1;
    dvy = vy(i2) - vy1;
    dvz = vz(i2) - vz1;
    /// C
    dt = t2 - t1;
    /// C
    dx = gx(i2) - gx(i1) - vx1 * dt;
    dy = gy(i2) - gy(i1) - vy1 * dt;
    dz = gz(i2) - gz(i1) - vz1 * dt;
    /// C
    if (ii1 - ii2 > 5) {
      dx += 10e0 * size1;
    } else if (ii1 - ii2 < -5) {
      dx = dx - 10e0 * size1;
    }
    /// C
    if (jj1 - jj2 > 5) {
      dy += 10e0 * size2;
    } else if (jj1 - jj2 < -5) {
      dy = dy - 10e0 * size2;
    }
    /// C
    if (kk1 - kk2 > 5) {
      dz += 10e0 * size3;
    } else if (kk1 - kk2 < -5) {
      dz = dz - 10e0 * size3;
    }
    /// C
    vp = dvx * dx + dvy * dy + dvz * dz;
    /// C
    allok = allok && vp < 0e0;
    /// C
  }
  /// C
  if (allok) {
    /// C
    v2p = dvx * dvx + dvy * dvy + dvz * dvz;
    /// C
    if (v2p == 0e0) {
      tm = tlarge;
    } else {
      tm = t2 - vp / v2p;
    }
    /// C
    /// C       note now tm is the absolute time
    /// C
    allok = allok && tm > t1 && tm > t2;
    /// C
  }
  /// C
  if (allok) {
    /// C
    dgx = dx - dvx * t2;
    dgy = dy - dvy * t2;
    dgz = dz - dvz * t2;
    /// C
    dm2 = -v2p * fem::pow2(tm) + dgx * dgx + dgy * dgy + dgz * dgz;
    /// C
    allok = allok && dm2 < cmn.cutof2;
    /// C
  }
  /// C
  if (allok) {
    /// C
    e1 = e(i1);
    px1 = px(i1);
    py1 = py(i1);
    pz1 = pz(i1);
    e2 = e(i2);
    px2 = px(i2);
    py2 = py(i2);
    pz2 = pz(i2);
    /// C
    rts2 = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
           fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco7_save {
  fem::variant_bindings prec2_bindings;
  double a;
  bool allokp;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  int i1;
  int i2;
  int ii;
  int jj;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc2;
  double tmp;
  double vp;

  isco7_save()
      : a(fem::double0),
        allokp(fem::bool0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc2(fem::double0),
        tmp(fem::double0),
        vp(fem::double0) {}
};

void isco7(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco7);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  bool& allokp = sve.allokp;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ii = sve.ii;
  int& jj = sve.jj;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc2 = sve.tc2;
  double& tmp = sve.tmp;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  /// C
  tm = tlarge;
  /// C
  if (allok) {
    FEM_DO_SAFE(ii, -1, 1) {
      FEM_DO_SAFE(jj, -1, 1) {
        /// C
        allokp = true;
        /// C
        i1 = i;
        i2 = j;
        /// C
        p4 = ft(j) - ft(i);
        p1 = gx(j) - gx(i);
        p2 = gy(j) - gy(i);
        p3 = gz(j) - gz(i);
        /// C
        p1 += ii * 10e0 * cmn.size1;
        p2 += jj * 10e0 * cmn.size2;
        /// C
        q4 = e(i);
        q1 = px(i);
        q2 = py(i);
        q3 = pz(i);
        /// C
        r4 = e(j);
        r1 = px(j);
        r2 = py(j);
        r3 = pz(j);
        /// C
        a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
        b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
        c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
        d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
        ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
        f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
        /// C
        /// C       make sure particle 2 formed early
        h = a + b;
        if (h > 0e0) {
          g = a;
          a = -b;
          b = -g;
          g = c;
          c = d;
          d = g;
          i1 = j;
          i2 = i;
        }
        /// C
        /// C       check the approaching criteria
        if (allokp) {
          vp = a * d - b * ee;
          allokp = allokp && vp < 0e0;
        }
        /// C
        /// C       check the closest approach distance criteria
        if (allokp) {
          dm2 = -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                         (fem::pow2(ee) - c * d);
          allokp = allokp && dm2 < cmn.cutof2;
        }
        /// C
        /// C       check the time criteria
        if (allokp) {
          tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
          tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
          tmp = 0.5e0 * (tc1 + tc2);
          allokp = allokp && tmp > ft(i) && tmp > ft(j);
        }
        /// C
        if (allokp && tmp < tm) {
          tm = tmp;
          cmn.jxa = ii;
          cmn.jya = jj;
          /// Cd                    dgxa(j) = ii * 10d0 * size1
          /// Cd                    dgya(j) = jj * 10d0 * size2
          /// Cd                    dgxa(i) = - dgxa(j)
          /// Cd                    dgya(i) = - dgya(j)
        }
        /// C
      }
    }
    /// C
    if (tm == tlarge) {
      allok = false;
    }
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    q4 = e(i1);
    q1 = px(i1);
    q2 = py(i1);
    q3 = pz(i1);
    /// C
    r4 = e(i2);
    r1 = px(i2);
    r2 = py(i2);
    r3 = pz(i2);
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (h > 0e0) {
    t1 = tm;
    t2 = tm;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco8_save {
  fem::variant_bindings prec2_bindings;
  double a;
  bool allokp;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  double ha;
  int i1;
  int i2;
  int ii;
  int jj;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc1a;
  double tc2;
  double tc2a;
  double tmp;
  double vp;

  isco8_save()
      : a(fem::double0),
        allokp(fem::bool0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        ha(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc1a(fem::double0),
        tc2(fem::double0),
        tc2a(fem::double0),
        tmp(fem::double0),
        vp(fem::double0) {}
};

void isco8(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco8);
  /// COMMON para5
  int& iordsc = cmn.iordsc;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  bool& allokp = sve.allokp;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  double& ha = sve.ha;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ii = sve.ii;
  int& jj = sve.jj;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc1a = sve.tc1a;
  double& tc2 = sve.tc2;
  double& tc2a = sve.tc2a;
  double& tmp = sve.tmp;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  /// C
  tm = tlarge;
  /// C
  if (allok) {
    FEM_DO_SAFE(ii, -1, 1) {
      FEM_DO_SAFE(jj, -1, 1) {
        /// C
        allokp = true;
        /// C
        i1 = i;
        i2 = j;
        /// C
        p4 = ft(j) - ft(i);
        p1 = gx(j) - gx(i);
        p2 = gy(j) - gy(i);
        p3 = gz(j) - gz(i);
        /// C
        p1 += ii * 10e0 * cmn.size1;
        p2 += jj * 10e0 * cmn.size2;
        /// C
        q4 = e(i);
        q1 = px(i);
        q2 = py(i);
        q3 = pz(i);
        /// C
        r4 = e(j);
        r1 = px(j);
        r2 = py(j);
        r3 = pz(j);
        /// C
        a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
        b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
        c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
        d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
        ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
        f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
        /// C
        /// C       make sure particle 2 formed early
        h = a + b;
        if (h > 0e0) {
          g = a;
          a = -b;
          b = -g;
          g = c;
          c = d;
          d = g;
          i1 = j;
          i2 = i;
        }
        /// C
        /// C       check the approaching criteria
        if (allokp) {
          vp = a * d - b * ee;
          allokp = allokp && vp < 0e0;
        }
        /// C
        /// C       check the closest approach distance criteria
        if (allokp) {
          dm2 = -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                         (fem::pow2(ee) - c * d);
          allokp = allokp && dm2 < cmn.cutof2;
        }
        /// C
        /// C       check the time criteria
        if (allokp) {
          tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
          tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
          if (iordsc == 20) {
            tmp = fem::min(tc1, tc2);
          } else if (iordsc == 21) {
            tmp = 0.5e0 * (tc1 + tc2);
          } else {
            tmp = fem::max(tc1, tc2);
          }
          allokp = allokp && tmp > ft(i) && tmp > ft(j);
        }
        /// C
        if (allokp && tmp < tm) {
          tm = tmp;
          cmn.jxa = ii;
          cmn.jya = jj;
          ha = h;
          tc1a = tc1;
          tc2a = tc2;
          /// Cd                    dgxa(j) = ii * 10d0 * size1
          /// Cd                    dgya(j) = jj * 10d0 * size2
          /// Cd                    dgxa(i) = - dgxa(j)
          /// Cd                    dgya(i) = - dgya(j)
        }
        /// C
      }
    }
    /// C
    if (tm == tlarge) {
      allok = false;
    }
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    q4 = e(i1);
    q1 = px(i1);
    q2 = py(i1);
    q3 = pz(i1);
    /// C
    r4 = e(i2);
    r1 = px(i2);
    r2 = py(i2);
    r3 = pz(i2);
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (ha > 0e0) {
    t1 = tc2a;
    t2 = tc1a;
  } else {
    t1 = tc1a;
    t2 = tc2a;
  }
  /// C
}

struct isco9_save {
  fem::variant_bindings prec2_bindings;
  bool allokp;
  double dgx;
  double dgy;
  double dgz;
  double dm2;
  double dt;
  double dvx;
  double dvy;
  double dvz;
  double dx;
  double dy;
  double dz;
  double e1;
  double e2;
  int i1;
  int i2;
  int ii;
  int isign;
  int jj;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double rts2;
  double tmp;
  double vp;
  double vx1;
  double vy1;
  double vz1;

  isco9_save()
      : allokp(fem::bool0),
        dgx(fem::double0),
        dgy(fem::double0),
        dgz(fem::double0),
        dm2(fem::double0),
        dt(fem::double0),
        dvx(fem::double0),
        dvy(fem::double0),
        dvz(fem::double0),
        dx(fem::double0),
        dy(fem::double0),
        dz(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        ii(fem::int0),
        isign(fem::int0),
        jj(fem::int0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        rts2(fem::double0),
        tmp(fem::double0),
        vp(fem::double0),
        vx1(fem::double0),
        vy1(fem::double0),
        vz1(fem::double0) {}
};

void isco9(common& cmn, int const& i, int const& j, bool& allok, double& tm,
           double& t1, double& t2) {
  FEM_CMN_SVE(isco9);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist3
  double& v2 = cmn.v2;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  bool& allokp = sve.allokp;
  double& dgx = sve.dgx;
  double& dgy = sve.dgy;
  double& dgz = sve.dgz;
  double& dm2 = sve.dm2;
  double& dt = sve.dt;
  double& dvx = sve.dvx;
  double& dvy = sve.dvy;
  double& dvz = sve.dvz;
  double& dx = sve.dx;
  double& dy = sve.dy;
  double& dz = sve.dz;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ii = sve.ii;
  int& isign = sve.isign;
  int& jj = sve.jj;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& rts2 = sve.rts2;
  double& tmp = sve.tmp;
  double& vp = sve.vp;
  double& vx1 = sve.vx1;
  double& vy1 = sve.vy1;
  double& vz1 = sve.vz1;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  if (ft(i) >= ft(j)) {
    i1 = j;
    i2 = i;
    isign = -1;
  } else {
    i1 = i;
    i2 = j;
    isign = 1;
  }
  /// C
  if (allok) {
    tm = tlarge;
    /// C
    t1 = ft(i1);
    vx1 = vx(i1);
    vy1 = vy(i1);
    vz1 = vz(i1);
    /// C
    t2 = ft(i2);
    /// C
    dvx = vx(i2) - vx1;
    dvy = vy(i2) - vy1;
    dvz = vz(i2) - vz1;
    /// C
    dt = t2 - t1;
    /// C
    FEM_DO_SAFE(ii, -1, 1) {
      FEM_DO_SAFE(jj, -1, 1) {
        /// C
        allokp = true;
        /// C
        dx = gx(i2) - gx(i1) - vx1 * dt;
        dy = gy(i2) - gy(i1) - vy1 * dt;
        dz = gz(i2) - gz(i1) - vz1 * dt;
        /// C
        dx += ii * 10e0 * cmn.size1;
        dy += jj * 10e0 * cmn.size2;
        /// C
        vp = dvx * dx + dvy * dy + dvz * dz;
        /// C
        allokp = allokp && vp < 0e0;
        /// C
        if (allokp) {
          /// C
          v2 = dvx * dvx + dvy * dvy + dvz * dvz;
          /// C
          if (v2 == 0e0) {
            tmp = tlarge;
          } else {
            tmp = t2 - vp / v2;
          }
          /// C
          /// C       note now tm is the absolute time
          /// C
          allokp = allokp && tmp > t1 && tmp > t2;
          /// C
        }
        /// C
        if (allokp) {
          /// C
          dgx = dx - dvx * t2;
          dgy = dy - dvy * t2;
          dgz = dz - dvz * t2;
          /// C
          dm2 = -v2 * fem::pow2(tmp) + dgx * dgx + dgy * dgy + dgz * dgz;
          /// C
          allokp = allokp && dm2 < cmn.cutof2;
          /// C
        }
        /// C
        if (allokp && tmp < tm) {
          tm = tmp;
          cmn.jxa = isign * ii;
          cmn.jya = isign * jj;
        }
        /// C
      }
    }
    /// C
    if (tm == tlarge) {
      allok = false;
    }
  }
  /// C
  if (allok) {
    /// C
    e1 = e(i1);
    px1 = px(i1);
    py1 = py(i1);
    pz1 = pz(i1);
    e2 = e(i2);
    px2 = px(i2);
    py2 = py(i2);
    pz2 = pz(i2);
    /// C
    rts2 = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
           fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco10_save {
  fem::variant_bindings prec2_bindings;
  double a;
  bool allokp;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  int i1;
  int i2;
  int ii;
  int jj;
  int kk;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc2;
  double tmp;
  double vp;

  isco10_save()
      : a(fem::double0),
        allokp(fem::bool0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        kk(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc2(fem::double0),
        tmp(fem::double0),
        vp(fem::double0) {}
};

void isco10(common& cmn, int const& i, int const& j, bool& allok, double& tm,
            double& t1, double& t2) {
  FEM_CMN_SVE(isco10);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  bool& allokp = sve.allokp;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kk = sve.kk;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc2 = sve.tc2;
  double& tmp = sve.tmp;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  /// C
  tm = tlarge;
  /// C
  if (allok) {
    FEM_DO_SAFE(ii, -1, 1) {
      FEM_DO_SAFE(jj, -1, 1) {
        FEM_DO_SAFE(kk, -1, 1) {
          allokp = true;
          /// C
          i1 = i;
          i2 = j;
          /// C
          p4 = ft(j) - ft(i);
          p1 = gx(j) - gx(i);
          p2 = gy(j) - gy(i);
          p3 = gz(j) - gz(i);
          /// C
          p1 += ii * 10e0 * cmn.size1;
          p2 += jj * 10e0 * cmn.size2;
          p3 += kk * 10e0 * cmn.size3;
          /// C
          q4 = e(i);
          q1 = px(i);
          q2 = py(i);
          q3 = pz(i);
          /// C
          r4 = e(j);
          r1 = px(j);
          r2 = py(j);
          r3 = pz(j);
          /// C
          a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
          b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
          c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
          d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
          ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
          f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
          /// C
          /// C       make sure particle 2 formed early
          h = a + b;
          if (h > 0e0) {
            g = a;
            a = -b;
            b = -g;
            g = c;
            c = d;
            d = g;
            i1 = j;
            i2 = i;
          }
          /// C
          /// C       check the approaching criteria
          if (allokp) {
            vp = a * d - b * ee;
            allokp = allokp && vp < 0e0;
          }
          /// C
          /// C       check the closest approach distance criteria
          if (allokp) {
            dm2 =
                -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                         (fem::pow2(ee) - c * d);
            allokp = allokp && dm2 < cmn.cutof2;
          }
          /// C
          /// C       check the time criteria
          if (allokp) {
            tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
            tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
            tmp = 0.5e0 * (tc1 + tc2);
            allokp = allokp && tmp > ft(i) && tmp > ft(j);
          }
          /// C
          if (allokp && tmp < tm) {
            tm = tmp;
            cmn.jxa = ii;
            cmn.jya = jj;
            cmn.jza = kk;
            /// Cd                    dgxa(j) = ii * 10d0 * size1
            /// Cd                    dgya(j) = jj * 10d0 * size2
            /// Cd                    dgxa(i) = - dgxa(j)
            /// Cd                    dgya(i) = - dgya(j)
          }
          /// C
        }
      }
    }
    /// C
    if (tm == tlarge) {
      allok = false;
    }
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    q4 = e(i1);
    q1 = px(i1);
    q2 = py(i1);
    q3 = pz(i1);
    /// C
    r4 = e(i2);
    r1 = px(i2);
    r2 = py(i2);
    r3 = pz(i2);
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (h > 0e0) {
    t1 = tm;
    t2 = tm;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco11_save {
  fem::variant_bindings prec2_bindings;
  double a;
  bool allokp;
  double b;
  double c;
  double d;
  double dm2;
  double ee;
  double f;
  double g;
  double h;
  double ha;
  int i1;
  int i2;
  int ii;
  int jj;
  int kk;
  double p1;
  double p2;
  double p3;
  double p4;
  double q1;
  double q2;
  double q3;
  double q4;
  double r1;
  double r2;
  double r3;
  double r4;
  double rts2;
  double tc1;
  double tc1a;
  double tc2;
  double tc2a;
  double tmp;
  double vp;

  isco11_save()
      : a(fem::double0),
        allokp(fem::bool0),
        b(fem::double0),
        c(fem::double0),
        d(fem::double0),
        dm2(fem::double0),
        ee(fem::double0),
        f(fem::double0),
        g(fem::double0),
        h(fem::double0),
        ha(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        ii(fem::int0),
        jj(fem::int0),
        kk(fem::int0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        p4(fem::double0),
        q1(fem::double0),
        q2(fem::double0),
        q3(fem::double0),
        q4(fem::double0),
        r1(fem::double0),
        r2(fem::double0),
        r3(fem::double0),
        r4(fem::double0),
        rts2(fem::double0),
        tc1(fem::double0),
        tc1a(fem::double0),
        tc2(fem::double0),
        tc2a(fem::double0),
        tmp(fem::double0),
        vp(fem::double0) {}
};

void isco11(common& cmn, int const& i, int const& j, bool& allok, double& tm,
            double& t1, double& t2) {
  FEM_CMN_SVE(isco11);
  /// COMMON para5
  int& iordsc = cmn.iordsc;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& a = sve.a;
  bool& allokp = sve.allokp;
  double& b = sve.b;
  double& c = sve.c;
  double& d = sve.d;
  double& dm2 = sve.dm2;
  double& ee = sve.ee;
  double& f = sve.f;
  double& g = sve.g;
  double& h = sve.h;
  double& ha = sve.ha;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ii = sve.ii;
  int& jj = sve.jj;
  int& kk = sve.kk;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& p4 = sve.p4;
  double& q1 = sve.q1;
  double& q2 = sve.q2;
  double& q3 = sve.q3;
  double& q4 = sve.q4;
  double& r1 = sve.r1;
  double& r2 = sve.r2;
  double& r3 = sve.r3;
  double& r4 = sve.r4;
  double& rts2 = sve.rts2;
  double& tc1 = sve.tc1;
  double& tc1a = sve.tc1a;
  double& tc2 = sve.tc2;
  double& tc2a = sve.tc2a;
  double& tmp = sve.tmp;
  double& vp = sve.vp;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  /// C       set up numbers for later calculations
  /// C
  tm = tlarge;
  /// C
  if (allok) {
    FEM_DO_SAFE(ii, -1, 1) {
      FEM_DO_SAFE(jj, -1, 1) {
        FEM_DO_SAFE(kk, -1, 1) {
          /// C
          allokp = true;
          /// C
          i1 = i;
          i2 = j;
          /// C
          p4 = ft(j) - ft(i);
          p1 = gx(j) - gx(i);
          p2 = gy(j) - gy(i);
          p3 = gz(j) - gz(i);
          /// C
          p1 += ii * 10e0 * cmn.size1;
          p2 += jj * 10e0 * cmn.size2;
          p3 += kk * 10e0 * cmn.size3;
          /// C
          q4 = e(i);
          q1 = px(i);
          q2 = py(i);
          q3 = pz(i);
          /// C
          r4 = e(j);
          r1 = px(j);
          r2 = py(j);
          r3 = pz(j);
          /// C
          a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3;
          b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3;
          c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3;
          d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3;
          ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3;
          f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3;
          /// C
          /// C       make sure particle 2 formed early
          h = a + b;
          if (h > 0e0) {
            g = a;
            a = -b;
            b = -g;
            g = c;
            c = d;
            d = g;
            i1 = j;
            i2 = i;
          }
          /// C
          /// C       check the approaching criteria
          if (allokp) {
            vp = a * d - b * ee;
            allokp = allokp && vp < 0e0;
          }
          /// C
          /// C       check the closest approach distance criteria
          if (allokp) {
            dm2 =
                -f - (fem::pow2(a) * d + fem::pow2(b) * c - 2e0 * a * b * ee) /
                         (fem::pow2(ee) - c * d);
            allokp = allokp && dm2 < cmn.cutof2;
          }
          /// C
          /// C       check the time criteria
          if (allokp) {
            tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (fem::pow2(ee) - c * d);
            tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (fem::pow2(ee) - c * d);
            if (iordsc == 20) {
              tmp = fem::min(tc1, tc2);
            } else if (iordsc == 21) {
              tmp = 0.5e0 * (tc1 + tc2);
            } else {
              tmp = fem::max(tc1, tc2);
            }
            allokp = allokp && tmp > ft(i) && tmp > ft(j);
          }
          /// C
          if (allokp && tmp < tm) {
            tm = tmp;
            cmn.jxa = ii;
            cmn.jya = jj;
            cmn.jza = kk;
            ha = h;
            tc1a = tc1;
            tc2a = tc2;
            /// Cd                    dgxa(j) = ii * 10d0 * size1
            /// Cd                    dgya(j) = jj * 10d0 * size2
            /// Cd                    dgxa(i) = - dgxa(j)
            /// Cd                    dgya(i) = - dgya(j)
          }
          /// C
        }
      }
    }
    /// C
    if (tm == tlarge) {
      allok = false;
    }
    /// C
  }
  /// C
  /// C        check rts cut
  if (allok) {
    /// C
    q4 = e(i1);
    q1 = px(i1);
    q2 = py(i1);
    q3 = pz(i1);
    /// C
    r4 = e(i2);
    r1 = px(i2);
    r2 = py(i2);
    r3 = pz(i2);
    /// C
    rts2 = fem::pow2((q4 + r4)) - fem::pow2((q1 + r1)) - fem::pow2((q2 + r2)) -
           fem::pow2((q3 + r3));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else if (ha > 0e0) {
    t1 = tc2a;
    t2 = tc1a;
  } else {
    t1 = tc1a;
    t2 = tc2a;
  }
  /// C
}

struct isco12_save {
  fem::variant_bindings prec2_bindings;
  bool allokp;
  double dgx;
  double dgy;
  double dgz;
  double dm2;
  double dt;
  double dvx;
  double dvy;
  double dvz;
  double dx;
  double dy;
  double dz;
  double e1;
  double e2;
  int i1;
  int i2;
  int ii;
  int isign;
  int jj;
  int kk;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double rts2;
  double tmp;
  double vp;
  double vx1;
  double vy1;
  double vz1;

  isco12_save()
      : allokp(fem::bool0),
        dgx(fem::double0),
        dgy(fem::double0),
        dgz(fem::double0),
        dm2(fem::double0),
        dt(fem::double0),
        dvx(fem::double0),
        dvy(fem::double0),
        dvz(fem::double0),
        dx(fem::double0),
        dy(fem::double0),
        dz(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        ii(fem::int0),
        isign(fem::int0),
        jj(fem::int0),
        kk(fem::int0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        rts2(fem::double0),
        tmp(fem::double0),
        vp(fem::double0),
        vx1(fem::double0),
        vy1(fem::double0),
        vz1(fem::double0) {}
};

void isco12(common& cmn, int const& i, int const& j, bool& allok, double& tm,
            double& t1, double& t2) {
  FEM_CMN_SVE(isco12);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist1
  arr_cref<int> last(cmn.last, dimension(maxptn));
  /// COMMON ilist3
  double& v2 = cmn.v2;
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  bool& allokp = sve.allokp;
  double& dgx = sve.dgx;
  double& dgy = sve.dgy;
  double& dgz = sve.dgz;
  double& dm2 = sve.dm2;
  double& dt = sve.dt;
  double& dvx = sve.dvx;
  double& dvy = sve.dvy;
  double& dvz = sve.dvz;
  double& dx = sve.dx;
  double& dy = sve.dy;
  double& dz = sve.dz;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& ii = sve.ii;
  int& isign = sve.isign;
  int& jj = sve.jj;
  int& kk = sve.kk;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& rts2 = sve.rts2;
  double& tmp = sve.tmp;
  double& vp = sve.vp;
  double& vx1 = sve.vx1;
  double& vy1 = sve.vy1;
  double& vz1 = sve.vz1;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to decide whether there is a collision
  /// between C       particle i and j, if there is one allok=1, and tm gives
  /// the C       collision time, t1 the collision time for i, C       t2 the
  /// collision time for j
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       preventing consecutive collisions
  allok = last(i) != j || last(j) != i;
  /// C
  if (ft(i) >= ft(j)) {
    i1 = j;
    i2 = i;
    isign = -1;
  } else {
    i1 = i;
    i2 = j;
    isign = 1;
  }
  /// C
  if (allok) {
    tm = tlarge;
    /// C
    t1 = ft(i1);
    vx1 = vx(i1);
    vy1 = vy(i1);
    vz1 = vz(i1);
    /// C
    t2 = ft(i2);
    /// C
    dvx = vx(i2) - vx1;
    dvy = vy(i2) - vy1;
    dvz = vz(i2) - vz1;
    /// C
    dt = t2 - t1;
    /// C
    FEM_DO_SAFE(ii, -1, 1) {
      FEM_DO_SAFE(jj, -1, 1) {
        FEM_DO_SAFE(kk, -1, 1) {
          /// C
          allokp = true;
          /// C
          dx = gx(i2) - gx(i1) - vx1 * dt;
          dy = gy(i2) - gy(i1) - vy1 * dt;
          dz = gz(i2) - gz(i1) - vz1 * dt;
          /// C
          dx += ii * 10e0 * cmn.size1;
          dy += jj * 10e0 * cmn.size2;
          dz += kk * 10e0 * cmn.size3;
          /// C
          vp = dvx * dx + dvy * dy + dvz * dz;
          /// C
          allokp = allokp && vp < 0e0;
          /// C
          if (allokp) {
            /// C
            v2 = dvx * dvx + dvy * dvy + dvz * dvz;
            /// C
            if (v2 == 0e0) {
              tmp = tlarge;
            } else {
              tmp = t2 - vp / v2;
            }
            /// C
            /// C       note now tm is the absolute time
            /// C
            allokp = allokp && tmp > t1 && tmp > t2;
            /// C
          }
          /// C
          if (allokp) {
            /// C
            dgx = dx - dvx * t2;
            dgy = dy - dvy * t2;
            dgz = dz - dvz * t2;
            /// C
            dm2 = -v2 * fem::pow2(tmp) + dgx * dgx + dgy * dgy + dgz * dgz;
            /// C
            allokp = allokp && dm2 < cmn.cutof2;
            /// C
          }
          /// C
          if (allokp && tmp < tm) {
            tm = tmp;
            cmn.jxa = isign * ii;
            cmn.jya = isign * jj;
            cmn.jza = isign * kk;
          }
          /// C
        }
      }
    }
    /// C
    if (tm == tlarge) {
      allok = false;
    }
  }
  /// C
  if (allok) {
    /// C
    e1 = e(i1);
    px1 = px(i1);
    py1 = py(i1);
    pz1 = pz(i1);
    e2 = e(i2);
    px2 = px(i2);
    py2 = py(i2);
    pz2 = pz(i2);
    /// C
    rts2 = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
           fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
    /// C
    allok = allok && rts2 > cmn.rscut2;
  }
  /// C
  if (!allok) {
    tm = tlarge;
    t1 = tlarge;
    t2 = tlarge;
  } else {
    t1 = tm;
    t2 = tm;
  }
  /// C
}

struct isco_save {
  int iorder;

  isco_save() : iorder(fem::int0) {}
};

void isco(common& cmn, int const& i, int const& j, bool& allok, double& tm,
          double& t1, double& t2) {
  FEM_CMN_SVE(isco);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  ///
  /// SAVE
  int& iorder = sve.iorder;
  ///
  /// C
  /// Cc      SAVE /para5/
  /// C
  iorder = cmn.iordsc / 10;
  if (iconfg == 1) {
    if (iorder == 1) {
      isco1(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 2) {
      isco2(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 3) {
      isco3(cmn, i, j, allok, tm, t1, t2);
    }
  } else if (iconfg == 2 || iconfg == 4) {
    if (iorder == 1) {
      isco4(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 2) {
      isco5(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 3) {
      isco6(cmn, i, j, allok, tm, t1, t2);
    }
  } else if (iconfg == 3) {
    if (iorder == 1) {
      isco7(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 2) {
      isco8(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 3) {
      isco9(cmn, i, j, allok, tm, t1, t2);
    }
  } else if (iconfg == 5) {
    if (iorder == 1) {
      isco10(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 2) {
      isco11(cmn, i, j, allok, tm, t1, t2);
    } else if (iorder == 3) {
      isco12(cmn, i, j, allok, tm, t1, t2);
    }
  }
  /// C
}

struct mintm_save {
  bool allok;
  double t1;
  double t2;
  double tm;

  mintm_save()
      : allok(fem::bool0),
        t1(fem::double0),
        t2(fem::double0),
        tm(fem::double0) {}
};

void mintm(common& cmn, int const& i, int const& j, double& tmin, int& nc) {
  FEM_CMN_SVE(mintm);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON aurec2
  const int maxptn = 400001;
  arr_ref<double> dgxa(cmn.dgxa, dimension(maxptn));
  arr_ref<double> dgya(cmn.dgya, dimension(maxptn));
  arr_ref<double> dgza(cmn.dgza, dimension(maxptn));
  /// COMMON ilist5
  arr_ref<double> ct(cmn.ct, dimension(maxptn));
  ///
  /// SAVE
  bool& allok = sve.allok;
  double& t1 = sve.t1;
  double& tm = sve.tm;
  ///
  /// C       this subroutine is used to check whether particle j has smaller
  /// C       collision time with particle i than other particles
  /// C       or in other words, update next(i)
  /// C
  /// C       input i,j,tmin,nc
  /// C       output tmin,nc
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  isco(cmn, i, j, allok, tm, t1, sve.t2);
  /// C
  if (allok && tm < tmin) {
    tmin = tm;
    ct(i) = t1;
    nc = j;
    if (iconfg == 3 || iconfg == 5) {
      dgxa(i) = -cmn.jxa * 10e0 * cmn.size1;
      dgya(i) = -cmn.jya * 10e0 * cmn.size2;
      if (iconfg == 5) {
        dgza(i) = -cmn.jza * 10e0 * cmn.size3;
      }
    }
  }
  /// C
}

struct chcell_save {
  int j;
  int jj;
  int jmintm;
  int l;

  chcell_save()
      : j(fem::int0), jj(fem::int0), jmintm(fem::int0), l(fem::int0) {}
};

void chcell(common& cmn, int const& il, int const& i1, int const& i2,
            int const& i3, int const& last0, double const& /* t */,
            double& tmin, int& nc) {
  FEM_CMN_SVE(chcell);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> nic(cmn.nic, dimension(maxptn));
  /// COMMON ilist2
  arr_cref<int, 3> icel(cmn.icel, dimension(10, 10, 10));
  ///
  /// SAVE
  int& j = sve.j;
  int& jj = sve.jj;
  int& jmintm = sve.jmintm;
  int& l = sve.l;
  ///
  /// C       this program is used to check through all the particles, except
  /// last0 C       in the cell (i1,i2,i3) and see if we can get a particle
  /// collision C       with time less than the original input tmin ( the
  /// collision time of C       il with the wall C       last0 cas be set to 0
  /// if we don't want to exclude last0
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist2/
  /// Cc      SAVE /ilist4/
  /// C
  if (iconfg == 3 || iconfg == 5) {
    jj = cmn.ichkpt;
    FEM_DO_SAFE(j, 1, jj) {
      /// C     10/24/02 get rid of argument usage mismatch in mintm():
      jmintm = j;
      if (j != il && j != last0) {
        mintm(cmn, il, jmintm, tmin, nc);
      }
      /// C     &          call mintm(il, j, tmin, nc)
      /// C
    }
    return;
  }
  /// C
  /// C       set l
  if (i1 == 11 && i2 == 11 && i3 == 11) {
    l = cmn.icell;
  } else {
    l = icel(i1, i2, i3);
  }
  /// C
  if (l == 0) {
    return;
  }
  /// C
  j = nic(l);
  /// C
  /// C       if there is only one particle
  if (j == 0) {
    /// C
    /// C       if it's not il or last0,when last is not wall
    if (l == il || l == last0) {
      return;
    }
    mintm(cmn, il, l, tmin, nc);
    /// C
    /// C       if there are many particles
  } else {
    if (l != il && l != last0) {
      mintm(cmn, il, l, tmin, nc);
    }
    while (j != l) {
      if (j != il && j != last0) {
        mintm(cmn, il, j, tmin, nc);
      }
      j = nic(j);
    }
  }
  /// C
}

struct chout_save {
  fem::variant_bindings prec2_bindings;
  int i;
  int j;
  int k;
  int m1;
  int m2;
  int m3;

  chout_save()
      : i(fem::int0),
        j(fem::int0),
        k(fem::int0),
        m1(fem::int0),
        m2(fem::int0),
        m3(fem::int0) {}
};

void chout(common& cmn, int const& l, int const& last0, double const& t,
           double& tmin, int& nc) {
  FEM_CMN_SVE(chout);
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  const int maxptn = 400001;
  /// SAVE
  int& i = sve.i;
  int& j = sve.j;
  int& k = sve.k;
  int& m1 = sve.m1;
  int& m2 = sve.m2;
  int& m3 = sve.m3;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  /* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> ft( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to check the surface when the colliding
  /// C       particle is outside the cube
  /// C
  /// Cc      SAVE /prec2/
  /// C
  m1 = 11;
  m2 = 11;
  m3 = 11;
  chcell(cmn, l, m1, m2, m3, last0, t, tmin, nc);
  /// C
  FEM_DO_SAFE(i, 1, 10) {
    FEM_DO_SAFE(j, 1, 10) {
      FEM_DO_SAFE(k, 1, 10) {
        if (i == 1 || i == 10 || j == 1 || j == 10 || k == 1 || k == 10) {
          chcell(cmn, l, i, j, k, last0, t, tmin, nc);
        }
      }
    }
  }
  /// C
}

struct chin1_save {
  int i;
  int itest;
  int j;
  int k;
  int m1;
  int m2;
  int m3;

  chin1_save()
      : i(fem::int0),
        itest(fem::int0),
        j(fem::int0),
        k(fem::int0),
        m1(fem::int0),
        m2(fem::int0),
        m3(fem::int0) {}
};

void chin1(common& cmn, int const& l, int const& i1, int const& i2,
           int const& i3, int const& last0, double const& t, double& tmin,
           int& nc) {
  FEM_CMN_SVE(chin1);
  /// SAVE
  int& i = sve.i;
  int& itest = sve.itest;
  int& j = sve.j;
  int& k = sve.k;
  int& m1 = sve.m1;
  int& m2 = sve.m2;
  int& m3 = sve.m3;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube
  /// C       and update the afftected particles through chcell
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  itest = 0;
  /// C
  FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i >= 1 && i <= 10 && j >= 1 && j <= 10 && k >= 1 && k <= 10) {
          chcell(cmn, l, i, j, k, last0, t, tmin, nc);
        } else if (itest == 0) {
          m1 = 11;
          m2 = 11;
          m3 = 11;
          chcell(cmn, l, m1, m2, m3, last0, t, tmin, nc);
          itest = 1;
        }
      }
    }
  }
  /// C
}

struct chin2_save {
  int i;
  int ia;
  int ib;
  int ic;
  int itest;
  int j;
  int k;

  chin2_save()
      : i(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        itest(fem::int0),
        j(fem::int0),
        k(fem::int0) {}
};

void chin2(common& cmn, int const& l, int const& i1, int const& i2,
           int const& i3, int const& last0, double const& t, double& tmin,
           int& nc) {
  FEM_CMN_SVE(chin2);
  /// SAVE
  int& i = sve.i;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& j = sve.j;
  int& k = sve.k;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube
  /// C       and update the afftected particles through chcell
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  sve.itest = 0;
  /// C
  FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ia = i;
        ib = j;
        ic = k;
        if (k >= 1 && k <= 10) {
          if (i == 0) {
            ia = 10;
          }
          if (i == 11) {
            ia = 1;
          }
          if (j == 0) {
            ib = 10;
          }
          if (j == 11) {
            ib = 1;
          }
          chcell(cmn, l, ia, ib, ic, last0, t, tmin, nc);
        }
      }
    }
  }
  /// C
}

struct chin3_save {
  int i;
  int ia;
  int ib;
  int ic;
  int itest;
  int j;
  int k;

  chin3_save()
      : i(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        itest(fem::int0),
        j(fem::int0),
        k(fem::int0) {}
};

void chin3(common& cmn, int const& l, int const& i1, int const& i2,
           int const& i3, int const& last0, double const& t, double& tmin,
           int& nc) {
  FEM_CMN_SVE(chin3);
  /// SAVE
  int& i = sve.i;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& j = sve.j;
  int& k = sve.k;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube
  /// C       and update the afftected particles through chcell
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  sve.itest = 0;
  /// C
  FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i == 0) {
          ia = 10;
        } else if (i == 11) {
          ia = 1;
        } else {
          ia = i;
        }
        if (j == 0) {
          ib = 10;
        } else if (j == 11) {
          ib = 1;
        } else {
          ib = j;
        }
        if (k == 0) {
          ic = 10;
        } else if (k == 11) {
          ic = 1;
        } else {
          ic = k;
        }
        chcell(cmn, l, ia, ib, ic, last0, t, tmin, nc);
      }
    }
  }
  /// C
}

struct reor_save {
  int i1;
  int i2;
  int i3;
  int icels0;
  int nc;
  double tmin1;

  reor_save()
      : i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        icels0(fem::int0),
        nc(fem::int0),
        tmin1(fem::double0) {}
};

void reor(common& cmn, double const& t, double& tmin, int const& j,
          int const& last0) {
  FEM_CMN_SVE(reor);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  ///
  /// SAVE
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& icels0 = sve.icels0;
  int& nc = sve.nc;
  double& tmin1 = sve.tmin1;
  ///
  /// C       this subroutine is used to fix ct(i) when tm is greater than ct(i)
  /// C       next(i) is last1 or last2
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /ilist1/
  /// Cd        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
  /// Cc      SAVE /ilist5/
  /// C
  icels0 = icels(j);
  /// C
  i1 = icels0 / 10000;
  i2 = (icels0 - i1 * 10000) / 100;
  i3 = icels0 - i1 * 10000 - i2 * 100;
  /// C
  wallc(cmn, j, i1, i2, i3, t, tmin1);
  /// C
  if (tmin <= tmin1) {
    nc = last0;
  } else {
    tmin = tmin1;
    nc = 0;
  }
  /// C
  if (iconfg == 3 || iconfg == 5) {
    chcell(cmn, j, i1, i2, i3, last0, t, tmin, nc);
  } else {
    if (i1 == 11 && i2 == 11 && i3 == 11) {
      chout(cmn, j, last0, t, tmin, nc);
    } else {
      if (iconfg == 1) {
        chin1(cmn, j, i1, i2, i3, last0, t, tmin, nc);
      } else if (iconfg == 2) {
        chin2(cmn, j, i1, i2, i3, last0, t, tmin, nc);
      } else if (iconfg == 4) {
        chin3(cmn, j, i1, i2, i3, last0, t, tmin, nc);
      }
    }
  }
  /// C
  fixtim(cmn, j, t, tmin1, tmin, nc);
  /// C
}

struct dchcel_save {
  int last0;
  int m;
  int n;
  double tm;

  dchcel_save()
      : last0(fem::int0), m(fem::int0), n(fem::int0), tm(fem::double0) {}
};

void dchcel(common& cmn, int const& l, int const& i, int const& j, int const& k,
            double const& t) {
  FEM_CMN_SVE(dchcel);
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> next(cmn.next, dimension(maxptn));
  arr_cref<int> nic(cmn.nic, dimension(maxptn));
  /// COMMON ilist2
  arr_cref<int, 3> icel(cmn.icel, dimension(10, 10, 10));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  ///
  /// SAVE
  int& last0 = sve.last0;
  int& m = sve.m;
  int& n = sve.n;
  double& tm = sve.tm;
  ///
  /// C       this subroutine is used to recalculate next collision time for
  /// C       particles in the cell i,j,k if the next collision partener is l
  /// C
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist2/
  /// Cc      SAVE /ilist5/
  /// C
  if (i == 11 || j == 11 || k == 11) {
    if (!(i == 11 && j == 11 && k == 11)) {
      FEM_STOP("cerr");
    }
    m = cmn.icell;
  } else {
    m = icel(i, j, k);
  }
  /// C
  if (m == 0) {
    return;
  }
  if (next(m) == l) {
    tm = tlarge;
    last0 = 0;
    reor(cmn, t, tm, m, last0);
  }
  n = nic(m);
  if (n == 0) {
    return;
  }
  while (n != m) {
    if (next(n) == l) {
      tm = tlarge;
      last0 = 0;
      reor(cmn, t, tm, n, last0);
    }
    n = nic(n);
  }
  /// C
}

struct dchout_save {
  fem::variant_bindings prec2_bindings;
  int i;
  int i1;
  int i2;
  int i3;
  int j;
  int k;
  double td;
  double tt;
  double x1;
  double x2;
  double x3;

  dchout_save()
      : i(fem::int0),
        i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        j(fem::int0),
        k(fem::int0),
        td(fem::double0),
        tt(fem::double0),
        x1(fem::double0),
        x2(fem::double0),
        x3(fem::double0) {}
};

void dchout(common& cmn, int const& l, int const& ii, double const& t) {
  FEM_CMN_SVE(dchout);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  double& v1 = cmn.v1;
  double& v2 = cmn.v2;
  double& v3 = cmn.v3;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  int& i = sve.i;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& j = sve.j;
  int& k = sve.k;
  double& td = sve.td;
  double& tt = sve.tt;
  double& x1 = sve.x1;
  double& x2 = sve.x2;
  double& x3 = sve.x3;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to check collisions of l with particles
  /// when C       l is outside the cube and the collision just happened is a
  /// collision C       including a collision with wall (hence we need to use
  /// dcheck to throw C       away old collisions that are not in the new
  /// neighboring cells.
  /// C
  /// C       input l,t
  /// C
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  tt = ft(l);
  td = t - cmn.size;
  x1 = gx(l) + vx(l) * (t - tt);
  x2 = gy(l) + vy(l) * (t - tt);
  x3 = gz(l) + vz(l) * (t - tt);
  if (td <= 0e0) {
    i1 = integ(x1 / size1) + 6;
    i2 = integ(x2 / size2) + 6;
    i3 = integ(x3 / size3) + 6;
    if (integ(x1 / size1) == x1 / size1 && vx(l) < 0e0) {
      i1 = i1 - 1;
    }
    if (integ(x2 / size2) == x2 / size2 && vy(l) < 0e0) {
      i2 = i2 - 1;
    }
    if (integ(x3 / size3) == x3 / size3 && vz(l) < 0e0) {
      i3 = i3 - 1;
    }
  } else {
    i1 = integ(x1 / (size1 + v1 * td)) + 6;
    i2 = integ(x2 / (size2 + v2 * td)) + 6;
    i3 = integ(x3 / (size3 + v3 * td)) + 6;
    /// C     10/24/02 (i) below should be (l):
    if (integ(x1 / (size1 + v1 * td)) == x1 / (size1 + v1 * td) &&
        vx(l) < (i1 - 6) * v1) {
      i1 = i1 - 1;
    }
    /// C     &        vx(i) .lt. (i1 - 6) * v1) i1 = i1 - 1
    if (integ(x2 / (size2 + v2 * td)) == x2 / (size2 + v2 * td) &&
        vy(l) < (i2 - 6) * v2) {
      i2 = i2 - 1;
    }
    /// C     &        vy(i) .lt. (i2 - 6) * v2) i2 = i2 - 1
    if (integ(x3 / (size3 + v3 * td)) == x3 / (size3 + v3 * td) &&
        vz(l) < (i3 - 6) * v3) {
      i3 = i3 - 1;
    }
    /// C     &        vz(i) .lt. (i3 - 6) * v3) i3 = i3 - 1
  }
  /// C
  if (ii == 1) {
    i = 9;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (j >= 1 && j <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 2) {
    i = 2;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (j >= 1 && j <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 3) {
    j = 9;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i >= 1 && i <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 4) {
    j = 2;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i >= 1 && i <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 5) {
    k = 9;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        if (i >= 1 && i <= 10 && j >= 1 && j <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 6) {
    k = 2;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        if (i >= 1 && i <= 10 && j >= 1 && j <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
}

struct dchin1_save {
  int i;
  int itest;
  int j;
  int k;

  dchin1_save() : i(fem::int0), itest(fem::int0), j(fem::int0), k(fem::int0) {}
};

void dchin1(common& cmn, int const& l, int const& ii, int const& i1,
            int const& i2, int const& i3, double const& t) {
  FEM_CMN_SVE(dchin1);
  int& i = sve.i;
  int& j = sve.j;
  int& k = sve.k;
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube when the collision just happened is a collision including
  /// C       collision with wall
  /// C       and update the afftected particles through chkcel
  /// C
  /// C       input l,ii(specifying the direction of the wall collision),
  /// C          i1,i2,i3, (specifying the position of the cell
  /// C                    we are going to check)
  /// C          t
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  sve.itest = 0;
  /// C
  if (ii == 1) {
    if (i1 == 1) {
      goto statement_100;
    }
    if (i1 == 2) {
      if (i2 >= 2 && i2 <= 9 && i3 >= 2 && i3 <= 9) {
        i = 11;
        j = 11;
        k = 11;
        dchcel(cmn, l, i, j, k, t);
      }
      goto statement_100;
    }
    i = i1 - 2;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (j >= 1 && j <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 2) {
    if (i1 == 10) {
      goto statement_100;
    }
    if (i1 == 9) {
      if (i2 >= 2 && i2 <= 9 && i3 >= 2 && i3 <= 9) {
        i = 11;
        j = 11;
        k = 11;
        dchcel(cmn, l, i, j, k, t);
      }
      goto statement_100;
    }
    i = i1 + 2;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (j >= 1 && j <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 3) {
    if (i2 == 1) {
      goto statement_100;
    }
    if (i2 == 2) {
      if (i1 >= 2 && i1 <= 9 && i3 >= 2 && i3 <= 9) {
        i = 11;
        j = 11;
        k = 11;
        dchcel(cmn, l, i, j, k, t);
      }
      goto statement_100;
    }
    j = i2 - 2;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i >= 1 && i <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 4) {
    if (i2 == 10) {
      goto statement_100;
    }
    if (i2 == 9) {
      if (i1 >= 2 && i1 <= 9 && i3 >= 2 && i3 <= 9) {
        i = 11;
        j = 11;
        k = 11;
        dchcel(cmn, l, i, j, k, t);
      }
      goto statement_100;
    }
    j = i2 + 2;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i >= 1 && i <= 10 && k >= 1 && k <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 5) {
    if (i3 == 1) {
      goto statement_100;
    }
    if (i3 == 2) {
      if (i1 >= 2 && i1 <= 9 && i2 >= 2 && i2 <= 9) {
        i = 11;
        j = 11;
        k = 11;
        dchcel(cmn, l, i, j, k, t);
      }
      goto statement_100;
    }
    k = i3 - 2;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        if (i >= 1 && i <= 10 && j >= 1 && j <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
  /// C
  if (ii == 6) {
    if (i3 == 10) {
      goto statement_100;
    }
    if (i3 == 9) {
      if (i1 >= 2 && i1 <= 9 && i2 >= 2 && i2 <= 9) {
        i = 11;
        j = 11;
        k = 11;
        dchcel(cmn, l, i, j, k, t);
      }
      goto statement_100;
    }
    k = i3 + 2;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        if (i >= 1 && i <= 10 && j >= 1 && j <= 10) {
          dchcel(cmn, l, i, j, k, t);
        }
      }
    }
  }
/// C
statement_100:;
  /// C
}

struct dchin2_save {
  int i;
  int ia;
  int ib;
  int ic;
  int j;
  int k;

  dchin2_save()
      : i(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        j(fem::int0),
        k(fem::int0) {}
};

void dchin2(common& cmn, int const& l, int const& ii, int const& i1,
            int const& i2, int const& i3, double const& t) {
  FEM_CMN_SVE(dchin2);
  int& i = sve.i;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& j = sve.j;
  int& k = sve.k;
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube when the collision just happened is a collision including
  /// C       collision with wall
  /// C       and update the afftected particles through chkcel
  /// C
  /// C       input l,ii(specifying the direction of the wall collision),
  /// C          i1,i2,i3, (specifying the position of the cell
  /// C                    we are going to check)
  /// C          t
  /// C
  if (ii == 1) {
    i = i1 - 2;
    if (i <= 0) {
      i += 10;
    }
    ia = i;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ib = j;
        ic = k;
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        if (k >= 1 && k <= 10) {
          dchcel(cmn, l, ia, ib, ic, t);
        }
      }
    }
  }
  /// C
  if (ii == 2) {
    i = i1 + 2;
    if (i >= 11) {
      i = i - 10;
    }
    ia = i;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ib = j;
        ic = k;
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        if (k >= 1 && k <= 10) {
          dchcel(cmn, l, ia, ib, ic, t);
        }
      }
    }
  }
  /// C
  if (ii == 3) {
    j = i2 - 2;
    if (j <= 0) {
      j += 10;
    }
    ib = j;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ia = i;
        ic = k;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (k >= 1 && k <= 10) {
          dchcel(cmn, l, ia, ib, ic, t);
        }
      }
    }
  }
  /// C
  if (ii == 4) {
    j = i2 + 2;
    if (j >= 11) {
      j = j - 10;
    }
    ib = j;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ia = i;
        ic = k;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (k >= 1 && k <= 10) {
          dchcel(cmn, l, ia, ib, ic, t);
        }
      }
    }
  }
  /// C
  if (ii == 5) {
    if (i3 == 2) {
      goto statement_100;
    }
    k = i3 - 2;
    ic = k;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        ia = i;
        ib = j;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
  if (ii == 6) {
    if (i3 == 9) {
      goto statement_100;
    }
    k = i3 + 2;
    ic = k;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        ia = i;
        ib = j;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
/// C
statement_100:;
  /// C
}

struct dchin3_save {
  int i;
  int ia;
  int ib;
  int ic;
  int j;
  int k;

  dchin3_save()
      : i(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        j(fem::int0),
        k(fem::int0) {}
};

void dchin3(common& cmn, int const& l, int const& ii, int const& i1,
            int const& i2, int const& i3, double const& t) {
  FEM_CMN_SVE(dchin3);
  /// SAVE
  int& i = sve.i;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& j = sve.j;
  int& k = sve.k;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube when the collision just happened is a collision including
  /// C       collision with wall
  /// C       and update the afftected particles through chkcel
  /// C
  /// C       input l,ii(specifying the direction of the wall collision),
  /// C          i1,i2,i3, (specifying the position of the cell
  /// C                    we are going to check)
  /// C          t
  /// C
  if (ii == 1) {
    i = i1 - 2;
    if (i <= 0) {
      i += 10;
    }
    ia = i;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ib = j;
        ic = k;
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        if (k == 0) {
          ic = 10;
        }
        if (k == 11) {
          ic = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
  if (ii == 2) {
    i = i1 + 2;
    if (i >= 11) {
      i = i - 10;
    }
    ia = i;
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ib = j;
        ic = k;
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        if (k == 0) {
          ic = 10;
        }
        if (k == 11) {
          ic = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
  if (ii == 3) {
    j = i2 - 2;
    if (j <= 0) {
      j += 10;
    }
    ib = j;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ia = i;
        ic = k;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (k == 0) {
          ic = 10;
        }
        if (k == 11) {
          ic = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
  if (ii == 4) {
    j = i2 + 2;
    if (j >= 11) {
      j = j - 10;
    }
    ib = j;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ia = i;
        ic = k;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (k == 0) {
          ic = 10;
        }
        if (k == 11) {
          ic = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
  if (ii == 5) {
    k = i3 - 2;
    if (k <= 0) {
      k += 10;
    }
    ic = k;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        ia = i;
        ib = j;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
  if (ii == 6) {
    k = i3 + 2;
    if (k >= 11) {
      k = k - 10;
    }
    ic = k;
    FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
      FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
        ia = i;
        ib = j;
        if (i == 0) {
          ia = 10;
        }
        if (i == 11) {
          ia = 1;
        }
        if (j == 0) {
          ib = 10;
        }
        if (j == 11) {
          ib = 1;
        }
        dchcel(cmn, l, ia, ib, ic, t);
      }
    }
  }
  /// C
}

struct cellre_save {
  fem::variant_bindings prec2_bindings;
  double ctmp;
  double ddt;
  double dtt;
  bool good;
  int i1;
  int i2;
  int i3;
  int icels0;
  int ii;
  int j;
  int k;
  double otmp;
  double t0;
  double tmin1;

  cellre_save()
      : ctmp(fem::double0),
        ddt(fem::double0),
        dtt(fem::double0),
        good(fem::bool0),
        i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        icels0(fem::int0),
        ii(fem::int0),
        j(fem::int0),
        k(fem::int0),
        otmp(fem::double0),
        t0(fem::double0),
        tmin1(fem::double0) {}
};

void cellre(common& cmn, int const& i, double const& t) {
  FEM_CMN_SVE(cellre);
  int& iconfg = cmn.iconfg;
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  arr_ref<double> dgxa(cmn.dgxa, dimension(maxptn));
  arr_ref<double> dgya(cmn.dgya, dimension(maxptn));
  arr_ref<double> dgza(cmn.dgza, dimension(maxptn));
  arr_ref<int> next(cmn.next, dimension(maxptn));
  arr_ref<int> icsta(cmn.icsta, dimension(maxptn));
  arr_cref<int> nic(cmn.nic, dimension(maxptn));
  arr_ref<int> icels(cmn.icels, dimension(maxptn));
  int& icell = cmn.icell;
  arr_ref<int, 3> icel(cmn.icel, dimension(10, 10, 10));
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  int& ichkpt = cmn.ichkpt;
  arr_ref<double> ct(cmn.ct, dimension(maxptn));
  arr_ref<double> ot(cmn.ot, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  double& ctmp = sve.ctmp;
  double& ddt = sve.ddt;
  double& dtt = sve.dtt;
  bool& good = sve.good;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& icels0 = sve.icels0;
  int& ii = sve.ii;
  int& j = sve.j;
  int& k = sve.k;
  double& otmp = sve.otmp;
  double& t0 = sve.t0;
  double& tmin1 = sve.tmin1;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_ref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used for changing the cell of a particle that
  /// C       collide with the wall
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist2/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// C
  /// C       this happens before update the /prec2/ common; in contrast with
  /// C       scat which happens after updating the glue common
  /// C
  t0 = t;
/// C
statement_1000:
  /// C
  if (iconfg == 3 || iconfg == 5) {
    k = fem::mod(icsta(i), 10);
    /// C
    if (k == 1) {
      gx(i) = gx(i) - 10e0 * size1;
      dgxa(i) += 10e0 * size1;
      FEM_DO_SAFE(ii, 1, ichkpt) {
        if (next(ii) == i) {
          dgxa(ii) = dgxa(ii) - 10e0 * size1;
        }
      }
    }
    if (k == 2) {
      gx(i) += 10e0 * size1;
      dgxa(i) = dgxa(i) - 10e0 * size1;
      FEM_DO_SAFE(ii, 1, ichkpt) {
        if (next(ii) == i) {
          dgxa(ii) += 10e0 * size1;
        }
      }
    }
    if (k == 3) {
      gy(i) = gy(i) - 10e0 * size2;
      dgya(i) += 10e0 * size2;
      FEM_DO_SAFE(ii, 1, ichkpt) {
        if (next(ii) == i) {
          dgya(ii) = dgya(ii) - 10e0 * size2;
        }
      }
    }
    if (k == 4) {
      gy(i) += 10e0 * size2;
      dgya(i) = dgya(i) - 10e0 * size2;
      FEM_DO_SAFE(ii, 1, ichkpt) {
        if (next(ii) == i) {
          dgya(ii) += 10e0 * size2;
        }
      }
    }
    if (iconfg == 5) {
      if (k == 5) {
        gz(i) = gz(i) - 10e0 * size3;
        dgza(i) += 10e0 * size3;
        FEM_DO_SAFE(ii, 1, ichkpt) {
          if (next(ii) == i) {
            dgza(ii) = dgza(ii) - 10e0 * size3;
          }
        }
      }
      if (k == 6) {
        gz(i) += 10e0 * size3;
        dgza(i) = dgza(i) - 10e0 * size3;
        FEM_DO_SAFE(ii, 1, ichkpt) {
          if (next(ii) == i) {
            dgza(ii) += 10e0 * size3;
          }
        }
      }
    }
  } else {
    icels0 = icels(i);
    /// C
    i1 = icels0 / 10000;
    i2 = (icels0 - i1 * 10000) / 100;
    i3 = icels0 - i1 * 10000 - i2 * 100;
    /// C
    /// Cc       for particle inside the cube
    if (i1 >= 1 && i1 <= 10 && i2 >= 1 && i2 <= 10 && i3 >= 1 && i3 <= 10) {
      /// C
      /// C       this assignment takes care of nic(i)=0 automatically
      if (icel(i1, i2, i3) == i) {
        icel(i1, i2, i3) = nic(i);
      }
      /// C
      /// C1      rearrange the old cell
      /// C
      oldcre(cmn, i);
      /// C
      /// C2      rearrange the new cell
      /// C
      k = fem::mod(icsta(i), 10);
      /// C
      /// C2.1    particle goes out of the cube
      if (iconfg == 1) {
        good = (i1 == 1 && k == 2) || (i1 == 10 && k == 1) ||
               (i2 == 1 && k == 4) || (i2 == 10 && k == 3) ||
               (i3 == 1 && k == 6) || (i3 == 10 && k == 5);
      }
      if (iconfg == 2) {
        good = (i3 == 1 && k == 6) || (i3 == 10 && k == 5);
      }
      if (good) {
        /// C
        /// C                j = icell
        newcre(cmn, i, icell);
        /// C                 icell = j
        /// C
        icels(i) = 111111;
        /// C
        /// C2.2    particle moves inside the cube
      } else {
        /// C
        if (k == 1) {
          i1++;
        }
        if (k == 2) {
          i1 = i1 - 1;
        }
        if (k == 3) {
          i2++;
        }
        if (k == 4) {
          i2 = i2 - 1;
        }
        if (k == 5) {
          i3++;
        }
        if (k == 6) {
          i3 = i3 - 1;
        }
        /// C
        if (iconfg == 2 || iconfg == 4) {
          if (i1 == 0) {
            i1 = 10;
            gx(i) += 10e0 * size1;
          }
          if (i1 == 11) {
            i1 = 1;
            gx(i) = gx(i) - 10e0 * size1;
          }
          if (i2 == 0) {
            i2 = 10;
            gy(i) += 10e0 * size2;
          }
          if (i2 == 11) {
            i2 = 1;
            gy(i) = gy(i) - 10e0 * size2;
          }
          if (iconfg == 4) {
            if (i3 == 0) {
              i3 = 10;
              gz(i) += 10e0 * size3;
            }
            if (i3 == 11) {
              i3 = 1;
              gz(i) = gz(i) - 10e0 * size3;
            }
          }
        }
        /// C
        j = icel(i1, i2, i3);
        /// C
        newcre(cmn, i, j);
        /// C       in case icel changes
        /// C
        icel(i1, i2, i3) = j;
        /// C
        icels(i) = i1 * 10000 + i2 * 100 + i3;
        /// C
      }
      /// C
      /// Cc       for particles outside the cube
    } else {
      /// C
      if (icell == i) {
        icell = nic(i);
      }
      /// C
      oldcre(cmn, i);
      /// C
      k = fem::mod(icsta(i), 10);
      /// C
      ddt = t - ft(i);
      dtt = t - cmn.size;
      if (dtt <= 0e0) {
        i1 = integ((gx(i) + vx(i) * ddt) / size1) + 6;
        i2 = integ((gy(i) + vy(i) * ddt) / size2) + 6;
        i3 = integ((gz(i) + vz(i) * ddt) / size3) + 6;
      } else {
        i1 = integ((gx(i) + vx(i) * ddt) / (size1 + cmn.v1 * dtt)) + 6;
        i2 = integ((gy(i) + vy(i) * ddt) / (size2 + cmn.v2 * dtt)) + 6;
        i3 = integ((gz(i) + vz(i) * ddt) / (size3 + cmn.v3 * dtt)) + 6;
      }
      /// C
      if (k == 1) {
        i1 = 1;
      }
      if (k == 2) {
        i1 = 10;
      }
      if (k == 3) {
        i2 = 1;
      }
      if (k == 4) {
        i2 = 10;
      }
      if (k == 5) {
        i3 = 1;
      }
      if (k == 6) {
        i3 = 10;
      }
      /// C
      j = icel(i1, i2, i3);
      newcre(cmn, i, j);
      icel(i1, i2, i3) = j;
      /// C
      icels(i) = i1 * 10000 + i2 * 100 + i3;
      /// C
    }
  }
  /// C
  if (next(i) != 0) {
    otmp = ot(next(i));
    ctmp = ct(next(i));
  }
  /// C
  if (i1 == 11 && i2 == 11 && i3 == 11) {
    dchout(cmn, i, k, t);
  } else {
    if (iconfg == 1) {
      dchin1(cmn, i, k, i1, i2, i3, t);
    } else if (iconfg == 2) {
      dchin2(cmn, i, k, i1, i2, i3, t);
    } else if (iconfg == 4) {
      dchin3(cmn, i, k, i1, i2, i3, t);
    }
  }
  /// C
  if (icsta(i) / 10 == 11) {
    ot(next(i)) = otmp;
    ct(next(i)) = ctmp;
    next(next(i)) = i;
    wallc(cmn, i, i1, i2, i3, t0, tmin1);
    if (tmin1 < ct(i)) {
      icsta(i) += 10;
      t0 = tmin1;
      goto statement_1000;
    }
  }
  /// C
}

struct newpos_save {
  fem::variant_bindings prec2_bindings;
  double dt1;

  newpos_save() : dt1(fem::double0) {}
};

void newpos(common& cmn, double const& /* t */, int const& i) {
  FEM_CMN_SVE(newpos);
  /// COMMON prec4
  const int maxptn = 400001;
  arr_cref<double> vx(cmn.vx, dimension(maxptn));
  arr_cref<double> vy(cmn.vy, dimension(maxptn));
  arr_cref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON prec5
  arr_ref<double> eta(cmn.eta, dimension(maxptn));
  arr_ref<double> tau(cmn.tau, dimension(maxptn));
  /// COMMON ilist5
  arr_cref<double> ct(cmn.ct, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& dt1 = sve.dt1;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_ref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C
  /// C       this subroutine is used to calculate the 2 particle scattering
  /// C       get new position
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /ilist5/
  /// C
  dt1 = ct(i) - ft(i);
  /// C
  gx(i) += vx(i) * dt1;
  gy(i) += vy(i) * dt1;
  gz(i) += vz(i) * dt1;
  ft(i) = ct(i);
  /// C
  if (cmn.iconfg <= 3) {
    if (ft(i) <= fem::abs(gz(i))) {
      eta(i) = 1000000.e0;
    } else {
      eta(i) = 0.5e0 * fem::log((ft(i) + gz(i)) / (ft(i) - gz(i)));
    }
    /// Clin-8/2015 to avoid IEEE_OVERFLOW_FLAG:
    /// C           tau(i) = ft(i) / cosh(eta(i))
    if (eta(i) < 1000000.e0) {
      tau(i) = ft(i) / fem::cosh(eta(i));
    } else {
      tau(i) = 1e-10;
    }
    /// C
  }
  /// C
}

struct getht_save {
  int iseed;
  double rx;
  double xm2;
  double xmp2;
  double xmu2;

  getht_save()
      : iseed(fem::int0),
        rx(fem::double0),
        xm2(fem::double0),
        xmp2(fem::double0),
        xmu2(fem::double0) {}
};

void getht(common& cmn, int const& /* iscat */, int const& /* jscat */,
           double const& pp2, double& that) {
  FEM_CMN_SVE(getht);
  /// SAVE
  int& iseed = sve.iseed;
  double& rx = sve.rx;
  double& xm2 = sve.xm2;
  double& xmp2 = sve.xmp2;
  double& xmu2 = sve.xmu2;
  ///
  /// C
  /// C       this subroutine is used to get \hat{t} for a particular processes
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /anim/
  /// Cc      SAVE /rndm3/
  /// C
  iseed = cmn.iseedp;
  const double hbarc = 0.197327054e0;
  xmu2 = fem::pow2((hbarc * cmn.xmu));
  xmp2 = fem::pow2(cmn.xmp);
  xm2 = xmu2 + xmp2;
  rx = ran1(cmn, iseed);
  that = xm2 * (1e0 + 1e0 / ((1e0 - xm2 / (4e0 * pp2 + xm2)) * rx - 1e0));
  /// Ctest off isotropic scattering:
  /// C     &     + 1d0/((1d0 - xm2 / (4d0 * pp2 + xm2)) * ran1(2) - 1d0))
  /// C        if(izpc.eq.100) that=-4d0*pp2*ran1(2)
  if (cmn.izpc == 100) {
    that = -4e0 * pp2 * rx;
  }
  /// C
}

struct cropro_save {
  fem::variant_bindings cprod_bindings;
};

void cropro(common& cmn, double const& vx1, double const& vy1,
            double const& vz1, double const& vx2, double const& vy2,
            double const& vz2) {
  FEM_CMN_SVE(cropro);
  common_variant cprod(cmn.common_cprod, sve.cprod_bindings);
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> vx3;
      mbr<double> vy3;
      mbr<double> vz3;
      cprod.allocate(), vx3, vy3, vz3;
    }
  }
  double& vx3 = cprod.bind<double>();
  double& vy3 = cprod.bind<double>();
  double& vz3 = cprod.bind<double>();
  /// C
  /// C     this subroutine is used to calculate the cross product of
  /// C     (vx1,vy1,vz1) and (vx2,vy2,vz2) and get the result (vx3,vy3,vz3)
  /// C     and put the vector into common /cprod/
  /// C
  /// Cc      SAVE /cprod/
  /// C
  vx3 = vy1 * vz2 - vz1 * vy2;
  vy3 = vz1 * vx2 - vx1 * vz2;
  vz3 = vx1 * vy2 - vy1 * vx2;
  /// C
}

struct xnormv_save {
  double vv;

  xnormv_save() : vv(fem::double0) {}
};

void xnormv(common& cmn, double& vx, double& vy, double& vz) {
  FEM_CMN_SVE(xnormv);
  /// SAVE
  double& vv = sve.vv;
  ///
  /// C
  /// C      this subroutine is used to get a normalized vector
  /// C
  /// Clin-7/20/01:
  /// C      vv = sqrt(vx ** 2 + vy ** 2 + vz ** 2)
  vv = fem::dsqrt(fem::pow2(vx) + fem::pow2(vy) + fem::pow2(vz));
  vx = vx / vv;
  vy = vy / vv;
  vz = vz / vv;
  /// C
}

struct zprota_save {
  double a11;
  double a12;
  double a13;
  double a21;
  double a22;
  double a23;
  double a31;
  double a32;
  double a33;
  double c;
  double omc;
  double s;
  double vx;
  double vy;
  double vz;

  zprota_save()
      : a11(fem::double0),
        a12(fem::double0),
        a13(fem::double0),
        a21(fem::double0),
        a22(fem::double0),
        a23(fem::double0),
        a31(fem::double0),
        a32(fem::double0),
        a33(fem::double0),
        c(fem::double0),
        omc(fem::double0),
        s(fem::double0),
        vx(fem::double0),
        vy(fem::double0),
        vz(fem::double0) {}
};

/// C
/// Cbz1/29/99
/// C      subroutine rotate(xn1, xn2, xn3, theta, v1, v2, v3)
void zprota(common& cmn, double const& xn1, double const& xn2,
            double const& xn3, double const& theta, double& v1, double& v2,
            double& v3) {
  FEM_CMN_SVE(zprota);
  /// SAVE
  double& a11 = sve.a11;
  double& a12 = sve.a12;
  double& a13 = sve.a13;
  double& a21 = sve.a21;
  double& a22 = sve.a22;
  double& a23 = sve.a23;
  double& a31 = sve.a31;
  double& a32 = sve.a32;
  double& a33 = sve.a33;
  double& c = sve.c;
  double& omc = sve.omc;
  double& s = sve.s;
  double& vx = sve.vx;
  double& vy = sve.vy;
  double& vz = sve.vz;
  ///
  /// Cbz1/29/99end
  /// C
  /// C     this subroutine is used to rotate the vector (v1,v2,v3) by an angle
  /// theta C     around the unit vector (xn1, xn2, xn3)
  /// C
  vx = v1;
  vy = v2;
  vz = v3;
  c = fem::cos(theta);
  omc = 1e0 - c;
  s = fem::sin(theta);
  a11 = fem::pow2(xn1) * omc + c;
  a12 = xn1 * xn2 * omc - s * xn3;
  a13 = xn1 * xn3 * omc + s * xn2;
  a21 = xn1 * xn2 * omc + s * xn3;
  a22 = fem::pow2(xn2) * omc + c;
  a23 = xn2 * xn3 * omc - s * xn1;
  a31 = xn1 * xn3 * omc - s * xn2;
  a32 = xn3 * xn2 * omc + s * xn1;
  a33 = fem::pow2(xn3) * omc + c;
  v1 = vx * a11 + vy * a12 + vz * a13;
  v2 = vx * a21 + vy * a22 + vz * a23;
  v3 = vx * a31 + vy * a32 + vz * a33;
  /// C
}

struct newmom_save {
  fem::variant_bindings cprod_bindings;
  fem::variant_bindings prec2_bindings;
  double bex;
  double bey;
  double bez;
  double e1;
  double e2;
  int i1;
  int i2;
  int icels1;
  int icels2;
  int j1;
  int j2;
  int k1;
  int k2;
  double pp2;
  double px1;
  double px2;
  double py1;
  double py2;
  double pz1;
  double pz2;
  double rap1;
  double rap2;
  double rts2;
  double t1;
  double t2;
  double that;
  double theta;
  double x1;
  double x2;
  double y1;
  double y2;
  double z1;
  double z2;

  newmom_save()
      : bex(fem::double0),
        bey(fem::double0),
        bez(fem::double0),
        e1(fem::double0),
        e2(fem::double0),
        i1(fem::int0),
        i2(fem::int0),
        icels1(fem::int0),
        icels2(fem::int0),
        j1(fem::int0),
        j2(fem::int0),
        k1(fem::int0),
        k2(fem::int0),
        pp2(fem::double0),
        px1(fem::double0),
        px2(fem::double0),
        py1(fem::double0),
        py2(fem::double0),
        pz1(fem::double0),
        pz2(fem::double0),
        rap1(fem::double0),
        rap2(fem::double0),
        rts2(fem::double0),
        t1(fem::double0),
        t2(fem::double0),
        that(fem::double0),
        theta(fem::double0),
        x1(fem::double0),
        x2(fem::double0),
        y1(fem::double0),
        y2(fem::double0),
        z1(fem::double0),
        z2(fem::double0) {}
};

void newmom(common& cmn, double const& /* t */) {
  FEM_CMN_SVE(newmom);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON para6
  double& centy = cmn.centy;
  /// COMMON prec4
  const int maxptn = 400001;
  arr_ref<double> vx(cmn.vx, dimension(maxptn));
  arr_ref<double> vy(cmn.vy, dimension(maxptn));
  arr_ref<double> vz(cmn.vz, dimension(maxptn));
  /// COMMON prec5
  arr_ref<double> rap(cmn.rap, dimension(maxptn));
  /// COMMON aurec2
  arr_cref<double> dgxa(cmn.dgxa, dimension(maxptn));
  arr_cref<double> dgya(cmn.dgya, dimension(maxptn));
  arr_cref<double> dgza(cmn.dgza, dimension(maxptn));
  /// COMMON ilist1
  int& iscat = cmn.iscat;
  int& jscat = cmn.jscat;
  arr_ref<int> last(cmn.last, dimension(maxptn));
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  /// COMMON lor
  double& enenew = cmn.enenew;
  double& pxnew = cmn.pxnew;
  double& pynew = cmn.pynew;
  double& pznew = cmn.pznew;
  /// COMMON rndm2
  int& iff = cmn.iff;
  /// COMMON frzprc
  arr_cref<int> ifrz(cmn.ifrz, dimension(maxptn));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  common_variant cprod(cmn.common_cprod, sve.cprod_bindings);
  /// SAVE
  double& bex = sve.bex;
  double& bey = sve.bey;
  double& bez = sve.bez;
  double& e1 = sve.e1;
  double& e2 = sve.e2;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& icels1 = sve.icels1;
  int& icels2 = sve.icels2;
  int& j1 = sve.j1;
  int& j2 = sve.j2;
  int& k1 = sve.k1;
  int& k2 = sve.k2;
  double& pp2 = sve.pp2;
  double& px1 = sve.px1;
  double& px2 = sve.px2;
  double& py1 = sve.py1;
  double& py2 = sve.py2;
  double& pz1 = sve.pz1;
  double& pz2 = sve.pz2;
  double& rap1 = sve.rap1;
  double& rap2 = sve.rap2;
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  double& that = sve.that;
  double& theta = sve.theta;
  double& x1 = sve.x1;
  double& x2 = sve.x2;
  double& y1 = sve.y1;
  double& y2 = sve.y2;
  double& z1 = sve.z1;
  double& z2 = sve.z2;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
    {
      mbr<double> xn1;
      mbr<double> xn2;
      mbr<double> xn3;
      cprod.allocate(), xn1, xn2, xn3;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> e(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> xmass(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  double& xn1 = cprod.bind<double>();
  double& xn2 = cprod.bind<double>();
  double& xn3 = cprod.bind<double>();
  /// C
  /// C       this subroutine is used to calculate the 2 particle scattering
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Ctrans
  /// Cc      SAVE /para6/
  /// Ctransend
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /lor/
  /// Cc      SAVE /cprod/
  /// Cc      SAVE /rndm2/
  /// Cc      SAVE /anim/
  /// Cc      SAVE /frzprc/
  /// C
  /// Clin-6/06/02 no momentum change for partons already frozen out,
  /// C     however, spatial upgrade is needed to ensure overall system
  /// freezeout:
  if (cmn.isoft == 5) {
    if (ifrz(iscat) == 1 || ifrz(jscat) == 1) {
      last(iscat) = jscat;
      last(jscat) = iscat;
      return;
    }
  }
  /// Clin-6/06/02-end
  /// C
  /// C       iff is used to randomize the interaction to have both attractive
  /// and C        repulsive
  /// C
  iff = -iff;
  /// C
  if (iconfg == 2 || iconfg == 4) {
    icels1 = icels(iscat);
    i1 = icels1 / 10000;
    j1 = (icels1 - i1 * 10000) / 100;
    icels2 = icels(jscat);
    i2 = icels2 / 10000;
    j2 = (icels2 - i2 * 10000) / 100;
    if (iconfg == 4) {
      k1 = icels1 - i1 * 10000 - j1 * 100;
      k2 = icels2 - i2 * 10000 - j2 * 100;
    }
  }
  /// C
  px1 = px(iscat);
  py1 = py(iscat);
  pz1 = pz(iscat);
  e1 = e(iscat);
  x1 = gx(iscat);
  y1 = gy(iscat);
  z1 = gz(iscat);
  t1 = ft(iscat);
  px2 = px(jscat);
  py2 = py(jscat);
  pz2 = pz(jscat);
  e2 = e(jscat);
  /// C
  if (iconfg == 1) {
    x2 = gx(jscat);
    y2 = gy(jscat);
    z2 = gz(jscat);
  } else if (iconfg == 2 || iconfg == 4) {
    if (i1 - i2 > 5) {
      x2 = gx(jscat) + 10e0 * size1;
    } else if (i1 - i2 < -5) {
      x2 = gx(jscat) - 10e0 * size1;
    } else {
      x2 = gx(jscat);
    }
    if (j1 - j2 > 5) {
      y2 = gy(jscat) + 10e0 * size2;
    } else if (j1 - j2 < -5) {
      y2 = gy(jscat) - 10e0 * size2;
    } else {
      y2 = gy(jscat);
    }
    if (iconfg == 4) {
      if (k1 - k2 > 5) {
        z2 = gz(jscat) + 10e0 * size3;
      } else if (k1 - k2 < -5) {
        z2 = gz(jscat) - 10e0 * size3;
      } else {
        z2 = gz(jscat);
      }
    } else {
      z2 = gz(jscat);
    }
  } else if (iconfg == 3 || iconfg == 5) {
    x2 = gx(jscat) + dgxa(jscat);
    y2 = gy(jscat) + dgya(jscat);
    if (iconfg == 5) {
      z2 = gz(jscat) + dgza(jscat);
    } else {
      z2 = gz(jscat);
    }
  }
  t2 = ft(jscat);
  /// Ctrans
  sve.rts2 = fem::pow2((e1 + e2)) - fem::pow2((px1 + px2)) -
             fem::pow2((py1 + py2)) - fem::pow2((pz1 + pz2));
  /// Ctransend
  bex = (px1 + px2) / (e1 + e2);
  bey = (py1 + py2) / (e1 + e2);
  bez = (pz1 + pz2) / (e1 + e2);
  /// C
  /// Clin-11/2015-ctest off
  /// C        write(99,*) 'iscat,jscat,etotalA=',iscat,jscat,e1+e2
  /// C
  lorenz(cmn, e1, px1, py1, pz1, bex, bey, bez);
  /// Cc      SAVE pxnew, ..., values for later use.
  px1 = pxnew;
  py1 = pynew;
  pz1 = pznew;
  e1 = enenew;
  /// C
  pp2 = fem::pow2(pxnew) + fem::pow2(pynew) + fem::pow2(pznew);
  getht(cmn, iscat, jscat, pp2, that);
  theta = fem::dacos(that / (2e0 * pp2) + 1e0);
  theta = fem::dble(iff) * theta;
  /// C
  /// C       we boost to the cm frame, get rotation axis, and rotate 1 particle
  /// C       momentum
  /// C
  lorenz(cmn, t1, x1, y1, z1, bex, bey, bez);
  /// C
  x1 = pxnew;
  y1 = pynew;
  z1 = pznew;
  /// C
  lorenz(cmn, t2, x2, y2, z2, bex, bey, bez);
  /// C
  x2 = pxnew;
  y2 = pynew;
  z2 = pznew;
  /// C
  /// C       notice now pxnew, ..., are new positions
  cropro(cmn, x1 - x2, y1 - y2, z1 - z2, px1, py1, pz1);
  /// C
  xnormv(cmn, xn1, xn2, xn3);
  /// C
  /// Cbz1/29/99
  /// C        call rotate(xn1, xn2, xn3, theta, px1, py1, pz1)
  zprota(cmn, xn1, xn2, xn3, theta, px1, py1, pz1);
  /// Cbz1/29/99end
  /// C
  /// C       we invert the momentum to get the other particle's momentum
  px2 = -px1;
  py2 = -py1;
  pz2 = -pz1;
  /// Clin-4/13/01: modify in case m1, m2 are different:
  /// C        e2 = e1
  e2 = fem::dsqrt(fem::pow2(px2) + fem::pow2(py2) + fem::pow2(pz2) +
                  fem::pow2(xmass(jscat)));
  /// C
  /// Clin-11/2015-ctest off
  /// C        write(99,*) 'iscat,jscat,masses= ',iscat,jscat,
  /// C     1       xmass(iscat),xmass(jscat)
  /// C
  /// C       boost the 2 particle 4 momentum back to lab frame
  lorenz(cmn, e1, px1, py1, pz1, -bex, -bey, -bez);
  px(iscat) = pxnew;
  py(iscat) = pynew;
  pz(iscat) = pznew;
  e(iscat) = enenew;
  lorenz(cmn, e2, px2, py2, pz2, -bex, -bey, -bez);
  px(jscat) = pxnew;
  py(jscat) = pynew;
  pz(jscat) = pznew;
  e(jscat) = enenew;
  /// C
  /// Clin-11/2015-ctest off
  /// C        write(99,*) 'iscat,jscat,etotalB= ',iscat,jscat,
  /// C     1       e(iscat)+e(jscat)
  /// C
  vx(iscat) = px(iscat) / e(iscat);
  vy(iscat) = py(iscat) / e(iscat);
  vz(iscat) = pz(iscat) / e(iscat);
  vx(jscat) = px(jscat) / e(jscat);
  vy(jscat) = py(jscat) / e(jscat);
  vz(jscat) = pz(jscat) / e(jscat);
  /// C
  last(iscat) = jscat;
  last(jscat) = iscat;
  /// C
  if (iconfg <= 3) {
    if (e(iscat) <= fem::abs(pz(iscat))) {
      rap(iscat) = 1000000.e0;
    } else {
      rap(iscat) =
          0.5e0 * fem::log((e(iscat) + pz(iscat)) / (e(iscat) - pz(iscat)));
    }
    /// C
    if (e(jscat) <= fem::abs(pz(jscat))) {
      rap(jscat) = 1000000.e0;
    } else {
      rap(jscat) =
          0.5e0 * fem::log((e(jscat) + pz(jscat)) / (e(jscat) - pz(jscat)));
    }
    /// C
    /// Ctrans
    rap1 = rap(iscat);
    rap2 = rap(jscat);
    /// C
    if ((rap1 < centy + 0.5e0 && rap1 > centy - 0.5e0)) {
      /// C              write (9, *) sqrt(ft(iscat) ** 2 - gz(iscat) ** 2),
      /// rts2
    }
    if ((rap2 < centy + 0.5e0 && rap2 > centy - 0.5e0)) {
      /// C              write (9, *) sqrt(ft(jscat) ** 2 - gz(jscat) ** 2),
      /// rts2
    }
    /// Ctransend
  }
  /// C
  /// Clin-11/2015-ctest off
  /// C        write(99,*) 'iscat,jscat,xmp,xmu,that=',iscat,jscat,xmp,xmu,that
  /// C
}

void scat(common& cmn, double const& t, int const& iscat, int const& jscat) {
  /// C
  /// C       this subroutine is used to calculate the 2 particle scattering
  /// C
  newpos(cmn, t, iscat);
  newpos(cmn, t, jscat);
  newmom(cmn, t);
  /// C
}

void ck(common& cmn, int const& l, int& ick) {
  /// COMMON ilist1
  int& iscat = cmn.iscat;
  int& jscat = cmn.jscat;
  int& ictype = cmn.ictype;
  /// COMMON ilist4
  int& ifmpt = cmn.ifmpt;
  ///
  /// C       this subroutine is used for chcell to check whether l should be
  /// C       checked or not for updating tmin, nc
  /// C       input l
  /// C       output ick
  /// C       if ick=1, l should be checked, otherwise it should not be.
  /// C
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist4/
  /// C
  ick = 1;
  if (ictype == 1) {
    if (l == ifmpt) {
      ick = 0;
    }
  } else if (ictype == 0 || ictype == 3 || ictype == 4) {
    if (l == iscat || l == jscat) {
      ick = 0;
    }
  } else {
    if (l == iscat || l == jscat || l == ifmpt) {
      ick = 0;
    }
  }
  /// C       notice il is either iscat or jscat, or ifmpt, we deal with them
  /// C       seperately according to ictype
  /// C
}

struct ud2_save {
  bool allok;
  int i1;
  int i2;
  int i3;
  int icels0;
  double t1;
  double t2;
  double tm;
  double tmin1;

  ud2_save()
      : allok(fem::bool0),
        i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        icels0(fem::int0),
        t1(fem::double0),
        t2(fem::double0),
        tm(fem::double0),
        tmin1(fem::double0) {}
};

void ud2(common& cmn, int const& i, int const& j, double const& t, double& tmin,
         int& nc) {
  FEM_CMN_SVE(ud2);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON aurec1
  int& jxa = cmn.jxa;
  int& jya = cmn.jya;
  int& jza = cmn.jza;
  /// COMMON aurec2
  const int maxptn = 400001;
  arr_ref<double> dgxa(cmn.dgxa, dimension(maxptn));
  arr_ref<double> dgya(cmn.dgya, dimension(maxptn));
  arr_ref<double> dgza(cmn.dgza, dimension(maxptn));
  /// COMMON ilist1
  arr_cref<int> next(cmn.next, dimension(maxptn));
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  /// COMMON ilist3
  double& size1 = cmn.size1;
  double& size2 = cmn.size2;
  double& size3 = cmn.size3;
  /// COMMON ilist5
  arr_ref<double> ct(cmn.ct, dimension(maxptn));
  arr_cref<double> ot(cmn.ot, dimension(maxptn));
  ///
  /// SAVE
  bool& allok = sve.allok;
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& icels0 = sve.icels0;
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  double& tm = sve.tm;
  double& tmin1 = sve.tmin1;
  ///
  /// C       this subroutine is used to update next(i), ct(i), ot(i),
  /// C        and get tmin, nc for j
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /aurec1/
  /// Cc      SAVE /aurec2/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ilist5/
  /// C
  isco(cmn, i, j, allok, tm, t1, t2);
  /// C
  if (allok) {
    /// C       tm eq tmin, change nc to make sure fixtime get the collision
    /// with both C       wall and particle
    /// C
    if (tm < tmin) {
      tmin = tm;
      ct(j) = t2;
      nc = i;
      if (iconfg == 3 || iconfg == 5) {
        dgxa(j) = jxa * 10e0 * size1;
        dgya(j) = jya * 10e0 * size2;
        if (iconfg == 5) {
          dgza(j) = jza * 10e0 * size3;
        }
      }
    }
    /// C
    if (tm <= ot(i)) {
      ct(i) = t1;
      icels0 = icels(i);
      i1 = icels0 / 10000;
      i2 = (icels0 - i1 * 10000) / 100;
      i3 = icels0 - i1 * 10000 - i2 * 100;
      wallc(cmn, i, i1, i2, i3, t, tmin1);
      fixtim(cmn, i, t, tmin1, tm, j);
      if (iconfg == 3 || iconfg == 5) {
        dgxa(i) = -jxa * 10e0 * size1;
        dgya(i) = -jya * 10e0 * size2;
        if (iconfg == 5) {
          dgza(i) = -jza * 10e0 * size3;
        }
      }
    }
    /// C
    if (tm > ot(i) && next(i) == j) {
      ct(i) = t1;
      reor(cmn, t, tm, i, j);
    }
    /// C
  } else if (next(i) == j) {
    /// C
    tm = cmn.tlarge;
    /// C
    reor(cmn, t, tm, i, j);
    /// C
  }
  /// C
}

struct chkcel_save {
  int ick;
  int j;
  int jj;
  int jud2;
  int l;

  chkcel_save()
      : ick(fem::int0),
        j(fem::int0),
        jj(fem::int0),
        jud2(fem::int0),
        l(fem::int0) {}
};

void chkcel(common& cmn, int const& il, int const& i1, int const& i2,
            int const& i3, double const& t, double& tmin, int& nc) {
  FEM_CMN_SVE(chkcel);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> nic(cmn.nic, dimension(maxptn));
  /// COMMON ilist2
  arr_cref<int, 3> icel(cmn.icel, dimension(10, 10, 10));
  ///
  /// SAVE
  int& ick = sve.ick;
  int& j = sve.j;
  int& jj = sve.jj;
  int& jud2 = sve.jud2;
  int& l = sve.l;
  ///
  /// C       this program is used to check through all the particles
  /// C       in the cell (i1,i2,i3) and see if we can get a particle collision
  /// C       with time less than the original input tmin ( the collision time
  /// of C       il with the wall C       and update the affected particles
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist2/
  /// Cc      SAVE /ilist4/
  /// C
  if (iconfg == 3 || iconfg == 5) {
    jj = cmn.ichkpt;
    FEM_DO_SAFE(j, 1, jj) {
      ck(cmn, j, ick);
      /// C     10/24/02 get rid of argument usage mismatch in ud2():
      jud2 = j;
      /// C              if (ick .eq. 1) call ud2(j, il, t, tmin, nc)
      if (ick == 1) {
        ud2(cmn, jud2, il, t, tmin, nc);
      }
    }
    return;
  }
  /// C
  if (i1 == 11 && i2 == 11 && i3 == 11) {
    l = cmn.icell;
  } else {
    l = icel(i1, i2, i3);
  }
  /// C
  /// C       if there is no particle
  if (l == 0) {
    return;
  }
  j = nic(l);
  /// C       if there is only one particle
  if (j == 0) {
    ck(cmn, l, ick);
    if (ick == 1) {
      ud2(cmn, l, il, t, tmin, nc);
    }
    /// C
    /// C       if there are many particles
  } else {
    /// C
    /// C       we don't worry about the other colliding particle because it's
    /// C       set in last(), and will be checked in ud2
    /// C
    ck(cmn, l, ick);
    if (ick == 1) {
      ud2(cmn, l, il, t, tmin, nc);
    }
    /// C
    while (j != l) {
      ck(cmn, j, ick);
      if (ick == 1) {
        ud2(cmn, j, il, t, tmin, nc);
      }
      j = nic(j);
    }
  }
  /// C
}

struct chkout_save {
  fem::variant_bindings prec2_bindings;
  int i;
  int j;
  int k;
  int m1;
  int m2;
  int m3;

  chkout_save()
      : i(fem::int0),
        j(fem::int0),
        k(fem::int0),
        m1(fem::int0),
        m2(fem::int0),
        m3(fem::int0) {}
};

void chkout(common& cmn, int const& l, double const& t, double& tmin, int& nc) {
  FEM_CMN_SVE(chkout);
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  const int maxptn = 400001;
  /// SAVE
  int& i = sve.i;
  int& j = sve.j;
  int& k = sve.k;
  int& m1 = sve.m1;
  int& m2 = sve.m2;
  int& m3 = sve.m3;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  /* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> ft( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C       this subroutine is used to check the collisions with particles in
  /// C       surface cells to see if we can get a smaller collision time than
  /// tmin C       with particle nc, when the colliding particle is outside the
  /// cube C       input l,t,tmin,nc C       output tmin, nc
  /// C
  /// Cc      SAVE /prec2/
  /// C
  m1 = 11;
  m2 = 11;
  m3 = 11;
  chkcel(cmn, l, m1, m2, m3, t, tmin, nc);
  /// C
  FEM_DO_SAFE(i, 1, 10) {
    FEM_DO_SAFE(j, 1, 10) {
      FEM_DO_SAFE(k, 1, 10) {
        if (i == 1 || i == 10 || j == 1 || j == 10 || k == 1 || k == 10) {
          chkcel(cmn, l, i, j, k, t, tmin, nc);
        }
      }
    }
  }
  /// C
}

struct chkin1_save {
  int i;
  int itest;
  int j;
  int k;
  int m1;
  int m2;
  int m3;

  chkin1_save()
      : i(fem::int0),
        itest(fem::int0),
        j(fem::int0),
        k(fem::int0),
        m1(fem::int0),
        m2(fem::int0),
        m3(fem::int0) {}
};

void chkin1(common& cmn, int const& l, int const& i1, int const& i2,
            int const& i3, double const& t, double& tmin, int& nc) {
  FEM_CMN_SVE(chkin1);
  /// SAVE
  int& i = sve.i;
  int& itest = sve.itest;
  int& j = sve.j;
  int& k = sve.k;
  int& m1 = sve.m1;
  int& m2 = sve.m2;
  int& m3 = sve.m3;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube
  /// C       and update the afftected particles through chkcel
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  itest = 0;
  /// C
  FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i >= 1 && i <= 10 && j >= 1 && j <= 10 && k >= 1 && k <= 10) {
          chkcel(cmn, l, i, j, k, t, tmin, nc);
        } else if (itest == 0) {
          m1 = 11;
          m2 = 11;
          m3 = 11;
          chkcel(cmn, l, m1, m2, m3, t, tmin, nc);
          itest = 1;
        }
      }
    }
  }
  /// C
}

struct chkin2_save {
  int i;
  int ia;
  int ib;
  int ic;
  int itest;
  int j;
  int k;

  chkin2_save()
      : i(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        itest(fem::int0),
        j(fem::int0),
        k(fem::int0) {}
};

void chkin2(common& cmn, int const& l, int const& i1, int const& i2,
            int const& i3, double const& t, double& tmin, int& nc) {
  FEM_CMN_SVE(chkin2);
  /// SAVE
  int& i = sve.i;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& j = sve.j;
  int& k = sve.k;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube
  /// C       and update the afftected particles through chkcel
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  sve.itest = 0;
  /// C
  FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        ia = i;
        ib = j;
        ic = k;
        if (k >= 1 && k <= 10) {
          if (i == 0) {
            ia = 10;
          }
          if (i == 11) {
            ia = 1;
          }
          if (j == 0) {
            ib = 10;
          }
          if (j == 11) {
            ib = 1;
          }
          chkcel(cmn, l, ia, ib, ic, t, tmin, nc);
        }
      }
    }
  }
  /// C
}

struct chkin3_save {
  int i;
  int ia;
  int ib;
  int ic;
  int itest;
  int j;
  int k;

  chkin3_save()
      : i(fem::int0),
        ia(fem::int0),
        ib(fem::int0),
        ic(fem::int0),
        itest(fem::int0),
        j(fem::int0),
        k(fem::int0) {}
};

void chkin3(common& cmn, int const& l, int const& i1, int const& i2,
            int const& i3, double const& t, double& tmin, int& nc) {
  FEM_CMN_SVE(chkin3);
  /// SAVE
  int& i = sve.i;
  int& ia = sve.ia;
  int& ib = sve.ib;
  int& ic = sve.ic;
  int& j = sve.j;
  int& k = sve.k;
  ///
  /// C       this subroutine is used to check collisions for particle inside
  /// C       the cube
  /// C       and update the afftected particles through chkcel
  /// C
  /// C       itest is a flag to make sure the 111111 cell is checked only once
  sve.itest = 0;
  /// C
  FEM_DO_SAFE(i, i1 - 1, i1 + 1) {
    FEM_DO_SAFE(j, i2 - 1, i2 + 1) {
      FEM_DO_SAFE(k, i3 - 1, i3 + 1) {
        if (i == 0) {
          ia = 10;
        } else if (i == 11) {
          ia = 1;
        } else {
          ia = i;
        }
        if (j == 0) {
          ib = 10;
        } else if (j == 11) {
          ib = 1;
        } else {
          ib = j;
        }
        if (k == 0) {
          ic = 10;
        } else if (k == 11) {
          ic = 1;
        } else {
          ic = k;
        }
        chkcel(cmn, l, ia, ib, ic, t, tmin, nc);
      }
    }
  }
  /// C
}

struct ulist1_save {
  int i1;
  int i2;
  int i3;
  int icels0;
  int k;
  int nc;
  double tmin;
  double tmin1;

  ulist1_save()
      : i1(fem::int0),
        i2(fem::int0),
        i3(fem::int0),
        icels0(fem::int0),
        k(fem::int0),
        nc(fem::int0),
        tmin(fem::double0),
        tmin1(fem::double0) {}
};

void ulist1(common& cmn, int const& l, double const& t) {
  FEM_CMN_SVE(ulist1);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON ilist1
  const int maxptn = 400001;
  arr_cref<int> icsta(cmn.icsta, dimension(maxptn));
  arr_cref<int> icels(cmn.icels, dimension(maxptn));
  ///
  /// SAVE
  int& i1 = sve.i1;
  int& i2 = sve.i2;
  int& i3 = sve.i3;
  int& icels0 = sve.icels0;
  int& nc = sve.nc;
  double& tmin = sve.tmin;
  double& tmin1 = sve.tmin1;
  ///
  /// C       this subroutine is used to update the interaction list when
  /// particle C       l is disturbed.
  /// C
  /// Cc      SAVE /para5/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist5/
  /// C
  icels0 = icels(l);
  i1 = icels0 / 10000;
  i2 = (icels0 - i1 * 10000) / 100;
  i3 = icels0 - i1 * 10000 - i2 * 100;
  /// C       save collision info for use when the collision is a collision with
  /// wall C       otherwise wallc will change icsta
  sve.k = fem::mod(icsta(l), 10);
  /// C
  wallc(cmn, l, i1, i2, i3, t, tmin1);
  tmin = tmin1;
  nc = 0;
  /// C
  if (i1 == 11 && i2 == 11 && i3 == 11) {
    chkout(cmn, l, t, tmin, nc);
  } else {
    if (iconfg == 1) {
      chkin1(cmn, l, i1, i2, i3, t, tmin, nc);
    } else if (iconfg == 2) {
      chkin2(cmn, l, i1, i2, i3, t, tmin, nc);
    } else if (iconfg == 4) {
      chkin3(cmn, l, i1, i2, i3, t, tmin, nc);
    } else if (iconfg == 3 || iconfg == 5) {
      chkcel(cmn, l, i1, i2, i3, t, tmin, nc);
    }
  }
  /// C
  fixtim(cmn, l, t, tmin1, tmin, nc);
  /// C
}

struct ulist_save {
  int l;

  ulist_save() : l(fem::int0) {}
};

void ulist(common& cmn, double const& t) {
  FEM_CMN_SVE(ulist);
  /// COMMON ilist1
  int& jscat = cmn.jscat;
  int& ictype = cmn.ictype;
  ///
  /// SAVE
  int& l = sve.l;
  ///
  /// C     this subroutine is used to update a new collision time list
  /// C       notice this t has been updated
  /// C
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist4/
  /// C
  if (ictype == 1 || ictype == 2 || ictype == 5 || ictype == 6) {
    l = cmn.ifmpt;
    ulist1(cmn, l, t);
  }
  if (ictype != 1) {
    l = cmn.iscat;
    ulist1(cmn, l, t);
    if (jscat != 0) {
      l = jscat;
      ulist1(cmn, l, t);
    }
  }
  /// C
}

struct zpcrun_save {
  fem::variant_bindings prec2_bindings;
  int iscat0;
  int jscat0;
  int niscat;
  int njscat;
  double t1;

  zpcrun_save()
      : iscat0(fem::int0),
        jscat0(fem::int0),
        niscat(fem::int0),
        njscat(fem::int0),
        t1(fem::double0) {}
};

/// C
/// C*****************************************************************************
/// C
void zpcrun(common& cmn, fem::star_type const& /* UNHANDLED: star argument */) {
  FEM_CMN_SVE(zpcrun);
  common_write write(cmn);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON para7
  int& ioscar = cmn.ioscar;
  /// COMMON ilist1
  int& iscat = cmn.iscat;
  int& jscat = cmn.jscat;
  const int maxptn = 400001;
  arr_cref<int> next(cmn.next, dimension(maxptn));
  int& ictype = cmn.ictype;
  arr_cref<int> icsta(cmn.icsta, dimension(maxptn));
  /// COMMON ilist4
  int& ifmpt = cmn.ifmpt;
  int& ichkpt = cmn.ichkpt;
  /// COMMON ilist5
  arr_cref<double> ct(cmn.ct, dimension(maxptn));
  double& tlarge = cmn.tlarge;
  /// COMMON ilist6
  double& t = cmn.t;
  int& iopern = cmn.iopern;
  int& icolln = cmn.icolln;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  int& iscat0 = sve.iscat0;
  int& jscat0 = sve.jscat0;
  int& niscat = sve.niscat;
  int& njscat = sve.njscat;
  double& t1 = sve.t1;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  arr_cref<double> xmass(prec2.bind<double>(), dimension(maxptn));
  arr_cref<int> ityp(prec2.bind<int>(), dimension(maxptn));
  static const char* format_200 = "(i6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))";
  static const char* format_201 = "(i6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))";
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec4/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /ilist1/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// Cc      SAVE /ilist6/
  /// Cc      SAVE /ana1/
  /// Cc      SAVE /anim/
  /// C
  /// C       save last collision info
  if (fem::mod(ictype, 2) == 0) {
    savrec(cmn, iscat);
    savrec(cmn, jscat);
  }
  /// C
  /// C1      get operation type
  getict(cmn, t1);
  /// C2      check freezeout condition
  if (iconfg == 1 && t1 > tlarge / 2e0) {
    return;
  }
  const double tend1 = 250e0;
  if (iconfg == 2 || iconfg == 3) {
    if (t1 > tend1) {
      return;
    }
    /// C           if (ichkpt .eq. mul) then
    /// C              ii = 0
    /// C              do i = 1, mul
    /// C                 gztemp = gz(i) + vz(i) * (t1 - ft(i))
    /// C                 if (sqrt(t1 ** 2 - gztemp ** 2) .lt. tend) then
    /// C                    ii = 1
    /// C                    goto 1000
    /// C                 end if
    /// C              end do
    /// C 1000              continue
    /// C              if (ii .eq. 0) return 1
    /// C           end if
  }
  const double tend2 = 6.1e0;
  if (iconfg == 4 || iconfg == 5) {
    if (t1 > tend2) {
      return;
    }
  }
  /// C
  /// Clin-6/06/02 local freezeout for string melting,
  /// C     decide what partons have frozen out at time t1:
  if (cmn.isoft == 5) {
    local(cmn, t1);
  }
  /// C
  /// C3      update iopern, t
  /// C
  iopern++;
  t = t1;
  if (fem::mod(ictype, 2) == 0) {
    icolln++;
    /// C
    /// C     4/18/01-ctest off
    /// C           write (2006, 1233) 'iscat=', iscat, 'jscat=', jscat,
    /// C           write (2006, *) 'iscat=', iscat, ' jscat=', jscat,
    /// C     1 ityp(iscat), ityp(jscat)
    /// C           write (2006, 1233) 'iscat=', max(indx(iscat), indx(jscat)),
    /// C     &        'jscat=', min(indx(iscat), indx(jscat))
    /// C
    /// C           write (2006, 1234) ' icolln=', icolln, 't=', t
    /// C
    /// C 1233           format (a10, i10, a10, i10)
    /// C 1234           format (a15, i10, a5, f23.17, a5, f23.17)
  }
  /// C
  /// C4.1    deal with formation
  if (iconfg == 1 || iconfg == 2 || iconfg == 4) {
    if (ictype == 1 || ictype == 2 || ictype == 5 || ictype == 6) {
      celasn(cmn);
    }
  }
  /// C
  /// C4.2    deal with collisions
  /// C
  if (ictype != 1) {
    /// C
    iscat0 = iscat;
    jscat0 = jscat;
    /// C
    /// C        iscat is the larger one so that if it's a wall collision,
    /// C       it's still ok
    iscat = fem::max0(iscat0, jscat0);
    jscat = fem::min0(iscat0, jscat0);
    /// C
    /// Ctest off check icsta(i): 0 with f77 compiler
    /// C        write(9,*) 'BB:ictype,t1,iscat,jscat,icsta(i)=',
    /// C     1 ictype,t1,iscat,jscat,icsta(iscat)
    /// C
    /// C       check collision time table error 'tterr'
    /// Clin-4/2008 to avoid out-of-bound error in next():
    /// C           if (jscat .ne. 0 .and. next(jscat) .ne. iscat)
    /// C     &        then
    /// C              print *, 'iscat=', iscat, 'jscat=', jscat,
    /// C     &             'next(', jscat, ')=', next(jscat)
    /// C
    /// C              if (ct(iscat) .lt. tlarge / 2d0) stop 'tterr'
    /// C              if (ct(jscat) .lt. tlarge / 2d0) stop 'tterr'
    /// C           end if
    if (jscat != 0) {
      if (next(jscat) != iscat) {
        write(6, star), "iscat=", iscat, "jscat=", jscat, "next(", jscat,
            ")=", next(jscat);
        if (ct(iscat) < tlarge / 2e0) {
          FEM_STOP("tterr");
        }
        if (ct(jscat) < tlarge / 2e0) {
          FEM_STOP("tterr");
        }
      }
    }
    /// Clin-4/2008-end
    /// C
    /// C4.2.1     collisions with wall
    /// C
    /// C     8/19/02 avoid actual argument in common blocks of cellre:
    niscat = iscat;
    njscat = jscat;
    /// C           if (icsta(iscat) .ne. 0) call cellre(iscat, t)
    /// C           if (jscat .ne. 0) then
    /// C              if (icsta(jscat) .ne. 0) call cellre(jscat, t)
    /// C           end if
    if (icsta(iscat) != 0) {
      cellre(cmn, niscat, t);
    }
    if (jscat != 0) {
      if (icsta(jscat) != 0) {
        cellre(cmn, njscat, t);
      }
    }
    /// C
    /// C4.2.2     collision between particles
    /// C
    /// Clin-6/2009 write out info for each collision:
    /// C           if (mod(ictype, 2) .eq. 0) call scat(t, iscat, jscat)
    if (fem::mod(ictype, 2) == 0) {
      if (ioscar == 3) {
        write(95, star), "event,miss,iscat,jscat=", cmn.iaevt, cmn.miss, iscat,
            jscat;
        if (fem::dmax1(fem::abs(gx(iscat)), fem::abs(gy(iscat)),
                       fem::abs(gz(iscat)), fem::abs(ft(iscat)),
                       fem::abs(gx(jscat)), fem::abs(gy(jscat)),
                       fem::abs(gz(jscat)), fem::abs(ft(jscat))) < 9999) {
          write(95, format_200), ityp(iscat), px(iscat), py(iscat), pz(iscat),
              xmass(iscat), gx(iscat), gy(iscat), gz(iscat), ft(iscat);
          write(95, format_200), ityp(jscat), px(jscat), py(jscat), pz(jscat),
              xmass(jscat), gx(jscat), gy(jscat), gz(jscat), ft(jscat);
        } else {
          write(95, format_201), ityp(iscat), px(iscat), py(iscat), pz(iscat),
              xmass(iscat), gx(iscat), gy(iscat), gz(iscat), ft(iscat);
          write(95, format_201), ityp(jscat), px(jscat), py(jscat), pz(jscat),
              xmass(jscat), gx(jscat), gy(jscat), gz(jscat), ft(jscat);
        }
      }
      /// C
      scat(cmn, t, iscat, jscat);
      /// C
      if (ioscar == 3) {
        if (fem::dmax1(fem::abs(gx(iscat)), fem::abs(gy(iscat)),
                       fem::abs(gz(iscat)), fem::abs(ft(iscat)),
                       fem::abs(gx(jscat)), fem::abs(gy(jscat)),
                       fem::abs(gz(jscat)), fem::abs(ft(jscat))) < 9999) {
          write(95, format_200), ityp(iscat), px(iscat), py(iscat), pz(iscat),
              xmass(iscat), gx(iscat), gy(iscat), gz(iscat), ft(iscat);
          write(95, format_200), ityp(jscat), px(jscat), py(jscat), pz(jscat),
              xmass(jscat), gx(jscat), gy(jscat), gz(jscat), ft(jscat);
        } else {
          write(95, format_201), ityp(iscat), px(iscat), py(iscat), pz(iscat),
              xmass(iscat), gx(iscat), gy(iscat), gz(iscat), ft(iscat);
          write(95, format_201), ityp(jscat), px(jscat), py(jscat), pz(jscat),
              xmass(jscat), gx(jscat), gy(jscat), gz(jscat), ft(jscat);
        }
      }
    }
    /// C
  }
  /// C
  /// C5      update the interaction list
  ulist(cmn, t);
  /// C
  /// C6      update ifmpt. ichkpt
  /// C       old ichkpt and ifmpt are more conveniently used in ulist
  if (ifmpt <= cmn.mul) {
    if (ictype != 0 && ictype != 3 && ictype != 4) {
      ichkpt++;
      ifmpt++;
    }
  }
  /// C
}

void zpca1b(common& cmn, double const& rapi, double const& et, int const& ian) {
  /// COMMON para6
  double& centy = cmn.centy;
  /// COMMON ana2
  arr_ref<double> det(cmn.det, dimension(12));
  arr_ref<double> dn(cmn.dn, dimension(12));
  arr_ref<double> det1(cmn.det1, dimension(12));
  arr_ref<double> dn1(cmn.dn1, dimension(12));
  arr_ref<double> det2(cmn.det2, dimension(12));
  arr_ref<double> dn2(cmn.dn2, dimension(12));
  ///
  /// C
  /// Cc      SAVE /para6/
  /// Cc      SAVE /ilist6/
  /// Cc      SAVE /ana2/
  /// C
  if (rapi > centy - 0.5e0 && rapi < centy + 0.5e0) {
    det2(ian) += et;
    dn2(ian) += 1e0;
    /// Cdtrans
    if (ian == 10) {
      /// Cd              write (10, *) t, det2(ian)
    }
    if (ian == 11) {
      /// Cd              write (11, *) t, det2(ian)
    }
    if (ian == 12) {
      /// Cd              write (12, *) t, det2(ian)
    }
    /// Cdtransend
    if (rapi > centy - 0.25e0 && rapi < centy + 0.25e0) {
      det1(ian) += et;
      dn1(ian) += 1e0;
      if (rapi > centy - 0.1e0 && rapi < centy + 0.1e0) {
        det(ian) += et;
        dn(ian) += 1e0;
      }
    }
  }
  /// C
}

struct zpca1c_save {
  arr<double> en;
  int i;
  int j;

  zpca1c_save() : en(dimension(4), fem::fill0), i(fem::int0), j(fem::int0) {}
};

void zpca1c(common& cmn, double const& p0, double const& p1, double const& p2,
            double const& p3, int const& ian) {
  FEM_CMN_SVE(zpca1c);
  /// COMMON ana3
  arr_ref<double, 3> em(cmn.em, dimension(4, 4, 12));
  ///
  /// SAVE
  arr_ref<double> en(sve.en, dimension(4));
  int& i = sve.i;
  int& j = sve.j;
  ///
  /// C
  /// Cc      SAVE /ana3/
  /// C
  en(1) = p0;
  en(2) = p1;
  en(3) = p2;
  en(4) = p3;
  /// C
  FEM_DO_SAFE(i, 1, 4) {
    FEM_DO_SAFE(j, 1, 4) { em(i, j, ian) += en(i) * en(j) / p0; }
  }
  /// C
}

struct zpca1a_save {
  fem::variant_bindings prec2_bindings;
  double et;
  int ian;
  int ipic;
  double p0;
  double p1;
  double p2;
  double p3;
  double rapi;
  double t1;
  double t2;

  zpca1a_save()
      : et(fem::double0),
        ian(fem::int0),
        ipic(fem::int0),
        p0(fem::double0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        rapi(fem::double0),
        t1(fem::double0),
        t2(fem::double0) {}
};

void zpca1a(common& cmn, int const& i) {
  FEM_CMN_SVE(zpca1a);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON prec3
  const int maxptn = 400001;
  arr_cref<double> fts(cmn.fts, dimension(maxptn));
  arr_cref<double> pxs(cmn.pxs, dimension(maxptn));
  arr_cref<double> pys(cmn.pys, dimension(maxptn));
  arr_cref<double> pzs(cmn.pzs, dimension(maxptn));
  arr_cref<double> es(cmn.es, dimension(maxptn));
  /// COMMON prec5
  arr_cref<double> tau(cmn.tau, dimension(maxptn));
  /// COMMON prec6
  arr_cref<double> raps(cmn.raps, dimension(maxptn));
  arr_cref<double> taus(cmn.taus, dimension(maxptn));
  /// COMMON ana1
  arr_cref<double> ts(cmn.ts, dimension(12));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& et = sve.et;
  int& ian = sve.ian;
  int& ipic = sve.ipic;
  double& p0 = sve.p0;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& rapi = sve.rapi;
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  /* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec3/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /prec6/
  /// Cc      SAVE /ana1/
  /// C
  if (iconfg == 1) {
    t1 = fts(i);
    t2 = ft(i);
    ipic = 11;
  } else if (iconfg == 2 || iconfg == 3) {
    /// Cd           t1 = fts(i)
    /// Cd           t2 = ft(i)
    t1 = taus(i);
    t2 = tau(i);
    ipic = 12;
  } else if (iconfg == 4 || iconfg == 5) {
    t1 = fts(i);
    t2 = ft(i);
    ipic = 12;
  }
  /// C
  if (iconfg <= 3) {
    FEM_DO_SAFE(ian, 1, ipic) {
      if (t1 <= ts(ian) && t2 > ts(ian)) {
        rapi = raps(i);
        /// C     7/20/01:
        /// C                 et = sqrt(pxs(i) ** 2 + pys(i) ** 2 + xmp ** 2)
        et = fem::dsqrt(fem::pow2(pxs(i)) + fem::pow2(pys(i)) +
                        fem::pow2(cmn.xmp));
        zpca1b(cmn, rapi, et, ian);
      }
    }
  } else {
    FEM_DO_SAFE(ian, 1, ipic) {
      if (t1 <= ts(ian) && t2 > ts(ian)) {
        p0 = es(i);
        p1 = pxs(i);
        p2 = pys(i);
        p3 = pzs(i);
        zpca1c(cmn, p0, p1, p2, p3, ian);
      }
    }
  }
  /// C
}

/// C
/// C*****************************************************************************
/// C
void zpca1(common& cmn) {
  /// C
  /// Cc      SAVE /ilist1/
  /// C
  if (fem::mod(cmn.ictype, 2) == 0) {
    zpca1a(cmn, cmn.iscat);
    zpca1a(cmn, cmn.jscat);
    /// Clin-5/2009 ctest off v2 for parton:
    /// C           call flowp(1)
  }
  /// C
}

struct zpca2a_save {
  fem::variant_bindings prec2_bindings;
  double et;
  int i;
  int ian;
  int ipic;
  int j;
  double rapi;
  double t1;
  double t2;

  zpca2a_save()
      : et(fem::double0),
        i(fem::int0),
        ian(fem::int0),
        ipic(fem::int0),
        j(fem::int0),
        rapi(fem::double0),
        t1(fem::double0),
        t2(fem::double0) {}
};

void zpca2a(common& cmn) {
  FEM_CMN_SVE(zpca2a);
  /// COMMON para5
  int& iconfg = cmn.iconfg;
  /// COMMON para6
  double& centy = cmn.centy;
  /// COMMON prec5
  const int maxptn = 400001;
  arr_cref<double> rap(cmn.rap, dimension(maxptn));
  arr_cref<double> tau(cmn.tau, dimension(maxptn));
  /// COMMON ilist5
  double& tlarge = cmn.tlarge;
  /// COMMON ana1
  arr_cref<double> ts(cmn.ts, dimension(12));
  /// COMMON ana2
  arr_cref<double> det(cmn.det, dimension(12));
  arr_cref<double> dn(cmn.dn, dimension(12));
  arr_ref<double> detdy(cmn.detdy, dimension(12));
  arr_ref<double> detdn(cmn.detdn, dimension(12));
  arr_ref<double> dndy(cmn.dndy, dimension(12));
  arr_cref<double> det1(cmn.det1, dimension(12));
  arr_cref<double> dn1(cmn.dn1, dimension(12));
  arr_ref<double> detdy1(cmn.detdy1, dimension(12));
  arr_ref<double> detdn1(cmn.detdn1, dimension(12));
  arr_ref<double> dndy1(cmn.dndy1, dimension(12));
  arr_cref<double> det2(cmn.det2, dimension(12));
  arr_cref<double> dn2(cmn.dn2, dimension(12));
  arr_ref<double> detdy2(cmn.detdy2, dimension(12));
  arr_ref<double> detdn2(cmn.detdn2, dimension(12));
  arr_ref<double> dndy2(cmn.dndy2, dimension(12));
  /// COMMON ana4
  arr_ref<double> fdetdy(cmn.fdetdy, dimension(24));
  arr_ref<double> fdndy(cmn.fdndy, dimension(24));
  arr_ref<double> fdndpt(cmn.fdndpt, dimension(12));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  /// SAVE
  double& et = sve.et;
  int& i = sve.i;
  int& ian = sve.ian;
  int& ipic = sve.ipic;
  int& j = sve.j;
  double& rapi = sve.rapi;
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  /* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /para2/
  /// Cc      SAVE /para3/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /para6/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /prec5/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// Cc      SAVE /ilist6/
  /// Cc      SAVE /rndm1/
  /// Cc      SAVE /rndm2/
  /// Cc      SAVE /rndm3/
  /// Cc      SAVE /ana1/
  /// Cc      SAVE /ana2/
  /// Cc      SAVE /ana4/
  /// C
  FEM_DO_SAFE(i, 1, cmn.ichkpt) {
    rapi = rap(i);
    /// C     7/20/01:
    /// C           et = sqrt(px(i) ** 2 + py(i) ** 2 + xmp ** 2)
    et = fem::dsqrt(fem::pow2(px(i)) + fem::pow2(py(i)) + fem::pow2(cmn.xmp));
    /// C
    FEM_DO_SAFE(j, 1, 24) {
      if (rapi > j + centy - 13e0 && rapi < j + centy - 12e0) {
        fdetdy(j) += et;
        fdndy(j) += 1e0;
      }
    }
    /// C
    FEM_DO_SAFE(j, 1, 12) {
      if (et > 0.5e0 * (j - 1) && et < 0.5e0 * j) {
        fdndpt(j) += 1e0;
      }
    }
    /// C
    if (iconfg == 1) {
      t1 = ft(i);
      t2 = tlarge;
      ipic = 11;
    } else {
      t1 = tau(i);
      t2 = tlarge;
      ipic = 12;
    }
    /// C
    FEM_DO_SAFE(ian, 1, ipic) {
      if (t1 <= ts(ian) && t2 > ts(ian)) {
        zpca1b(cmn, rapi, et, ian);
      }
    }
    /// C
    if (iconfg == 1) {
      zpca1b(cmn, rapi, et, 12);
    }
  }
  /// C
  FEM_DO_SAFE(ian, 1, 12) {
    if (dn(ian) == 0e0 || dn1(ian) == 0e0 || dn2(ian) == 0e0) {
      /// Clin-9/2012 suppress output:
      /// C              print *, 'event=', ievt
      /// C              print *, 'dn(', ian, ')=', dn(ian), 'dn1(', ian,
      /// C     &           ')=', dn1(ian), 'dn2(', ian, ')=', dn2(ian)
    }
    detdy(ian) += det(ian);
    if (dn(ian) != 0) {
      detdn(ian) += det(ian) / dn(ian);
    }
    dndy(ian) += dn(ian);
    detdy1(ian) += det1(ian);
    if (dn1(ian) != 0) {
      detdn1(ian) += det1(ian) / dn1(ian);
    }
    dndy1(ian) += dn1(ian);
    detdy2(ian) += det2(ian);
    if (dn2(ian) != 0) {
      detdn2(ian) += det2(ian) / dn2(ian);
    }
    dndy2(ian) += dn2(ian);
  }
  /// C
}

struct zpca2b_save {
  fem::variant_bindings prec2_bindings;
  int i;
  int ian;
  int ipic;
  double p0;
  double p1;
  double p2;
  double p3;
  double t1;
  double t2;

  zpca2b_save()
      : i(fem::int0),
        ian(fem::int0),
        ipic(fem::int0),
        p0(fem::double0),
        p1(fem::double0),
        p2(fem::double0),
        p3(fem::double0),
        t1(fem::double0),
        t2(fem::double0) {}
};

void zpca2b(common& cmn) {
  FEM_CMN_SVE(zpca2b);
  /// COMMON ana1
  arr_cref<double> ts(cmn.ts, dimension(12));
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  const int maxptn = 400001;
  /// SAVE
  int& i = sve.i;
  int& ian = sve.ian;
  int& ipic = sve.ipic;
  double& p0 = sve.p0;
  double& p1 = sve.p1;
  double& p2 = sve.p2;
  double& p3 = sve.p3;
  double& t1 = sve.t1;
  double& t2 = sve.t2;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  /* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  /* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  /* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
    maxptn)) */
      ;
  /* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
  /// C
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /ilist4/
  /// Cc      SAVE /ilist5/
  /// Cc      SAVE /ana1/
  /// C
  FEM_DO_SAFE(i, 1, cmn.ichkpt) {
    t1 = ft(i);
    t2 = cmn.tlarge;
    ipic = 12;
    /// C
    FEM_DO_SAFE(ian, 1, ipic) {
      if (t1 <= ts(ian) && t2 > ts(ian)) {
        p0 = e(i);
        p1 = px(i);
        p2 = py(i);
        p3 = pz(i);
        zpca1c(cmn, p0, p1, p2, p3, ian);
      }
    }
  }
  /// C
}

struct zpca2c_save {
  fem::variant_bindings prec2_bindings;
  int aproj;
  int atarg;
  double bimp;
  fem::str<8> code;
  double ebeam;
  int event;
  int i;
  int nff;
  int ntestp;
  double phi;
  fem::str<4> reffra;
  fem::str<8> versn;
  int zproj;
  int ztarg;

  zpca2c_save()
      : aproj(fem::int0),
        atarg(fem::int0),
        bimp(fem::double0),
        code(fem::char0),
        ebeam(fem::double0),
        event(fem::int0),
        i(fem::int0),
        nff(fem::int0),
        ntestp(fem::int0),
        phi(fem::double0),
        reffra(fem::char0),
        versn(fem::char0),
        zproj(fem::int0),
        ztarg(fem::int0) {}
};

void zpca2c(common& cmn) {
  FEM_CMN_SVE(zpca2c);
  common_write write(cmn);
  /// COMMON para1
  int& mul = cmn.mul;
  ///
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  const int maxptn = 400001;
  /// SAVE
  int& aproj = sve.aproj;
  int& atarg = sve.atarg;
  double& bimp = sve.bimp;
  fem::str<8>& code = sve.code;
  double& ebeam = sve.ebeam;
  int& event = sve.event;
  int& i = sve.i;
  int& nff = sve.nff;
  int& ntestp = sve.ntestp;
  double& phi = sve.phi;
  fem::str<4>& reffra = sve.reffra;
  fem::str<8>& versn = sve.versn;
  int& zproj = sve.zproj;
  int& ztarg = sve.ztarg;
  ///
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<double> gx(dimension(maxptn));
      mbr<double> gy(dimension(maxptn));
      mbr<double> gz(dimension(maxptn));
      mbr<double> ft(dimension(maxptn));
      mbr<double> px(dimension(maxptn));
      mbr<double> py(dimension(maxptn));
      mbr<double> pz(dimension(maxptn));
      mbr<double> e(dimension(maxptn));
      mbr<double> xmass(dimension(maxptn));
      mbr<int> ityp(dimension(maxptn));
      prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
    }
  }
  arr_cref<double> gx(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> e(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> xmass(prec2.bind<double>(), dimension(maxptn));
  arr_cref<int> ityp(prec2.bind<int>(), dimension(maxptn));
  if (is_called_first_time) {
    nff = 0;
  }
  static const char* format_101 = "(a12)";
  /// C
  /// Cc      SAVE /para1/
  /// Cc      SAVE /prec2/
  /// C
  /// C       file header
  if (nff == 0) {
    write(26, format_101), "OSCAR1997A";
    write(26, format_101), "final_id_p_x";
    code = "ZPC";
    versn = "1.0.1";
    aproj = -1;
    zproj = -1;
    atarg = -1;
    ztarg = -1;
    reffra = "cm";
    ebeam = 0e0;
    ntestp = 1;
    write(26,
          "(2(a8,2x),'(',i3,',',i6,')+(',i3,',',i6,')',2x,a4,2x,e10.4,2x,i8)"),
        code, versn, aproj, zproj, atarg, ztarg, reffra, ebeam, ntestp;
    nff = 1;
    event = 1;
    bimp = 0e0;
    phi = 0e0;
  }
  /// C
  /// C       comment
  /// C
  /// C       event header
  write(26, "(i10,2x,i10,2x,f8.3,2x,f8.3)"), event, mul, bimp, phi;
  /// C
  /// C       particles
  FEM_DO_SAFE(i, 1, mul) {
    write(26, "(i10,2x,i10,2x,9(e12.6,2x))"), i, ityp(i), px(i), py(i), pz(i),
        e(i), xmass(i), gx(i), gy(i), gz(i), ft(i);
  }
  /// C
  event++;
  /// C
}

/// C
/// C*****************************************************************************
/// C
void zpca2(common& cmn) {
  common_write write(cmn);
  /// C
  /// Cc      SAVE /para3/
  /// Cc      SAVE /para5/
  /// Cc      SAVE /para7/
  /// Cc      SAVE /ilist6/
  /// Cc      SAVE /rndm1/
  /// Cc      SAVE /rndm2/
  /// Cc      SAVE /rndm3/
  /// Cc      SAVE /AREVT/
  /// C
  if (cmn.iconfg <= 3) {
    zpca2a(cmn);
  } else {
    zpca2b(cmn);
  }
  /// C
  if (cmn.ioscar == 1) {
    zpca2c(cmn);
  }
  /// C
  /// Cbzdbg2/17/99
  /// C        write (25, *) 'Event', nsevt - 1 + ievt,
  /// C    &         ', run', isbrun,
  /// C        WRITE (25, *) ' Event ', IAEVT, ', run ', IARUN,
  /// C     &     ',\n\t number of operations = ', iopern,
  /// C     &     ',\n\t number of collisions between particles = ',
  /// C     &         icolln,
  /// C     &     ',\n\t freezeout time=', t,
  /// C     &     ',\n\t ending at the ', number, 'th random number',
  /// C     &     ',\n\t ending collision iff=', iff
  write(25, star), " Event ", cmn.iaevt, ", run ", cmn.iarun;
  write(25, star), "    number of operations = ", cmn.iopern;
  write(25, star), "    number of collisions between particles = ", cmn.icolln;
  write(25, star), "    freezeout time=", cmn.t;
  write(25, star), "    ending at the ", cmn.number, "th random number";
  write(25, star), "    ending collision iff=", cmn.iff;
  /// C
}

struct zpcou1_save {
  double dpt;
  double dy;
  double dy1;
  double dy2;
  int ntotal;

  zpcou1_save()
      : dpt(fem::double0),
        dy(fem::double0),
        dy1(fem::double0),
        dy2(fem::double0),
        ntotal(fem::int0) {}
};

void zpcou1(common& cmn) {
  FEM_CMN_SVE(zpcou1);
  /// C
  /// Cc      SAVE /para3/
  /// Cc      SAVE /ana1/
  /// Cc      SAVE /ana2/
  /// Cc      SAVE /ana4/
  /// C
  sve.dpt = 0.5e0;
  sve.dy2 = 1e0;
  sve.dy1 = 0.5e0;
  sve.dy = 0.2e0;
  sve.ntotal = cmn.nevnt * cmn.nsbrun;
  /// C
}

struct zpcou2_save {
  int i;
  int ian;
  int ntotal;
  double vol;

  zpcou2_save()
      : i(fem::int0), ian(fem::int0), ntotal(fem::int0), vol(fem::double0) {}
};

void zpcou2(common& cmn) {
  FEM_CMN_SVE(zpcou2);
  common_write write(cmn);
  /// COMMON ana1
  arr_cref<double> ts(cmn.ts, dimension(12));
  /// COMMON ana3
  arr_cref<double, 3> em(cmn.em, dimension(4, 4, 12));
  ///
  /// SAVE
  int& i = sve.i;
  int& ian = sve.ian;
  int& ntotal = sve.ntotal;
  double& vol = sve.vol;
  ///
  /// C
  /// Cc      SAVE /para3/
  /// Cc      SAVE /ilist3/
  /// Cc      SAVE /ana1/
  /// Cc      SAVE /ana3/
  /// C
  cmn.io.open(28, "ana4/em.dat").status("unknown");
  vol = 1000.e0 * cmn.size1 * cmn.size2 * cmn.size3;
  ntotal = cmn.nevnt * cmn.nsbrun;
  /// C
  FEM_DO_SAFE(ian, 1, 12) {
    write(28, star), "*** for time ", ts(ian), "fm(s)";
    FEM_DO_SAFE(i, 1, 4) {
      write(28, star), em(i, 1, ian) / vol / ntotal,
          em(i, 2, ian) / vol / ntotal, em(i, 3, ian) / vol / ntotal,
          em(i, 4, ian) / vol / ntotal;
    }
  }
  /// C
}

/// C
/// C*****************************************************************************
/// C
void zpcou(common& cmn) {
  /// C
  /// Cc      SAVE /para5/
  /// C
  if (cmn.iconfg <= 3) {
    zpcou1(cmn);
  } else {
    zpcou2(cmn);
  }
  /// C
}

struct zpcmn_save {
  int i;
  int j;

  zpcmn_save() : i(fem::int0), j(fem::int0) {}
};

/// C.................... zpc.f
/// C        PROGRAM ZPC
void zpcmn(common& cmn) {
  FEM_CMN_SVE(zpcmn);
  int& i = sve.i;
  int& j = sve.j;
  /// C       Version: 1.0.1
  /// C       Author: Bin Zhang
  /// C       (suggestions, problems -> bzhang@nt1.phys.columbia.edu)
  /// Clin-4/20/01        PARAMETER (NMAXGL = 16000)
  /// Cc      SAVE /para3/
  /// C
  /// C       loop over events
  FEM_DO_SAFE(i, 1, cmn.nevnt) {
    cmn.ievt = i;
    /// C       generation of the initial condition for one event
    inievt(cmn);
    /// C      loop over many runs of the same event
    FEM_DO_SAFE(j, 1, cmn.nsbrun) {
      cmn.isbrun = j;
      /// C       initialization for one run of an event
      inirun(cmn);
    /// Clin-4/2008 not used:
    /// C             CALL HJAN1A
    statement_3000:
      /// C       do one collision
      zpcrun(cmn, star /* 4000 UNHANDLED */);
      zpca1(cmn);
      goto statement_3000;
      zpca2(cmn);
    }
  }
  zpcou(cmn);
  /// Clin-5/2009 ctest off
  /// C     5/17/01 calculate v2 for parton already frozen out:
  /// C        call flowp(3)
  /// C.....to get average values for different strings
  zpstrg(cmn);
}

struct hijing_save {
  fem::variant_bindings hstrng_bindings;
  fem::variant_bindings prec2_bindings;
  float aphx1;
  float aphx2;
  float b2;
  float bb;
  float bbx;
  float bby;
  float bmax;
  float bmin;
  float cx;
  float dengy;
  float dnbp;
  float dnbp1;
  float dnbp2;
  float dnbp3;
  float dnbt;
  float dnbt1;
  float dnbt2;
  float dnbt3;
  float gs;
  float gstot;
  float gstot0;
  int i;
  int i05;
  int idstr;
  int ierror;
  int ii;
  int iityp;
  int ijet;
  arr<int> ipcol;
  int isg;
  int istr;
  arr<int> itcol;
  int itest;
  int j;
  int jflg;
  int jjtp;
  int jout;
  int jp;
  int jphard;
  int jpmini;
  int jt;
  int jthard;
  int jtmini;
  arr<int> jtp;
  int kp;
  int kp2;
  int kt;
  int kt2;
  int lsg;
  int ncolt;
  int nftp;
  int nhard;
  int njet;
  int nlop;
  int nmini;
  int nmom;
  int npar;
  int npart;
  int nsbst;
  int nsbstr;
  int nstrg;
  int ntp;
  float phi;
  float r;
  float r2;
  float rantot;
  float rnd1;
  float rnd2;
  float rnd3;
  arr<float, 2> rnip;
  float rrb1;
  float rrb2;
  arr<float, 2> scip;
  arr<float, 2> sjip;
  float sx;
  float tt;
  float ttrig;
  float tts;
  float x;
  float xr;
  float xr1;
  float y1;
  float y2;
  float y3;

  hijing_save()
      : aphx1(fem::float0),
        aphx2(fem::float0),
        b2(fem::float0),
        bb(fem::float0),
        bbx(fem::float0),
        bby(fem::float0),
        bmax(fem::float0),
        bmin(fem::float0),
        cx(fem::float0),
        dengy(fem::float0),
        dnbp(fem::float0),
        dnbp1(fem::float0),
        dnbp2(fem::float0),
        dnbp3(fem::float0),
        dnbt(fem::float0),
        dnbt1(fem::float0),
        dnbt2(fem::float0),
        dnbt3(fem::float0),
        gs(fem::float0),
        gstot(fem::float0),
        gstot0(fem::float0),
        i(fem::int0),
        i05(fem::int0),
        idstr(fem::int0),
        ierror(fem::int0),
        ii(fem::int0),
        iityp(fem::int0),
        ijet(fem::int0),
        ipcol(dimension(90000), fem::fill0),
        isg(fem::int0),
        istr(fem::int0),
        itcol(dimension(90000), fem::fill0),
        itest(fem::int0),
        j(fem::int0),
        jflg(fem::int0),
        jjtp(fem::int0),
        jout(fem::int0),
        jp(fem::int0),
        jphard(fem::int0),
        jpmini(fem::int0),
        jt(fem::int0),
        jthard(fem::int0),
        jtmini(fem::int0),
        jtp(dimension(3), fem::fill0),
        kp(fem::int0),
        kp2(fem::int0),
        kt(fem::int0),
        kt2(fem::int0),
        lsg(fem::int0),
        ncolt(fem::int0),
        nftp(fem::int0),
        nhard(fem::int0),
        njet(fem::int0),
        nlop(fem::int0),
        nmini(fem::int0),
        nmom(fem::int0),
        npar(fem::int0),
        npart(fem::int0),
        nsbst(fem::int0),
        nsbstr(fem::int0),
        nstrg(fem::int0),
        ntp(fem::int0),
        phi(fem::float0),
        r(fem::float0),
        r2(fem::float0),
        rantot(fem::float0),
        rnd1(fem::float0),
        rnd2(fem::float0),
        rnd3(fem::float0),
        rnip(dimension(300, 300), fem::fill0),
        rrb1(fem::float0),
        rrb2(fem::float0),
        scip(dimension(300, 300), fem::fill0),
        sjip(dimension(300, 300), fem::fill0),
        sx(fem::float0),
        tt(fem::float0),
        ttrig(fem::float0),
        tts(fem::float0),
        x(fem::float0),
        xr(fem::float0),
        xr1(fem::float0),
        y1(fem::float0),
        y2(fem::float0),
        y3(fem::float0) {}
};

/// C.................... hijing1.383_ampt.f
/// C     Version 1.383
/// C     The variables isng in HIJSFT and JL in ATTRAD were not initialized.
/// C     The version initialize them. (as found by Fernando Marroquim)
/// C
/// C     Version 1.382
/// C     Nuclear distribution for deuteron is taken as the Hulthen wave
/// C     function as provided by Brian Cole (Columbia)
/// Clin     used my own implementation of impact parameter
/// Clin     & proton-neutron distance within a deuteron.
/// C
/// C     Version 1.381
/// C
/// C     The parameters for Wood-Saxon distribution for deuteron are
/// C     constrained to give the right rms ratius 2.116 fm
/// C     (R=0.0, D=0.5882)
/// C
/// C     Version 1.38
/// C
/// C     The following common block is added to record the number of elastic
/// C     (NELT, NELP) and inelastic (NINT, NINP) participants
/// C
/// C        COMMON/HJGLBR/NELT,NINT,NELP,NINP
/// C        SAVE /HJGLBR/
/// C
/// C     Version 1.37
/// C
/// C     A bug in the quenching subroutine is corrected. When calculating the
/// C     distance between two wounded nucleons, the displacement of the
/// C     impact parameter was not inculded. This bug was discovered by
/// C     Dr. V.Uzhinskii JINR, Dubna, Russia
/// C
/// C     Version 1.36
/// C
/// C     Modification Oct. 8, 1998. In hijing, log(ran(nseed)) occasionally
/// C     causes overfloat. It is modified to log(max(ran(nseed),1.0e-20)).
/// C
/// C     Nothing important has been changed here. A few 'garbage' has been
/// C     cleaned up here, like common block HJJET3 for the sea quark strings
/// C     which were originally created to implement the DPM scheme which
/// C     later was abadoned in the final version. The lines which operate
/// C     on these data are also deleted in the program.
/// C
/// C     Version 1.35
/// C     There are some changes in the program: subroutine HARDJET is now
/// C     consolidated with HIJHRD. HARDJET is used to re-initiate PYTHIA
/// C     for the triggered hard processes. Now that is done  altogether
/// C     with other normal hard processes in modified JETINI. In the new
/// C     version one calls JETINI every time one calls HIJHRD. In the new
/// C     version the effect of the isospin of the nucleon on hard processes,
/// C     especially direct photons is correctly considered.
/// C     For A+A collisions, one has to initilize pythia
/// C     separately for each type of collisions, pp, pn,np and nn,
/// C     or hp and hn for hA collisions. In JETINI we use the following
/// C     catalogue for different types of collisions:
/// C     h+h: h+h (itype=1)
/// C     h+A: h+p (itype=1), h+n (itype=2)
/// C     A+h: p+h (itype=1), n+h (itype=2)
/// C     A+A: p+p (itype=1), p+n (itype=2), n+p (itype=3), n+n (itype=4)
/// C*****************************************************************
/// C
/// C     Version 1.34
/// C     Last modification on January 5, 1998. Two mistakes are corrected in
/// C     function G. A Mistake in the subroutine Parton is also corrected.
/// C     (These are pointed out by Ysushi Nara).
/// C
/// C       Last modifcation on April 10, 1996. To conduct final
/// C       state radiation, PYTHIA reorganize the two scattered
/// C       partons and their final momenta will be a little
/// C       different. The summed total momenta of the partons
/// C       from the final state radiation are stored in HINT1(26-29)
/// C       and HINT1(36-39) which are little different from
/// C       HINT1(21-24) and HINT1(41-44).
/// C
/// C       Version 1.33
/// C
/// C       Last modfication  on September 11, 1995. When HIJING and
/// C       PYTHIA are initialized, the shadowing is evaluated at
/// C       b=0 which is the maximum. This will cause overestimate
/// C       of shadowing for peripheral interactions. To correct this
/// C       problem, shadowing is set to zero when initializing. Then
/// C       use these maximum  cross section without shadowing as a
/// C       normalization of the Monte Carlo. This however increase
/// C       the computing time. IHNT2(16) is used to indicate whether
/// C       the sturcture function is called for (IHNT2(16)=1) initialization
/// C       or for (IHNT2(16)=0)normal collisions simulation
/// C
/// C       Last modification on Aagust 28, 1994. Two bugs associate
/// C       with the impact parameter dependence of the shadowing is
/// C       corrected.
/// C
/// C       Last modification on October 14, 1994. One bug is corrected
/// C       in the direct photon production option in subroutine
/// C       HIJHRD.( this problem was reported by Jim Carroll and Mike Beddo).
/// C       Another bug associated with keeping the decay history
/// C       in the particle information is also corrected.(this problem
/// C       was reported by Matt Bloomer)
/// C
/// C       Last modification on July 15, 1994. The option to trig on
/// C       heavy quark production (charm IHPR2(18)=0 or beauty IHPR2(18)=1)
/// C       is added. To do this, set IHPR2(3)=3. For inclusive production,
/// C       one should reset HIPR1(10)=0.0. One can also trig larger pt
/// C       QQbar production by giving HIPR1(10) a nonvanishing value.
/// C       The mass of the heavy quark in the calculation of the cross
/// C       section (HINT1(59)--HINT1(65)) is given by HIPR1(7) (the
/// C       default is the charm mass D=1.5). We also include a separate
/// C       K-factor for heavy quark and direct photon production by
/// C       HIPR1(23)(D=2.0).
/// C
/// C       Last modification on May 24, 1994.  The option to
/// C       retain the information of all particles including those
/// C       who have decayed is IHPR(21)=1 (default=0). KATT(I,3) is
/// C       added to contain the line number of the parent particle
/// C       of the current line which is produced via a decay.
/// C       KATT(I,4) is the status number of the particle: 11=particle
/// C       which has decayed; 1=finally produced particle.
/// C
/// C       Last modification on May 24, 1994( in HIJSFT when valence quark
/// C       is quenched, the following error is corrected. 1.2*IHNT2(1) -->
/// C       1.2*IHNT2(1)**0.333333, 1.2*IHNT2(3) -->1.2*IHNT(3)**0.333333)
/// C
/// C       Last modification on March 16, 1994 (heavy flavor production
/// C       processes MSUB(81)=1 MSUB(82)=1 have been switched on,
/// C       charm production is the default, B-quark option is
/// C       IHPR2(18), when it is switched on, charm quark is
/// C       automatically off)
/// C
/// C       Last modification on March 23, 1994 (an error is corrected
/// C       in the impact parameter dependence of the jet cross section)
/// C
/// C       Last modification Oct. 1993 to comply with non-vax
/// C       machines' compiler
/// C
/// C*********************************************
/// C        LAST MODIFICATION April 5, 1991
/// CQUARK DISTRIBUTIOIN (1-X)**A/(X**2+C**2/S)**B
/// C(A=HIPR1(44),B=HIPR1(46),C=HIPR1(45))
/// C STRING FLIP, VENUS OPTION IHPR2(15)=1,IN WHICH ONE CAN HAVE ONE AND
/// C TWO COLOR CHANGES, (1-W)**2,W*(1-W),W*(1-W),AND W*2, W=HIPR1(18),
/// C AMONG PT DISTRIBUTION OF SEA QUARKS IS CONTROLLED BY HIPR1(42)
/// C
/// C        gluon jets can form a single string system
/// C
/// C        initial state radiation is included
/// C
/// C        all QCD subprocesses are included
/// C
/// C        direct particles production is included(currently only direct
/// C                photon)
/// C
/// C        Effect of high P_T trigger bias on multiple jets distribution
/// C
/// C******************************************************************
/// C                                HIJING.10                         *
/// C                  Heavy Ion Jet INteraction Generator             *
/// C                                   by                             *
/// C                   X. N. Wang      and   M. Gyulassy              *
/// C                      Lawrence Berkeley Laboratory                *
/// C                                                                  *
/// C******************************************************************
/// C
/// C******************************************************************
/// C NFP(K,1),NFP(K,2)=flavor of q and di-q, NFP(K,3)=present ID of  *
/// C proj, NFP(K,4) original ID of proj.  NFP(K,5)=colli status(0=no,*
/// C 1=elastic,2=the diffrac one in single-diffrac,3= excited string.*
/// C |NFP(K,6)| is the total # of jet production, if NFP(K,6)<0 it   *
/// C can not produce jet anymore. NFP(K,10)=valence quarks scattering*
/// C (0=has not been,1=is going to be, -1=has already been scattered *
/// C NFP(k,11) total number of interactions this proj has suffered   *
/// C PP(K,1)=PX,PP(K,2)=PY,PP(K,3)=PZ,PP(K,4)=E,PP(K,5)=M(invariant  *
/// C mass), PP(K,6,7),PP(K,8,9)=transverse momentum of quark and     *
/// C diquark,PP(K,10)=PT of the hard scattering between the valence  *
/// C quarks; PP(K,14,15)=the mass of quark,diquark.                   *
/// C******************************************************************
/// C
/// C****************************************************************
/// C
/// C        SUBROUTINE HIJING
/// C
/// C****************************************************************
void hijing(common& cmn, str_cref frame, float const& bmin0,
            float const& bmax0) {
  FEM_CMN_SVE(hijing);
  common_write write(cmn);
  arr_ref<float> hipr1(cmn.hipr1, dimension(100));
  arr_ref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  arr_ref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_ref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_ref<float, 2> yt(cmn.yt, dimension(3, 300));
  int& nelt = cmn.nelt;
  int& ninthj = cmn.ninthj;
  int& nelp = cmn.nelp;
  int& ninp = cmn.ninp;
  float& eatt = cmn.eatt;
  int& jatt = cmn.jatt;
  int& natt = cmn.natt;
  int& nt = cmn.nt;
  int& np = static_cast<common_hmain1&>(cmn).np;
  int& n0 = cmn.n0;
  int& n01 = cmn.n01;
  int& n10 = cmn.n10;
  int& n11 = cmn.n11;
  const int maxstr = 150001;
  arr_ref<int, 2> katt(cmn.katt, dimension(maxstr, 4));
  arr_ref<float, 2> patt(cmn.patt, dimension(maxstr, 4));
  arr_ref<int> npj(cmn.npj, dimension(300));
  arr_ref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_ref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_ref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_ref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_ref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_ref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_ref<int> ntj(cmn.ntj, dimension(300));
  arr_ref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_ref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_ref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_ref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_ref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_ref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  int& nsg = cmn.nsg;
  arr_ref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_ref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_ref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_ref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_ref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_ref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_ref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_ref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  int& ndr = cmn.ndr;
  arr_cref<int> kfdr(cmn.kfdr, dimension(maxstr));
  arr_cref<float, 2> pdr(cmn.pdr, dimension(maxstr, 5));
  arr_cref<float, 2> rtdr(cmn.rtdr, dimension(maxstr, 2));
  int& nseed = cmn.nseed;
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_cref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_ref<int> itypar(cmn.itypar, dimension(maxstr));
  arr_ref<float> gxar(cmn.gxar, dimension(maxstr));
  arr_ref<float> gyar(cmn.gyar, dimension(maxstr));
  arr_ref<float> gzar(cmn.gzar, dimension(maxstr));
  arr_ref<float> ftar(cmn.ftar, dimension(maxstr));
  arr_ref<float> pxar(cmn.pxar, dimension(maxstr));
  arr_ref<float> pyar(cmn.pyar, dimension(maxstr));
  arr_ref<float> pzar(cmn.pzar, dimension(maxstr));
  arr_ref<float> pear(cmn.pear, dimension(maxstr));
  arr_ref<float> xmar(cmn.xmar, dimension(maxstr));
  int& mul = cmn.mul;
  const int maxptn = 400001;
  arr_ref<double> gx0(cmn.gx0, dimension(maxptn));
  arr_ref<double> gy0(cmn.gy0, dimension(maxptn));
  arr_ref<double> gz0(cmn.gz0, dimension(maxptn));
  arr_ref<double> ft0(cmn.ft0, dimension(maxptn));
  arr_ref<double> px0(cmn.px0, dimension(maxptn));
  arr_ref<double> py0(cmn.py0, dimension(maxptn));
  arr_ref<double> pz0(cmn.pz0, dimension(maxptn));
  arr_ref<double> e0(cmn.e0, dimension(maxptn));
  arr_ref<double> xmass0(cmn.xmass0, dimension(maxptn));
  arr_ref<int> ityp0(cmn.ityp0, dimension(maxptn));
  arr_ref<int> lstrg0(cmn.lstrg0, dimension(maxptn));
  arr_ref<int> lpart0(cmn.lpart0, dimension(maxptn));
  arr_cref<int> lstrg1(cmn.lstrg1, dimension(maxptn));
  arr_cref<int> lpart1(cmn.lpart1, dimension(maxptn));
  int& nsp = cmn.nsp;
  int& nst = cmn.nst;
  int& nsi = cmn.nsi;
  arr_cref<double> ataui(cmn.ataui, dimension(maxstr));
  arr_cref<double> zt1(cmn.zt1, dimension(maxstr));
  arr_cref<double> zt2(cmn.zt2, dimension(maxstr));
  arr_cref<double> zt3(cmn.zt3, dimension(maxstr));
  int& isoft = cmn.isoft;
  int& isflag = cmn.isflag;
  arr_ref<double, 2> pxsgs(cmn.pxsgs, dimension(maxstr, 3));
  arr_ref<double, 2> pysgs(cmn.pysgs, dimension(maxstr, 3));
  arr_ref<double, 2> pzsgs(cmn.pzsgs, dimension(maxstr, 3));
  arr_ref<double, 2> pesgs(cmn.pesgs, dimension(maxstr, 3));
  arr_ref<double, 2> pmsgs(cmn.pmsgs, dimension(maxstr, 3));
  arr_ref<double, 2> gxsgs(cmn.gxsgs, dimension(maxstr, 3));
  arr_ref<double, 2> gysgs(cmn.gysgs, dimension(maxstr, 3));
  arr_ref<double, 2> gzsgs(cmn.gzsgs, dimension(maxstr, 3));
  arr_ref<double, 2> ftsgs(cmn.ftsgs, dimension(maxstr, 3));
  arr_ref<int, 2> k1sgs(cmn.k1sgs, dimension(maxstr, 3));
  arr_ref<int, 2> k2sgs(cmn.k2sgs, dimension(maxstr, 3));
  const int maxidl = 4001;
  arr_cref<int> itypn(cmn.itypn, dimension(maxidl));
  arr_cref<float> gxn(cmn.gxn, dimension(maxidl));
  arr_cref<float> gyn(cmn.gyn, dimension(maxidl));
  arr_cref<float> gzn(cmn.gzn, dimension(maxidl));
  arr_cref<float> ftn(cmn.ftn, dimension(maxidl));
  arr_cref<float> pxn(cmn.pxn, dimension(maxidl));
  arr_cref<float> pyn(cmn.pyn, dimension(maxidl));
  arr_cref<float> pzn(cmn.pzn, dimension(maxidl));
  arr_cref<float> een(cmn.een, dimension(maxidl));
  arr_cref<float> xmn(cmn.xmn, dimension(maxidl));
  float& bimp = cmn.bimp;
  int& iaevt = cmn.iaevt;
  int& miss = cmn.miss;
  int& ioscar = cmn.ioscar;
  float& phirp = cmn.phirp;
  arr_ref<double> xstrg0(cmn.xstrg0, dimension(maxptn));
  arr_ref<double> ystrg0(cmn.ystrg0, dimension(maxptn));
  arr_ref<int> istrg0(cmn.istrg0, dimension(maxptn));
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
  float& aphx1 = sve.aphx1;
  float& aphx2 = sve.aphx2;
  float& b2 = sve.b2;
  float& bb = sve.bb;
  float& bbx = sve.bbx;
  float& bby = sve.bby;
  float& bmax = sve.bmax;
  float& bmin = sve.bmin;
  float& cx = sve.cx;
  float& dengy = sve.dengy;
  float& dnbp = sve.dnbp;
  float& dnbp1 = sve.dnbp1;
  float& dnbp2 = sve.dnbp2;
  float& dnbp3 = sve.dnbp3;
  float& dnbt = sve.dnbt;
  float& dnbt1 = sve.dnbt1;
  float& dnbt2 = sve.dnbt2;
  float& dnbt3 = sve.dnbt3;
  float& gs = sve.gs;
  float& gstot = sve.gstot;
  float& gstot0 = sve.gstot0;
  int& i = sve.i;
  int& i05 = sve.i05;
  int& idstr = sve.idstr;
  int& ierror = sve.ierror;
  int& ii = sve.ii;
  int& iityp = sve.iityp;
  arr_ref<int> ipcol(sve.ipcol, dimension(90000));
  int& isg = sve.isg;
  int& istr = sve.istr;
  arr_ref<int> itcol(sve.itcol, dimension(90000));
  int& itest = sve.itest;
  int& j = sve.j;
  int& jflg = sve.jflg;
  int& jjtp = sve.jjtp;
  int& jout = sve.jout;
  int& jp = sve.jp;
  int& jphard = sve.jphard;
  int& jpmini = sve.jpmini;
  int& jt = sve.jt;
  int& jthard = sve.jthard;
  int& jtmini = sve.jtmini;
  arr_ref<int> jtp(sve.jtp, dimension(3));
  int& kp = sve.kp;
  int& kp2 = sve.kp2;
  int& kt = sve.kt;
  int& kt2 = sve.kt2;
  int& lsg = sve.lsg;
  int& ncolt = sve.ncolt;
  int& nftp = sve.nftp;
  int& nhard = sve.nhard;
  int& njet = sve.njet;
  int& nlop = sve.nlop;
  int& nmini = sve.nmini;
  int& nmom = sve.nmom;
  int& npar = sve.npar;
  int& npart = sve.npart;
  int& nsbst = sve.nsbst;
  int& nsbstr = sve.nsbstr;
  int& nstrg = sve.nstrg;
  int& ntp = sve.ntp;
  float& phi = sve.phi;
  float& r = sve.r;
  float& r2 = sve.r2;
  float& rantot = sve.rantot;
  float& rnd1 = sve.rnd1;
  float& rnd2 = sve.rnd2;
  float& rnd3 = sve.rnd3;
  arr_ref<float, 2> rnip(sve.rnip, dimension(300, 300));
  float& rrb1 = sve.rrb1;
  float& rrb2 = sve.rrb2;
  arr_ref<float, 2> scip(sve.scip, dimension(300, 300));
  arr_ref<float, 2> sjip(sve.sjip, dimension(300, 300));
  float& sx = sve.sx;
  float& tt = sve.tt;
  float& ttrig = sve.ttrig;
  float& tts = sve.tts;
  float& x = sve.x;
  float& xr = sve.xr;
  float& xr1 = sve.xr1;
  float& y1 = sve.y1;
  float& y2 = sve.y2;
  float& y3 = sve.y3;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
    {
      mbr<double> gx5(dimension(maxptn));
      mbr<double> gy5(dimension(maxptn));
      mbr<double> gz5(dimension(maxptn));
      mbr<double> ft5(dimension(maxptn));
      mbr<double> px5(dimension(maxptn));
      mbr<double> py5(dimension(maxptn));
      mbr<double> pz5(dimension(maxptn));
      mbr<double> e5(dimension(maxptn));
      mbr<double> xmass5(dimension(maxptn));
      mbr<int> ityp5(dimension(maxptn));
      prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5, ityp5;
    }
  }
  arr_ref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_ref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  arr_cref<double> gx5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gy5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> gz5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> px5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> py5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> pz5(prec2.bind<double>(), dimension(maxptn));
  arr_ref<double> e5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<double> xmass5(prec2.bind<double>(), dimension(maxptn));
  arr_cref<int> ityp5(prec2.bind<int>(), dimension(maxptn));
  static const char* format_210 = "(i6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))";
  static const char* format_211 = "(i6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))";
  static const char* format_243 = "(f10.3,1x,f10.3,2(1x,i5),1x,f10.3,2(1x,i5))";
  static const char* format_395 = "(3i8,f10.4,4i5)";
  /// C
  /// Cbz1/25/99
  /// Clin-4/20/01        PARAMETER (MAXSTR = 1600)
  /// Cbz1/25/99end
  /// Clin-4/26/01:
  /// C
  /// Cbz1/31/99
  /// Clin-8/2015:
  /// C
  /// Cbz1/31/99end
  /// C
  /// Cc      SAVE /HPARNT/
  /// C
  /// Cc      SAVE /hjcrdn/
  /// Clin-7/16/03 NINT is a intrinsic fortran function, rename it to NINTHJ
  /// C        COMMON/HJGLBR/NELT,NINT,NELP,NINP
  /// Cc      SAVE /HJGLBR/
  /// Cc      SAVE /HMAIN1/
  /// Clin-4/26/01
  /// C        COMMON/HMAIN2/KATT(130000,4),PATT(130000,4)
  /// Cc      SAVE /HMAIN2/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /HJJET1/
  /// Clin-4/2008
  /// C        COMMON/HJJET2/NSG,NJSG(900),IASG(900,3),K1SG(900,100),
  /// C     &       K2SG(900,100),PXSG(900,100),PYSG(900,100),
  /// C     &       PZSG(900,100),PESG(900,100),PMSG(900,100)
  /// Cc      SAVE /HJJET2/
  /// Clin-4/2008:
  /// C        common/xydr/rtdr(900,2)
  /// Cc      SAVE /HJJET4/
  /// Cc      SAVE /RNDF77/
  /// C
  /// Cc      SAVE /LUJETS/
  /// Cc      SAVE /LUDAT1/
  /// C
  /// Clin-9/29/03 changed name in order to distinguish from /prec2/
  /// Ccbz11/11/98
  /// C        COMMON /ARPRC/ ITYP(MAXSTR),
  /// C     &     GX(MAXSTR), GY(MAXSTR), GZ(MAXSTR), FT(MAXSTR),
  /// C     &     PX(MAXSTR), PY(MAXSTR), PZ(MAXSTR), EE(MAXSTR),
  /// C     &     XM(MAXSTR)
  /// Cc      SAVE /ARPRC/
  /// Ccbz11/11/98end
  /// C
  /// Cbz1/25/99
  /// Cc      SAVE /PARA1/
  /// Cc      SAVE /prec1/
  /// Cc      SAVE /prec2/
  /// Cc      SAVE /ilist7/
  /// Cc      SAVE /ilist8/
  /// Cc      SAVE /SREC1/
  /// Cc      SAVE /SREC2/
  /// Cbz1/25/99end
  /// C
  /// Clin-2/25/00
  /// Cc      SAVE /frzout/
  /// Clin-4/11/01 soft:
  /// Cc      SAVE /anim/
  /// Clin-4/25/01 soft3:
  /// Cc      SAVE /SOFT/
  /// Clin-4/26/01 lepton and photon info:
  /// Cc      SAVE /NOPREC/
  /// Clin-6/22/01:
  /// Cc      SAVE /lastt/
  /// Clin-7/2011 ioscar value is needed:
  /// Clin-2/2012 allow random orientation of reaction plane:
  /// Clin-8/2015:
  /// C
  bmax = fem::min(bmax0, hipr1(34) + hipr1(35));
  bmin = fem::min(bmin0, bmax);
  if (ihnt2(1) <= 1 && ihnt2(3) <= 1) {
    bmin = 0.0f;
    bmax = 2.5f * fem::sqrt(hipr1(31) * 0.1f / hipr1(40));
  }
  /// C                        ********HIPR1(31) is in mb =0.1fm**2
  /// C*******THE FOLLOWING IS TO SELECT THE COORDINATIONS OF NUCLEONS
  /// C       BOTH IN PROJECTILE AND TARGET NUCLEAR( in fm)
  /// C
  yp(1, 1) = 0.0f;
  yp(2, 1) = 0.0f;
  yp(3, 1) = 0.0f;
  if (ihnt2(1) <= 1) {
    goto statement_14;
  }
  FEM_DO_SAFE(kp, 1, ihnt2(1)) {
  statement_5:
    r = hirnd(cmn, 1);
    x = ranart(nseed);
    cx = 2.0f * x - 1.0f;
    sx = fem::sqrt(1.0f - cx * cx);
    /// C                ********choose theta from uniform cos(theta) distr
    phi = ranart(nseed) * 2.0f * hipr1(40);
    /// C                ********choose phi form uniform phi distr 0 to 2*pi
    yp(1, kp) = r * sx * fem::cos(phi);
    yp(2, kp) = r * sx * fem::sin(phi);
    yp(3, kp) = r * cx;
    if (hipr1(29) == 0.0f) {
      goto statement_10;
    }
    FEM_DO_SAFE(kp2, 1, kp - 1) {
      dnbp1 = fem::pow2((yp(1, kp) - yp(1, kp2)));
      dnbp2 = fem::pow2((yp(2, kp) - yp(2, kp2)));
      dnbp3 = fem::pow2((yp(3, kp) - yp(3, kp2)));
      dnbp = dnbp1 + dnbp2 + dnbp3;
      if (dnbp < hipr1(29) * hipr1(29)) {
        goto statement_5;
      }
      /// C                        ********two neighbors cannot be closer than
      /// C                                HIPR1(29)
    }
  statement_10:;
  }
  /// C
  /// Clin-1/27/03 Hulthen wavefn for deuteron borrowed from hijing1.382.f,
  /// C     but modified [divide by 2, & x(p)=-x(n)]:
  /// C     (Note: hijing1.383.f has corrected this bug in hijing1.382.f)
  if (ihnt2(1) == 2) {
    rnd1 = fem::max(ranart(nseed), 1.0e-20f);
    rnd2 = fem::max(ranart(nseed), 1.0e-20f);
    rnd3 = fem::max(ranart(nseed), 1.0e-20f);
    r = -(fem::log(rnd1) * 4.38f / 2.0f + fem::log(rnd2) * 0.85f / 2.0f +
          4.38f * 0.85f * fem::log(rnd3) / (4.38f + 0.85f));
    x = ranart(nseed);
    cx = 2.0f * x - 1.0f;
    sx = fem::sqrt(1.0f - cx * cx);
    phi = ranart(nseed) * 2.0f * hipr1(40);
    /// C     R above is the relative distance between p & n in a deuteron:
    r = r / 2.f;
    yp(1, 1) = r * sx * fem::cos(phi);
    yp(2, 1) = r * sx * fem::sin(phi);
    yp(3, 1) = r * cx;
    /// C     p & n has opposite coordinates in the deuteron frame:
    yp(1, 2) = -yp(1, 1);
    yp(2, 2) = -yp(2, 1);
    yp(3, 2) = -yp(3, 1);
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(1) - 1) {
    FEM_DO_SAFE(j, i + 1, ihnt2(1)) {
      if (yp(3, i) > yp(3, j)) {
        goto statement_12;
      }
      y1 = yp(1, i);
      y2 = yp(2, i);
      y3 = yp(3, i);
      yp(1, i) = yp(1, j);
      yp(2, i) = yp(2, j);
      yp(3, i) = yp(3, j);
      yp(1, j) = y1;
      yp(2, j) = y2;
      yp(3, j) = y3;
    statement_12:;
    }
  }
/// C
/// C******************************
statement_14:
  yt(1, 1) = 0.0f;
  yt(2, 1) = 0.0f;
  yt(3, 1) = 0.0f;
  if (ihnt2(3) <= 1) {
    goto statement_24;
  }
  FEM_DO_SAFE(kt, 1, ihnt2(3)) {
  statement_15:
    r = hirnd(cmn, 2);
    x = ranart(nseed);
    cx = 2.0f * x - 1.0f;
    sx = fem::sqrt(1.0f - cx * cx);
    /// C                ********choose theta from uniform cos(theta) distr
    phi = ranart(nseed) * 2.0f * hipr1(40);
    /// C                ********chose phi form uniform phi distr 0 to 2*pi
    yt(1, kt) = r * sx * fem::cos(phi);
    yt(2, kt) = r * sx * fem::sin(phi);
    yt(3, kt) = r * cx;
    if (hipr1(29) == 0.0f) {
      goto statement_20;
    }
    FEM_DO_SAFE(kt2, 1, kt - 1) {
      dnbt1 = fem::pow2((yt(1, kt) - yt(1, kt2)));
      dnbt2 = fem::pow2((yt(2, kt) - yt(2, kt2)));
      dnbt3 = fem::pow2((yt(3, kt) - yt(3, kt2)));
      dnbt = dnbt1 + dnbt2 + dnbt3;
      if (dnbt < hipr1(29) * hipr1(29)) {
        goto statement_15;
      }
      /// C                        ********two neighbors cannot be closer than
      /// C                                HIPR1(29)
    }
  statement_20:;
  }
  /// C
  /// Clin-1/27/03 Hulthen wavefn for deuteron borrowed from hijing1.382.f,
  /// C     but modified [divide by 2, & x(p)=-x(n)]:
  if (ihnt2(3) == 2) {
    rnd1 = fem::max(ranart(nseed), 1.0e-20f);
    rnd2 = fem::max(ranart(nseed), 1.0e-20f);
    rnd3 = fem::max(ranart(nseed), 1.0e-20f);
    r = -(fem::log(rnd1) * 4.38f / 2.0f + fem::log(rnd2) * 0.85f / 2.0f +
          4.38f * 0.85f * fem::log(rnd3) / (4.38f + 0.85f));
    x = ranart(nseed);
    cx = 2.0f * x - 1.0f;
    sx = fem::sqrt(1.0f - cx * cx);
    phi = ranart(nseed) * 2.0f * hipr1(40);
    r = r / 2.f;
    yt(1, 1) = r * sx * fem::cos(phi);
    yt(2, 1) = r * sx * fem::sin(phi);
    yt(3, 1) = r * cx;
    yt(1, 2) = -yt(1, 1);
    yt(2, 2) = -yt(2, 1);
    yt(3, 2) = -yt(3, 1);
  }
  /// C
  FEM_DO_SAFE(i, 1, ihnt2(3) - 1) {
    FEM_DO_SAFE(j, i + 1, ihnt2(3)) {
      if (yt(3, i) < yt(3, j)) {
        goto statement_22;
      }
      y1 = yt(1, i);
      y2 = yt(2, i);
      y3 = yt(3, i);
      yt(1, i) = yt(1, j);
      yt(2, i) = yt(2, j);
      yt(3, i) = yt(3, j);
      yt(1, j) = y1;
      yt(2, j) = y2;
      yt(3, j) = y3;
    statement_22:;
    }
  }
/// C
/// C********************
statement_24:
  miss = -1;
statement_50:
  miss++;
  /// C
  /// Clin-6/2009
  /// C        IF(MISS.GT.50) THEN
  if (miss > cmn.maxmiss) {
    write(6, star), "infinite loop happened in  HIJING";
    FEM_STOP(0);
  }
  /// C
  /// Clin-4/30/01:
  itest = 0;
  /// C
  natt = 0;
  jatt = 0;
  eatt = 0.0f;
  hijini(cmn);
  nlop = 0;
/// C                        ********Initialize for a new event
statement_60:
  nt = 0;
  np = 0;
  n0 = 0;
  n01 = 0;
  n10 = 0;
  n11 = 0;
  nelt = 0;
  ninthj = 0;
  nelp = 0;
  ninp = 0;
  nsg = 0;
  ncolt = 0;
  /// C
  /// C****        BB IS THE ABSOLUTE VALUE OF IMPACT PARAMETER,BB**2 IS
  /// C       RANDOMLY GENERATED AND ITS ORIENTATION IS RANDOMLY SET
  /// C       BY THE ANGLE PHI  FOR EACH COLLISION.******************
  /// C
  bb = fem::sqrt(fem::pow2(bmin) +
                 ranart(nseed) * (fem::pow2(bmax) - fem::pow2(bmin)));
  /// Cbz6/28/99 flow1
  /// Clin-2/2012:
  phi = 0.f;
  if (cmn.iphirp == 1) {
    phi = 2.0f * hipr1(40) * ranart(nseed);
  }
  phirp = phi;
  /// Cbz6/28/99 flow1 end
  bbx = bb * fem::cos(phi);
  bby = bb * fem::sin(phi);
  hint1(19) = bb;
  hint1(20) = phi;
  /// C
  FEM_DO_SAFE(jp, 1, ihnt2(1)) {
    FEM_DO_SAFE(jt, 1, ihnt2(3)) {
      scip(jp, jt) = -1.0f;
      b2 = fem::pow2((yp(1, jp) + bbx - yt(1, jt))) +
           fem::pow2((yp(2, jp) + bby - yt(2, jt)));
      r2 = b2 * hipr1(40) / hipr1(31) / 0.1f;
      /// C                ********mb=0.1*fm, YP is in fm,HIPR1(31) is in mb
      rrb1 = fem::min((fem::pow2(yp(1, jp)) + fem::pow2(yp(2, jp))) /
                          fem::pow2(1.2f) /
                          fem::pow(fem::real(ihnt2(1)), 0.6666667f),
                      1.0f);
      rrb2 = fem::min((fem::pow2(yt(1, jt)) + fem::pow2(yt(2, jt))) /
                          fem::pow2(1.2f) /
                          fem::pow(fem::real(ihnt2(3)), 0.6666667f),
                      1.0f);
      aphx1 = hipr1(6) * 4.0f / 3.0f * (fem::pow(ihnt2(1), 0.3333333f) - 1.0f) *
              fem::sqrt(1.0f - rrb1);
      aphx2 = hipr1(6) * 4.0f / 3.0f * (fem::pow(ihnt2(3), 0.3333333f) - 1.0f) *
              fem::sqrt(1.0f - rrb2);
      hint1(18) = hint1(14) - aphx1 * hint1(15) - aphx2 * hint1(16) +
                  aphx1 * aphx2 * hint1(17);
      if (ihpr2(14) == 0 || (ihnt2(1) == 1 && ihnt2(3) == 1)) {
        gs = 1.0f -
             fem::exp(-(hipr1(30) + hint1(18)) * romg(cmn, r2) / hipr1(31));
        rantot = ranart(nseed);
        if (rantot > gs) {
          goto statement_70;
        }
        goto statement_65;
      }
      gstot0 = 2.0f * (1.0f - fem::exp(-(hipr1(30) + hint1(18)) / hipr1(31) /
                                       2.0f * romg(cmn, 0.0f)));
      r2 = r2 / gstot0;
      gs =
          1.0f - fem::exp(-(hipr1(30) + hint1(18)) / hipr1(31) * romg(cmn, r2));
      gstot = 2.0f * (1.0f - fem::sqrt(1.0f - gs));
      rantot = ranart(nseed) * gstot0;
      if (rantot > gstot) {
        goto statement_70;
      }
      if (rantot > gs) {
        hijcsc(cmn, jp, jt);
        goto statement_70;
        /// C                        ********perform elastic collisions
      }
    statement_65:
      scip(jp, jt) = r2;
      rnip(jp, jt) = rantot;
      sjip(jp, jt) = hint1(18);
      ncolt++;
      ipcol(ncolt) = jp;
      itcol(ncolt) = jt;
    statement_70:;
    }
  }
  /// C                ********total number interactions proj and targ has
  /// C                                suffered
  /// C
  /// Clin-5/22/01 write impact parameter:
  bimp = bb;
  write(6, star), "#impact parameter,nlop,ncolt=", bimp, nlop, ncolt;
  /// C
  if (ncolt == 0) {
    nlop++;
    if (nlop <= 20 || (ihnt2(1) == 1 && ihnt2(3) == 1)) {
      goto statement_60;
    }
    return;
  }
  /// C               ********At large impact parameter, there maybe no
  /// C                       interaction at all. For NN collision
  /// C                       repeat the event until interaction happens
  /// C
  if (ihpr2(3) != 0) {
    nhard = 1 + fem::fint(ranart(nseed) * (ncolt - 1) + 0.5f);
    nhard = fem::min(nhard, ncolt);
    jphard = ipcol(nhard);
    jthard = itcol(nhard);
    /// Clin-6/2009 ctest off:
    /// C           write(99,*) IAEVT,NHARD,NCOLT,JPHARD,JTHARD
  }
  /// C
  if (ihpr2(9) == 1) {
    nmini = 1 + fem::fint(ranart(nseed) * (ncolt - 1) + 0.5f);
    nmini = fem::min(nmini, ncolt);
    jpmini = ipcol(nmini);
    jtmini = itcol(nmini);
  }
  /// C                ********Specifying the location of the hard and
  /// C                        minijet if they are enforced by user
  /// C
  FEM_DO_SAFE(jp, 1, ihnt2(1)) {
    FEM_DO_SAFE(jt, 1, ihnt2(3)) {
      if (scip(jp, jt) == -1.0f) {
        goto statement_200;
      }
      nfp(jp, 11)++;
      nft(jt, 11)++;
      if (nfp(jp, 5) <= 1 && nft(jt, 5) > 1) {
        np++;
        n01++;
      } else if (nfp(jp, 5) > 1 && nft(jt, 5) <= 1) {
        nt++;
        n10++;
      } else if (nfp(jp, 5) <= 1 && nft(jt, 5) <= 1) {
        np++;
        nt++;
        n0++;
      } else if (nfp(jp, 5) > 1 && nft(jt, 5) > 1) {
        n11++;
      }
      jout = 0;
      nfp(jp, 10) = 0;
      nft(jt, 10) = 0;
      /// C*****************************************************************
      if (ihpr2(8) == 0 && ihpr2(3) == 0) {
        goto statement_160;
      }
      /// C                ********When IHPR2(8)=0 no jets are produced
      if (nfp(jp, 6) < 0 || nft(jt, 6) < 0) {
        goto statement_160;
      }
      /// C                ********jets can not be produced for (JP,JT)
      /// C                        because not enough energy avaible for
      /// C                                JP or JT
      r2 = scip(jp, jt);
      hint1(18) = sjip(jp, jt);
      tt = romg(cmn, r2) * hint1(18) / hipr1(31);
      tts = hipr1(30) * romg(cmn, r2) / hipr1(31);
      njet = 0;
      /// C
      if (ihpr2(3) != 0 && jp == jphard && jt == jthard) {
        jetini(cmn, jp, jt, 1);
        hijhrd(cmn, jp, jt, 0, jflg, 0);
        hint1(26) = hint1(47);
        hint1(27) = hint1(48);
        hint1(28) = hint1(49);
        hint1(29) = hint1(50);
        hint1(36) = hint1(67);
        hint1(37) = hint1(68);
        hint1(38) = hint1(69);
        hint1(39) = hint1(70);
        /// C
        if (fem::abs(hint1(46)) > hipr1(11) && jflg == 2) {
          nfp(jp, 7) = 1;
        }
        if (fem::abs(hint1(56)) > hipr1(11) && jflg == 2) {
          nft(jt, 7) = 1;
        }
        if (fem::max(fem::abs(hint1(46)), fem::abs(hint1(56))) > hipr1(11) &&
            jflg >= 3) {
          iasg(nsg, 3) = 1;
        }
        ihnt2(9) = ihnt2(14);
        ihnt2(10) = ihnt2(15);
        FEM_DO_SAFE(i05, 1, 5) {
          hint1(20 + i05) = hint1(40 + i05);
          hint1(30 + i05) = hint1(50 + i05);
        }
        /// Clin-6/2009 ctest off:
        /// C           write(99,*) jp,jt,IHPR2(3),HIPR1(10),njet,
        /// C     1          ihnt2(9),hint1(21),hint1(22),hint1(23),
        /// C     2          ihnt2(10),hint1(31),hint1(32),hint1(33)
        /// C           write(99,*) ' '
        jout = 1;
        if (ihpr2(8) == 0) {
          goto statement_160;
        }
        rrb1 = fem::min((fem::pow2(yp(1, jp)) + fem::pow2(yp(2, jp))) /
                            fem::pow2(1.2f) /
                            fem::pow(fem::real(ihnt2(1)), 0.6666667f),
                        1.0f);
        rrb2 = fem::min((fem::pow2(yt(1, jt)) + fem::pow2(yt(2, jt))) /
                            fem::pow2(1.2f) /
                            fem::pow(fem::real(ihnt2(3)), 0.6666667f),
                        1.0f);
        aphx1 = hipr1(6) * 4.0f / 3.0f *
                (fem::pow(ihnt2(1), 0.3333333f) - 1.0f) *
                fem::sqrt(1.0f - rrb1);
        aphx2 = hipr1(6) * 4.0f / 3.0f *
                (fem::pow(ihnt2(3), 0.3333333f) - 1.0f) *
                fem::sqrt(1.0f - rrb2);
        hint1(65) = hint1(61) - aphx1 * hint1(62) - aphx2 * hint1(63) +
                    aphx1 * aphx2 * hint1(64);
        ttrig = romg(cmn, r2) * hint1(65) / hipr1(31);
        njet = -1;
        /// C                ********subtract the trigger jet from total number
        /// C                        of jet production  to be done since it has
        /// C                                already been produced here
        xr1 = -fem::alog(fem::exp(-ttrig) +
                         ranart(nseed) * (1.0f - fem::exp(-ttrig)));
      statement_106:
        njet++;
        xr1 = xr1 - fem::alog(fem::max(ranart(nseed), 1.0e-20f));
        if (xr1 < ttrig) {
          goto statement_106;
        }
        xr = 0.0f;
      statement_107:
        njet++;
        xr = xr - fem::alog(fem::max(ranart(nseed), 1.0e-20f));
        if (xr < tt - ttrig) {
          goto statement_107;
        }
        njet = njet - 1;
        goto statement_112;
      }
      /// C                ********create a hard interaction with specified P_T
      /// C                                 when IHPR2(3)>0
      if (ihpr2(9) == 1 && jp == jpmini && jt == jtmini) {
        goto statement_110;
      }
      /// C                ********create at least one pair of mini jets
      /// C                        when IHPR2(9)=1
      /// C
      /// Clin-4/15/2010 changed .LT. to .LE. to avoid problem when two sides
      /// are equal; C     this problem may lead to a jet production when there
      /// should be none and C     crash the run; crashes at low energies were
      /// reported by P. Bhaduri. C        IF(IHPR2(8).GT.0
      /// .AND.RNIP(JP,JT).LT.EXP(-TT)* C     &                (1.0-EXP(-TTS)))
      /// GO TO 160
      if (ihpr2(8) > 0 &&
          rnip(jp, jt) <= fem::exp(-tt) * (1.0f - fem::exp(-tts))) {
        goto statement_160;
      }
    /// C
    /// C                ********this is the probability for no jet production
    statement_110:
      xr = -fem::alog(fem::exp(-tt) + ranart(nseed) * (1.0f - fem::exp(-tt)));
    statement_111:
      njet++;
      xr = xr - fem::alog(fem::max(ranart(nseed), 1.0e-20f));
      if (xr < tt) {
        goto statement_111;
      }
    statement_112:
      njet = fem::min(njet, ihpr2(8));
      if (ihpr2(8) < 0) {
        njet = fem::abs(ihpr2(8));
      }
      /// C                ******** Determine number of mini jet production
      /// C
      FEM_DO_SAFE(sve.ijet, 1, njet) {
        jetini(cmn, jp, jt, 0);
        hijhrd(cmn, jp, jt, jout, jflg, 1);
        /// C                ********JFLG=1 jets valence quarks, JFLG=2 with
        /// C                        gluon jet, JFLG=3 with q-qbar prod for
        /// C                        (JP,JT). If JFLG=0 jets can not be produced
        /// C                        this time. If JFLG=-1, error occured
        /// abandon C                        this event. JOUT is the total hard
        /// scat for C                        (JP,JT) up to now.
        if (jflg == 0) {
          goto statement_160;
        }
        if (jflg < 0) {
          if (ihpr2(10) != 0) {
            write(6, star), "error occured in HIJHRD";
          }
          goto statement_50;
        }
        jout++;
        if (fem::abs(hint1(46)) > hipr1(11) && jflg == 2) {
          nfp(jp, 7) = 1;
        }
        if (fem::abs(hint1(56)) > hipr1(11) && jflg == 2) {
          nft(jt, 7) = 1;
        }
        if (fem::max(fem::abs(hint1(46)), fem::abs(hint1(56))) > hipr1(11) &&
            jflg >= 3) {
          iasg(nsg, 3) = 1;
        }
        /// C                ******** jet with PT>HIPR1(11) will be quenched
      }
    statement_160:
      /// C
      hijsft(cmn, jp, jt, jout, ierror);
      if (ierror != 0) {
        if (ihpr2(10) != 0) {
          write(6, star), "error occured in HIJSFT";
        }
        goto statement_50;
      }
      /// C
      /// C                ********conduct soft scattering between JP and JT
      jatt += jout;
    statement_200:;
    }
  }
  /// C
  /// C**************************
  /// C
  /// Clin-6/2009 write out initial minijet information:
  /// Clin-2/2012:
  /// C           call minijet_out(BB)
  minijet_out(cmn, bb, phirp);
  if (cmn.pttrig > 0 && cmn.ntrig == 0) {
    goto statement_50;
  }
  /// Clin-4/2012
  /// Clin-6/2009 write out initial transverse positions of initial nucleons:
  /// C           write(94,*) IAEVT,MISS,IHNT2(1),IHNT2(3)
  FEM_DO_SAFE(jp, 1, ihnt2(1)) {
    /// Clin-6/2009:
    /// C           write(94,203) YP(1,JP)+0.5*BB, YP(2,JP), JP, NFP(JP,5)
    /// Clin-2/2012:
    /// C       write(94,203) YP(1,JP)+0.5*BB, YP(2,JP), JP, NFP(JP,5),yp(3,jp)
    /// Clin-4/2012:
    /// C           write(94,203) YP(1,JP)+0.5*BB*cos(phiRP),
    /// C     1 YP(2,JP)+0.5*BB*sin(phiRP), JP, NFP(JP,5),yp(3,jp)
    if (nfp(jp, 5) > 2) {
      ninp++;
    } else if (nfp(jp, 5) == 2 || nfp(jp, 5) == 1) {
      nelp++;
    }
  }
  FEM_DO_SAFE(jt, 1, ihnt2(3)) {
    /// Clin-6/2009 target nucleon # has a minus sign for distinction from
    /// projectile: C           write(94,203) YT(1,JT)-0.5*BB, YT(2,JT), -JT,
    /// NFT(JT,5) Clin-2/2012: C       write(94,203) YT(1,JT)-0.5*BB, YT(2,JT),
    /// -JT, NFT(JT,5),yt(3,jt) Clin-4/2012: C           write(94,203)
    /// YT(1,JT)-0.5*BB*cos(phiRP), C     1 YT(2,JT)-0.5*BB*sin(phiRP), -JT,
    /// NFT(JT,5),yt(3,jt)
    if (nft(jt, 5) > 2) {
      ninthj++;
    } else if (nft(jt, 5) == 2 || nft(jt, 5) == 1) {
      nelt++;
    }
  }
  /// C 203    format(f10.3,1x,f10.3,2(1x,I5))
  /// C 203    format(f10.3,1x,f10.3,2(1x,I5),1x,f10.3)
  /// C
  /// C*******************************
  /// C
  /// C********perform jet quenching for jets with PT>HIPR1(11)**********
  /// C
  if ((ihpr2(8) != 0 || ihpr2(3) != 0) && ihpr2(4) > 0 && ihnt2(1) > 1 &&
      ihnt2(3) > 1) {
    FEM_DO_SAFE(i, 1, ihnt2(1)) {
      if (nfp(i, 7) == 1) {
        quench(cmn, i, 1);
      }
    }
    FEM_DO_SAFE(i, 1, ihnt2(3)) {
      if (nft(i, 7) == 1) {
        quench(cmn, i, 2);
      }
    }
    FEM_DO_SAFE(isg, 1, nsg) {
      if (iasg(isg, 3) == 1) {
        quench(cmn, isg, 3);
      }
    }
  }
  /// C
  /// Clin*****4/09/01-soft1, default way of treating strings:
  if (isoft == 1) {
    /// Clin-4/16/01 allow fragmentation:
    isflag = 1;
    /// C
    /// Cbz1/25/99
    /// C.....transfer data from HIJING to ZPC
    nsp = ihnt2(1);
    nst = ihnt2(3);
    nsi = nsg;
    istr = 0;
    npar = 0;
    FEM_DO_SAFE(i, 1, ihnt2(1)) {
      istr++;
      FEM_DO_SAFE(j, 1, npj(i)) {
        /// Cbz1/27/99
        /// C.....for now only consider gluon cascade
        if (kfpj(i, j) == 21) {
          /// Cbz1/27/99end
          /// C
          npar++;
          lstrg0(npar) = istr;
          lpart0(npar) = j;
          ityp0(npar) = kfpj(i, j);
          /// Cbz6/28/99 flow1
          /// Clin-7/20/01 add dble or sngl to make precisions consistent
          /// C              GX0(NPAR) = YP(1, I)
          /// Clin-2/2012:
          /// C              GX0(NPAR) = dble(YP(1, I) + 0.5 * BB)
          gx0(npar) = fem::dble(yp(1, i) + 0.5f * bb * fem::cos(phirp));
          /// Cbz6/28/99 flow1 end
          /// C              GY0(NPAR) = dble(YP(2, I))
          gy0(npar) = fem::dble(yp(2, i) + 0.5f * bb * fem::sin(phirp));
          gz0(npar) = 0e0;
          ft0(npar) = 0e0;
          px0(npar) = fem::dble(pjpx(i, j));
          py0(npar) = fem::dble(pjpy(i, j));
          pz0(npar) = fem::dble(pjpz(i, j));
          xmass0(npar) = fem::dble(pjpm(i, j));
          /// C              E0(NPAR) = dble(PJPE(I, J))
          e0(npar) = fem::dsqrt(fem::pow2(px0(npar)) + fem::pow2(py0(npar)) +
                                fem::pow2(pz0(npar)) + fem::pow2(xmass0(npar)));
          /// Clin-7/20/01-end
          /// C
          /// Cbz1/27/99
          /// C.....end gluon selection
        }
        /// Cbz1/27/99end
      }
    }
    FEM_DO_SAFE(i, 1, ihnt2(3)) {
      istr++;
      FEM_DO_SAFE(j, 1, ntj(i)) {
        /// Cbz1/27/99
        /// C.....for now only consider gluon cascade
        if (kftj(i, j) == 21) {
          /// Cbz1/27/99end
          npar++;
          lstrg0(npar) = istr;
          lpart0(npar) = j;
          ityp0(npar) = kftj(i, j);
          /// Cbz6/28/99 flow1
          /// Clin-7/20/01 add dble or sngl to make precisions consistent
          /// C              GX0(NPAR) = YT(1, I)
          /// Clin-2/2012:
          /// C              GX0(NPAR) = dble(YT(1, I) - 0.5 * BB)
          gx0(npar) = fem::dble(yt(1, i) - 0.5f * bb * fem::cos(phirp));
          /// Cbz6/28/99 flow1 end
          /// C              GY0(NPAR) = dble(YT(2, I))
          gy0(npar) = fem::dble(yt(2, i) - 0.5f * bb * fem::sin(phirp));
          gz0(npar) = 0e0;
          ft0(npar) = 0e0;
          px0(npar) = fem::dble(pjtx(i, j));
          py0(npar) = fem::dble(pjty(i, j));
          pz0(npar) = fem::dble(pjtz(i, j));
          xmass0(npar) = fem::dble(pjtm(i, j));
          /// C              E0(NPAR) = dble(PJTE(I, J))
          e0(npar) = fem::dsqrt(fem::pow2(px0(npar)) + fem::pow2(py0(npar)) +
                                fem::pow2(pz0(npar)) + fem::pow2(xmass0(npar)));
          /// C
          /// Cbz1/27/99
          /// C.....end gluon selection
        }
        /// Cbz1/27/99end
      }
    }
    FEM_DO_SAFE(i, 1, nsg) {
      istr++;
      FEM_DO_SAFE(j, 1, njsg(i)) {
        /// Cbz1/27/99
        /// C.....for now only consider gluon cascade
        if (k2sg(i, j) == 21) {
          /// Cbz1/27/99end
          npar++;
          lstrg0(npar) = istr;
          lpart0(npar) = j;
          ityp0(npar) = k2sg(i, j);
          /// Clin-7/20/01 add dble or sngl to make precisions consistent:
          gx0(npar) = 0.5e0 * fem::dble(yp(1, iasg(i, 1)) + yt(1, iasg(i, 2)));
          gy0(npar) = 0.5e0 * fem::dble(yp(2, iasg(i, 1)) + yt(2, iasg(i, 2)));
          gz0(npar) = 0e0;
          ft0(npar) = 0e0;
          px0(npar) = fem::dble(pxsg(i, j));
          py0(npar) = fem::dble(pysg(i, j));
          pz0(npar) = fem::dble(pzsg(i, j));
          xmass0(npar) = fem::dble(pmsg(i, j));
          /// C              E0(NPAR) = dble(PESG(I, J))
          e0(npar) = fem::dsqrt(fem::pow2(px0(npar)) + fem::pow2(py0(npar)) +
                                fem::pow2(pz0(npar)) + fem::pow2(xmass0(npar)));
          /// Cbz1/27/99
          /// C.....end gluon selection
        }
        /// Cbz1/27/99end
      }
    }
    mul = npar;
    /// C
    /// Cbz2/4/99
    hjana1(cmn);
    /// Cbz2/4/99end
    /// C
    /// Clin-6/2009:
    if (ioscar == 3) {
      write(95, star), iaevt, mul;
    }
    /// C.....call ZPC for parton cascade
    zpcmn(cmn);
    /// C
    /// C     write out parton and wounded nucleon information to ana/zpc1.mom:
    /// Clin-6/2009:
    /// C        WRITE (14, 395) ITEST, MUL, bimp, NELP,NINP,NELT,NINTHJ
    write(14, format_395), iaevt, miss, mul, bimp, nelp, ninp, nelt, ninthj;
    FEM_DO_SAFE(i, 1, mul) {
      /// Cc           WRITE (14, 411) PX5(I), PY5(I), PZ5(I), ITYP5(I),
      /// C     &        XMASS5(I), E5(I)
      if (fem::dmax1(fem::abs(gx5(i)), fem::abs(gy5(i)), fem::abs(gz5(i)),
                     fem::abs(ft5(i))) < 9999) {
        write(14, format_210), ityp5(i), px5(i), py5(i), pz5(i), xmass5(i),
            gx5(i), gy5(i), gz5(i), ft5(i);
      } else {
        /// C     change format for large numbers:
        write(14, format_211), ityp5(i), px5(i), py5(i), pz5(i), xmass5(i),
            gx5(i), gy5(i), gz5(i), ft5(i);
      }
      /// C
    }
    /// C
    /// Clin-4/09/01:
    itest++;
    /// C 411    FORMAT(1X, 3F10.3, I6, 2F10.3)
    /// Cbz3/19/99 end
    /// C
    /// Clin-5/2009 ctest off:
    /// C        call frztm(1,1)
    /// C
    /// C.....transfer data back from ZPC to HIJING
    FEM_DO_SAFE(i, 1, mul) {
      if (lstrg1(i) <= nsp) {
        nstrg = lstrg1(i);
        npart = lpart1(i);
        kfpj(nstrg, npart) = ityp5(i);
        /// Clin-7/20/01 add dble or sngl to make precisions consistent
        pjpx(nstrg, npart) = fem::sngl(px5(i));
        pjpy(nstrg, npart) = fem::sngl(py5(i));
        pjpz(nstrg, npart) = fem::sngl(pz5(i));
        pjpe(nstrg, npart) = fem::sngl(e5(i));
        pjpm(nstrg, npart) = fem::sngl(xmass5(i));
      } else if (lstrg1(i) <= nsp + nst) {
        nstrg = lstrg1(i) - nsp;
        npart = lpart1(i);
        kftj(nstrg, npart) = ityp5(i);
        pjtx(nstrg, npart) = fem::sngl(px5(i));
        pjty(nstrg, npart) = fem::sngl(py5(i));
        pjtz(nstrg, npart) = fem::sngl(pz5(i));
        pjte(nstrg, npart) = fem::sngl(e5(i));
        pjtm(nstrg, npart) = fem::sngl(xmass5(i));
      } else {
        nstrg = lstrg1(i) - nsp - nst;
        npart = lpart1(i);
        k2sg(nstrg, npart) = ityp5(i);
        pxsg(nstrg, npart) = fem::sngl(px5(i));
        pysg(nstrg, npart) = fem::sngl(py5(i));
        pzsg(nstrg, npart) = fem::sngl(pz5(i));
        pesg(nstrg, npart) = fem::sngl(e5(i));
        pmsg(nstrg, npart) = fem::sngl(xmass5(i));
      }
    }
    /// Cbz1/25/99end
    /// C
    /// Cbz2/4/99
    hjana2(cmn);
    /// Cbz2/4/99end
    /// C
    /// Clin*****4/09/01-soft2, put q+dq+X in strings into ZPC:
  } else if (isoft == 2) {
    nsp = ihnt2(1);
    nst = ihnt2(3);
    /// Clin-4/27/01:
    nsi = nsg;
    npar = 0;
    istr = 0;
    /// C
    /// Clin  No fragmentation to hadrons, only on parton level,
    /// C     and transfer minijet and string data from HIJING to ZPC:
    mstj(1) = 0;
    /// Clin-4/12/01 forbid soft radiation before ZPC to avoid small-mass
    /// strings, C     and forbid jet order reversal before ZPC to avoid
    /// unphysical flavors:
    ihpr2(1) = 0;
    isflag = 0;
    /// C
    if (ihpr2(20) != 0) {
      FEM_DO_SAFE(ntp, 1, 2) {
        FEM_DO_SAFE(jjtp, 1, ihnt2(2 * ntp - 1)) {
          istr++;
          /// C change: do gluon kink only once: either here or in
          /// fragmentation.
          hijfrg(cmn, jjtp, ntp, ierror);
          /// C                 call lulist(1)
          if (ntp == 1) {
            /// C 354                continue
            npj(jjtp) = fem::max0(n - 2, 0);
            /// C
            /// Clin-4/12/01:                    NPJ(jjtp)=MAX0(ipartn-2,0)
          } else {
            /// C 355                continue
            ntj(jjtp) = fem::max0(n - 2, 0);
            /// Clin-4/12/01:                    NTJ(jjtp)=MAX0(ipartn-2,0)
          }
          /// C
          FEM_DO_SAFE(ii, 1, n) {
            npar++;
            lstrg0(npar) = istr;
            lpart0(npar) = ii;
            ityp0(npar) = k(ii, 2);
            gz0(npar) = 0e0;
            ft0(npar) = 0e0;
            /// Clin-7/20/01 add dble or sngl to make precisions consistent
            px0(npar) = fem::dble(p(ii, 1));
            py0(npar) = fem::dble(p(ii, 2));
            pz0(npar) = fem::dble(p(ii, 3));
            xmass0(npar) = fem::dble(p(ii, 5));
            /// C                 E0(NPAR) = dble(P(II,4))
            e0(npar) =
                fem::dsqrt(fem::pow2(px0(npar)) + fem::pow2(py0(npar)) +
                           fem::pow2(pz0(npar)) + fem::pow2(xmass0(npar)));
            if (ntp == 1) {
              /// Clin-7/20/01 add dble or sngl to make precisions consistent
              /// Clin-2/2012:
              /// C                    GX0(NPAR) = dble(YP(1, jjtp)+0.5 * BB)
              /// C                    GY0(NPAR) = dble(YP(2, jjtp))
              gx0(npar) = fem::dble(yp(1, jjtp) + 0.5f * bb * fem::cos(phirp));
              gy0(npar) = fem::dble(yp(2, jjtp) + 0.5f * bb * fem::sin(phirp));
              /// C
              iityp = ityp0(npar);
              nstrg = lstrg0(npar);
              if (iityp == 2112 || iityp == 2212) {
              } else if ((iityp == 1 || iityp == 2) && (ii == 1 || ii == n)) {
                pp(nstrg, 6) = fem::sngl(px0(npar));
                pp(nstrg, 7) = fem::sngl(py0(npar));
                pp(nstrg, 14) = fem::sngl(xmass0(npar));
              } else if ((iityp == 1103 || iityp == 2101 || iityp == 2103 ||
                          iityp == 2203.f || iityp == 3101 || iityp == 3103.f ||
                          iityp == 3201 || iityp == 3203 || iityp == 3303) &&
                         (ii == 1 || ii == n)) {
                pp(nstrg, 8) = fem::sngl(px0(npar));
                pp(nstrg, 9) = fem::sngl(py0(npar));
                pp(nstrg, 15) = fem::sngl(xmass0(npar));
              } else {
                npart = lpart0(npar) - 1;
                kfpj(nstrg, npart) = ityp0(npar);
                pjpx(nstrg, npart) = fem::sngl(px0(npar));
                pjpy(nstrg, npart) = fem::sngl(py0(npar));
                pjpz(nstrg, npart) = fem::sngl(pz0(npar));
                pjpe(nstrg, npart) = fem::sngl(e0(npar));
                pjpm(nstrg, npart) = fem::sngl(xmass0(npar));
              }
            } else {
              /// Clin-2/2012:
              /// C                    GX0(NPAR) = dble(YT(1, jjtp)-0.5 * BB)
              /// C                    GY0(NPAR) = dble(YT(2, jjtp))
              gx0(npar) = fem::dble(yt(1, jjtp) - 0.5f * bb * fem::cos(phirp));
              gy0(npar) = fem::dble(yt(2, jjtp) - 0.5f * bb * fem::sin(phirp));
              iityp = ityp0(npar);
              nstrg = lstrg0(npar) - nsp;
              if (iityp == 2112 || iityp == 2212) {
              } else if ((iityp == 1 || iityp == 2) && (ii == 1 || ii == n)) {
                pt(nstrg, 6) = fem::sngl(px0(npar));
                pt(nstrg, 7) = fem::sngl(py0(npar));
                pt(nstrg, 14) = fem::sngl(xmass0(npar));
              } else if ((iityp == 1103 || iityp == 2101 || iityp == 2103 ||
                          iityp == 2203.f || iityp == 3101 || iityp == 3103.f ||
                          iityp == 3201 || iityp == 3203 || iityp == 3303) &&
                         (ii == 1 || ii == n)) {
                pt(nstrg, 8) = fem::sngl(px0(npar));
                pt(nstrg, 9) = fem::sngl(py0(npar));
                pt(nstrg, 15) = fem::sngl(xmass0(npar));
              } else {
                npart = lpart0(npar) - 1;
                kftj(nstrg, npart) = ityp0(npar);
                pjtx(nstrg, npart) = fem::sngl(px0(npar));
                pjty(nstrg, npart) = fem::sngl(py0(npar));
                pjtz(nstrg, npart) = fem::sngl(pz0(npar));
                pjte(nstrg, npart) = fem::sngl(e0(npar));
                pjtm(nstrg, npart) = fem::sngl(xmass0(npar));
              }
            }
          }
        }
      }
      FEM_DO_SAFE(isg, 1, nsg) {
        istr++;
        hijfrg(cmn, isg, 3, ierror);
        /// C              call lulist(2)
        /// C
        njsg(isg) = n;
        /// C
        FEM_DO_SAFE(ii, 1, n) {
          npar++;
          lstrg0(npar) = istr;
          lpart0(npar) = ii;
          ityp0(npar) = k(ii, 2);
          gx0(npar) =
              0.5e0 * fem::dble(yp(1, iasg(isg, 1)) + yt(1, iasg(isg, 2)));
          gy0(npar) =
              0.5e0 * fem::dble(yp(2, iasg(isg, 1)) + yt(2, iasg(isg, 2)));
          gz0(npar) = 0e0;
          ft0(npar) = 0e0;
          px0(npar) = fem::dble(p(ii, 1));
          py0(npar) = fem::dble(p(ii, 2));
          pz0(npar) = fem::dble(p(ii, 3));
          xmass0(npar) = fem::dble(p(ii, 5));
          /// C                 E0(NPAR) = dble(P(II,4))
          e0(npar) = fem::dsqrt(fem::pow2(px0(npar)) + fem::pow2(py0(npar)) +
                                fem::pow2(pz0(npar)) + fem::pow2(xmass0(npar)));
        }
      }
    }
    /// C
    mul = npar;
    /// Cbz2/4/99
    hjana1(cmn);
    /// Cbz2/4/99end
    /// Clin-6/2009:
    if (ioscar == 3) {
      write(95, star), iaevt, mul;
    }
    /// C.....call ZPC for parton cascade
    zpcmn(cmn);
    /// Cbz3/19/99
    /// Clin-6/2009:
    /// C        WRITE (14, 395) ITEST, MUL, bimp, NELP,NINP,NELT,NINTHJ
    write(14, format_395), iaevt, miss, mul, bimp, nelp, ninp, nelt, ninthj;
    itest++;
    /// C
    FEM_DO_SAFE(i, 1, mul) {
      /// C           WRITE (14, 311) PX5(I), PY5(I), PZ5(I), ITYP5(I),
      /// C     &        XMASS5(I), E5(I)
      /// Clin-4/2012 write parton freeze-out position in zpc.dat for this test
      /// scenario: C           WRITE (14, 312) PX5(I), PY5(I), PZ5(I),
      /// ITYP5(I), C     &        XMASS5(I), E5(I),LSTRG1(I), LPART1(I)
      if (fem::dmax1(fem::abs(gx5(i)), fem::abs(gy5(i)), fem::abs(gz5(i)),
                     fem::abs(ft5(i))) < 9999) {
        write(14, format_210), ityp5(i), px5(i), py5(i), pz5(i), xmass5(i),
            gx5(i), gy5(i), gz5(i), ft5(i);
      } else {
        write(14, format_211), ityp5(i), px5(i), py5(i), pz5(i), xmass5(i),
            gx5(i), gy5(i), gz5(i), ft5(i);
      }
      /// C
    }
    /// C 311    FORMAT(1X, 3F10.4, I6, 2F10.4)
    /// C 312    FORMAT(1X, 3F10.3, I6, 2F10.3,1X,I6,1X,I3)
    /// Cbz3/19/99 end
    /// C
    /// Clin-5/2009 ctest off:
    /// C        call frztm(1,1)
    /// C
    /// Clin-4/13/01 initialize four momenta and invariant mass of strings after
    /// ZPC:
    FEM_DO_SAFE(nmom, 1, 5) {
      FEM_DO_SAFE(nstrg, 1, nsp) { pp(nstrg, nmom) = 0.f; }
      FEM_DO_SAFE(nstrg, 1, nst) { pt(nstrg, nmom) = 0.f; }
    }
    /// Clin-4/13/01-end
    /// C
    FEM_DO_SAFE(i, 1, mul) {
      iityp = ityp5(i);
      if (lstrg1(i) <= nsp) {
        nstrg = lstrg1(i);
        /// C     nucleons without interactions:
        if (iityp == 2112 || iityp == 2212) {
          /// Clin-7/20/01 add dble or sngl to make precisions consistent
          pp(nstrg, 1) = fem::sngl(px5(i));
          pp(nstrg, 2) = fem::sngl(py5(i));
          pp(nstrg, 3) = fem::sngl(pz5(i));
          pp(nstrg, 4) = fem::sngl(e5(i));
          pp(nstrg, 5) = fem::sngl(xmass5(i));
          /// C     valence quark:
        } else if ((iityp == 1 || iityp == 2) &&
                   (lpart1(i) == 1 || lpart1(i) == (npj(nstrg) + 2))) {
          pp(nstrg, 6) = fem::sngl(px5(i));
          pp(nstrg, 7) = fem::sngl(py5(i));
          pp(nstrg, 14) = fem::sngl(xmass5(i));
          pp(nstrg, 1) += fem::sngl(px5(i));
          pp(nstrg, 2) += fem::sngl(py5(i));
          pp(nstrg, 3) += fem::sngl(pz5(i));
          pp(nstrg, 4) += fem::sngl(e5(i));
          pp(nstrg, 5) =
              fem::sqrt(fem::pow2(pp(nstrg, 4)) - fem::pow2(pp(nstrg, 1)) -
                        fem::pow2(pp(nstrg, 2)) - fem::pow2(pp(nstrg, 3)));
          /// C     diquark:
        } else if ((iityp == 1103 || iityp == 2101 || iityp == 2103 ||
                    iityp == 2203.f || iityp == 3101 || iityp == 3103.f ||
                    iityp == 3201 || iityp == 3203 || iityp == 3303) &&
                   (lpart1(i) == 1 || lpart1(i) == (npj(nstrg) + 2))) {
          pp(nstrg, 8) = fem::sngl(px5(i));
          pp(nstrg, 9) = fem::sngl(py5(i));
          pp(nstrg, 15) = fem::sngl(xmass5(i));
          pp(nstrg, 1) += fem::sngl(px5(i));
          pp(nstrg, 2) += fem::sngl(py5(i));
          pp(nstrg, 3) += fem::sngl(pz5(i));
          pp(nstrg, 4) += fem::sngl(e5(i));
          pp(nstrg, 5) =
              fem::sqrt(fem::pow2(pp(nstrg, 4)) - fem::pow2(pp(nstrg, 1)) -
                        fem::pow2(pp(nstrg, 2)) - fem::pow2(pp(nstrg, 3)));
          /// C     partons in projectile or target strings:
        } else {
          npart = lpart1(i) - 1;
          kfpj(nstrg, npart) = ityp5(i);
          pjpx(nstrg, npart) = fem::sngl(px5(i));
          pjpy(nstrg, npart) = fem::sngl(py5(i));
          pjpz(nstrg, npart) = fem::sngl(pz5(i));
          pjpe(nstrg, npart) = fem::sngl(e5(i));
          pjpm(nstrg, npart) = fem::sngl(xmass5(i));
        }
      } else if (lstrg1(i) <= nsp + nst) {
        nstrg = lstrg1(i) - nsp;
        if (iityp == 2112 || iityp == 2212) {
          pt(nstrg, 1) = fem::sngl(px5(i));
          pt(nstrg, 2) = fem::sngl(py5(i));
          pt(nstrg, 3) = fem::sngl(pz5(i));
          pt(nstrg, 4) = fem::sngl(e5(i));
          pt(nstrg, 5) = fem::sngl(xmass5(i));
        } else if ((iityp == 1 || iityp == 2) &&
                   (lpart1(i) == 1 || lpart1(i) == (ntj(nstrg) + 2))) {
          pt(nstrg, 6) = fem::sngl(px5(i));
          pt(nstrg, 7) = fem::sngl(py5(i));
          pt(nstrg, 14) = fem::sngl(xmass5(i));
          pt(nstrg, 1) += fem::sngl(px5(i));
          pt(nstrg, 2) += fem::sngl(py5(i));
          pt(nstrg, 3) += fem::sngl(pz5(i));
          pt(nstrg, 4) += fem::sngl(e5(i));
          pt(nstrg, 5) =
              fem::sqrt(fem::pow2(pt(nstrg, 4)) - fem::pow2(pt(nstrg, 1)) -
                        fem::pow2(pt(nstrg, 2)) - fem::pow2(pt(nstrg, 3)));
        } else if ((iityp == 1103 || iityp == 2101 || iityp == 2103 ||
                    iityp == 2203.f || iityp == 3101 || iityp == 3103.f ||
                    iityp == 3201 || iityp == 3203 || iityp == 3303) &&
                   (lpart1(i) == 1 || lpart1(i) == (ntj(nstrg) + 2))) {
          pt(nstrg, 8) = fem::sngl(px5(i));
          pt(nstrg, 9) = fem::sngl(py5(i));
          pt(nstrg, 15) = fem::sngl(xmass5(i));
          pt(nstrg, 1) += fem::sngl(px5(i));
          pt(nstrg, 2) += fem::sngl(py5(i));
          pt(nstrg, 3) += fem::sngl(pz5(i));
          pt(nstrg, 4) += fem::sngl(e5(i));
          pt(nstrg, 5) =
              fem::sqrt(fem::pow2(pt(nstrg, 4)) - fem::pow2(pt(nstrg, 1)) -
                        fem::pow2(pt(nstrg, 2)) - fem::pow2(pt(nstrg, 3)));
        } else {
          npart = lpart1(i) - 1;
          kftj(nstrg, npart) = ityp5(i);
          pjtx(nstrg, npart) = fem::sngl(px5(i));
          pjty(nstrg, npart) = fem::sngl(py5(i));
          pjtz(nstrg, npart) = fem::sngl(pz5(i));
          pjte(nstrg, npart) = fem::sngl(e5(i));
          pjtm(nstrg, npart) = fem::sngl(xmass5(i));
        }
      } else {
        nstrg = lstrg1(i) - nsp - nst;
        npart = lpart1(i);
        k2sg(nstrg, npart) = ityp5(i);
        pxsg(nstrg, npart) = fem::sngl(px5(i));
        pysg(nstrg, npart) = fem::sngl(py5(i));
        pzsg(nstrg, npart) = fem::sngl(pz5(i));
        pesg(nstrg, npart) = fem::sngl(e5(i));
        pmsg(nstrg, npart) = fem::sngl(xmass5(i));
      }
    }
    /// Cbz1/25/99end
    /// C
    /// Clin-4/09/01  turn on fragmentation with soft radiation
    /// C     and jet order reversal to form hadrons after ZPC:
    mstj(1) = 1;
    ihpr2(1) = 1;
    isflag = 1;
    /// Clin-4/13/01 allow small mass strings (D=1.5GeV):
    hipr1(1) = 0.94f;
    /// C
    /// Cbz2/4/99
    hjana2(cmn);
    /// Cbz2/4/99end
    /// C
    /// Clin-4/19/01-soft3, fragment strings, then convert hadrons to partons
    /// C     and input to ZPC:
  } else if (isoft == 3 || isoft == 4 || isoft == 5) {
    /// Clin-4/24/01 normal fragmentation first:
    isflag = 0;
    /// C        write(99,*) 'IAEVT,NSG,NDR=',IAEVT,NSG,NDR
    /// C
    if (ihpr2(20) != 0) {
      FEM_DO_SAFE(isg, 1, nsg) {
        hijfrg(cmn, isg, 3, ierror);
        /// C
        nsbst = 1;
        idstr = 92;
        if (ihpr2(21) == 0) {
          luedit(cmn, 2);
        } else {
        statement_551:
          nsbst++;
          if (k(nsbst, 2) < 91 || k(nsbst, 2) > 93) {
            goto statement_551;
          }
          idstr = k(nsbst, 2);
          nsbst++;
        }
        /// C
        if (frame == "LAB") {
          hboost(cmn);
        }
        /// C                ******** boost back to lab frame(if it was in)
        /// C
        nsbstr = 0;
        FEM_DO_SAFE(i, nsbst, n) {
          if (k(i, 2) == idstr) {
            nsbstr++;
            goto statement_560;
          }
          k(i, 4) = nsbstr;
          natt++;
          katt(natt, 1) = k(i, 2);
          katt(natt, 2) = 20;
          katt(natt, 4) = k(i, 1);
          /// C     from Yasushi, to avoid violation of array limits:
          /// C                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
          /// Clin-4/2008 to avoid out-of-bound error in K():
          /// C                   IF(K(I,3).EQ.0 .OR.
          /// C     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
          /// C                      KATT(NATT,3)=0
          if (k(i, 3) == 0) {
            katt(natt, 3) = 0;
          } else if (k(i, 3) != 0 && k(k(i, 3), 2) == idstr) {
            katt(natt, 3) = 0;
            /// Clin-4/2008-end
          } else {
            katt(natt, 3) = natt - i + k(i, 3) + nsbstr - k(k(i, 3), 4);
          }
          /// C
          /// C       ****** identify the mother particle
          patt(natt, 1) = p(i, 1);
          patt(natt, 2) = p(i, 2);
          patt(natt, 3) = p(i, 3);
          patt(natt, 4) = p(i, 4);
          eatt += p(i, 4);
          gxar(natt) = 0.5f * (yp(1, iasg(isg, 1)) + yt(1, iasg(isg, 2)));
          gyar(natt) = 0.5f * (yp(2, iasg(isg, 1)) + yt(2, iasg(isg, 2)));
          gzar(natt) = 0.f;
          ftar(natt) = 0.f;
          itypar(natt) = k(i, 2);
          pxar(natt) = p(i, 1);
          pyar(natt) = p(i, 2);
          pzar(natt) = p(i, 3);
          pear(natt) = p(i, 4);
          xmar(natt) = p(i, 5);
          /// Clin-8/2015: record hadron information, to be used for its
          /// constituent partons:
          xstrg0(natt) = fem::dble(gxar(natt));
          ystrg0(natt) = fem::dble(gyar(natt));
          istrg0(natt) = isg;
        /// C                   write(99,*)
        /// xstrg0(NATT),ystrg0(NATT),istrg0(NATT), C     1 K(I,2),P(I, 1),P(I,
        /// 2),P(I, 3) Cbz11/11/98end
        /// C
        statement_560:;
        }
      }
      /// C                ********Fragment the q-qbar jets systems *****
      /// C
      jtp(1) = ihnt2(1);
      jtp(2) = ihnt2(3);
      FEM_DO_SAFE(ntp, 1, 2) {
        FEM_DO_SAFE(jjtp, 1, jtp(ntp)) {
          hijfrg(cmn, jjtp, ntp, ierror);
          /// C
          nsbst = 1;
          idstr = 92;
          if (ihpr2(21) == 0) {
            luedit(cmn, 2);
          } else {
          statement_581:
            nsbst++;
            if (k(nsbst, 2) < 91 || k(nsbst, 2) > 93) {
              goto statement_581;
            }
            idstr = k(nsbst, 2);
            nsbst++;
          }
          if (frame == "LAB") {
            hboost(cmn);
          }
          /// C                ******** boost back to lab frame(if it was in)
          /// C
          nftp = nfp(jjtp, 5);
          if (ntp == 2) {
            nftp = 10 + nft(jjtp, 5);
          }
          nsbstr = 0;
          FEM_DO_SAFE(i, nsbst, n) {
            if (k(i, 2) == idstr) {
              nsbstr++;
              goto statement_590;
            }
            k(i, 4) = nsbstr;
            natt++;
            katt(natt, 1) = k(i, 2);
            katt(natt, 2) = nftp;
            katt(natt, 4) = k(i, 1);
            /// C                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR)
            /// THEN Clin-4/2008 C                   IF(K(I,3).EQ.0 .OR. C     1
            /// (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN C KATT(NATT,3)=0
            if (k(i, 3) == 0) {
              katt(natt, 3) = 0;
            } else if (k(i, 3) != 0 && k(k(i, 3), 2) == idstr) {
              katt(natt, 3) = 0;
              /// Clin-4/2008-end
            } else {
              katt(natt, 3) = natt - i + k(i, 3) + nsbstr - k(k(i, 3), 4);
            }
            /// C
            /// C       ****** identify the mother particle
            patt(natt, 1) = p(i, 1);
            patt(natt, 2) = p(i, 2);
            patt(natt, 3) = p(i, 3);
            patt(natt, 4) = p(i, 4);
            eatt += p(i, 4);
            if (ntp == 1) {
              /// Clin-2/2012:
              /// C                      GXAR(NATT) = YP(1, jjtp)+0.5 * BB
              /// C                      GYAR(NATT) = YP(2, jjtp)
              gxar(natt) = yp(1, jjtp) + 0.5f * bb * fem::cos(phirp);
              gyar(natt) = yp(2, jjtp) + 0.5f * bb * fem::sin(phirp);
              /// C
            } else {
              /// Clin-2/2012:
              /// C                      GXAR(NATT) = YT(1, jjtp)-0.5 * BB
              /// C                      GYAR(NATT) = YT(2, jjtp)
              gxar(natt) = yt(1, jjtp) - 0.5f * bb * fem::cos(phirp);
              gyar(natt) = yt(2, jjtp) - 0.5f * bb * fem::sin(phirp);
            }
            gzar(natt) = 0.f;
            ftar(natt) = 0.f;
            itypar(natt) = k(i, 2);
            pxar(natt) = p(i, 1);
            pyar(natt) = p(i, 2);
            pzar(natt) = p(i, 3);
            pear(natt) = p(i, 4);
            xmar(natt) = p(i, 5);
            /// Clin-8/2015: record hadron information, to be used for its
            /// constituent partons:
            xstrg0(natt) = fem::dble(gxar(natt));
            ystrg0(natt) = fem::dble(gyar(natt));
            /// C     String ID is separated for projectile/target strings:
            istrg0(natt) = ntp * 10000 + jjtp;
          /// C if(N.eq.nsbst.and.(K(I,2).eq.2112.or.K(I,2).eq.2212)) then C
          /// write(99,*) xstrg0(NATT),ystrg0(NATT),istrg0(NATT) C     1
          /// ,K(I,2),P(I, 1),P(I, 2),P(I, 3),'spectator' C else C write(99,*)
          /// xstrg0(NATT),ystrg0(NATT),istrg0(NATT) C     1 ,K(I,2),P(I,
          /// 1),P(I, 2),P(I, 3) C                   endif Cbz11/11/98end
          /// C
          statement_590:;
          }
        }
      }
      /// C     ********Fragment the q-qq related string systems
    }
    /// Clin-4/2008 check for zero NDR value:
    if (ndr >= 1) {
      /// C
      FEM_DO_SAFE(i, 1, ndr) {
        natt++;
        katt(natt, 1) = kfdr(i);
        katt(natt, 2) = 40;
        katt(natt, 3) = 0;
        patt(natt, 1) = pdr(i, 1);
        patt(natt, 2) = pdr(i, 2);
        patt(natt, 3) = pdr(i, 3);
        patt(natt, 4) = pdr(i, 4);
        eatt += pdr(i, 4);
        /// Clin-11/11/03     set direct photons positions and time at
        /// formation:
        gxar(natt) = rtdr(i, 1);
        gyar(natt) = rtdr(i, 2);
        gzar(natt) = 0.f;
        ftar(natt) = 0.f;
        itypar(natt) = katt(natt, 1);
        pxar(natt) = patt(natt, 1);
        pyar(natt) = patt(natt, 2);
        pzar(natt) = patt(natt, 3);
        pear(natt) = patt(natt, 4);
        xmar(natt) = pdr(i, 5);
      }
      /// Clin-4/2008:
    }
    /// Clin-6/2009
    embedhighpt(cmn);
    /// C
    hjana1(cmn);
    /// C
    /// Clin-4/19/01 convert hadrons to partons for ZPC (with GX0 given):
    htop(cmn);
    /// C
    /// Clin-7/03/01 move up, used in zpstrg (otherwise not set and incorrect):
    nsp = 0;
    nst = 0;
    nsg = natt;
    nsi = nsg;
    /// Clin-7/03/01-end
    /// C
    /// Clin-6/2009:
    if (ioscar == 3) {
      write(95, star), iaevt, mul;
    }
    /// C
    /// C.....call ZPC for parton cascade
    zpcmn(cmn);
    /// Clin-6/2009:
    /// C        WRITE (14, 395) ITEST, MUL, bimp, NELP,NINP,NELT,NINTHJ
    write(14, format_395), iaevt, miss, mul, bimp, nelp, ninp, nelt, ninthj;
    itest++;
    /// C
    FEM_DO_SAFE(i, 1, mul) {
      /// C           WRITE (14, 511) PX5(I), PY5(I), PZ5(I), ITYP5(I),
      /// C     &        XMASS5(I), E5(I)
      /// Clin-4/2012 write parton freeze-out position in zpc.dat
      /// C     for string melting version:
      /// C           WRITE (14, 512) ITYP5(I), PX5(I), PY5(I), PZ5(I),
      /// C     &        XMASS5(I), LSTRG1(I), LPART1(I), FT5(I)
      if (fem::dmax1(fem::abs(gx5(i)), fem::abs(gy5(i)), fem::abs(gz5(i)),
                     fem::abs(ft5(i))) < 9999) {
        write(14, format_210), ityp5(i), px5(i), py5(i), pz5(i), xmass5(i),
            gx5(i), gy5(i), gz5(i), ft5(i);
      } else {
        write(14, format_211), ityp5(i), px5(i), py5(i), pz5(i), xmass5(i),
            gx5(i), gy5(i), gz5(i), ft5(i);
      }
      /// C
    }
    /// C 511    FORMAT(1X, 3F10.4, I6, 2F10.4)
    /// C 512    FORMAT(I6,4(1X,F10.3),1X,I6,1X,I3,1X,F10.3)
    /// C 513    FORMAT(1X, 4F10.4)
    /// C
    /// Clin-5/2009 ctest off:
    /// C        call frztm(1,1)
    /// C
    /// Clin  save data after ZPC for fragmentation purpose:
    /// C.....transfer data back from ZPC to HIJING
    FEM_DO_SAFE(i, 1, maxstr) {
      FEM_DO_SAFE(j, 1, 3) {
        k1sgs(i, j) = 0;
        k2sgs(i, j) = 0;
        pxsgs(i, j) = 0e0;
        pysgs(i, j) = 0e0;
        pzsgs(i, j) = 0e0;
        pesgs(i, j) = 0e0;
        pmsgs(i, j) = 0e0;
        gxsgs(i, j) = 0e0;
        gysgs(i, j) = 0e0;
        gzsgs(i, j) = 0e0;
        ftsgs(i, j) = 0e0;
      }
    }
    FEM_DO_SAFE(i, 1, mul) {
      iityp = ityp5(i);
      nstrg = lstrg1(i);
      npart = lpart1(i);
      k2sgs(nstrg, npart) = ityp5(i);
      pxsgs(nstrg, npart) = px5(i);
      pysgs(nstrg, npart) = py5(i);
      pzsgs(nstrg, npart) = pz5(i);
      pmsgs(nstrg, npart) = xmass5(i);
      /// Clin-7/20/01 E5(I) does no include the finite parton mass XMASS5(I),
      /// C     so define it anew:
      /// C           PESGS(NSTRG, NPART) = E5(I)
      /// C           if(abs(PZ5(i)/E5(i)).gt.0.9999999d0)
      /// C     1          write(91,*) 'a',PX5(i),PY5(i),XMASS5(i),PZ5(i),E5(i)
      e5(i) = fem::dsqrt(fem::pow2(px5(i)) + fem::pow2(py5(i)) +
                         fem::pow2(pz5(i)) + fem::pow2(xmass5(i)));
      pesgs(nstrg, npart) = e5(i);
      /// C           if(abs(PZ5(i)/E5(i)).gt.0.9999999d0)
      /// C     1          write(91,*) 'b: new E5(I)=',E5(i)
      /// Clin-7/20/01-end
      gxsgs(nstrg, npart) = gx5(i);
      gysgs(nstrg, npart) = gy5(i);
      gzsgs(nstrg, npart) = gz5(i);
      ftsgs(nstrg, npart) = ft5(i);
    }
    hjana2(cmn);
    /// C
    /// Clin-4/19/01-end
    /// C
  }
  /// Clin-4/09/01-end
  /// C
  /// C**************fragment all the string systems in the following*****
  /// C
  /// C********nsbst is where particle information starts
  /// C********nsbstR+1 is the number of strings in fragmentation
  /// C********the number of strings before a line is stored in K(I,4)
  /// C********IDSTR is id number of the string system (91,92 or 93)
  /// C
  /// Clin-4/30/01 convert partons to hadrons after ZPC:
  if (isoft == 3 || isoft == 4 || isoft == 5) {
    natt = 0;
    eatt = 0.f;
    ptoh(cmn);
    FEM_DO_SAFE(i, 1, cmn.nnozpc) {
      natt++;
      katt(natt, 1) = itypn(i);
      patt(natt, 1) = pxn(i);
      patt(natt, 2) = pyn(i);
      patt(natt, 3) = pzn(i);
      patt(natt, 4) = een(i);
      eatt += een(i);
      gxar(natt) = gxn(i);
      gyar(natt) = gyn(i);
      gzar(natt) = gzn(i);
      ftar(natt) = ftn(i);
      itypar(natt) = itypn(i);
      pxar(natt) = pxn(i);
      pyar(natt) = pyn(i);
      pzar(natt) = pzn(i);
      pear(natt) = een(i);
      xmar(natt) = xmn(i);
    }
    goto statement_565;
  }
  /// Clin-4/30/01-end
  if (ihpr2(20) != 0) {
    FEM_DO_SAFE(isg, 1, nsg) {
      hijfrg(cmn, isg, 3, ierror);
      if (mstu(24) != 0 || ierror > 0) {
        mstu(24) = 0;
        mstu(28) = 0;
        if (ihpr2(10) != 0) {
          /// C                      call lulist(2)
          write(6, star), "error occured ISG, repeat the event";
          write(6, star), isg;
          /// C
        }
        goto statement_50;
      }
      /// C                        ********Check errors
      /// C
      nsbst = 1;
      idstr = 92;
      if (ihpr2(21) == 0) {
        luedit(cmn, 2);
      } else {
      statement_351:
        nsbst++;
        if (k(nsbst, 2) < 91 || k(nsbst, 2) > 93) {
          goto statement_351;
        }
        idstr = k(nsbst, 2);
        nsbst++;
      }
      /// C
      if (frame == "LAB") {
        hboost(cmn);
      }
      /// C                ******** boost back to lab frame(if it was in)
      /// C
      nsbstr = 0;
      FEM_DO_SAFE(i, nsbst, n) {
        if (k(i, 2) == idstr) {
          nsbstr++;
          goto statement_360;
        }
        k(i, 4) = nsbstr;
        natt++;
        katt(natt, 1) = k(i, 2);
        katt(natt, 2) = 20;
        katt(natt, 4) = k(i, 1);
        /// C                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
        /// Clin-4/2008:
        /// C                   IF(K(I,3).EQ.0 .OR.
        /// C     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
        /// C                      KATT(NATT,3)=0
        if (k(i, 3) == 0) {
          katt(natt, 3) = 0;
        } else if (k(i, 3) != 0 && k(k(i, 3), 2) == idstr) {
          katt(natt, 3) = 0;
          /// Clin-4/2008-end
        } else {
          katt(natt, 3) = natt - i + k(i, 3) + nsbstr - k(k(i, 3), 4);
        }
        /// C
        /// C       ****** identify the mother particle
        patt(natt, 1) = p(i, 1);
        patt(natt, 2) = p(i, 2);
        patt(natt, 3) = p(i, 3);
        patt(natt, 4) = p(i, 4);
        eatt += p(i, 4);
        /// C
        /// Cbz11/11/98
        /// Cbz1/25/99
        /// C                   GXAR(NATT) = 0.5 * (YP(1, IASG(ISG, 1)) +
        /// C     &                YT(1, IASG(ISG, 2)))
        /// C                   GYAR(NATT) = 0.5 * (YP(2, IASG(ISG, 1)) +
        /// C     &                YT(2, IASG(ISG, 2)))
        lsg = nsp + nst + isg;
        gxar(natt) = fem::sngl(zt1(lsg));
        gyar(natt) = fem::sngl(zt2(lsg));
        gzar(natt) = fem::sngl(zt3(lsg));
        ftar(natt) = fem::sngl(ataui(lsg));
        /// Cbz1/25/99end
        itypar(natt) = k(i, 2);
        pxar(natt) = p(i, 1);
        pyar(natt) = p(i, 2);
        pzar(natt) = p(i, 3);
        pear(natt) = p(i, 4);
        xmar(natt) = p(i, 5);
      /// Cbz11/11/98end
      /// C
      statement_360:;
      }
    }
    /// C                ********Fragment the q-qbar jets systems *****
    /// C
    jtp(1) = ihnt2(1);
    jtp(2) = ihnt2(3);
    FEM_DO_SAFE(ntp, 1, 2) {
      FEM_DO_SAFE(jjtp, 1, jtp(ntp)) {
        hijfrg(cmn, jjtp, ntp, ierror);
        if (mstu(24) != 0 || ierror > 0) {
          mstu(24) = 0;
          mstu(28) = 0;
          if (ihpr2(10) != 0) {
            /// C                  call lulist(2)
            write(6, star), "error occured P&T, repeat the event";
            write(6, star), ntp, jjtp;
            /// Clin-6/2009 when this happens, the event will be repeated,
            /// C     and another record for the same event number will be
            /// written into C     zpc.dat, zpc.res,
            /// minijet-initial-beforePropagation.dat, C
            /// parton-initial-afterPropagation.dat,
            /// parton-after-coalescence.dat, C     and
            /// parton-collisionsHistory.dat.
          }
          goto statement_50;
        }
        /// C                        ********check errors
        /// C
        nsbst = 1;
        idstr = 92;
        if (ihpr2(21) == 0) {
          luedit(cmn, 2);
        } else {
        statement_381:
          nsbst++;
          if (k(nsbst, 2) < 91 || k(nsbst, 2) > 93) {
            goto statement_381;
          }
          idstr = k(nsbst, 2);
          nsbst++;
        }
        if (frame == "LAB") {
          hboost(cmn);
        }
        /// C                ******** boost back to lab frame(if it was in)
        /// C
        nftp = nfp(jjtp, 5);
        if (ntp == 2) {
          nftp = 10 + nft(jjtp, 5);
        }
        nsbstr = 0;
        FEM_DO_SAFE(i, nsbst, n) {
          if (k(i, 2) == idstr) {
            nsbstr++;
            goto statement_390;
          }
          k(i, 4) = nsbstr;
          natt++;
          katt(natt, 1) = k(i, 2);
          katt(natt, 2) = nftp;
          katt(natt, 4) = k(i, 1);
          /// C                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
          /// Clin-4/2008:
          /// C                   IF(K(I,3).EQ.0 .OR.
          /// C     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
          /// C                      KATT(NATT,3)=0
          if (k(i, 3) == 0) {
            katt(natt, 3) = 0;
          } else if (k(i, 3) != 0 && k(k(i, 3), 2) == idstr) {
            katt(natt, 3) = 0;
            /// Clin-4/2008-end
          } else {
            katt(natt, 3) = natt - i + k(i, 3) + nsbstr - k(k(i, 3), 4);
          }
          /// C       ****** identify the mother particle
          patt(natt, 1) = p(i, 1);
          patt(natt, 2) = p(i, 2);
          patt(natt, 3) = p(i, 3);
          patt(natt, 4) = p(i, 4);
          eatt += p(i, 4);
          /// Cbz11/11/98
          /// Cbz1/25/99
          /// C                   IF (NTP .EQ. 1) THEN
          /// C                      GXAR(NATT) = YP(1, jjtp)
          /// C                   ELSE
          /// C                      GXAR(NATT) = YT(1, jjtp)
          /// C                   END IF
          /// C                   IF (NTP .EQ. 1) THEN
          /// C                      GYAR(NATT) = YP(2, jjtp)
          /// C                   ELSE
          /// C                      GYAR(NATT) = YT(2, jjtp)
          /// C                   END IF
          if (ntp == 1) {
            lsg = jjtp;
          } else {
            lsg = jjtp + nsp;
          }
          gxar(natt) = fem::sngl(zt1(lsg));
          gyar(natt) = fem::sngl(zt2(lsg));
          gzar(natt) = fem::sngl(zt3(lsg));
          ftar(natt) = fem::sngl(ataui(lsg));
          /// Cbz1/25/99end
          itypar(natt) = k(i, 2);
          pxar(natt) = p(i, 1);
          pyar(natt) = p(i, 2);
          pzar(natt) = p(i, 3);
          pear(natt) = p(i, 4);
          xmar(natt) = p(i, 5);
        /// Cbz11/11/98end
        /// C
        statement_390:;
        }
      }
    }
    /// C     ********Fragment the q-qq related string systems
  }
  /// C
  FEM_DO_SAFE(i, 1, ndr) {
    natt++;
    katt(natt, 1) = kfdr(i);
    katt(natt, 2) = 40;
    katt(natt, 3) = 0;
    patt(natt, 1) = pdr(i, 1);
    patt(natt, 2) = pdr(i, 2);
    patt(natt, 3) = pdr(i, 3);
    patt(natt, 4) = pdr(i, 4);
    eatt += pdr(i, 4);
    /// Clin-11/11/03     set direct photons positions and time at formation:
    gxar(natt) = rtdr(i, 1);
    gyar(natt) = rtdr(i, 2);
    gzar(natt) = 0.f;
    ftar(natt) = 0.f;
    itypar(natt) = katt(natt, 1);
    pxar(natt) = patt(natt, 1);
    pyar(natt) = patt(natt, 2);
    pzar(natt) = patt(natt, 3);
    pear(natt) = patt(natt, 4);
    xmar(natt) = pdr(i, 5);
  }
/// C
/// C                        ********store the direct-produced particles
/// C
/// Clin-4/19/01 soft3:
statement_565:
  /// C
  dengy = eatt / (ihnt2(1) * hint1(6) + ihnt2(3) * hint1(7)) - 1.0f;
  if (fem::abs(dengy) > hipr1(43) && ihpr2(20) != 0 && ihpr2(21) == 0) {
    if (ihpr2(10) != 0) {
      write(6, star), "Energy not conserved, repeat the event";
    }
    /// C                call lulist(1)
    write(6, star), "violated:EATT(GeV),NATT,B(fm)=", eatt, natt, bimp;
    goto statement_50;
  }
  write(6, star), "satisfied:EATT(GeV),NATT,B(fm)=", eatt, natt, bimp;
  write(6, star), " ";
  /// C
  /// Clin-4/2012 write out initial transverse positions of initial nucleons:
  write(94, star), iaevt, miss, ihnt2(1), ihnt2(3), bimp;
  FEM_DO_SAFE(jp, 1, ihnt2(1)) {
    /// Clin-12/2012 write out present and original flavor code of nucleons:
    /// C           write(94,243) YP(1,JP)+0.5*BB*cos(phiRP),
    /// C     1 YP(2,JP)+0.5*BB*sin(phiRP), JP, NFP(JP,5),yp(3,jp)
    write(94, format_243), yp(1, jp) + 0.5f * bb *fem::cos(phirp),
        yp(2, jp) + 0.5f * bb *fem::sin(phirp), jp, nfp(jp, 5), yp(3, jp),
        nfp(jp, 3), nfp(jp, 4);
  }
  FEM_DO_SAFE(jt, 1, ihnt2(3)) {
    /// C target nucleon # has a minus sign for distinction from projectile:
    /// Clin-12/2012 write out present and original flavor code of nucleons:
    /// C           write(94,243) YT(1,JT)-0.5*BB*cos(phiRP),
    /// C     1 YT(2,JT)-0.5*BB*sin(phiRP), -JT, NFT(JT,5),yt(3,jt)
    write(94, format_243), yt(1, jt) - 0.5f * bb *fem::cos(phirp),
        yt(2, jt) - 0.5f * bb *fem::sin(phirp), -jt, nft(jt, 5), yt(3, jt),
        nft(jt, 3), nft(jt, 4);
  }
  /// Clin-12/2012 write out present and original flavor code of nucleons:
  /// C 243    format(f10.3,1x,f10.3,2(1x,I5),1x,f10.3)
  /// Clin-4/2012-end
  /// C
}

typedef float (*fnkick_function_pointer)(common&, float const&);

float fnkick(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  ///
  /// Cc      SAVE /HPARNT/
  return_value = 1.0f / (x + fem::pow2(hipr1(19))) /
                 (x + fem::pow2(hipr1(20))) /
                 (1 + fem::exp((fem::sqrt(x) - hipr1(20)) / 0.4f));
  return return_value;
}

typedef float (*fnkc2_function_pointer)(common&, float const&);

float fnkc2(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  ///
  /// Cc      SAVE /HPARNT/
  return_value = x * fem::exp(-2.0f * x / hipr1(42));
  return return_value;
}

typedef float (*fnstru_function_pointer)(common&, float const&);

float fnstru(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// Cc      SAVE /HPARNT/
  return_value =
      fem::pow((1.0f - x), hipr1(44)) /
      fem::pow((fem::pow2(x) + fem::pow2(hipr1(45)) / fem::pow2(hint1(1))),
               hipr1(46));
  return return_value;
}

typedef float (*fnstrm_function_pointer)(common&, float const&);

float fnstrm(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// Cc      SAVE /HPARNT/
  return_value =
      1.0f /
      fem::pow(
          (fem::pow2((1.0f - x)) + fem::pow2(hipr1(45)) / fem::pow2(hint1(1))),
          hipr1(46)) /
      fem::pow((fem::pow2(x) + fem::pow2(hipr1(45)) / fem::pow2(hint1(1))),
               hipr1(46));
  return return_value;
}

typedef float (*fnstrs_function_pointer)(common&, float const&);

float fnstrs(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// Cc      SAVE /HPARNT/
  return_value =
      fem::pow((1.0f - x), hipr1(47)) /
      fem::pow((fem::pow2(x) + fem::pow2(hipr1(45)) / fem::pow2(hint1(1))),
               hipr1(48));
  return return_value;
}

float wdsax(common& cmn, float const& x) {
  float return_value = fem::float0;
  /// COMMON wood
  float& r = static_cast<common_wood&>(cmn).r;
  float& w = cmn.w;
  ///
  /// C                             ********THREE PARAMETER WOOD SAXON
  /// Cc      SAVE /WOOD/
  return_value = cmn.fnorm * (1.f + w * fem::pow2((x / r))) /
                 (1 + fem::exp((x - r) / cmn.d));
  if (w < 0.f) {
    if (x >= r / fem::sqrt(fem::abs(w))) {
      return_value = 0.f;
    }
  }
  return return_value;
}

typedef float (*rwdsax_function_pointer)(common&, float const&);

float rwdsax(common& cmn, float const& x) {
  float return_value = fem::float0;
  return_value = x * x * wdsax(cmn, x);
  return return_value;
}

struct ftot_save {
  float omg;

  ftot_save() : omg(fem::float0) {}
};

typedef float (*ftot_function_pointer)(common&, float const&);

float ftot(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ftot);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  float& omg = sve.omg;
  ///
  /// Cc      SAVE /HPARNT/
  omg = omg0(cmn, x) * (hipr1(30) + hint1(11)) / hipr1(31) / 2.0f;
  return_value = 2.0f * (1.0f - fem::exp(-omg));
  return return_value;
}

struct fhin_save {
  float omg;

  fhin_save() : omg(fem::float0) {}
};

typedef float (*fhin_function_pointer)(common&, float const&);

float fhin(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fhin);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  float& omg = sve.omg;
  ///
  /// Cc      SAVE /HPARNT/
  omg = omg0(cmn, x) * (hipr1(30) + hint1(11)) / hipr1(31) / 2.0f;
  return_value = 1.0f - fem::exp(-2.0f * omg);
  return return_value;
}

struct ftotjt_save {
  float omg;

  ftotjt_save() : omg(fem::float0) {}
};

typedef float (*ftotjt_function_pointer)(common&, float const&);

float ftotjt(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ftotjt);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  float& omg = sve.omg;
  ///
  /// Cc      SAVE /HPARNT/
  omg = omg0(cmn, x) * hint1(11) / hipr1(31) / 2.0f;
  return_value = 1.0f - fem::exp(-2.0f * omg);
  return return_value;
}

struct ftotrg_save {
  float omg;

  ftotrg_save() : omg(fem::float0) {}
};

typedef float (*ftotrg_function_pointer)(common&, float const&);

float ftotrg(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(ftotrg);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  float& omg = sve.omg;
  ///
  /// Cc      SAVE /HPARNT/
  omg = omg0(cmn, x) * hint1(60) / hipr1(31) / 2.0f;
  return_value = 1.0f - fem::exp(-2.0f * omg);
  return return_value;
}

struct sgmin_save {
  float ga;
  int i;
  float z;

  sgmin_save() : ga(fem::float0), i(fem::int0), z(fem::float0) {}
};

float sgmin(common& cmn, int const& n) {
  float return_value = fem::float0;
  FEM_CMN_SVE(sgmin);
  float& ga = sve.ga;
  int& i = sve.i;
  float& z = sve.z;
  ga = 0.f;
  if (n <= 2) {
    goto statement_20;
  }
  FEM_DO_SAFE(i, 1, n - 1) {
    z = i;
    ga += fem::alog(z);
  }
statement_20:
  return_value = ga;
  return return_value;
}

struct fnjet_save {
  float c0;
  float omg1;

  fnjet_save() : c0(fem::float0), omg1(fem::float0) {}
};

typedef float (*fnjet_function_pointer)(common&, float const&);

float fnjet(common& cmn, float const& x) {
  float return_value = fem::float0;
  FEM_CMN_SVE(fnjet);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  /// COMMON njet
  int& n = static_cast<common_njet&>(cmn).n;
  ///
  /// SAVE
  float& c0 = sve.c0;
  float& omg1 = sve.omg1;
  ///
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /NJET/
  omg1 = omg0(cmn, x) * hint1(11) / hipr1(31);
  /// Clin-8/2015 could cause IEEE_UNDERFLOW, does not seem to affect results:
  c0 = fem::exp(n * fem::alog(omg1) - sgmin(cmn, n + 1));
  if (n == 0) {
    c0 = 1.0f - fem::exp(-2.0f * omg0(cmn, x) * hipr1(30) / hipr1(31) / 2.0f);
  }
  return_value = c0 * fem::exp(-omg1);
  return return_value;
}

struct gauss1_save {
  float aa;
  float bb;
  float c1;
  float c2;
  float identifier_const;
  float delta;
  int i;
  float s16;
  float s8;
  float u;
  arr<float> w;
  arr<float> x;
  float y;

  gauss1_save()
      : aa(fem::float0),
        bb(fem::float0),
        c1(fem::float0),
        c2(fem::float0),
        identifier_const(fem::float0),
        delta(fem::float0),
        i(fem::int0),
        s16(fem::float0),
        s8(fem::float0),
        u(fem::float0),
        w(dimension(12), fem::fill0),
        x(dimension(12), fem::fill0),
        y(fem::float0) {}
};

/// C
/// C*********GAUSSIAN ONE-DIMENSIONAL INTEGRATION PROGRAM*************
/// C
float gauss1(common& cmn, fhin_function_pointer f, float const& a,
             float const& b, float const& eps) {
  float return_value = fem::float0;
  FEM_CMN_SVE(gauss1);
  common_write write(cmn);
  float& aa = sve.aa;
  float& bb = sve.bb;
  float& c1 = sve.c1;
  float& c2 = sve.c2;
  float& identifier_const = sve.identifier_const;
  float& delta = sve.delta;
  int& i = sve.i;
  float& s16 = sve.s16;
  float& s8 = sve.s8;
  float& u = sve.u;
  arr_ref<float> w(sve.w, dimension(12));
  arr_ref<float> x(sve.x, dimension(12));
  float& y = sve.y;
  if (is_called_first_time) {
    identifier_const = 1.0e-12f;
    {
      static const float values[] = {
          0.1012285f, .2223810f, .3137067f, .3623838f, .0271525f, .0622535f,
          0.0951585f, .1246290f, .1495960f, .1691565f, .1826034f, .1894506f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), w;
    }
    {
      static const float values[] = {
          0.9602899f, .7966665f, .5255324f, .1834346f, .9894009f, .9445750f,
          0.8656312f, .7554044f, .6178762f, .4580168f, .2816036f, .0950125f};
      fem::data_of_type<float>(FEM_VALUES_AND_SIZE), x;
    }
  }
  /// C
  delta = identifier_const * fem::abs(a - b);
  return_value = 0.0f;
  aa = a;
statement_5:
  y = b - aa;
  if (fem::abs(y) <= delta) {
    return return_value;
  }
statement_2:
  bb = aa + y;
  c1 = 0.5f * (aa + bb);
  c2 = c1 - aa;
  s8 = 0.0f;
  s16 = 0.0f;
  FEM_DO_SAFE(i, 1, 4) {
    u = x(i) * c2;
    s8 += w(i) * (f(cmn, c1 + u) + f(cmn, c1 - u));
  }
  FEM_DO_SAFE(i, 5, 12) {
    u = x(i) * c2;
    s16 += w(i) * (f(cmn, c1 + u) + f(cmn, c1 - u));
  }
  s8 = s8 * c2;
  s16 = s16 * c2;
  if (fem::abs(s16 - s8) > eps * (1.f + fem::abs(s16))) {
    goto statement_4;
  }
  return_value += s16;
  aa = bb;
  goto statement_5;
statement_4:
  y = 0.5f * y;
  if (fem::abs(y) > delta) {
    goto statement_2;
  }
  write(6, "(1x,'GAUSS1....TOO HIGH ACURACY REQUIRED')");
  return_value = 0.0f;
  return return_value;
}

struct hifun_save {
  float fnorm;
  int j;
  float xdd;

  hifun_save() : fnorm(fem::float0), j(fem::int0), xdd(fem::float0) {}
};

/// C
/// C The next three subroutines are for Monte Carlo generation
/// C according to a given function FHB. One calls first HIFUN
/// C with assigned channel number I, low and up limits. Then to
/// C generate the distribution one can call HIRND(I) which gives
/// C you a random number generated according to the given function.
/// C
void hifun(common& cmn, int const& i, float const& xmin, float const& xmax,
           fnkc2_function_pointer fhb) {
  FEM_CMN_SVE(hifun);
  /// COMMON hijhb
  arr_ref<float, 2> rr(cmn.rr, dimension(10, 201));
  arr_ref<float, 2> xx(cmn.xx, dimension(10, 201));
  ///
  /// SAVE
  float& fnorm = sve.fnorm;
  int& j = sve.j;
  float& xdd = sve.xdd;
  ///
  /// Cc      SAVE /HIJHB/
  fnorm = gauss1(cmn, fhb, xmin, xmax, 0.001f);
  FEM_DO_SAFE(j, 1, 201) {
    xx(i, j) = xmin + (xmax - xmin) * (j - 1) / 200.0f;
    xdd = xx(i, j);
    rr(i, j) = gauss1(cmn, fhb, xmin, xdd, 0.001f) / fnorm;
  }
}

struct hijwds_save {
  float a;
  arr<float> dd;
  float fgaus;
  int i;
  arr<int> iaa;
  arr<float> rr;
  arr<float> ww;
  float xlow;

  hijwds_save()
      : a(fem::float0),
        dd(dimension(20), fem::fill0),
        fgaus(fem::float0),
        i(fem::int0),
        iaa(dimension(20), fem::fill0),
        rr(dimension(20), fem::fill0),
        ww(dimension(20), fem::fill0),
        xlow(fem::float0) {}
};

/// C
/// C ********************************************************
/// C ************************              WOOD-SAX
void hijwds(common& cmn, int const& ia, int const& idh, float& xhigh) {
  FEM_CMN_SVE(hijwds);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  /// COMMON wood
  float& r = static_cast<common_wood&>(cmn).r;
  float& d = cmn.d;
  float& fnorm = cmn.fnorm;
  float& w = cmn.w;
  ///
  /// SAVE
  float& a = sve.a;
  arr_ref<float> dd(sve.dd, dimension(20));
  float& fgaus = sve.fgaus;
  int& i = sve.i;
  arr_ref<int> iaa(sve.iaa, dimension(20));
  arr_ref<float> rr(sve.rr, dimension(20));
  arr_ref<float> ww(sve.ww, dimension(20));
  float& xlow = sve.xlow;
  ///
  if (is_called_first_time) {
    {
      fem::data_values data;
      data.values, 2, 4, 12, 16, 27, 32, 40, 56;
      data.values, 63, 93, 184, 197, 208, 7 * datum(0.f);
      data, iaa;
    }
    {
      fem::data_values data;
      data.values, 0.01f, .964f, 2.355f, 2.608f, 2.84f, 3.458f, 3.766f, 3.971f;
      data.values, 4.214f, 4.87f, 6.51f, 6.38f, 6.624f, 7 * datum(0.f);
      data, rr;
    }
    {
      fem::data_values data;
      data.values, 0.5882f, .322f, .522f, .513f, .569f, .61f, .586f, .5935f;
      data.values, .586f, .573f, .535f, .535f, .549f, 7 * datum(0.f);
      data, dd;
    }
    fem::data((values, 0.0f, .517f, -0.149f, -0.051f, 0.f, -0.208f, -0.161f,
               13 * datum(0.f))),
        ww;
  }
  /// C     SETS UP HISTOGRAM IDH WITH RADII FOR
  /// C     NUCLEUS IA DISTRIBUTED ACCORDING TO THREE PARAM WOOD SAXON
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /WOOD/
  /// C        DIMENSION IAA(20),RR(20),DD(20),WW(20),RMS(20)
  /// C
  /// C   PARAMETERS OF SPECIAL NUCLEI FROM ATOMIC DATA AND NUC DATA TABLES
  /// C     VOL 14, 5-6 1974
  /// C        DATA RMS/2.11,1.71,2.46,2.73,3.05,3.247,3.482,3.737,3.925,4.31,
  /// C     1        5.42,5.33,5.521,7*0./
  /// C
  a = ia;
  /// C
  /// C                 ********SET WOOD-SAX PARAMS FIRST  AS IN DATE ET AL
  d = 0.54f;
  /// C                        ********D IS WOOD SAX DIFFUSE PARAM IN FM
  r = 1.19f * fem::pow(a, (1.f / 3.f)) - 1.61f * fem::pow(a, (-1.f / 3.f));
  /// C                         ********R IS RADIUS PARAM
  w = 0.f;
  /// C                 ********W IS The third of three WOOD-SAX PARAM
  /// C
  /// C                      ********CHECK TABLE FOR SPECIAL CASES
  FEM_DO_SAFE(i, 1, 13) {
    if (ia == iaa(i)) {
      r = rr(i);
      d = dd(i);
      w = ww(i);
      /// Clin RS not used                              RS=RMS(I)
    }
  }
  /// C                             ********FNORM is the normalize factor
  fnorm = 1.0f;
  xlow = 0.f;
  xhigh = r + 12.f * d;
  if (w < -0.01f) {
    if (xhigh > r / fem::sqrt(fem::abs(w))) {
      xhigh = r / fem::sqrt(fem::abs(w));
    }
  }
  fgaus = gauss1(cmn, rwdsax, xlow, xhigh, 0.001f);
  fnorm = 1.f / fgaus;
  /// C
  if (idh == 1) {
    hint1(72) = r;
    hint1(73) = d;
    hint1(74) = w;
    hint1(75) = fnorm / 4.0f / hipr1(40);
  } else if (idh == 2) {
    hint1(76) = r;
    hint1(77) = d;
    hint1(78) = w;
    hint1(79) = fnorm / 4.0f / hipr1(40);
  }
  /// C
  /// C             NOW SET UP HBOOK FUNCTIONS IDH FOR  R**2*RHO(R)
  /// C             THESE HISTOGRAMS ARE USED TO GENERATE RANDOM RADII
  hifun(cmn, idh, xlow, xhigh, rwdsax);
}

double subcr1(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value = 4.e0 / 9.e0 * (1.e0 + fem::pow2(u)) / fem::pow2(t);
  return return_value;
}

double subcr2(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value = 4.e0 / 9.e0 * (fem::pow2(t) + fem::pow2(u));
  return return_value;
}

double subcr3(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value =
      4.e0 / 9.e0 *
      (fem::pow2(t) + fem::pow2(u) + (1.e0 + fem::pow2(u)) / fem::pow2(t) -
       2.e0 * fem::pow2(u) / 3.e0 / t);
  return return_value;
}

double subcr4(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value = 8.e0 / 3.e0 * (fem::pow2(t) + fem::pow2(u)) *
                 (4.e0 / 9.e0 / t / u - 1.e0);
  return return_value;
}

double subcr5(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value = 3.e0 / 8.e0 * (fem::pow2(t) + fem::pow2(u)) *
                 (4.e0 / 9.e0 / t / u - 1.e0);
  return return_value;
}

double subcr6(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value =
      (1.e0 + fem::pow2(u)) * (1.e0 / fem::pow2(t) - 4.e0 / u / 9.e0);
  return return_value;
}

double subcr7(double const& t, double const& u) {
  double return_value = fem::double0;
  return_value =
      9.e0 / 2.e0 * (3.e0 - t * u - u / fem::pow2(t) - t / fem::pow2(u));
  return return_value;
}

struct gmre_save {
  double z;

  gmre_save() : z(fem::double0) {}
};

double gmre(common& cmn, double const& x) {
  double return_value = fem::double0;
  FEM_CMN_SVE(gmre);
  double& z = sve.z;
  z = x;
  if (x > 3.0e0) {
    goto statement_10;
  }
  z = x + 3.e0;
statement_10:
  return_value =
      0.5e0 * fem::dlog(2.e0 * 3.14159265e0 / z) + z * fem::dlog(z) - z +
      fem::dlog(1.e0 + 1.e0 / 12.e0 / z + 1.e0 / 288.e0 / fem::pow2(z) -
                139.e0 / 51840.e0 / fem::pow3(z) -
                571.e0 / 2488320.e0 / fem::pow4(z));
  if (z == x) {
    goto statement_20;
  }
  return_value = return_value - fem::dlog(z - 1.e0) - fem::dlog(z - 2.e0) -
                 fem::dlog(z - 3.e0);
statement_20:
  return return_value;
}

struct parton_save {
  double aax;
  double ag;
  double aphg;
  double aphs;
  double as;
  double at1;
  double at2;
  double at3;
  double at4;
  double b12;
  double b34;
  double bg;
  double bs;
  double btag;
  double btas;
  double cag;
  double cas;
  double cnd;
  double cnud;
  double dlam;
  double fs1;
  double fs2;
  double fud1;
  double fud2;
  double gmd;
  double gmg;
  double gms;
  double gmud;
  int i;
  double q0;
  double rrx;
  double s;

  parton_save()
      : aax(fem::double0),
        ag(fem::double0),
        aphg(fem::double0),
        aphs(fem::double0),
        as(fem::double0),
        at1(fem::double0),
        at2(fem::double0),
        at3(fem::double0),
        at4(fem::double0),
        b12(fem::double0),
        b34(fem::double0),
        bg(fem::double0),
        bs(fem::double0),
        btag(fem::double0),
        btas(fem::double0),
        cag(fem::double0),
        cas(fem::double0),
        cnd(fem::double0),
        cnud(fem::double0),
        dlam(fem::double0),
        fs1(fem::double0),
        fs2(fem::double0),
        fud1(fem::double0),
        fud2(fem::double0),
        gmd(fem::double0),
        gmg(fem::double0),
        gms(fem::double0),
        gmud(fem::double0),
        i(fem::int0),
        q0(fem::double0),
        rrx(fem::double0),
        s(fem::double0) {}
};

void parton(common& cmn, arr_ref<double, 2> f, double const& x1,
            double const& x2, double const& qq) {
  FEM_CMN_SVE(parton);
  f(dimension(2, 7));
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  int& ipcrs = cmn.ipcrs;
  double& dshadow = cmn.dshadow;
  int& ishadow = cmn.ishadow;
  ///
  double& aax = sve.aax;
  double& ag = sve.ag;
  double& aphg = sve.aphg;
  double& aphs = sve.aphs;
  double& as = sve.as;
  double& at1 = sve.at1;
  double& at2 = sve.at2;
  double& at3 = sve.at3;
  double& at4 = sve.at4;
  double& b12 = sve.b12;
  double& b34 = sve.b34;
  double& bg = sve.bg;
  double& bs = sve.bs;
  double& btag = sve.btag;
  double& btas = sve.btas;
  double& cag = sve.cag;
  double& cas = sve.cas;
  double& cnd = sve.cnd;
  double& cnud = sve.cnud;
  double& dlam = sve.dlam;
  double& fs1 = sve.fs1;
  double& fs2 = sve.fs2;
  double& fud1 = sve.fud1;
  double& fud2 = sve.fud2;
  double& gmd = sve.gmd;
  double& gmg = sve.gmg;
  double& gms = sve.gms;
  double& gmud = sve.gmud;
  int& i = sve.i;
  double& q0 = sve.q0;
  double& rrx = sve.rrx;
  double& s = sve.s;
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /NJET/
  /// Clin-7/2009:
  dlam = fem::dble(hipr1(15));
  q0 = fem::dble(hipr1(16));
  s = fem::dlog(fem::dlog(qq / fem::pow2(dlam)) /
                fem::dlog(fem::pow2(q0) / fem::pow2(dlam)));
  if (ihpr2(7) == 2) {
    goto statement_200;
  }
  /// C*******************************************************
  at1 = 0.419e0 + 0.004e0 * s - 0.007e0 * fem::pow2(s);
  at2 = 3.460e0 + 0.724e0 * s - 0.066e0 * fem::pow2(s);
  gmud = 4.40e0 - 4.86e0 * s + 1.33e0 * fem::pow2(s);
  at3 = 0.763e0 - 0.237e0 * s + 0.026e0 * fem::pow2(s);
  at4 = 4.00e0 + 0.627e0 * s - 0.019e0 * fem::pow2(s);
  gmd = -0.421e0 * s + 0.033e0 * fem::pow2(s);
  /// C*******************************************************
  cas = 1.265e0 - 1.132e0 * s + 0.293e0 * fem::pow2(s);
  as = -0.372e0 * s - 0.029e0 * fem::pow2(s);
  bs = 8.05e0 + 1.59e0 * s - 0.153e0 * fem::pow2(s);
  aphs = 6.31e0 * s - 0.273e0 * fem::pow2(s);
  btas = -10.5e0 * s - 3.17e0 * fem::pow2(s);
  gms = 14.7e0 * s + 9.80e0 * fem::pow2(s);
  /// C********************************************************
  /// C        CAC=0.135*S-0.075*S**2
  /// C        AC=-0.036-0.222*S-0.058*S**2
  /// C        BC=6.35+3.26*S-0.909*S**2
  /// C        APHC=-3.03*S+1.50*S**2
  /// C        BTAC=17.4*S-11.3*S**2
  /// C        GMC=-17.9*S+15.6*S**2
  /// C***********************************************************
  cag = 1.56e0 - 1.71e0 * s + 0.638e0 * fem::pow2(s);
  ag = -0.949e0 * s + 0.325e0 * fem::pow2(s);
  bg = 6.0e0 + 1.44e0 * s - 1.05e0 * fem::pow2(s);
  aphg = 9.0e0 - 7.19e0 * s + 0.255e0 * fem::pow2(s);
  btag = -16.5e0 * s + 10.9e0 * fem::pow2(s);
  gmg = 15.3e0 * s - 10.1e0 * fem::pow2(s);
  goto statement_300;
/// C********************************************************
statement_200:
  at1 = 0.374e0 + 0.014e0 * s;
  at2 = 3.33e0 + 0.753e0 * s - 0.076e0 * fem::pow2(s);
  gmud = 6.03e0 - 6.22e0 * s + 1.56e0 * fem::pow2(s);
  at3 = 0.761e0 - 0.232e0 * s + 0.023e0 * fem::pow2(s);
  at4 = 3.83e0 + 0.627e0 * s - 0.019e0 * fem::pow2(s);
  gmd = -0.418e0 * s + 0.036e0 * fem::pow2(s);
  /// C************************************
  cas = 1.67e0 - 1.92e0 * s + 0.582e0 * fem::pow2(s);
  as = -0.273e0 * s - 0.164e0 * fem::pow2(s);
  bs = 9.15e0 + 0.530e0 * s - 0.763e0 * fem::pow2(s);
  aphs = 15.7e0 * s - 2.83e0 * fem::pow2(s);
  btas = -101.0e0 * s + 44.7e0 * fem::pow2(s);
  gms = 223.0e0 * s - 117.0e0 * fem::pow2(s);
  /// C*********************************
  /// C        CAC=0.067*S-0.031*S**2
  /// C        AC=-0.120-0.233*S-0.023*S**2
  /// C        BC=3.51+3.66*S-0.453*S**2
  /// C        APHC=-0.474*S+0.358*S**2
  /// C        BTAC=9.50*S-5.43*S**2
  /// C        GMC=-16.6*S+15.5*S**2
  /// C**********************************
  cag = 0.879e0 - 0.971e0 * s + 0.434e0 * fem::pow2(s);
  ag = -1.16e0 * s + 0.476e0 * fem::pow2(s);
  bg = 4.0e0 + 1.23e0 * s - 0.254e0 * fem::pow2(s);
  aphg = 9.0e0 - 5.64e0 * s - 0.817e0 * fem::pow2(s);
  btag = -7.54e0 * s + 5.50e0 * fem::pow2(s);
  gmg = -0.596e0 * s + 1.26e0 * fem::pow2(s);
/// C*********************************
statement_300:
  b12 = fem::dexp(gmre(cmn, at1) + gmre(cmn, at2 + 1.e0) -
                  gmre(cmn, at1 + at2 + 1.e0));
  b34 = fem::dexp(gmre(cmn, at3) + gmre(cmn, at4 + 1.e0) -
                  gmre(cmn, at3 + at4 + 1.e0));
  cnud = 3.e0 / b12 / (1.e0 + gmud * at1 / (at1 + at2 + 1.e0));
  cnd = 1.e0 / b34 / (1.e0 + gmd * at3 / (at3 + at4 + 1.e0));
  /// C********************************************************
  /// C        FUD=X*(U+D)
  /// C        FS=X*2(UBAR+DBAR+SBAR)  AND UBAR=DBAR=SBAR
  /// C*******************************************************
  fud1 = cnud * fem::pow(x1, at1) * fem::pow((1.e0 - x1), at2) *
         (1.e0 + gmud * x1);
  fs1 = cas * fem::pow(x1, as) * fem::pow((1.e0 - x1), bs) *
        (1.e0 + aphs * x1 + btas * fem::pow2(x1) + gms * fem::pow3(x1));
  f(1, 3) =
      cnd * fem::pow(x1, at3) * fem::pow((1.e0 - x1), at4) * (1.e0 + gmd * x1) +
      fs1 / 6.e0;
  f(1, 1) = fud1 - f(1, 3) + fs1 / 3.e0;
  f(1, 2) = fs1 / 6.e0;
  f(1, 4) = fs1 / 6.e0;
  f(1, 5) = fs1 / 6.e0;
  f(1, 6) = fs1 / 6.e0;
  f(1, 7) = cag * fem::pow(x1, ag) * fem::pow((1.e0 - x1), bg) *
            (1.e0 + aphg * x1 + btag * fem::pow2(x1) + gmg * fem::pow3(x1));
  /// C
  fud2 = cnud * fem::pow(x2, at1) * fem::pow((1.e0 - x2), at2) *
         (1.e0 + gmud * x2);
  fs2 = cas * fem::pow(x2, as) * fem::pow((1.e0 - x2), bs) *
        (1.e0 + aphs * x2 + btas * fem::pow2(x2) + gms * fem::pow3(x2));
  f(2, 3) =
      cnd * fem::pow(x2, at3) * fem::pow((1.e0 - x2), at4) * (1.e0 + gmd * x2) +
      fs2 / 6.e0;
  f(2, 1) = fud2 - f(2, 3) + fs2 / 3.e0;
  f(2, 2) = fs2 / 6.e0;
  f(2, 4) = fs2 / 6.e0;
  f(2, 5) = fs2 / 6.e0;
  f(2, 6) = fs2 / 6.e0;
  f(2, 7) = cag * fem::pow(x2, ag) * fem::pow((1.e0 - x2), bg) *
            (1.e0 + aphg * x2 + btag * fem::pow2(x2) + gmg * fem::pow3(x2));
  /// C***********Nuclear effect on the structure function****************
  /// C
  if (ihpr2(6) == 1 && ihnt2(1) > 1) {
    aax = 1.193e0 *
          fem::dble(fem::pow(fem::alog(fem::ffloat(ihnt2(1))), 0.16666666f));
    rrx = aax * (fem::pow3(x1) - 1.2e0 * fem::pow2(x1) + 0.21e0 * x1) + 1.e0 +
          fem::dble(1.079f *
                    (fem::pow(fem::ffloat(ihnt2(1)), 0.33333333f) - 1.0f)) /
              fem::dble(fem::alog(fem::ffloat(ihnt2(1)) + 1.0f)) *
              fem::dsqrt(x1) * fem::dexp(-fem::pow2(x1) / 0.01e0);
    /// Clin-8/2015 DEXP() above may cause IEEE_UNDERFLOW,
    /// C     does not seem to affect results.
    /// C     &          /DLOG(IHNT2(1)+1.0D0)*(DSQRT(X1)*DEXP(-X1**2/0.01)
    /// Clin-7/2009 enable users to modify nuclear shadowing:
    if (ishadow == 1) {
      rrx = 1.e0 + dshadow * (rrx - 1.e0);
    }
    if (ipcrs == 1 || ipcrs == 3) {
      rrx = fem::dexp(-fem::pow2(x1) / 0.01e0);
    }
    /// Clin-7/2009:
    if ((ipcrs == 1 || ipcrs == 3) && ishadow == 1) {
      rrx = fem::dexp(-fem::pow2(x1) / 0.01e0) * dshadow;
    }
    FEM_DO_SAFE(i, 1, 7) { f(1, i) = rrx * f(1, i); }
  }
  if (ihpr2(6) == 1 && ihnt2(3) > 1) {
    aax = 1.193e0 *
          fem::dble(fem::pow(fem::alog(fem::ffloat(ihnt2(3))), 0.16666666f));
    rrx =
        aax * (fem::pow3(x2) - 1.2e0 * fem::pow2(x2) + 0.21e0 * x2) + 1.e0 +
        fem::dble(1.079f * (fem::pow(fem::ffloat(ihnt2(3)), 0.33333f) - 1.0f)) /
            fem::dble(fem::alog(fem::ffloat(ihnt2(3)) + 1.0f)) *
            fem::dsqrt(x2) * fem::dexp(-fem::pow2(x2) / 0.01e0);
    /// C     &         /DLOG(IHNT2(3)+1.0D0)*DSQRT(X2)*DEXP(-X2**2/0.01)
    /// Clin-7/2009:
    if (ishadow == 1) {
      rrx = 1.e0 + dshadow * (rrx - 1.e0);
    }
    if (ipcrs == 2 || ipcrs == 3) {
      rrx = fem::dexp(-fem::pow2(x2) / 0.01e0);
    }
    /// Clin-7/2009:
    if ((ipcrs == 2 || ipcrs == 3) && ishadow == 1) {
      rrx = fem::dexp(-fem::pow2(x2) / 0.01e0) * dshadow;
    }
    FEM_DO_SAFE(i, 1, 7) { f(2, i) = rrx * f(2, i); }
  }
  /// C
}

struct g_save {
  double af;
  double aph;
  double dlam;
  arr<double, 2> f;
  double g11;
  double g12;
  double g13;
  double g2;
  double g31;
  double g32;
  double g4;
  double g5;
  double g61;
  double g62;
  double g7;
  double ss;
  double t;
  double u;
  double x1;
  double x2;
  double xt;
  double z;

  g_save()
      : af(fem::double0),
        aph(fem::double0),
        dlam(fem::double0),
        f(dimension(2, 7), fem::fill0),
        g11(fem::double0),
        g12(fem::double0),
        g13(fem::double0),
        g2(fem::double0),
        g31(fem::double0),
        g32(fem::double0),
        g4(fem::double0),
        g5(fem::double0),
        g61(fem::double0),
        g62(fem::double0),
        g7(fem::double0),
        ss(fem::double0),
        t(fem::double0),
        u(fem::double0),
        x1(fem::double0),
        x2(fem::double0),
        xt(fem::double0),
        z(fem::double0) {}
};

double g(common& cmn, double const& y1, double const& y2, double const& pt2) {
  double return_value = fem::double0;
  FEM_CMN_SVE(g);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  double& af = sve.af;
  double& aph = sve.aph;
  double& dlam = sve.dlam;
  arr_ref<double, 2> f(sve.f, dimension(2, 7));
  double& g11 = sve.g11;
  double& g12 = sve.g12;
  double& g13 = sve.g13;
  double& g2 = sve.g2;
  double& g31 = sve.g31;
  double& g32 = sve.g32;
  double& g4 = sve.g4;
  double& g5 = sve.g5;
  double& g61 = sve.g61;
  double& g62 = sve.g62;
  double& g7 = sve.g7;
  double& ss = sve.ss;
  double& t = sve.t;
  double& u = sve.u;
  double& x1 = sve.x1;
  double& x2 = sve.x2;
  double& xt = sve.xt;
  double& z = sve.z;
  ///
  /// Cc      SAVE /HPARNT/
  xt = 2.e0 * fem::dsqrt(pt2) / fem::dble(hint1(1));
  x1 = 0.5e0 * xt * (fem::dexp(y1) + fem::dexp(y2));
  x2 = 0.5e0 * xt * (fem::dexp(-y1) + fem::dexp(-y2));
  z = fem::dsqrt(1.e0 - fem::pow2(xt) / x1 / x2);
  ss = x1 * x2 * fem::pow2(fem::dble(hint1(1)));
  t = -(1.e0 - z) / 2.e0;
  u = -(1.e0 + z) / 2.e0;
  af = 3.e0;
  dlam = fem::dble(hipr1(15));
  aph = 12.e0 * 3.1415926e0 / (33.e0 - 2.e0 * af) /
        fem::dlog(pt2 / fem::pow2(dlam));
  /// C
  parton(cmn, f, x1, x2, pt2);
  /// C
  g11 = ((f(1, 1) + f(1, 2)) * (f(2, 3) + f(2, 4) + f(2, 5) + f(2, 6)) +
         (f(1, 3) + f(1, 4)) * (f(2, 5) + f(2, 6))) *
        subcr1(t, u);
  /// C
  g12 = ((f(2, 1) + f(2, 2)) * (f(1, 3) + f(1, 4) + f(1, 5) + f(1, 6)) +
         (f(2, 3) + f(2, 4)) * (f(1, 5) + f(1, 6))) *
        subcr1(u, t);
  /// C
  g13 = (f(1, 1) * f(2, 1) + f(1, 2) * f(2, 2) + f(1, 3) * f(2, 3) +
         f(1, 4) * f(2, 4) + f(1, 5) * f(2, 5) + f(1, 6) * f(2, 6)) *
        (subcr1(u, t) + subcr1(t, u) - 8.e0 / t / u / 27.e0);
  /// C
  g2 = (af - 1) *
       (f(1, 1) * f(2, 2) + f(2, 1) * f(1, 2) + f(1, 3) * f(2, 4) +
        f(2, 3) * f(1, 4) + f(1, 5) * f(2, 6) + f(2, 5) * f(1, 6)) *
       subcr2(t, u);
  /// C
  g31 = (f(1, 1) * f(2, 2) + f(1, 3) * f(2, 4) + f(1, 5) * f(2, 6)) *
        subcr3(t, u);
  g32 = (f(2, 1) * f(1, 2) + f(2, 3) * f(1, 4) + f(2, 5) * f(1, 6)) *
        subcr3(u, t);
  /// C
  g4 = (f(1, 1) * f(2, 2) + f(2, 1) * f(1, 2) + f(1, 3) * f(2, 4) +
        f(2, 3) * f(1, 4) + f(1, 5) * f(2, 6) + f(2, 5) * f(1, 6)) *
       subcr4(t, u);
  /// C
  g5 = af * f(1, 7) * f(2, 7) * subcr5(t, u);
  /// C
  g61 = f(1, 7) * (f(2, 1) + f(2, 2) + f(2, 3) + f(2, 4) + f(2, 5) + f(2, 6)) *
        subcr6(t, u);
  g62 = f(2, 7) * (f(1, 1) + f(1, 2) + f(1, 3) + f(1, 4) + f(1, 5) + f(1, 6)) *
        subcr6(u, t);
  /// C
  g7 = f(1, 7) * f(2, 7) * subcr7(t, u);
  /// C
  return_value = (g11 + g12 + g13 + g2 + g31 + g32 + g4 + g5 + g61 + g62 + g7) *
                 fem::dble(hipr1(17)) * 3.14159e0 * fem::pow2(aph) /
                 fem::pow2(ss);
  return return_value;
}

struct fjet_save {
  double pt2;
  double xt;
  double y1;
  double y2;
  double ymn2;
  double ymx1;
  double ymx2;

  fjet_save()
      : pt2(fem::double0),
        xt(fem::double0),
        y1(fem::double0),
        y2(fem::double0),
        ymn2(fem::double0),
        ymx1(fem::double0),
        ymx2(fem::double0) {}
};

typedef double (*fjet_function_pointer)(common&, arr_cref<double>,
                                        double const&);

double fjet(common& cmn, arr_cref<double> x, double const& /* wgt */) {
  double return_value = fem::double0;
  FEM_CMN_SVE(fjet);
  x(dimension(10));
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  double& pt2 = sve.pt2;
  double& xt = sve.xt;
  double& y1 = sve.y1;
  double& y2 = sve.y2;
  double& ymn2 = sve.ymn2;
  double& ymx1 = sve.ymx1;
  double& ymx2 = sve.ymx2;
  ///
  /// Cc      SAVE /HPARNT/
  pt2 = fem::dble(fem::pow2(hint1(1)) / 4.0f - fem::pow2(hipr1(8))) * x(1) +
        fem::pow2(fem::dble(hipr1(8)));
  xt = 2.0e0 * fem::dsqrt(pt2) / fem::dble(hint1(1));
  ymx1 = fem::dlog(1.0e0 / xt + fem::dsqrt(1.0e0 / fem::pow2(xt) - 1.0e0));
  y1 = 2.0e0 * ymx1 * x(2) - ymx1;
  ymx2 = fem::dlog(2.0e0 / xt - fem::dexp(y1));
  ymn2 = fem::dlog(2.0e0 / xt - fem::dexp(-y1));
  y2 = (ymx2 + ymn2) * x(3) - ymn2;
  return_value = 2.0e0 * ymx1 * (ymx2 + ymn2) *
                 fem::dble(fem::pow2(hint1(1)) / 4.0f - fem::pow2(hipr1(8))) *
                 g(cmn, y1, y2, pt2) / 2.0e0;
  return return_value;
}

struct ghvq_save {
  double af;
  double aph;
  double dlam;
  arr<double, 2> f;
  double ggg;
  double gqq;
  double ss;
  double x1;
  double x2;
  double xt;

  ghvq_save()
      : af(fem::double0),
        aph(fem::double0),
        dlam(fem::double0),
        f(dimension(2, 7), fem::fill0),
        ggg(fem::double0),
        gqq(fem::double0),
        ss(fem::double0),
        x1(fem::double0),
        x2(fem::double0),
        xt(fem::double0) {}
};

double ghvq(common& cmn, double const& y1, double const& y2,
            double const& amt2) {
  double return_value = fem::double0;
  FEM_CMN_SVE(ghvq);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  double& af = sve.af;
  double& aph = sve.aph;
  double& dlam = sve.dlam;
  arr_ref<double, 2> f(sve.f, dimension(2, 7));
  double& ggg = sve.ggg;
  double& gqq = sve.gqq;
  double& ss = sve.ss;
  double& x1 = sve.x1;
  double& x2 = sve.x2;
  double& xt = sve.xt;
  ///
  /// Cc      SAVE /HPARNT/
  xt = 2.0e0 * fem::dsqrt(amt2) / fem::dble(hint1(1));
  x1 = 0.5e0 * xt * (fem::dexp(y1) + fem::dexp(y2));
  x2 = 0.5e0 * xt * (fem::dexp(-y1) + fem::dexp(-y2));
  ss = x1 * x2 * fem::pow2(fem::dble(hint1(1)));
  af = 4.0e0;
  if (ihpr2(18) != 0) {
    af = 5.0e0;
  }
  dlam = fem::dble(hipr1(15));
  aph = 12.0e0 * 3.1415926e0 / (33.e0 - 2.e0 * af) /
        fem::dlog(amt2 / fem::pow2(dlam));
  /// C
  parton(cmn, f, x1, x2, amt2);
  /// C
  gqq = 4.e0 * (dcosh(y1 - y2) + fem::pow2(fem::dble(hipr1(7))) / amt2) /
        (1.e0 + dcosh(y1 - y2)) / 9.e0 *
        (f(1, 1) * f(2, 2) + f(1, 2) * f(2, 1) + f(1, 3) * f(2, 4) +
         f(1, 4) * f(2, 3) + f(1, 5) * f(2, 6) + f(1, 6) * f(2, 5));
  ggg = (8.e0 * dcosh(y1 - y2) - 1.e0) *
        (dcosh(y1 - y2) + 2.e0 * fem::pow2(fem::dble(hipr1(7))) / amt2 -
         2.e0 * fem::pow4(fem::dble(hipr1(7))) / fem::pow2(amt2)) /
        (1.e0 + dcosh(y1 - y2)) / 24.e0 * f(1, 7) * f(2, 7);
  /// C
  return_value = (gqq + ggg) * fem::dble(hipr1(23)) * 3.14159e0 *
                 fem::pow2(aph) / fem::pow2(ss);
  return return_value;
}

struct gphotn_save {
  double af;
  double aph;
  double aphem;
  double dlam;
  arr<double, 2> f;
  double g11;
  double g12;
  double g2;
  double ss;
  double t;
  double u;
  double x1;
  double x2;
  double xt;
  double z;

  gphotn_save()
      : af(fem::double0),
        aph(fem::double0),
        aphem(fem::double0),
        dlam(fem::double0),
        f(dimension(2, 7), fem::fill0),
        g11(fem::double0),
        g12(fem::double0),
        g2(fem::double0),
        ss(fem::double0),
        t(fem::double0),
        u(fem::double0),
        x1(fem::double0),
        x2(fem::double0),
        xt(fem::double0),
        z(fem::double0) {}
};

double gphotn(common& cmn, double const& y1, double const& y2,
              double const& pt2) {
  double return_value = fem::double0;
  FEM_CMN_SVE(gphotn);
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  double& af = sve.af;
  double& aph = sve.aph;
  double& aphem = sve.aphem;
  double& dlam = sve.dlam;
  arr_ref<double, 2> f(sve.f, dimension(2, 7));
  double& g11 = sve.g11;
  double& g12 = sve.g12;
  double& g2 = sve.g2;
  double& ss = sve.ss;
  double& t = sve.t;
  double& u = sve.u;
  double& x1 = sve.x1;
  double& x2 = sve.x2;
  double& xt = sve.xt;
  double& z = sve.z;
  ///
  /// Cc      SAVE /HPARNT/
  xt = 2.e0 * fem::dsqrt(pt2) / fem::dble(hint1(1));
  x1 = 0.5e0 * xt * (fem::dexp(y1) + fem::dexp(y2));
  x2 = 0.5e0 * xt * (fem::dexp(-y1) + fem::dexp(-y2));
  z = fem::dsqrt(1.e0 - fem::pow2(xt) / x1 / x2);
  ss = x1 * x2 * fem::pow2(fem::dble(hint1(1)));
  t = -(1.e0 - z) / 2.e0;
  u = -(1.e0 + z) / 2.e0;
  af = 3.e0;
  dlam = fem::dble(hipr1(15));
  aph = 12.e0 * 3.1415926e0 / (33.e0 - 2.e0 * af) /
        fem::dlog(pt2 / fem::pow2(dlam));
  aphem = 1.e0 / 137.e0;
  /// C
  parton(cmn, f, x1, x2, pt2);
  /// C
  g11 = -(fem::pow2(u) + 1.e0) / u / 3.e0 * f(1, 7) *
        (4.e0 * f(2, 1) + 4.e0 * f(2, 2) + f(2, 3) + f(2, 4) + f(2, 5) +
         f(2, 6)) /
        9.e0;
  g12 = -(fem::pow2(t) + 1.e0) / t / 3.e0 * f(2, 7) *
        (4.e0 * f(1, 1) + 4.e0 * f(1, 2) + f(1, 3) + f(1, 4) + f(1, 5) +
         f(1, 6)) /
        9.e0;
  g2 =
      8.e0 * (fem::pow2(u) + fem::pow2(t)) / u / t / 9.e0 *
      (4.e0 * f(1, 1) * f(2, 2) + 4.e0 * f(1, 2) * f(2, 1) + f(1, 3) * f(2, 4) +
       f(1, 4) * f(2, 3) + f(1, 5) * f(2, 6) + f(1, 6) * f(2, 5)) /
      9.e0;
  /// C
  return_value = (g11 + g12 + g2) * fem::dble(hipr1(23)) * 3.14159e0 * aph *
                 aphem / fem::pow2(ss);
  return return_value;
}

struct fjetrg_save {
  double am2;
  double amt2;
  double gtrig;
  double pt2;
  float ptmax;
  float ptmin;
  double xt;
  double y1;
  double y2;
  double ymn2;
  double ymx1;
  double ymx2;

  fjetrg_save()
      : am2(fem::double0),
        amt2(fem::double0),
        gtrig(fem::double0),
        pt2(fem::double0),
        ptmax(fem::float0),
        ptmin(fem::float0),
        xt(fem::double0),
        y1(fem::double0),
        y2(fem::double0),
        ymn2(fem::double0),
        ymx1(fem::double0),
        ymx2(fem::double0) {}
};

typedef double (*fjetrg_function_pointer)(common&, arr_cref<double>,
                                          double const&);

double fjetrg(common& cmn, arr_cref<double> x, double const& /* wgt */) {
  double return_value = fem::double0;
  FEM_CMN_SVE(fjetrg);
  x(dimension(10));
  /// COMMON hparnt
  arr_cref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_cref<float> hint1(cmn.hint1, dimension(100));
  ///
  /// SAVE
  double& am2 = sve.am2;
  double& amt2 = sve.amt2;
  double& gtrig = sve.gtrig;
  double& pt2 = sve.pt2;
  float& ptmax = sve.ptmax;
  float& ptmin = sve.ptmin;
  double& xt = sve.xt;
  double& y1 = sve.y1;
  double& y2 = sve.y2;
  double& ymn2 = sve.ymn2;
  double& ymx1 = sve.ymx1;
  double& ymx2 = sve.ymx2;
  ///
  /// Cc      SAVE /HPARNT/
  ptmin = fem::abs(hipr1(10)) - 0.25f;
  ptmin = fem::max(ptmin, hipr1(8));
  am2 = 0.e0;
  if (ihpr2(3) == 3) {
    am2 = fem::dble(fem::pow2(hipr1(7)));
    ptmin = fem::max(0.0f, hipr1(10));
  }
  ptmax = fem::abs(hipr1(10)) + 0.25f;
  if (hipr1(10) <= 0.0f) {
    ptmax = hint1(1) / 2.0f - fem::sngl(am2);
  }
  if (ptmax <= ptmin) {
    ptmax = ptmin + 0.25f;
  }
  pt2 = fem::dble(fem::pow2(ptmax) - fem::pow2(ptmin)) * x(1) +
        fem::pow2(fem::dble(ptmin));
  amt2 = pt2 + am2;
  xt = 2.0e0 * fem::dsqrt(amt2) / fem::dble(hint1(1));
  ymx1 = fem::dlog(1.0e0 / xt + fem::dsqrt(1.0e0 / fem::pow2(xt) - 1.0e0));
  y1 = 2.0e0 * ymx1 * x(2) - ymx1;
  ymx2 = fem::dlog(2.0e0 / xt - fem::dexp(y1));
  ymn2 = fem::dlog(2.0e0 / xt - fem::dexp(-y1));
  y2 = (ymx2 + ymn2) * x(3) - ymn2;
  if (ihpr2(3) == 3) {
    gtrig = 2.0e0 * ghvq(cmn, y1, y2, amt2);
  } else if (ihpr2(3) == 2) {
    gtrig = 2.0e0 * gphotn(cmn, y1, y2, pt2);
  } else {
    gtrig = g(cmn, y1, y2, pt2);
  }
  return_value = 2.0e0 * ymx1 * (ymx2 + ymn2) *
                 fem::dble(fem::pow2(ptmax) - fem::pow2(ptmin)) * gtrig / 2.0e0;
  return return_value;
}

struct aran9_save {
  int i;

  aran9_save() : i(fem::int0) {}
};

void aran9(common& cmn, arr_ref<float> qran, int const& ndim) {
  FEM_CMN_SVE(aran9);
  qran(dimension(10));
  /// SAVE
  int& i = sve.i;
  ///
  FEM_DO_SAFE(i, 1, ndim) { qran(i) = ranart(cmn.num1); }
}

struct vegas_save {
  double alph;
  double calls;
  arr<double, 2> d;
  arr<double, 2> di;
  double dr;
  arr<double> dt;
  double dv2g;
  arr<double> dx;
  double dxg;
  double f2;
  double f2b;
  double fb;
  int i;
  arr<int> ia;
  int j;
  int k;
  arr<int> kg;
  int mds;
  int nd;
  int ndm;
  int ndmx;
  int ng;
  int npg;
  double one;
  arr<float> qran;
  arr<double> r;
  double rc;
  double ti2;
  double wgt;
  arr<double> x;
  arr<double> xin;
  double xjac;
  double xn;
  double xnd;
  double xo;

  vegas_save()
      : alph(fem::double0),
        calls(fem::double0),
        d(dimension(50, 10), fem::fill0),
        di(dimension(50, 10), fem::fill0),
        dr(fem::double0),
        dt(dimension(10), fem::fill0),
        dv2g(fem::double0),
        dx(dimension(10), fem::fill0),
        dxg(fem::double0),
        f2(fem::double0),
        f2b(fem::double0),
        fb(fem::double0),
        i(fem::int0),
        ia(dimension(10), fem::fill0),
        j(fem::int0),
        k(fem::int0),
        kg(dimension(10), fem::fill0),
        mds(fem::int0),
        nd(fem::int0),
        ndm(fem::int0),
        ndmx(fem::int0),
        ng(fem::int0),
        npg(fem::int0),
        one(fem::double0),
        qran(dimension(10), fem::fill0),
        r(dimension(50), fem::fill0),
        rc(fem::double0),
        ti2(fem::double0),
        wgt(fem::double0),
        x(dimension(10), fem::fill0),
        xin(dimension(50), fem::fill0),
        xjac(fem::double0),
        xn(fem::double0),
        xnd(fem::double0),
        xo(fem::double0) {}
};

/// C*******************************************************************
/// C
/// C*******************************************************************
/// C   SUBROUTINE PERFORMS N-DIMENSIONAL MONTE CARLO INTEG'N
/// C      - BY G.P. LEPAGE   SEPT 1976/(REV)APR 1978
/// C*******************************************************************
/// C
void vegas(common& cmn, fjet_function_pointer fxn, double& avgi, double& sd,
           double& chi2a) {
  FEM_CMN_SVE(vegas);
  common_write write(cmn);
  arr_cref<double> xl(cmn.xl, dimension(10));
  arr_cref<double> xu(cmn.xu, dimension(10));
  int& ndim = cmn.ndim;
  int& ncall = cmn.ncall;
  arr_ref<double, 2> xi(cmn.xi, dimension(50, 10));
  double& si = cmn.si;
  double& si2 = cmn.si2;
  double& swgt = cmn.swgt;
  double& schi = cmn.schi;
  int& ndo = cmn.ndo;
  int& it = cmn.it;
  double& f = static_cast<common_bveg3&>(cmn).f;
  double& ti = cmn.ti;
  double& tsi = cmn.tsi;
  ///
  double& alph = sve.alph;
  double& calls = sve.calls;
  arr_ref<double, 2> d(sve.d, dimension(50, 10));
  arr_ref<double, 2> di(sve.di, dimension(50, 10));
  double& dr = sve.dr;
  arr_ref<double> dt(sve.dt, dimension(10));
  double& dv2g = sve.dv2g;
  arr_ref<double> dx(sve.dx, dimension(10));
  double& dxg = sve.dxg;
  double& f2 = sve.f2;
  double& f2b = sve.f2b;
  double& fb = sve.fb;
  int& i = sve.i;
  arr_ref<int> ia(sve.ia, dimension(10));
  int& j = sve.j;
  int& k = sve.k;
  arr_ref<int> kg(sve.kg, dimension(10));
  int& mds = sve.mds;
  int& nd = sve.nd;
  int& ndm = sve.ndm;
  int& ndmx = sve.ndmx;
  int& ng = sve.ng;
  int& npg = sve.npg;
  double& one = sve.one;
  arr_ref<float> qran(sve.qran, dimension(10));
  arr_ref<double> r(sve.r, dimension(50));
  double& rc = sve.rc;
  double& ti2 = sve.ti2;
  double& wgt = sve.wgt;
  arr_ref<double> x(sve.x, dimension(10));
  arr_ref<double> xin(sve.xin, dimension(50));
  double& xjac = sve.xjac;
  double& xn = sve.xn;
  double& xnd = sve.xnd;
  double& xo = sve.xo;
  if (is_called_first_time) {
    ndmx = 50;
    alph = 1.5e0;
    one = 1.e0;
    mds = -1;
  }
  /// Cc      SAVE /BVEG1/
  /// Cc      SAVE /BVEG2/
  /// Cc      SAVE /BVEG3/
  /// C      REAL*4 QRAN(10)
  /// C
  ndo = 1;
  FEM_DO_SAFE(j, 1, ndim) { xi(1, j) = one; }
  /// C
  /// UNHANDLED: ENTRY vegas1(fxn,avgi,sd,chi2a)
  /// C         - INITIALIZES CUMMULATIVE VARIABLES, BUT NOT GRID
  it = 0;
  si = 0.e0;
  si2 = si;
  swgt = si;
  schi = si;
  /// C
  /// UNHANDLED: ENTRY vegas2(fxn,avgi,sd,chi2a)
  /// C         - NO INITIALIZATION
  nd = ndmx;
  ng = 1;
  if (mds == 0) {
    goto statement_2;
  }
  ng = fem::fint(fem::pow((fem::real(ncall) / 2.f), (1.f / fem::real(ndim))));
  mds = 1;
  if ((2 * ng - ndmx) < 0) {
    goto statement_2;
  }
  mds = -1;
  npg = ng / ndmx + 1;
  nd = ng / npg;
  ng = npg * nd;
statement_2:
  k = fem::pow(ng, ndim);
  npg = ncall / k;
  if (npg < 2) {
    npg = 2;
  }
  calls = npg * k;
  dxg = one / ng;
  dv2g = fem::pow2((calls * fem::pow(dxg, ndim))) / npg / npg / (npg - one);
  xnd = nd;
  ndm = nd - 1;
  dxg = dxg * xnd;
  xjac = one / calls;
  FEM_DO_SAFE(j, 1, ndim) {
    /// C***this is the line 50
    dx(j) = xu(j) - xl(j);
    xjac = xjac * dx(j);
  }
  /// C
  /// C   REBIN PRESERVING BIN DENSITY
  /// C
  if (nd == ndo) {
    goto statement_8;
  }
  rc = ndo / xnd;
  FEM_DO_SAFE(j, 1, ndim) {
    k = 0;
    xn = 0.e0;
    dr = xn;
    i = k;
  statement_4:
    k++;
    dr += one;
    xo = xn;
    xn = xi(k, j);
  statement_5:
    if (rc > dr) {
      goto statement_4;
    }
    i++;
    dr = dr - rc;
    xin(i) = xn - (xn - xo) * dr;
    if (i < ndm) {
      goto statement_5;
    }
    FEM_DO_SAFE(i, 1, ndm) { xi(i, j) = xin(i); }
    xi(nd, j) = one;
  }
  ndo = nd;
/// C
statement_8:
/// C      IF(NPRN.NE.0) WRITE(16,200) NDIM,CALLS,IT,ITMX,ACC,MDS,ND
/// C     1                           ,(XL(J),XU(J),J=1,NDIM)
/// C
/// UNHANDLED: ENTRY vegas3(fxn,avgi,sd,chi2a)
/// C         - MAIN INTEGRATION LOOP
statement_9:
  it++;
  ti = 0.e0;
  tsi = ti;
  FEM_DO_SAFE(j, 1, ndim) {
    kg(j) = 1;
    FEM_DO_SAFE(i, 1, nd) {
      d(i, j) = ti;
      di(i, j) = ti;
    }
  }
/// C
statement_11:
  fb = 0.e0;
  f2b = fb;
  k = 0;
statement_12:
  k++;
  aran9(cmn, qran, ndim);
  wgt = xjac;
  FEM_DO_SAFE(j, 1, ndim) {
    xn = fem::dble(fem::ffloat(kg(j)) - qran(j)) * dxg + one;
    /// C*****this is the line 100
    ia(j) = fem::fint(xn);
    if (ia(j) > 1) {
      goto statement_13;
    }
    xo = xi(ia(j), j);
    rc = (xn - ia(j)) * xo;
    goto statement_14;
  statement_13:
    xo = xi(ia(j), j) - xi(ia(j) - 1, j);
    rc = xi(ia(j) - 1, j) + (xn - ia(j)) * xo;
  statement_14:
    x(j) = xl(j) + rc * dx(j);
    wgt = wgt * xo * xnd;
  }
  /// C
  f = wgt;
  f = f * fxn(cmn, x, wgt);
  f2 = f * f;
  fb += f;
  f2b += f2;
  FEM_DO_SAFE(j, 1, ndim) {
    di(ia(j), j) += f;
    if (mds >= 0) {
      d(ia(j), j) += f2;
    }
  }
  if (k < npg) {
    goto statement_12;
  }
  /// C
  f2b = fem::dsqrt(f2b * npg);
  f2b = (f2b - fb) * (f2b + fb);
  ti += fb;
  tsi += f2b;
  if (mds >= 0) {
    goto statement_18;
  }
  FEM_DO_SAFE(j, 1, ndim) { d(ia(j), j) += f2b; }
statement_18:
  k = ndim;
statement_19:
  kg(k) = fem::mod(kg(k), ng) + 1;
  if (kg(k) != 1) {
    goto statement_11;
  }
  k = k - 1;
  if (k > 0) {
    goto statement_19;
  }
  /// C
  /// C   FINAL RESULTS FOR THIS ITERATION
  /// C
  tsi = tsi * dv2g;
  ti2 = ti * ti;
  wgt = ti2 / (tsi + 1.0e-37);
  si += ti * wgt;
  si2 += ti2;
  swgt += wgt;
  swgt += 1.0e-37;
  si2 += 1.0e-37;
  schi += ti2 * wgt;
  avgi = si / swgt;
  sd = swgt * it / si2;
  chi2a = sd * (schi / swgt - avgi * avgi) / fem::dble(fem::ffloat(it) - .999f);
  sd = fem::dsqrt(one / sd);
  /// C****this is the line 150
  if (cmn.nprn == 0) {
    goto statement_21;
  }
  tsi = fem::dsqrt(tsi);
/// C      WRITE(16,201) IT,TI,TSI,AVGI,SD,CHI2A
/// C      IF(NPRN.GE.0) GO TO 21
/// C      DO 20 J=1,NDIM
/// C20    WRITE(16,202) J,(XI(I,J),DI(I,J),D(I,J),I=1,ND)
/// C
/// C   REFINE GRID
/// C
statement_21:
  FEM_DO_SAFE(j, 1, ndim) {
    xo = d(1, j);
    xn = d(2, j);
    d(1, j) = (xo + xn) / 2.e0;
    dt(j) = d(1, j);
    FEM_DO_SAFE(i, 2, ndm) {
      d(i, j) = xo + xn;
      xo = xn;
      xn = d(i + 1, j);
      d(i, j) = (d(i, j) + xn) / 3.e0;
      dt(j) += d(i, j);
    }
    d(nd, j) = (xn + xo) / 2.e0;
    dt(j) += d(nd, j);
  }
  /// C
  FEM_DO_SAFE(j, 1, ndim) {
    rc = 0.e0;
    FEM_DO_SAFE(i, 1, nd) {
      r(i) = 0.e0;
      if (dt(j) >= 1.0e18) {
        write(6, star), "************** A SINGULARITY >1.0D18";
        /// C      WRITE(5,1111)
        /// C1111  FORMAT(1X,'**************IMPORTANT NOTICE***************')
        /// C      WRITE(5,1112)
        /// C1112  FORMAT(1X,'THE INTEGRAND GIVES RISE A SINGULARITY >1.0D18')
        /// C      WRITE(5,1113)
        /// C1113  FORMAT(1X,'PLEASE CHECK THE INTEGRAND AND THE LIMITS')
        /// C      WRITE(5,1114)
        /// C1114  FORMAT(1X,'**************END NOTICE*************')
      }
      if (d(i, j) <= 1.0e-18) {
        goto statement_24;
      }
      xo = dt(j) / d(i, j);
      r(i) = fem::pow(((xo - one) / xo / fem::dlog(xo)), alph);
    statement_24:
      rc += r(i);
    }
    rc = rc / xnd;
    k = 0;
    xn = 0.e0;
    dr = xn;
    i = k;
  statement_25:
    k++;
    dr += r(k);
    xo = xn;
    /// C****this is the line 200
    xn = xi(k, j);
  statement_26:
    if (rc > dr) {
      goto statement_25;
    }
    i++;
    dr = dr - rc;
    xin(i) = xn - (xn - xo) * dr / (r(k) + 1.0e-30);
    if (i < ndm) {
      goto statement_26;
    }
    FEM_DO_SAFE(i, 1, ndm) { xi(i, j) = xin(i); }
    xi(nd, j) = one;
  }
  /// C
  if (it < cmn.itmx && cmn.acc * fem::dabs(avgi) < sd) {
    goto statement_9;
  }
  /// C200   FORMAT('0INPUT PARAMETERS FOR VEGAS:  NDIM=',I3,'  NCALL=',F8.0
  /// C     1    /28X,'  IT=',I5,'  ITMX=',I5/28X,'  ACC=',G9.3
  /// C     2    /28X,'  MDS=',I3,'   ND=',I4/28X,'  (XL,XU)=',
  /// C     3    (T40,'( ',G12.6,' , ',G12.6,' )'))
  /// C201   FORMAT(////' INTEGRATION BY VEGAS' / '0ITERATION NO.',I3,
  /// C     1    ':   INTEGRAL =',G14.8/21X,'STD DEV  =',G10.4 /
  /// C     2    ' ACCUMULATED RESULTS:   INTEGRAL =',G14.8 /
  /// C     3    24X,'STD DEV  =',G10.4 / 24X,'CHI**2 PER IT''N =',G10.4)
  /// C202   FORMAT('0DATA FOR AXIS',I2 / ' ',6X,'X',7X,'  DELT I  ',
  /// C     1    2X,' CONV''CE  ',11X,'X',7X,'  DELT I  ',2X,' CONV''CE  '
  /// C     2   ,11X,'X',7X,'  DELT I  ',2X,' CONV''CE  ' /
  /// C     2    (' ',3G12.4,5X,3G12.4,5X,3G12.4))
}

struct crsjet_save {
  double avgi;
  double chi2a;
  double sd;

  crsjet_save() : avgi(fem::double0), chi2a(fem::double0), sd(fem::double0) {}
};

/// C
/// C        THIS PROGRAM IS TO CALCULATE THE JET CROSS SECTION
/// C        THE INTEGRATION IS DONE BY USING VEGAS
/// C
void crsjet(common& cmn) {
  FEM_CMN_SVE(crsjet);
  /// COMMON hparnt
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  /// COMMON njet
  int& ipcrs = cmn.ipcrs;
  ///
  /// SAVE
  double& avgi = sve.avgi;
  double& chi2a = sve.chi2a;
  double& sd = sve.sd;
  ///
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /NJET/
  /// Cc      SAVE /BVEG1/
  /// Cc      SAVE /BVEG2/
  /// Cc      SAVE /BVEG3/
  /// Cc      SAVE /SEDVAX/
  /// C
  /// C************************
  /// C        NCALL give the number of inner-iteration, ITMX
  /// C       gives the limit of out-iteration. Nprn is an option
  /// C       ( 1: print the integration process. 0: do not print)
  /// C
  cmn.ndim = 3;
  ipcrs = 0;
  vegas(cmn, fjet, avgi, sd, chi2a);
  hint1(14) = fem::sngl(avgi) / 2.5682f;
  if (ihpr2(6) == 1 && ihnt2(1) > 1) {
    ipcrs = 1;
    vegas(cmn, fjet, avgi, sd, chi2a);
    hint1(15) = fem::sngl(avgi) / 2.5682f;
  }
  if (ihpr2(6) == 1 && ihnt2(3) > 1) {
    ipcrs = 2;
    vegas(cmn, fjet, avgi, sd, chi2a);
    hint1(16) = fem::sngl(avgi) / 2.5682f;
  }
  if (ihpr2(6) == 1 && ihnt2(1) > 1 && ihnt2(3) > 1) {
    ipcrs = 3;
    vegas(cmn, fjet, avgi, sd, chi2a);
    hint1(17) = fem::sngl(avgi) / 2.5682f;
  }
  /// C                ********Total inclusive jet cross section(Pt>P0)
  /// C
  if (ihpr2(3) != 0) {
    ipcrs = 0;
    vegas(cmn, fjetrg, avgi, sd, chi2a);
    hint1(61) = fem::sngl(avgi) / 2.5682f;
    if (ihpr2(6) == 1 && ihnt2(1) > 1) {
      ipcrs = 1;
      vegas(cmn, fjetrg, avgi, sd, chi2a);
      hint1(62) = fem::sngl(avgi) / 2.5682f;
    }
    if (ihpr2(6) == 1 && ihnt2(3) > 1) {
      ipcrs = 2;
      vegas(cmn, fjetrg, avgi, sd, chi2a);
      hint1(63) = fem::sngl(avgi) / 2.5682f;
    }
    if (ihpr2(6) == 1 && ihnt2(1) > 1 && ihnt2(3) > 1) {
      ipcrs = 3;
      vegas(cmn, fjetrg, avgi, sd, chi2a);
      hint1(64) = fem::sngl(avgi) / 2.5682f;
    }
  }
  /// C                        ********cross section of trigger jet
  /// C
}

struct hijcrs_save {
  float aphx1;
  float aphx2;
  int i;

  hijcrs_save() : aphx1(fem::float0), aphx2(fem::float0), i(fem::int0) {}
};

void hijcrs(common& cmn) {
  FEM_CMN_SVE(hijcrs);
  /// COMMON hparnt
  arr_ref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
  /// COMMON njet
  int& n = static_cast<common_njet&>(cmn).n;
  ///
  /// SAVE
  float& aphx1 = sve.aphx1;
  float& aphx2 = sve.aphx2;
  int& i = sve.i;
  ///
  /// C        THIS IS TO CALCULATE THE CROSS SECTIONS OF JET PRODUCTION AND
  /// C        THE TOTAL INELASTIC CROSS SECTIONS.
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /NJET/
  if (hint1(1) >= 10.0f) {
    crsjet(cmn);
  }
  /// C                        ********calculate jet cross section(in mb)
  /// C
  /// Clin-7/2009 these are related to nuclear shadowing:
  aphx1 = hipr1(6) * (fem::pow(ihnt2(1), 0.3333333f) - 1.0f);
  aphx2 = hipr1(6) * (fem::pow(ihnt2(3), 0.3333333f) - 1.0f);
  hint1(11) = hint1(14) - aphx1 * hint1(15) - aphx2 * hint1(16) +
              aphx1 * aphx2 * hint1(17);
  hint1(10) = gauss1(cmn, ftotjt, 0.0f, 20.0f, 0.01f);
  hint1(12) = gauss1(cmn, fhin, 0.0f, 20.0f, 0.01f);
  hint1(13) = gauss1(cmn, ftot, 0.0f, 20.0f, 0.01f);
  hint1(60) = hint1(61) - aphx1 * hint1(62) - aphx2 * hint1(63) +
              aphx1 * aphx2 * hint1(64);
  hint1(59) = gauss1(cmn, ftotrg, 0.0f, 20.0f, 0.01f);
  if (hint1(59) == 0.0f) {
    hint1(59) = hint1(60);
  }
  if (hint1(1) >= 10.0f) {
    FEM_DO_SAFE(i, 0, 20) {
      n = i;
      hint1(80 + i) = gauss1(cmn, fnjet, 0.0f, 20.0f, 0.01f) / hint1(12);
    }
  }
  hint1(10) = hint1(10) * hipr1(31);
  hint1(12) = hint1(12) * hipr1(31);
  hint1(13) = hint1(13) * hipr1(31);
  hint1(59) = hint1(59) * hipr1(31);
  /// C                ********Total and Inel cross section are calculated
  /// C                        by Gaussian integration.
  if (ihpr2(13) != 0) {
    hipr1(33) = 1.36f * (1.0f + 36.0f / fem::pow2(hint1(1))) *
                fem::alog(0.6f + 0.1f * fem::pow2(hint1(1)));
    hipr1(33) = hipr1(33) / hint1(12);
  }
  /// C                ********Parametrized cross section for single
  /// C                        diffractive reaction(Goulianos)
}

void title(common& cmn) {
  common_write write(cmn);
  /// C
  /// Cc      SAVE /RNDF77/
  /// C
  write(6,
        "(/,/,10x,'**************************************************',/,10x,"
        "'*     |      |       _______      /  ------/     *',/,10x,"
        "'*   ----- ------     |_____|     /_/     /       *',/,10x,"
        "'*    |||    /        |_____|      /    / |       *',/,10x,"
        "'*    /| |  /_/       /_______    /_  /    |      *',/,10x,"
        "'*   / |     / /     /  /  / |        -------     *',/,10x,"
        "'*     |    / /|       /  /  |     /     |        *',/,10x,"
        "'*     |   / /  |     /  /  _|    /   -------     *',/,10x,"
        "'*                                                *',/,10x,"
        "'**************************************************',/,10x,"
        "'                      HIJING                      ',/,10x,"
        "'       Heavy Ion Jet INteraction Generator        ',/,10x,"
        "'                        by                        ',/,10x,"
        "'            X. N. Wang  and  M. Gyulassy           ',/,10x,"
        "'             Lawrence Berkeley Laboratory           ',/,/)");
  /// Clin-8/15/02 f77:
  /// C200        FORMAT(///10X,
  /// C     &        '**************************************************'/10X,
  /// C     &  '*     |      \       _______      /  ------/     *'/10X,
  /// C     &        '*   ----- ------     |_____|     /_/     /       *'/10X,
  /// C     &        '*    ||\    /        |_____|      /    / \       *'/10X,
  /// C     &        '*    /| \  /_/       /_______    /_  /    \_     *'/10X,
  /// C     &        '*   / |     / /     /  /  / |        -------     *'/10X,
  /// C     &        '*     |    / /\       /  /  |     /     |        *'/10X,
  /// C     &        '*     |   / /  \     /  / \_|    /   -------     *'/10X,
}

struct lugive_save {
  arr<fem::str<26> > chalp;
  arr<fem::str<4> > chvar;

  lugive_save()
      : chalp(dimension(2), fem::fill0), chvar(dimension(17), fem::fill0) {}
};

/// C
/// C*********************************************************************
/// C
void lugive(common& cmn, str_cref chin) {
  FEM_CMN_SVE(lugive);
  common_read read(cmn);
  common_write write(cmn);
  int& n = static_cast<common_lujets&>(cmn).n;
  arr_ref<int, 2> k(cmn.k, dimension(9000, 5));
  arr_ref<float, 2> p(static_cast<common_lujets&>(cmn).p, dimension(9000, 5));
  arr_ref<float, 2> v(cmn.v, dimension(9000, 5));
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_ref<float> parj(cmn.parj, dimension(200));
  arr_ref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_ref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_ref<float> parf(cmn.parf, dimension(2000));
  arr_ref<float, 2> vckm(cmn.vckm, dimension(4, 4));
  arr_ref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_ref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_ref<float> brat(cmn.brat, dimension(2000));
  arr_ref<int, 2> kfdp(cmn.kfdp, dimension(2000, 5));
  str_arr_ref<1> chaf(cmn.chaf, dimension(500));
  ///
  str_arr_ref<1> chalp(sve.chalp, dimension(2));
  str_arr_ref<1> chvar(sve.chvar, dimension(17));
  if (is_called_first_time) {
    {
      static const char* values[] = {"N",    "K",    "P",    "V",    "MSTU",
                                     "PARU", "MSTJ", "PARJ", "KCHG", "PMAS",
                                     "PARF", "VCKM", "MDCY", "MDME", "BRAT",
                                     "KFDP", "CHAF"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chvar;
    }
    {
      static const char* values[] = {"abcdefghijklmnopqrstuvwxyz",
                                     "ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
      fem::data_of_type_str(FEM_VALUES_AND_SIZE), chalp;
    }
  }
  fem::str<104> chbit = fem::char0;
  int lbit = fem::int0;
  int ltot = fem::int0;
  int lcom = fem::int0;
  fem::str<104> chfix = fem::char0;
  int llow = fem::int0;
  int lhig = fem::int0;
  int lnam = fem::int0;
  fem::str<4> chnam = fem::char0;
  int lalp = fem::int0;
  int ivar = fem::int0;
  int iv = fem::int0;
  int i = fem::int0;
  int j = fem::int0;
  int lind = fem::int0;
  fem::str<8> chind = fem::char0;
  int i1 = fem::int0;
  int ierr = fem::int0;
  int iold = fem::int0;
  float rold = fem::float0;
  fem::str<8> chold = fem::char0;
  fem::str<10> chini = fem::char0;
  int inew = fem::int0;
  fem::str<16> chinr = fem::char0;
  float rnew = fem::float0;
  fem::str<8> chnew = fem::char0;
  static const char* format_1000 = "(5x,a60)";
  /// C
  /// C...Purpose: to set values of commonblock variables.
  /// C
  /// C...Length of character variable. Subdivide it into instructions.
  if (mstu(12) >= 1) {
    lulist(cmn, 0);
  }
  chbit = chin + str_cref(" ");
  lbit = 101;
statement_100:
  lbit = lbit - 1;
  if (chbit(lbit, lbit) == " ") {
    goto statement_100;
  }
  ltot = 0;
  FEM_DO_SAFE(lcom, 1, lbit) {
    if (chbit(lcom, lcom) == " ") {
      goto statement_110;
    }
    ltot++;
    chfix(ltot, ltot) = chbit(lcom, lcom);
  statement_110:;
  }
  llow = 0;
statement_120:
  lhig = llow + 1;
statement_130:
  lhig++;
  if (lhig <= ltot && chfix(lhig, lhig) != ";") {
    goto statement_130;
  }
  lbit = lhig - llow - 1;
  chbit(1, lbit) = chfix(llow + 1, lhig - 1);
  /// C
  /// C...Identify commonblock variable.
  lnam = 1;
statement_140:
  lnam++;
  if (chbit(lnam, lnam) != "(" && chbit(lnam, lnam) != "=" && lnam <= 4) {
    goto statement_140;
  }
  chnam = chbit(1, lnam - 1) + str_cref(" ");
  FEM_DO_SAFE(lcom, 1, lnam - 1) {
    FEM_DO_SAFE(lalp, 1, 26) {
      if (chnam(lcom, lcom) == chalp(1)(lalp, lalp)) {
        chnam(lcom, lcom) = chalp(2)(lalp, lalp);
      }
    }
  }
  ivar = 0;
  FEM_DO_SAFE(iv, 1, 17) {
    if (chnam == chvar(iv)) {
      ivar = iv;
    }
  }
  if (ivar == 0) {
    luerrm(cmn, 18, "(LUGIVE:) do not recognize variable " + chnam);
    llow = lhig;
    if (llow < ltot) {
      goto statement_120;
    }
    return;
  }
  /// C
  /// C...Identify any indices.
  i = 0;
  j = 0;
  if (chbit(lnam, lnam) == "(") {
    lind = lnam;
  statement_170:
    lind++;
    if (chbit(lind, lind) != ")" && chbit(lind, lind) != ",") {
      goto statement_170;
    }
    chind = " ";
    if ((chbit(lnam + 1, lnam + 1) == "C" ||
         chbit(lnam + 1, lnam + 1) == "c") &&
        (ivar == 9 || ivar == 10 || ivar == 13 || ivar == 17)) {
      chind(lnam - lind + 11, 8) = chbit(lnam + 2, lind - 1);
      read(chind, "(i8)"), i1;
      i = lucomp(cmn, i1);
    } else {
      chind(lnam - lind + 10, 8) = chbit(lnam + 1, lind - 1);
      read(chind, "(i8)"), i;
    }
    lnam = lind;
    if (chbit(lnam, lnam) == ")") {
      lnam++;
    }
  }
  if (chbit(lnam, lnam) == ",") {
    lind = lnam;
  statement_180:
    lind++;
    if (chbit(lind, lind) != ")" && chbit(lind, lind) != ",") {
      goto statement_180;
    }
    chind = " ";
    chind(lnam - lind + 10, 8) = chbit(lnam + 1, lind - 1);
    read(chind, "(i8)"), j;
    lnam = lind + 1;
  }
  /// C
  /// C...Check that indices allowed and save old value.
  ierr = 1;
  if (chbit(lnam, lnam) != "=") {
    goto statement_190;
  }
  if (ivar == 1) {
    if (i != 0 || j != 0) {
      goto statement_190;
    }
    iold = n;
  } else if (ivar == 2) {
    if (i < 1 || i > mstu(4) || j < 1 || j > 5) {
      goto statement_190;
    }
    iold = k(i, j);
  } else if (ivar == 3) {
    if (i < 1 || i > mstu(4) || j < 1 || j > 5) {
      goto statement_190;
    }
    rold = p(i, j);
  } else if (ivar == 4) {
    if (i < 1 || i > mstu(4) || j < 1 || j > 5) {
      goto statement_190;
    }
    rold = v(i, j);
  } else if (ivar == 5) {
    if (i < 1 || i > 200 || j != 0) {
      goto statement_190;
    }
    iold = mstu(i);
  } else if (ivar == 6) {
    if (i < 1 || i > 200 || j != 0) {
      goto statement_190;
    }
    rold = paru(i);
  } else if (ivar == 7) {
    if (i < 1 || i > 200 || j != 0) {
      goto statement_190;
    }
    iold = mstj(i);
  } else if (ivar == 8) {
    if (i < 1 || i > 200 || j != 0) {
      goto statement_190;
    }
    rold = parj(i);
  } else if (ivar == 9) {
    if (i < 1 || i > mstu(6) || j < 1 || j > 3) {
      goto statement_190;
    }
    iold = kchg(i, j);
  } else if (ivar == 10) {
    if (i < 1 || i > mstu(6) || j < 1 || j > 4) {
      goto statement_190;
    }
    rold = pmas(i, j);
  } else if (ivar == 11) {
    if (i < 1 || i > 2000 || j != 0) {
      goto statement_190;
    }
    rold = parf(i);
  } else if (ivar == 12) {
    if (i < 1 || i > 4 || j < 1 || j > 4) {
      goto statement_190;
    }
    rold = vckm(i, j);
  } else if (ivar == 13) {
    if (i < 1 || i > mstu(6) || j < 1 || j > 3) {
      goto statement_190;
    }
    iold = mdcy(i, j);
  } else if (ivar == 14) {
    if (i < 1 || i > mstu(7) || j < 1 || j > 2) {
      goto statement_190;
    }
    iold = mdme(i, j);
  } else if (ivar == 15) {
    if (i < 1 || i > mstu(7) || j != 0) {
      goto statement_190;
    }
    rold = brat(i);
  } else if (ivar == 16) {
    if (i < 1 || i > mstu(7) || j < 1 || j > 5) {
      goto statement_190;
    }
    iold = kfdp(i, j);
  } else if (ivar == 17) {
    if (i < 1 || i > mstu(6) || j != 0) {
      goto statement_190;
    }
    chold = chaf(i);
  }
  ierr = 0;
statement_190:
  if (ierr == 1) {
    luerrm(cmn, 18, "(LUGIVE:) unallowed indices for " + chbit(1, lnam - 1));
    llow = lhig;
    if (llow < ltot) {
      goto statement_120;
    }
    return;
  }
  /// C
  /// C...Print current value of variable. Loop back.
  if (lnam >= lbit) {
    chbit(lnam, 14) = " ";
    chbit(15, 60) = " has the value                                ";
    if (ivar == 1 || ivar == 2 || ivar == 5 || ivar == 7 || ivar == 9 ||
        ivar == 13 || ivar == 14 || ivar == 16) {
      write(chbit(51, 60), "(i10)"), iold;
    } else if (ivar != 17) {
      write(chbit(47, 60), "(f14.5)"), rold;
    } else {
      chbit(53, 60) = chold;
    }
    if (mstu(13) >= 1) {
      write(mstu(11), format_1000), chbit(1, 60);
    }
    llow = lhig;
    if (llow < ltot) {
      goto statement_120;
    }
    return;
  }
  /// C
  /// C...Read in new variable value.
  if (ivar == 1 || ivar == 2 || ivar == 5 || ivar == 7 || ivar == 9 ||
      ivar == 13 || ivar == 14 || ivar == 16) {
    chini = " ";
    chini(lnam - lbit + 11, 10) = chbit(lnam + 1, lbit);
    read(chini, "(i10)"), inew;
  } else if (ivar != 17) {
    chinr = " ";
    chinr(lnam - lbit + 17, 16) = chbit(lnam + 1, lbit);
    read(chinr, "(f16.2)"), rnew;
  } else {
    chnew = chbit(lnam + 1, lbit) + str_cref(" ");
  }
  /// C
  /// C...Store new variable value.
  if (ivar == 1) {
    n = inew;
  } else if (ivar == 2) {
    k(i, j) = inew;
  } else if (ivar == 3) {
    p(i, j) = rnew;
  } else if (ivar == 4) {
    v(i, j) = rnew;
  } else if (ivar == 5) {
    mstu(i) = inew;
  } else if (ivar == 6) {
    paru(i) = rnew;
  } else if (ivar == 7) {
    mstj(i) = inew;
  } else if (ivar == 8) {
    parj(i) = rnew;
  } else if (ivar == 9) {
    kchg(i, j) = inew;
  } else if (ivar == 10) {
    pmas(i, j) = rnew;
  } else if (ivar == 11) {
    parf(i) = rnew;
  } else if (ivar == 12) {
    vckm(i, j) = rnew;
  } else if (ivar == 13) {
    mdcy(i, j) = inew;
  } else if (ivar == 14) {
    mdme(i, j) = inew;
  } else if (ivar == 15) {
    brat(i) = rnew;
  } else if (ivar == 16) {
    kfdp(i, j) = inew;
  } else if (ivar == 17) {
    chaf(i) = chnew;
  }
  /// C
  /// C...Write old and new value. Loop back.
  chbit(lnam, 14) = " ";
  chbit(15, 60) = " changed from                to               ";
  if (ivar == 1 || ivar == 2 || ivar == 5 || ivar == 7 || ivar == 9 ||
      ivar == 13 || ivar == 14 || ivar == 16) {
    write(chbit(33, 42), "(i10)"), iold;
    write(chbit(51, 60), "(i10)"), inew;
  } else if (ivar != 17) {
    write(chbit(29, 42), "(f14.5)"), rold;
    write(chbit(47, 60), "(f14.5)"), rnew;
  } else {
    chbit(35, 42) = chold;
    chbit(53, 60) = chnew;
  }
  if (mstu(13) >= 1) {
    write(mstu(11), format_1000), chbit(1, 60);
  }
  llow = lhig;
  if (llow < ltot) {
    goto statement_120;
  }
  /// C
  /// C...Format statement for output on unit MSTU(11) (by default 6).
  /// C
}

struct hijset_save {
  fem::variant_bindings hstrng_bindings;
  double dd1;
  double dd2;
  double dd3;
  double dd4;
  fem::str<4> eframe;
  int i;
  int j;
  float rkp;
  float rmax;

  hijset_save()
      : dd1(fem::double0),
        dd2(fem::double0),
        dd3(fem::double0),
        dd4(fem::double0),
        eframe(fem::char0),
        i(fem::int0),
        j(fem::int0),
        rkp(fem::float0),
        rmax(fem::float0) {}
};

void hijset(common& cmn, float const& efrm, str_cref frame, str_cref proj,
            str_cref targ, int const& iap, int const& izp, int const& iat,
            int const& izt) {
  FEM_CMN_SVE(hijset);
  common_write write(cmn);
  arr_ref<float> hipr1(cmn.hipr1, dimension(100));
  arr_cref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  arr_ref<int> ihnt2(cmn.ihnt2, dimension(50));
  arr_cref<float, 2> hidat0(cmn.hidat0, dimension(10, 10));
  arr_ref<float> hidat(cmn.hidat, dimension(10));
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_ref<float> parj(cmn.parj, dimension(200));
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  double& dd1 = sve.dd1;
  double& dd2 = sve.dd2;
  double& dd3 = sve.dd3;
  double& dd4 = sve.dd4;
  fem::str<4>& eframe = sve.eframe;
  int& i = sve.i;
  int& j = sve.j;
  float& rkp = sve.rkp;
  float& rmax = sve.rmax;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  /* arr_cref<int, 2> nfp( */ hstrng.bind<int>() /* , dimension(300, 15)) */;
  /* arr_cref<float, 2> pp( */ hstrng.bind<float>() /* , dimension(300,
    15)) */
      ;
  /* arr_cref<int, 2> nft( */ hstrng.bind<int>() /* , dimension(300, 15)) */;
  /* arr_cref<float, 2> pt( */ hstrng.bind<float>() /* , dimension(300,
    15)) */
      ;
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HIJDAT/
  /// Cc      SAVE /LUDAT1/
  /// C
  title(cmn);
  ihnt2(1) = iap;
  ihnt2(2) = izp;
  ihnt2(3) = iat;
  ihnt2(4) = izt;
  ihnt2(5) = 0;
  ihnt2(6) = 0;
  /// C
  hint1(8) = fem::max(ulmass(cmn, 2112), ulmass(cmn, 2212));
  hint1(9) = hint1(8);
  /// C
  if (proj != "A") {
    if (proj == "P") {
      ihnt2(5) = 2212;
    } else if (proj == "PBAR") {
      ihnt2(5) = -2212;
    } else if (proj == "PI+") {
      ihnt2(5) = 211;
    } else if (proj == "PI-") {
      ihnt2(5) = -211;
    } else if (proj == "K+") {
      ihnt2(5) = 321;
    } else if (proj == "K-") {
      ihnt2(5) = -321;
    } else if (proj == "N") {
      ihnt2(5) = 2112;
    } else if (proj == "NBAR") {
      ihnt2(5) = -2112;
    } else {
      write(6, star), proj, "wrong or unavailable proj name";
      FEM_STOP(0);
    }
    hint1(8) = ulmass(cmn, ihnt2(5));
  }
  if (targ != "A") {
    if (targ == "P") {
      ihnt2(6) = 2212;
    } else if (targ == "PBAR") {
      ihnt2(6) = -2212;
    } else if (targ == "PI+") {
      ihnt2(6) = 211;
    } else if (targ == "PI-") {
      ihnt2(6) = -211;
    } else if (targ == "K+") {
      ihnt2(6) = 321;
    } else if (targ == "K-") {
      ihnt2(6) = -321;
    } else if (targ == "N") {
      ihnt2(6) = 2112;
    } else if (targ == "NBAR") {
      ihnt2(6) = -2112;
    } else {
      write(6, star), targ, "wrong or unavailable targ name";
      FEM_STOP(0);
    }
    hint1(9) = ulmass(cmn, ihnt2(6));
  }
  /// C
  /// C...Switch off decay of pi0, K0S, Lambda, Sigma+-, Xi0-, Omega-.
  if (ihpr2(12) > 0) {
    lugive(cmn, "MDCY(C221,1)=0");
    /// Clin-11/07/00 no K* decays:
    lugive(cmn, "MDCY(C313,1)=0");
    lugive(cmn, "MDCY(C-313,1)=0");
    lugive(cmn, "MDCY(C323,1)=0");
    lugive(cmn, "MDCY(C-323,1)=0");
    /// Clin-1/04/01 no K0 and K0bar decays so K0L and K0S do not appear,
    /// C     this way the K/Kbar difference is accounted for exactly:
    lugive(cmn, "MDCY(C311,1)=0");
    lugive(cmn, "MDCY(C-311,1)=0");
    /// Clin-11/08/00 no Delta decays:
    lugive(cmn, "MDCY(C1114,1)=0");
    lugive(cmn, "MDCY(C2114,1)=0");
    lugive(cmn, "MDCY(C2214,1)=0");
    lugive(cmn, "MDCY(C2224,1)=0");
    lugive(cmn, "MDCY(C-1114,1)=0");
    lugive(cmn, "MDCY(C-2114,1)=0");
    lugive(cmn, "MDCY(C-2214,1)=0");
    lugive(cmn, "MDCY(C-2224,1)=0");
    /// Clin-11/07/00-end
    /// Cbz12/4/98
    lugive(cmn, "MDCY(C213,1)=0");
    lugive(cmn, "MDCY(C-213,1)=0");
    lugive(cmn, "MDCY(C113,1)=0");
    lugive(cmn, "MDCY(C223,1)=0");
    lugive(cmn, "MDCY(C333,1)=0");
    /// Cbz12/4/98end
    lugive(cmn, "MDCY(C111,1)=0");
    lugive(cmn, "MDCY(C310,1)=0");
    lugive(cmn, "MDCY(C411,1)=0;MDCY(C-411,1)=0");
    lugive(cmn, "MDCY(C421,1)=0;MDCY(C-421,1)=0");
    lugive(cmn, "MDCY(C431,1)=0;MDCY(C-431,1)=0");
    lugive(cmn, "MDCY(C511,1)=0;MDCY(C-511,1)=0");
    lugive(cmn, "MDCY(C521,1)=0;MDCY(C-521,1)=0");
    lugive(cmn, "MDCY(C531,1)=0;MDCY(C-531,1)=0");
    lugive(cmn, "MDCY(C3122,1)=0;MDCY(C-3122,1)=0");
    lugive(cmn, "MDCY(C3112,1)=0;MDCY(C-3112,1)=0");
    lugive(cmn, "MDCY(C3212,1)=0;MDCY(C-3212,1)=0");
    lugive(cmn, "MDCY(C3222,1)=0;MDCY(C-3222,1)=0");
    lugive(cmn, "MDCY(C3312,1)=0;MDCY(C-3312,1)=0");
    lugive(cmn, "MDCY(C3322,1)=0;MDCY(C-3322,1)=0");
    lugive(cmn, "MDCY(C3334,1)=0;MDCY(C-3334,1)=0");
    /// Clin-7/2011-no HQ(charm or bottom) decays in order to get net-HQ
    /// conservation:
    lugive(cmn, "MDCY(C441,1)=0");
    lugive(cmn, "MDCY(C443,1)=0");
    lugive(cmn, "MDCY(C413,1)=0;MDCY(C-413,1)=0");
    lugive(cmn, "MDCY(C423,1)=0;MDCY(C-423,1)=0");
    lugive(cmn, "MDCY(C433,1)=0;MDCY(C-433,1)=0");
    lugive(cmn, "MDCY(C4112,1)=0;MDCY(C-4112,1)=0");
    lugive(cmn, "MDCY(C4114,1)=0;MDCY(C-4114,1)=0");
    lugive(cmn, "MDCY(C4122,1)=0;MDCY(C-4122,1)=0");
    lugive(cmn, "MDCY(C4212,1)=0;MDCY(C-4212,1)=0");
    lugive(cmn, "MDCY(C4214,1)=0;MDCY(C-4214,1)=0");
    lugive(cmn, "MDCY(C4222,1)=0;MDCY(C-4222,1)=0");
    lugive(cmn, "MDCY(C4224,1)=0;MDCY(C-4224,1)=0");
    lugive(cmn, "MDCY(C4132,1)=0;MDCY(C-4132,1)=0");
    lugive(cmn, "MDCY(C4312,1)=0;MDCY(C-4312,1)=0");
    lugive(cmn, "MDCY(C4314,1)=0;MDCY(C-4314,1)=0");
    lugive(cmn, "MDCY(C4232,1)=0;MDCY(C-4232,1)=0");
    lugive(cmn, "MDCY(C4322,1)=0;MDCY(C-4322,1)=0");
    lugive(cmn, "MDCY(C4324,1)=0;MDCY(C-4324,1)=0");
    lugive(cmn, "MDCY(C4332,1)=0;MDCY(C-4332,1)=0");
    lugive(cmn, "MDCY(C4334,1)=0;MDCY(C-4334,1)=0");
    lugive(cmn, "MDCY(C551,1)=0");
    lugive(cmn, "MDCY(C553,1)=0");
    lugive(cmn, "MDCY(C513,1)=0;MDCY(C-513,1)=0");
    lugive(cmn, "MDCY(C523,1)=0;MDCY(C-523,1)=0");
    lugive(cmn, "MDCY(C533,1)=0;MDCY(C-533,1)=0");
    lugive(cmn, "MDCY(C5112,1)=0;MDCY(C-5112,1)=0");
    lugive(cmn, "MDCY(C5114,1)=0;MDCY(C-5114,1)=0");
    lugive(cmn, "MDCY(C5122,1)=0;MDCY(C-5122,1)=0");
    lugive(cmn, "MDCY(C5212,1)=0;MDCY(C-5212,1)=0");
    lugive(cmn, "MDCY(C5214,1)=0;MDCY(C-5214,1)=0");
    lugive(cmn, "MDCY(C5222,1)=0;MDCY(C-5222,1)=0");
    lugive(cmn, "MDCY(C5224,1)=0;MDCY(C-5224,1)=0");
    /// Clin-7/2011-end
  }
  mstu(12) = 0;
  mstu(21) = 1;
  if (ihpr2(10) == 0) {
    mstu(22) = 0;
    mstu(25) = 0;
    mstu(26) = 0;
  }
  /// C
  /// Clin    parj(41) and (42) are a, b parameters in Lund, read from
  /// input.ampt: C        PARJ(41)=HIPR1(3) C        PARJ(42)=HIPR1(4) C
  /// PARJ(41)=2.2 C        PARJ(42)=0.5
  /// C
  /// Clin  2 popcorn parameters read from input.ampt:
  /// C        IHPR2(11) = 3
  /// C        PARJ(5) = 0.5
  mstj(12) = ihpr2(11);
  /// C
  /// Clin  parj(21) gives the mean gaussian width for hadron Pt:
  parj(21) = hipr1(2);
  /// Clin  parj(2) is gamma_s=P(s)/P(u), kappa propto 1/b/(2+a) assumed.
  rkp = hipr1(4) * (2 + hipr1(3)) / parj(42) / (2 + parj(41));
  parj(2) = fem::pow(parj(2), (1.f / rkp));
  parj(21) = parj(21) * fem::sqrt(rkp);
  /// Clin-10/31/00 update when string tension is changed:
  hipr1(2) = parj(21);
  /// C
  /// Clin-4/2015: set upper limit for gamma_s=P(s)/P(u) to 0.4
  /// C     (to limit strangeness enhancement when string tension is strongly
  /// C     increased due to using a very low value of parameter b in Lund
  /// C     symmetric splitting function as done in arXiv:1403.6321):
  parj(2) = fem::min(parj(2), 0.4f);
  /// C
  /// C                        ******** set up for jetset
  if (frame == "LAB") {
    dd1 = fem::dble(efrm);
    dd2 = fem::dble(hint1(8));
    dd3 = fem::dble(hint1(9));
    hint1(1) = fem::sqrt(fem::pow2(hint1(8)) + 2.0f * hint1(9) * efrm +
                         fem::pow2(hint1(9)));
    dd4 = fem::dsqrt(fem::pow2(dd1) - fem::pow2(dd2)) / (dd1 + dd3);
    hint1(2) = fem::sngl(dd4);
    hint1(3) = 0.5f * fem::sngl(fem::dlog((1.e0 + dd4) / (1.e0 - dd4)));
    dd4 = fem::dsqrt(fem::pow2(dd1) - fem::pow2(dd2)) / dd1;
    hint1(4) = 0.5f * fem::sngl(fem::dlog((1.e0 + dd4) / (1.e0 - dd4)));
    hint1(5) = 0.0f;
    hint1(6) = efrm;
    hint1(7) = hint1(9);
  } else if (frame == "CMS") {
    hint1(1) = efrm;
    hint1(2) = 0.0f;
    hint1(3) = 0.0f;
    dd1 = fem::dble(hint1(1));
    dd2 = fem::dble(hint1(8));
    dd3 = fem::dble(hint1(9));
    dd4 = fem::dsqrt(1.e0 - 4.e0 * fem::pow2(dd2) / fem::pow2(dd1));
    hint1(4) = 0.5f * fem::sngl(fem::dlog((1.e0 + dd4) / (1.e0 - dd4)));
    dd4 = fem::dsqrt(1.e0 - 4.e0 * fem::pow2(dd3) / fem::pow2(dd1));
    hint1(5) = -0.5f * fem::sngl(fem::dlog((1.e0 + dd4) / (1.e0 - dd4)));
    hint1(6) = hint1(1) / 2.0f;
    hint1(7) = hint1(1) / 2.0f;
  }
  /// C                ********define Lorentz transform to lab frame
  /// C
  /// C                ********calculate the cross sections involved with
  /// C                        nucleon collisions.
  if (ihnt2(1) > 1) {
    hijwds(cmn, ihnt2(1), 1, rmax);
    hipr1(34) = rmax;
    /// C                        ********set up Wood-Sax distr for proj.
  }
  if (ihnt2(3) > 1) {
    hijwds(cmn, ihnt2(3), 2, rmax);
    hipr1(35) = rmax;
    /// C                        ********set up Wood-Sax distr for  targ.
  }
  /// C
  i = 0;
statement_20:
  i++;
  if (i == 10) {
    goto statement_30;
  }
  if (hidat0(10, i) <= hint1(1)) {
    goto statement_20;
  }
statement_30:
  if (i == 1) {
    i = 2;
  }
  FEM_DO_SAFE(j, 1, 9) {
    hidat(j) = hidat0(j, i - 1) + (hidat0(j, i) - hidat0(j, i - 1)) *
                                      (hint1(1) - hidat0(10, i - 1)) /
                                      (hidat0(10, i) - hidat0(10, i - 1));
  }
  hipr1(31) = hidat(5);
  hipr1(30) = 2.0f * hidat(5);
  /// C
  hijcrs(cmn);
  /// C
  if (ihpr2(5) != 0) {
    hifun(cmn, 3, 0.0f, 36.0f, fnkick);
    /// C                ********booking for generating pt**2 for pt kick
  }
  hifun(cmn, 7, 0.0f, 6.0f, fnkc2);
  hifun(cmn, 4, 0.0f, 1.0f, fnstru);
  hifun(cmn, 5, 0.0f, 1.0f, fnstrm);
  hifun(cmn, 6, 0.0f, 1.0f, fnstrs);
  /// C                ********booking for x distribution of valence quarks
  eframe = "Ecm";
  if (frame == "LAB") {
    eframe = "Elab";
  }
  write(
      6,
      "(10x,'**************************************************',/,10x,'*',48x,"
      "'*',/,10x,'*         HIJING has been initialized at         "
      "*',/,10x,'*',"
      "13x,a4,'= ',f10.2,' GeV/n',13x,'*',/,10x,'*',48x,'*',/,10x,'*',8x,'for "
      "',"
      "a4,'(',i3,',',i3,')',' + ',a4,'(',i3,',',i3,')',7x,'*',/,10x,"
      "'**************************************************')"),
      eframe, efrm, proj, ihnt2(1), ihnt2(2), targ, ihnt2(3), ihnt2(4);
}

struct blockdata_hidata_save {
  fem::variant_bindings hstrng_bindings;
  int i;
  int j;

  blockdata_hidata_save() : i(fem::int0), j(fem::int0) {}
};

/// C
/// C***************************************************************
/// C
void blockdata_hidata(common& cmn) {
  FEM_CMN_SVE(blockdata_hidata);
  /// COMMON bveg1
  arr_ref<double> xl(cmn.xl, dimension(10));
  arr_ref<double> xu(cmn.xu, dimension(10));
  /// COMMON hparnt
  arr_ref<float> hipr1(cmn.hipr1, dimension(100));
  arr_ref<int> ihpr2(cmn.ihpr2, dimension(50));
  arr_ref<float> hint1(cmn.hint1, dimension(100));
  arr_ref<int> ihnt2(cmn.ihnt2, dimension(50));
  /// COMMON hmain1
  int& np = static_cast<common_hmain1&>(cmn).np;
  /// COMMON hmain2
  const int maxstr = 150001;
  arr_ref<int, 2> katt(cmn.katt, dimension(maxstr, 4));
  arr_ref<float, 2> patt(cmn.patt, dimension(maxstr, 4));
  /// COMMON hjcrdn
  arr_ref<float, 2> yp(cmn.yp, dimension(3, 300));
  arr_ref<float, 2> yt(cmn.yt, dimension(3, 300));
  /// COMMON hjjet1
  arr_ref<int> npj(cmn.npj, dimension(300));
  arr_ref<int, 2> kfpj(cmn.kfpj, dimension(300, 500));
  arr_ref<float, 2> pjpx(cmn.pjpx, dimension(300, 500));
  arr_ref<float, 2> pjpy(cmn.pjpy, dimension(300, 500));
  arr_ref<float, 2> pjpz(cmn.pjpz, dimension(300, 500));
  arr_ref<float, 2> pjpe(cmn.pjpe, dimension(300, 500));
  arr_ref<float, 2> pjpm(cmn.pjpm, dimension(300, 500));
  arr_ref<int> ntj(cmn.ntj, dimension(300));
  arr_ref<int, 2> kftj(cmn.kftj, dimension(300, 500));
  arr_ref<float, 2> pjtx(cmn.pjtx, dimension(300, 500));
  arr_ref<float, 2> pjty(cmn.pjty, dimension(300, 500));
  arr_ref<float, 2> pjtz(cmn.pjtz, dimension(300, 500));
  arr_ref<float, 2> pjte(cmn.pjte, dimension(300, 500));
  arr_ref<float, 2> pjtm(cmn.pjtm, dimension(300, 500));
  /// COMMON hjjet2
  arr_ref<int> njsg(cmn.njsg, dimension(maxstr));
  arr_ref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
  arr_ref<int, 2> k1sg(cmn.k1sg, dimension(maxstr, 100));
  arr_ref<int, 2> k2sg(cmn.k2sg, dimension(maxstr, 100));
  arr_ref<float, 2> pxsg(cmn.pxsg, dimension(maxstr, 100));
  arr_ref<float, 2> pysg(cmn.pysg, dimension(maxstr, 100));
  arr_ref<float, 2> pzsg(cmn.pzsg, dimension(maxstr, 100));
  arr_ref<float, 2> pesg(cmn.pesg, dimension(maxstr, 100));
  arr_ref<float, 2> pmsg(cmn.pmsg, dimension(maxstr, 100));
  /// COMMON hijdat
  arr_ref<float, 2> hidat0(cmn.hidat0, dimension(10, 10));
  arr_ref<float> hidat(cmn.hidat, dimension(10));
  /// COMMON hpint
  arr_ref<float, 2> atco(cmn.atco, dimension(200, 20));
  arr_ref<float> atxs(cmn.atxs, dim1(0, 200));
  ///
  common_variant hstrng(cmn.common_hstrng, sve.hstrng_bindings);
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> nfp(dimension(300, 15));
      mbr<float> pp(dimension(300, 15));
      mbr<int> nft(dimension(300, 15));
      mbr<float> pt(dimension(300, 15));
      hstrng.allocate(), nfp, pp, nft, pt;
    }
  }
  arr_ref<int, 2> nfp(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pp(hstrng.bind<float>(), dimension(300, 15));
  arr_ref<int, 2> nft(hstrng.bind<int>(), dimension(300, 15));
  arr_ref<float, 2> pt(hstrng.bind<float>(), dimension(300, 15));
  if (is_called_first_time) {
    cmn.num1 = 30123984;
    fem::data((values, 10 * datum(0.e0))), xl;
    fem::data((values, 10 * datum(1.e0))), xu;
    cmn.ncall = 1000;
    cmn.itmx = 100;
    cmn.acc = 0.01f;
    cmn.nprn = 0;
    {
      fem::data_values data;
      data.values, 1.5f, 0.35f, 0.5f, 0.9f, 2.0f, 0.1f, 1.5f, 2.0f;
      data.values, -1.0f, -2.25f, 2.0f, 0.5f, 1.0f, 2.0f, 0.2f, 2.0f;
      data.values, 2.5f, 0.3f, 0.1f, 1.4f, 1.6f, 1.0f, 2.0f, 0.0f;
      data.values, 0.0f, 0.0f, 0.0f, 0.0f, 0.4f, 57.0f, 28.5f, 3.9f;
      data.values, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 3.14159f;
      data.values, 0.0f, 0.4f, 0.1f, 1.5f, 0.1f, 0.25f, 0.0f, 0.5f;
      data.values, 0.0f, 0.0f, 50 * datum(0.0f);
      data, hipr1;
    }
    {
      fem::data_values data;
      data.values, 1, 3, 0, 1, 1, 1, 1, 10;
      data.values, 0, 0, 1, 1, 1, 1, 0, 0;
      data.values, 1, 0, 0, 1, 30 * datum(0);
      data, ihpr2;
    }
    fem::data((values, 100 * datum(0))), hint1;
    fem::data((values, 50 * datum(0))), ihnt2;
    cmn.natt = 0;
    cmn.eatt = 0.0f;
    cmn.jatt = 0;
    cmn.nt = 0;
    np = 0;
    cmn.n0 = 0;
    cmn.n01 = 0;
    cmn.n10 = 0;
    cmn.n11 = 0;
    fem::data((values, 600004 * datum(0))), katt;
    fem::data((values, 600004 * datum(0.0f))), patt;
    fem::data((values, 4500 * datum(0))), nfp;
    fem::data((values, 4500 * datum(0.0f))), pp;
    fem::data((values, 4500 * datum(0))), nft;
    fem::data((values, 4500 * datum(0.0f))), pt;
    fem::data((values, 900 * datum(0.0f))), yp;
    fem::data((values, 900 * datum(0.0f))), yt;
    fem::data((values, 300 * datum(0))), npj;
    fem::data((values, 150000 * datum(0))), kfpj;
    fem::data((values, 150000 * datum(0.0f))), pjpx;
    fem::data((values, 150000 * datum(0.0f))), pjpy;
    fem::data((values, 150000 * datum(0.0f))), pjpz;
    fem::data((values, 150000 * datum(0.0f))), pjpe;
    fem::data((values, 150000 * datum(0.0f))), pjpm;
    fem::data((values, 300 * datum(0))), ntj;
    fem::data((values, 150000 * datum(0))), kftj;
    fem::data((values, 150000 * datum(0.0f))), pjtx;
    fem::data((values, 150000 * datum(0.0f))), pjty;
    fem::data((values, 150000 * datum(0.0f))), pjtz;
    fem::data((values, 150000 * datum(0.0f))), pjte;
    fem::data((values, 150000 * datum(0.0f))), pjtm;
    cmn.nsg = 0;
    fem::data((values, 150001 * datum(0))), njsg;
    fem::data((values, 450003 * datum(0))), iasg;
    fem::data((values, 15000100 * datum(0))), k1sg;
    fem::data((values, 15000100 * datum(0))), k2sg;
    fem::data((values, 15000100 * datum(0.0f))), pxsg;
    fem::data((values, 15000100 * datum(0.0f))), pysg;
    fem::data((values, 15000100 * datum(0.0f))), pzsg;
    fem::data((values, 15000100 * datum(0.0f))), pesg;
    fem::data((values, 15000100 * datum(0.0f))), pmsg;
    cmn.mint4 = 0;
    cmn.mint5 = 0;
    fem::data((values, 4000 * datum(0.0f))), atco;
    fem::data((values, 201 * datum(0.0f))), atxs;
    {
      static const float values[] = {0.0f, 0.0f,  0.0f, 0.0f, 0.0f,
                                     0.0f, 2.25f, 2.5f, 4.0f, 4.1f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(1, sve.i); }
    }
    {
      static const float values[] = {2.0f, 3.0f, 5.0f,  6.0f,  7.0f,
                                     8.0f, 8.0f, 10.0f, 10.0f, 10.0f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(2, sve.i); }
    }
    {
      static const float values[] = {1.0f,   0.8f,  0.8f,  0.7f,  0.45f,
                                     0.215f, 0.21f, 0.19f, 0.19f, 0.19f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(3, sve.i); }
    }
    {
      static const float values[] = {0.35f, 0.35f, 0.3f, 0.3f, 0.3f,
                                     0.3f,  0.5f,  0.6f, 0.6f, 0.6f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(4, sve.i); }
    }
    {
      static const float values[] = {23.8f, 24.0f, 26.0f, 26.2f, 27.0f,
                                     28.5f, 28.5f, 28.5f, 28.5f, 28.5f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(5, sve.i); }
    }
    {
      fem::data_values data((values, 40 * datum(0.0f)));
      FEM_DO_SAFE(sve.j, 6, 9) {
        FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(sve.j, sve.i); }
      }
    }
    {
      static const float values[] = {5.0f,   20.0f,  53.0f,  62.0f,   100.0f,
                                     200.0f, 546.0f, 900.0f, 1800.0f, 4000.0f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(sve.i, 1, 10) { data, hidat0(10, sve.i); }
    }
    fem::data((values, 10 * datum(0.0f))), hidat;
  }
  /// Cc      SAVE /BVEG1/
  /// Cc      SAVE /SEDVAX/
  /// Cc      SAVE /HPARNT/
  /// Cc      SAVE /HMAIN1/
  /// Cc      SAVE /HMAIN2/
  /// Cc      SAVE /HSTRNG/
  /// Cc      SAVE /hjcrdn/
  /// Cc      SAVE /HJJET1/
  /// Cc      SAVE /HJJET2/
  /// Cc      SAVE /HIJDAT/
  /// Cc      SAVE /HPINT/
  /// C...give all the switchs and parameters the default values
  /// Clin-4/2008 input.ampt provides NSEED for AMPT:
  /// C        DATA NSEED/74769375/
  /// C
  /// C...initialize all the data common blocks
  /// Clin-4/26/01
  /// C        DATA KATT/520000*0/PATT/520000*0.0/
  /// C
  /// Clin-4/2008
  /// C        DATA NSG/0/,NJSG/900*0/,IASG/2700*0/,K1SG/90000*0/,K2SG/90000*0/
  /// C     &       ,PXSG/90000*0.0/,PYSG/90000*0.0/,PZSG/90000*0.0/
  /// C     &       ,PESG/90000*0.0/,PMSG/90000*0.0/
}

struct blockdata_ludata_save {
  fem::variant_bindings ludatr_bindings;
};

/// C
/// C*********************************************************************
/// C
void blockdata_ludata(common& cmn) {
  FEM_CMN_SVE(blockdata_ludata);
  /// COMMON ludat1
  arr_ref<int> mstu(cmn.mstu, dimension(200));
  arr_ref<float> paru(cmn.paru, dimension(200));
  arr_ref<int> mstj(cmn.mstj, dimension(200));
  arr_ref<float> parj(cmn.parj, dimension(200));
  /// COMMON ludat2
  arr_ref<int, 2> kchg(cmn.kchg, dimension(500, 3));
  arr_ref<float, 2> pmas(cmn.pmas, dimension(500, 4));
  arr_ref<float> parf(cmn.parf, dimension(2000));
  arr_ref<float, 2> vckm(cmn.vckm, dimension(4, 4));
  /// COMMON ludat3
  arr_ref<int, 2> mdcy(cmn.mdcy, dimension(500, 3));
  arr_ref<int, 2> mdme(cmn.mdme, dimension(2000, 2));
  arr_ref<float> brat(cmn.brat, dimension(2000));
  arr_ref<int, 2> kfdp(cmn.kfdp, dimension(2000, 5));
  /// COMMON ludat4
  str_arr_ref<1> chaf(cmn.chaf, dimension(500));
  ///
  common_variant ludatr(cmn.common_ludatr, sve.ludatr_bindings);
  int i = fem::int0;
  int j = fem::int0;
  if (is_called_first_time) {
    using fem::mbr;  /// member of variant common or equivalence
    {
      mbr<int> mrlu(dimension(6));
      mbr<float> rrlu(dimension(100));
      ludatr.allocate(), mrlu, rrlu;
    }
  }
  arr_ref<int> mrlu(ludatr.bind<int>(), dimension(6));
  /* arr_cref<float> rrlu( */ ludatr.bind<float>() /* , dimension(100)) */;
  if (is_called_first_time) {
    {
      fem::data_values data;
      data.values, 0, 0, 0, 9000, 10000, 500, 2000, 0;
      data.values, 0, 2, 6, 1, 1, 0, 1, 1;
      data.values, 0, 0, 0, 0, 2, 10, 0, 0;
      data.values, 1, 10, 0, 0, 0, 0, 0, 0;
      data.values, 0, 0, 0, 0, 0, 0, 0, 0;
      data.values, 2, 2, 1, 4, 2, 1, 1, 0;
      data.values, 0, 0, 25, 24, 0, 1, 0, 0;
      data.values, 0, 0, 0, 0, 0, 0, 0, 0;
      data.values, 0, 0, 0, 0, 0, 0, 40 * datum(0), 1;
      data.values, 5, 3, 5, 0, 0, 0, 0, 0;
      data.values, 0, 60 * datum(0), 7, 2, 1989, 11, 25, 0;
      data.values, 0, 0, 0, 0, 0, 0, 0, 0;
      data.values, 0, 0, 0, 0, 0, 0;
      data, mstu;
    }
    {
      fem::data_values data;
      data.values, 3.1415927f, 6.2831854f, 0.1973f, 5.068f, 0.3894f, 2.568f,
          4 * datum(0.f), 0.001f;
      data.values, 0.09f, 0.01f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 2.0f, 1.0f, 0.25f;
      data.values, 2.5f, 0.05f, 0.f, 0.f, 0.0001f, 0.f, 0.f, 2.5f;
      data.values, 1.5f, 7.0f, 1.0f, 0.5f, 2.0f, 3.2f, 0.f, 0.f;
      data.values, 0.f, 40 * datum(0.f), 0.0072974f, 0.230f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.20f, 0.25f, 1.0f, 4.0f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 1.0f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 70 * datum(0.f);
      data, paru;
    }
    {
      fem::data_values data;
      data.values, 1, 3, 0, 0, 0, 0, 0, 0;
      data.values, 0, 0, 1, 2, 0, 1, 0, 0;
      data.values, 0, 0, 0, 0, 2, 1, 1, 2;
      data.values, 1, 0, 0, 0, 0, 0, 0, 0;
      data.values, 0, 0, 0, 0, 0, 0, 0, 0;
      data.values, 1, 2, 4, 2, 5, 0, 1, 0;
      data.values, 0, 0, 0, 3, 0, 0, 0, 0;
      data.values, 0, 0, 0, 0, 40 * datum(0), 5, 2, 7;
      data.values, 5, 1, 1, 0, 2, 0, 1, 0;
      data.values, 0, 0, 0, 1, 1, 0, 0, 0;
      data.values, 0, 80 * datum(0);
      data, mstj;
    }
    {
      fem::data_values data;
      data.values, 0.10f, 0.30f, 0.40f, 0.05f, 0.50f, 0.50f, 0.50f, 0.f;
      data.values, 0.f, 0.f, 0.50f, 0.60f, 0.75f, 0.f, 0.f, 0.f;
      data.values, 0.f, 1.0f, 1.0f, 0.f, 0.35f, 1.0f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.10f, 1.0f;
      data.values, 0.8f, 1.5f, 0.8f, 2.0f, 0.2f, 2.5f, 0.6f, 2.5f;
      data.values, 0.5f, 0.9f, 0.5f, 0.9f, 0.5f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.77f, 0.77f, 0.77f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 1.0f, 0.f, 4.5f, 0.7f, 0.f, 0.003f;
      data.values, 0.5f, 0.5f, 0.f, 0.f, 0.f, 0.f, 10.f, 1000.f;
      data.values, 100.f, 1000.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.4f, 1.0f, 1.0f, 0.f, 10.f, 10.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.02f, 1.0f, 0.2f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 1.5f, 0.5f, 91.2f, 2.40f, 0.02f, 2.0f, 1.0f, 0.25f;
      data.values, 0.002f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.01f, 0.99f;
      data.values, 0.f, 0.f, 0.2f, 0.f, 60 * datum(0.f);
      data, parj;
    }
    {
      fem::data_values data;
      data.values, -1, 2, -1, 2, -1, 2, -1, 2;
      data.values, 2 * datum(0), -3, 0, -3, 0, -3, 0, -3;
      data.values, 6 * datum(0), 3, 9 * datum(0), 3, 2 * datum(0), 3,
          46 * datum(0), 2;
      data.values, -1, 2, -1, 2, 3, 11 * datum(0), 3, 0;
      data.values, 2 * datum(3), 0, 3, 0, 3, 12 * datum(0), 3, 0;
      data.values, 2 * datum(3), 0, 3, 0, 3, 12 * datum(0), 3, 0;
      data.values, 2 * datum(3), 0, 3, 0, 3, 12 * datum(0), 3, 0;
      data.values, 2 * datum(3), 0, 3, 0, 3, 12 * datum(0), 3, 0;
      data.values, 2 * datum(3), 0, 3, 0, 3, 12 * datum(0), 3, 0;
      data.values, 2 * datum(3), 0, 3, 0, 3, 72 * datum(0), 3, 0;
      data.values, 3, 28 * datum(0), 3, 2 * datum(0), 3, 8 * datum(0), -3,
          8 * datum(0);
      data.values, 3, 0, -3, 0, 3, -3, 3 * datum(0), 3;
      data.values, 6, 0, 3, 5 * datum(0), -3, 0, 3, -3;
      data.values, 0, -3, 4 * datum(0), -3, 0, 3, 6, -3;
      data.values, 0, 3, -3, 0, -3, 0, 3, 6;
      data.values, 0, 3, 5 * datum(0), -3, 0, 3, -3, 0;
      data.values, -3, 114 * datum(0);
      FEM_DO_SAFE(i, 1, 500) { data, kchg(i, 1); }
    }
    {
      fem::data_values data((values, 8 * datum(1), 12 * datum(0), 2,
                             68 * datum(0), -1, 410 * datum(0)));
      FEM_DO_SAFE(i, 1, 500) { data, kchg(i, 2); }
    }
    {
      fem::data_values data;
      data.values, 8 * datum(1), 2 * datum(0), 8 * datum(1), 5 * datum(0), 1,
          9 * datum(0), 1, 2 * datum(0);
      data.values, 1, 2 * datum(0), 1, 41 * datum(0), 1, 0, 7 * datum(1),
          10 * datum(0);
      data.values, 9 * datum(1), 11 * datum(0), 9 * datum(1), 11 * datum(0),
          9 * datum(1), 11 * datum(0), 9 * datum(1), 11 * datum(0);
      data.values, 9 * datum(1), 11 * datum(0), 9 * datum(1), 71 * datum(0),
          3 * datum(1), 22 * datum(0), 1, 5 * datum(0);
      data.values, 1, 0, 2 * datum(1), 6 * datum(0), 1, 0, 2 * datum(1),
          6 * datum(0);
      data.values, 2 * datum(1), 0, 5 * datum(1), 0, 6 * datum(1), 4 * datum(0),
          6 * datum(1), 4 * datum(0);
      data.values, 16 * datum(1), 4 * datum(0), 6 * datum(1), 114 * datum(0);
      FEM_DO_SAFE(i, 1, 500) { data, kchg(i, 3); }
    }
    {
      fem::data_values data;
      data.values, .0099f, .0056f, .199f, 1.35f, 5.f, 90.f, 120.f, 200.f;
      data.values, 2 * datum(0.f), .00051f, 0.f, .1057f, 0.f, 1.7841f, 0.f,
          60.f;
      data.values, 5 * datum(0.f), 91.2f, 80.f, 15.f, 6 * datum(0.f), 300.f,
          900.f, 600.f;
      data.values, 300.f, 900.f, 300.f, 2 * datum(0.f), 5000.f, 60 * datum(0.f),
          .1396f, .4977f;
      data.values, .4936f, 1.8693f, 1.8645f, 1.9693f, 5.2794f, 5.2776f,
          5.47972f, 0.f;
      data.values, .135f, .5488f, .9575f, 2.9796f, 9.4f, 117.99f, 238.f, 397.f;
      data.values, 2 * datum(0.f), .7669f, .8962f, .8921f, 2.0101f, 2.0071f,
          2.1127f, 2 * datum(5.3354f);
      data.values, 5.5068f, 0.f, .77f, .782f, 1.0194f, 3.0969f, 9.4603f, 118.f;
      data.values, 238.f, 397.f, 2 * datum(0.f), 1.233f, 2 * datum(1.3f),
          2 * datum(2.322f), 2.51f, 2 * datum(5.73f);
      data.values, 5.97f, 0.f, 1.233f, 1.17f, 1.41f, 3.46f, 9.875f, 118.42f;
      data.values, 238.42f, 397.42f, 2 * datum(0.f), .983f, 2 * datum(1.429f),
          2 * datum(2.272f), 2.46f, 2 * datum(5.68f);
      data.values, 5.92f, 0.f, .983f, 1.f, 1.4f, 3.4151f, 9.8598f, 118.4f;
      data.values, 238.4f, 397.4f, 2 * datum(0.f), 1.26f, 2 * datum(1.401f),
          2 * datum(2.372f), 2.56f, 2 * datum(5.78f);
      data.values, 6.02f, 0.f, 1.26f, 1.283f, 1.422f, 3.5106f, 9.8919f, 118.5f;
      data.values, 238.5f, 397.5f, 2 * datum(0.f), 1.318f, 2 * datum(1.426f),
          2 * datum(2.422f), 2.61f, 2 * datum(5.83f);
      data.values, 6.07f, 0.f, 1.318f, 1.274f, 1.525f, 3.5563f, 9.9132f,
          118.45f;
      data.values, 238.45f, 397.45f, 2 * datum(0.f), 2 * datum(.4977f),
          83 * datum(0.f), 1.1156f, 5 * datum(0.f), 2.2849f;
      data.values, 0.f, 2 * datum(2.46f), 6 * datum(0.f), 5.62f, 0.f,
          2 * datum(5.84f), 6 * datum(0.f), .9396f;
      data.values, .9383f, 0.f, 1.1974f, 1.1926f, 1.1894f, 1.3213f, 1.3149f,
          0.f;
      data.values, 2.454f, 2.4529f, 2.4522f, 2 * datum(2.55f), 2.73f,
          4 * datum(0.f), 3 * datum(5.8f), 2 * datum(5.96f);
      data.values, 6.12f, 4 * datum(0.f), 1.234f, 1.233f, 1.232f, 1.231f,
          1.3872f, 1.3837f;
      data.values, 1.3828f, 1.535f, 1.5318f, 1.6724f, 3 * datum(2.5f),
          2 * datum(2.63f), 2.8f, 4 * datum(0.f);
      data.values, 3 * datum(5.81f), 2 * datum(5.97f), 6.13f, 114 * datum(0.f);
      FEM_DO_SAFE(i, 1, 500) { data, pmas(i, 1); }
    }
    {
      fem::data_values data;
      data.values, 22 * datum(0.f), 2.4f, 2.3f, 88 * datum(0.f), .0002f, .001f,
          6 * datum(0.f), .149f;
      data.values, .0505f, .0513f, 7 * datum(0.f), .153f, .0085f, .0044f,
          7 * datum(0.f), .15f;
      data.values, 2 * datum(.09f), 2 * datum(.06f), .04f, 3 * datum(.1f), 0.f,
          .15f, .335f, .08f;
      data.values, 2 * datum(.01f), 5 * datum(0.f), .057f, 2 * datum(.287f),
          2 * datum(.06f), .04f, 3 * datum(.1f), 0.f;
      data.values, .057f, 0.f, .25f, .0135f, 6 * datum(0.f), .4f,
          2 * datum(.184f), 2 * datum(.06f);
      data.values, .04f, 3 * datum(.1f), 0.f, .4f, .025f, .055f, .0135f,
          6 * datum(0.f);
      data.values, .11f, .115f, .099f, 2 * datum(.06f), 4 * datum(.1f), 0.f,
          .11f, .185f;
      data.values, .076f, .0026f, 146 * datum(0.f), 4 * datum(.115f), .039f,
          2 * datum(.036f), .0099f, .0091f;
      data.values, 131 * datum(0.f);
      FEM_DO_SAFE(i, 1, 500) { data, pmas(i, 2); }
    }
    {
      fem::data_values data;
      data.values, 22 * datum(0.f), 2 * datum(20.f), 88 * datum(0.f), .002f,
          .005f, 6 * datum(0.f), .4f, 2 * datum(.2f);
      data.values, 7 * datum(0.f), .4f, .1f, .015f, 7 * datum(0.f), .25f,
          2 * datum(.01f), 3 * datum(.08f);
      data.values, 2 * datum(.2f), .12f, 0.f, .25f, .2f, .001f, 2 * datum(.02f),
          5 * datum(0.f);
      data.values, .05f, 2 * datum(.4f), 3 * datum(.08f), 2 * datum(.2f), .12f,
          0.f, .05f, 0.f;
      data.values, .35f, .05f, 6 * datum(0.f), 3 * datum(.3f), 2 * datum(.08f),
          .06f, 2 * datum(.2f), .12f;
      data.values, 0.f, .3f, .05f, .025f, .001f, 6 * datum(0.f), .25f,
          4 * datum(.12f);
      data.values, 4 * datum(.2f), 0.f, .25f, .17f, .2f, .01f, 146 * datum(0.f),
          4 * datum(.14f);
      data.values, .04f, 2 * datum(.035f), 2 * datum(.05f), 131 * datum(0.f);
      FEM_DO_SAFE(i, 1, 500) { data, pmas(i, 3); }
    }
    {
      fem::data_values data;
      data.values, 12 * datum(0.f), 658650.f, 0.f, .091f, 68 * datum(0.f), .1f,
          .43f, 15 * datum(0.f);
      data.values, 7803.f, 0.f, 3709.f, .32f, .128f, .131f, 3 * datum(.393f),
          84 * datum(0.f);
      data.values, .004f, 26 * datum(0.f), 15540.f, 26.75f, 83 * datum(0.f),
          78.88f, 5 * datum(0.f), .054f;
      data.values, 0.f, 2 * datum(.13f), 6 * datum(0.f), .393f, 0.f,
          2 * datum(.393f), 9 * datum(0.f), 44.3f;
      data.values, 0.f, 24.f, 49.1f, 86.9f, 6 * datum(0.f), .13f,
          9 * datum(0.f), .393f;
      data.values, 13 * datum(0.f), 24.6f, 130 * datum(0.f);
      FEM_DO_SAFE(i, 1, 500) { data, pmas(i, 4); }
    }
    {
      fem::data_values data;
      data.values, 0.5f, 0.25f, 0.5f, 0.25f, 1.f, 0.5f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.5f, 0.f, 0.5f, 0.f, 1.f, 1.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.5f, 0.f, 0.5f, 0.f;
      data.values, 1.f, 1.f, 0.f, 0.f, 0.f, 0.f, 0.5f, 0.f;
      data.values, 0.5f, 0.f, 1.f, 1.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.5f, 0.f, 0.5f, 0.f, 1.f, 1.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.5f, 0.f, 0.5f, 0.f, 1.f, 1.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.75f, 0.5f, 0.f, 0.1667f;
      data.values, 0.0833f, 0.1667f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 1.f, 0.3333f, 0.6667f, 0.3333f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 0.f, 0.f, 0.325f, 0.325f, 0.5f, 1.6f;
      data.values, 5.0f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.11f;
      data.values, 0.16f, 0.048f, 0.50f, 0.45f, 0.55f, 0.60f, 0.f, 0.f;
      data.values, 0.2f, 0.1f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
      data.values, 0.f, 0.f, 1870 * datum(0.f);
      data, parf;
    }
    {
      static const float values[] = {0.95150f, 0.04847f, 0.00003f, 0.00000f,
                                     0.04847f, 0.94936f, 0.00217f, 0.00000f,
                                     0.00003f, 0.00217f, 0.99780f, 0.00000f,
                                     0.00000f, 0.00000f, 0.00000f, 1.00000f};
      fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
      FEM_DO_SAFE(i, 1, 4) {
        FEM_DO_SAFE(j, 1, 4) { data, vckm(i, j); }
      }
    }
    {
      fem::data_values data;
      data.values, 14 * datum(0), 1, 0, 1, 5 * datum(0), 3 * datum(1),
          6 * datum(0), 1;
      data.values, 4 * datum(0), 1, 2 * datum(0), 1, 42 * datum(0),
          7 * datum(1), 12 * datum(0), 1;
      data.values, 0, 6 * datum(1), 0, 8 * datum(1), 2 * datum(0), 9 * datum(1),
          0, 8 * datum(1);
      data.values, 2 * datum(0), 9 * datum(1), 0, 8 * datum(1), 2 * datum(0),
          9 * datum(1), 0, 8 * datum(1);
      data.values, 2 * datum(0), 9 * datum(1), 0, 8 * datum(1), 2 * datum(0),
          9 * datum(1), 0, 8 * datum(1);
      data.values, 3 * datum(0), 1, 83 * datum(0), 1, 5 * datum(0), 1, 0,
          2 * datum(1);
      data.values, 6 * datum(0), 1, 0, 2 * datum(1), 9 * datum(0), 5 * datum(1),
          0, 6 * datum(1);
      data.values, 4 * datum(0), 6 * datum(1), 4 * datum(0), 16 * datum(1),
          4 * datum(0), 6 * datum(1), 114 * datum(0);
      FEM_DO_SAFE(i, 1, 500) { data, mdcy(i, 1); }
    }
    {
      fem::data_values data;
      data.values, 1, 9, 17, 25, 33, 41, 49, 57;
      data.values, 2 * datum(0), 65, 69, 71, 76, 78, 118, 120;
      data.values, 125, 2 * datum(0), 127, 136, 149, 166, 186, 6 * datum(0);
      data.values, 203, 4 * datum(0), 219, 2 * datum(0), 227, 42 * datum(0),
          236, 237;
      data.values, 241, 250, 252, 254, 256, 11 * datum(0), 276, 277;
      data.values, 279, 285, 406, 574, 606, 607, 608, 0;
      data.values, 609, 611, 617, 623, 624, 625, 626, 627;
      data.values, 2 * datum(0), 628, 629, 632, 635, 638, 640, 641;
      data.values, 642, 643, 0, 644, 645, 650, 658, 661;
      data.values, 670, 685, 686, 2 * datum(0), 687, 688, 693, 698;
      data.values, 700, 702, 703, 705, 707, 0, 709, 710;
      data.values, 713, 717, 718, 719, 721, 722, 2 * datum(0), 723;
      data.values, 726, 728, 730, 734, 738, 740, 744, 748;
      data.values, 0, 752, 755, 759, 763, 765, 767, 769;
      data.values, 770, 2 * datum(0), 771, 773, 775, 777, 779, 781;
      data.values, 784, 786, 788, 0, 791, 793, 806, 810;
      data.values, 812, 814, 816, 817, 2 * datum(0), 818, 824, 835;
      data.values, 846, 854, 862, 867, 875, 883, 0, 888;
      data.values, 895, 903, 905, 907, 909, 911, 912, 2 * datum(0);
      data.values, 913, 921, 83 * datum(0), 923, 5 * datum(0), 927, 0, 1001;
      data.values, 1002, 6 * datum(0), 1003, 0, 1004, 1005, 9 * datum(0), 1006;
      data.values, 1008, 1009, 1012, 1013, 0, 1015, 1016, 1017;
      data.values, 1018, 1019, 1020, 4 * datum(0), 1021, 1022, 1023, 1024;
      data.values, 1025, 1026, 4 * datum(0), 1027, 1028, 1031, 1034, 1035;
      data.values, 1038, 1041, 1044, 1046, 1048, 1052, 1053, 1054;
      data.values, 1055, 1057, 1059, 4 * datum(0), 1060, 1061, 1062, 1063;
      data.values, 1064, 1065, 114 * datum(0);
      FEM_DO_SAFE(i, 1, 500) { data, mdcy(i, 2); }
    }
    {
      fem::data_values data;
      data.values, 8 * datum(8), 2 * datum(0), 4, 2, 5, 2, 40, 2;
      data.values, 5, 2, 2 * datum(0), 9, 13, 17, 20, 17;
      data.values, 6 * datum(0), 16, 4 * datum(0), 8, 2 * datum(0), 9,
          42 * datum(0), 1;
      data.values, 4, 9, 3 * datum(2), 20, 11 * datum(0), 1, 2, 6;
      data.values, 121, 168, 32, 3 * datum(1), 0, 2, 2 * datum(6), 5 * datum(1);
      data.values, 2 * datum(0), 1, 3 * datum(3), 2, 4 * datum(1), 0, 1, 5;
      data.values, 8, 3, 9, 15, 2 * datum(1), 2 * datum(0), 1, 2 * datum(5);
      data.values, 2 * datum(2), 1, 3 * datum(2), 0, 1, 3, 4, 2 * datum(1);
      data.values, 2, 2 * datum(1), 2 * datum(0), 3, 2 * datum(2), 2 * datum(4),
          2, 3 * datum(4);
      data.values, 0, 3, 2 * datum(4), 3 * datum(2), 2 * datum(1), 2 * datum(0),
          5 * datum(2), 3;
      data.values, 2 * datum(2), 3, 0, 2, 13, 4, 3 * datum(2), 2 * datum(1);
      data.values, 2 * datum(0), 6, 2 * datum(11), 2 * datum(8), 5,
          2 * datum(8), 5, 0;
      data.values, 7, 8, 4 * datum(2), 2 * datum(1), 2 * datum(0), 8, 2,
          83 * datum(0);
      data.values, 4, 5 * datum(0), 74, 0, 2 * datum(1), 6 * datum(0), 1, 0;
      data.values, 2 * datum(1), 9 * datum(0), 2, 1, 3, 1, 2, 0;
      data.values, 6 * datum(1), 4 * datum(0), 6 * datum(1), 4 * datum(0), 1,
          2 * datum(3), 1, 3 * datum(3);
      data.values, 2 * datum(2), 4, 3 * datum(1), 2 * datum(2), 1, 4 * datum(0),
          6 * datum(1), 114 * datum(0);
      FEM_DO_SAFE(i, 1, 500) { data, mdcy(i, 3); }
    }
    {
      fem::data_values data;
      data.values, 6 * datum(1), -1, 7 * datum(1), -1, 7 * datum(1), -1,
          7 * datum(1), -1;
      data.values, 7 * datum(1), -1, 7 * datum(1), -1, 85 * datum(1),
          2 * datum(-1), 7 * datum(1), 2 * datum(-1);
      data.values, 3 * datum(1), 2 * datum(-1), 6 * datum(1), 2 * datum(-1),
          6 * datum(1), 3 * datum(-1), 3 * datum(1), -1;
      data.values, 3 * datum(1), -1, 3 * datum(1), 5 * datum(-1), 3 * datum(1),
          -1, 6 * datum(1), 2 * datum(-1);
      data.values, 3 * datum(1), -1, 11 * datum(1), 2 * datum(-1), 6 * datum(1),
          2 * datum(-1), 3 * datum(1), -1;
      data.values, 3 * datum(1), -1, 4 * datum(1), 2 * datum(-1), 2 * datum(1),
          -1, 488 * datum(1), 2 * datum(0);
      data.values, 1275 * datum(1);
      FEM_DO_SAFE(i, 1, 2000) { data, mdme(i, 1); }
    }
    {
      fem::data_values data;
      data.values, 70 * datum(102), 42, 6 * datum(102), 2 * datum(42),
          2 * datum(0), 7 * datum(41), 2 * datum(0), 23 * datum(41);
      data.values, 6 * datum(102), 45, 28 * datum(102), 8 * datum(32),
          9 * datum(0), 16 * datum(32), 4 * datum(0), 8 * datum(32);
      data.values, 4 * datum(0), 32, 4 * datum(0), 8 * datum(32), 8 * datum(0),
          4 * datum(32), 4 * datum(0), 6 * datum(32);
      data.values, 3 * datum(0), 12, 2 * datum(42), 2 * datum(11),
          9 * datum(42), 6 * datum(45), 20 * datum(46), 7 * datum(0);
      data.values, 34 * datum(42), 86 * datum(0), 2 * datum(25), 26,
          24 * datum(42), 142 * datum(0), 25, 26;
      data.values, 0, 10 * datum(42), 19 * datum(0), 2 * datum(13),
          3 * datum(85), 0, 2, 4 * datum(0);
      data.values, 2, 8 * datum(0), 2 * datum(32), 87, 88, 3 * datum(3), 0,
          2 * datum(3);
      data.values, 0, 2 * datum(3), 0, 3, 5 * datum(0), 3, 1, 0;
      data.values, 3, 2 * datum(0), 2 * datum(3), 3 * datum(0), 1, 4 * datum(0),
          12, 3 * datum(0);
      /// Fortran EMulation library of fable module

      using namespace std;
      namespace AMPT {
      using namespace fem::major_types;
void
acosh(...)
{
  throw std::runtime_error(
    }
    {
  fem::data_values data;
    "Missing function implementation: acosh");
}
dcosh(...)
    "Missing function implementation: dcosh");
dfour(...)
    "Missing function implementation: dfour");
digk(...)
    "Missing function implementation: digk");
djgk(...)
    "Missing function implementation: djgk");
std::complex<float>
fgk(...)
    "Missing function implementation: fgk");
four(...)
    "Missing function implementation: four");
hmeps(...)
    "Missing function implementation: hmeps");
idint(...)
    "Missing function implementation: idint");
ludbrb(...) data.values, .015f, .005f, 1.f, 0.f, 1.f, 0.f, 1.f, 0.f;
    "Missing function implementation: ludbrb");
    5 * datum(0.f);
pawt(...)
    "Missing function implementation: pawt");
rand(...)
    "Missing function implementation: rand");
srand(...)
    "Missing function implementation: srand");
struct common_gg float dx;
float dy;
float dz;
float dpx;
float dpy;
float dpz;
common_gg()
    : dx(fem::float0),
      dy(fem::float0),
      dz(fem::float0),
      dpx(fem::float0),
      dpy(fem::float0),
      dpz(fem::float0) {}
};  // namespace AMPT
struct common_zz int zta;
int zpr;
common_zz() : zta(fem::int0), zpr(fem::int0) struct common_run int num;
common_run() : num(fem::int0) struct common_input1 int masspr;
    }
    {
      fem::data_values data;
      int massta;
      int iseed;
      int iavoid;
      float dt;
      common_input1()
          : masspr(fem::int0),
            massta(fem::int0),
            iseed(fem::int0),
            iavoid(fem::int0),
            dt(fem::float0) data.values,
            .012f,
            .389f,
            .319f,
            .237f,
            .049f,
            .005f,
            .001f,
            .441f;
      struct common_input2 int ilab;
      data.values, .002f, .666f, .333f, .001f, .49f, .34f, .17f, .52f;
      int manyb;
      int ntmax;
      int icoll;
      int insys;
      int ipot;
      int mode;
      int imomen;
      data.values, .11f, .28f, .14f, .313f, .157f, .11f, .667f, .333f;
      int nfreq;
      int icflow;
      int icrho;
      int icou;
      int kpoten;
      int kmul;
      common_input2()
          : data.values,
          .6f, .3f, .067f, .033f, .6f, .3f, .067f, .033f;
      ilab(fem::int0), manyb(fem::int0), ntmax(fem::int0), icoll(fem::int0),
          insys(fem::int0), ipot(fem::int0), int ilab;
      mode(fem::int0), imomen(fem::int0), nfreq(fem::int0), icflow(fem::int0),
          icrho(fem::int0), icou(fem::int0), data.values, .332f, .166f, .168f,
          .084f, .086f, .043f, .059f, kpoten(fem::int0),
          kmul(fem::int0) struct common_input3 float plab;
      float elab;
      data.values, .08f, .04f, .3f, .15f, .16f, .08f, .13f, .06f;
      float zeropt;
      float b0;
      data.values, .08f, .13f, .06f, .08f, .04f, .3f, .15f, .16f;
      float bi;
      float bm;
      float dencut;
      float cycbox;
    }
    {
      fem::data_values data;
      common_input3()
          : plab(fem::float0),
            elab(fem::float0),
            zeropt(fem::float0),
            b0(fem::float0),
            bi(fem::float0),
            bm(fem::float0),
            dencut(fem::float0),
            cycbox(fem::float0) struct common_imulst int iperts;
      common_imulst() : iperts(fem::int0) struct common_coal double dpcoal;
      double drcoal;
      double ecritl;
      common_coal()
          : dpcoal(fem::double0),
            data.values,
            .331f,
            .663f,
            .006f,
            .663f,
            .331f,
            .006f,
            1.f,
            .88f;
      drcoal(fem::double0), ecritl(fem::double0) struct common_anim int nevent;
      int isoft;
    }
    {
      fem::data_values data;
      int isflag;
      int izpc;
      common_anim()
          : nevent(fem::int0),
            isoft(fem::int0),
            data.values,
            22,
            23,
            -24,
            25,
            23,
            24,
            -12,
            22;
      isflag(fem::int0), data.values, 22, 23, -24, 25, 23, 24, -89, 22;
      data.values, 23, -24, 25, 23, 24, 1, 2, 3;
      data.values, 4, 5, 6, 7, 8, 21, 1, 2;
      data.values, 3, 4, 5, 6, 7, 8, 11, 13;
      data.values, 15, 17, 37, 1, 2, 3, 4, 5;
      data.values, 6, 7, 8, 11, 12, 13, 14, 15;
      izpc(fem::int0) struct common_para7 data.values, -11, -13, -15, -17, 1, 2,
          3, 4;
      data.values, 5, 6, 7, 8, 11, 13, 15, 17;
      int ioscar;
      data.values, 5, 6, 7, 8, 11, 12, 13, 14;
      data.values, 15, 16, 17, 18, -1, -3, -5, -7;
      data.values, -11, -13, -15, -17, 1, 2, 3, 4;
      data.values, 5, 6, 11, 13, 15, 82, -11, -13;
      int nsmbbbar;
      int nsmmeson;
      common_para7()
          : ioscar(fem::int0),
            nsmbbbar(fem::int0),
            nsmmeson(fem::int0) struct common_embed int iembed;
      int nsembd;
      float pxqembd;
      float pyqembd;
      float xembd;
      float yembd;
      float psembd;
      float tmaxembd;
      float phidecomp;
      common_embed()
          : iembed(fem::int0),
            nsembd(fem::int0),
            pxqembd(fem::float0),
            pyqembd(fem::float0),
            data.values,
            -311,
            -313,
            -311,
            -313,
            -311,
            -313,
            -311,
            -313;
      data.values, -311, -313, -311, -321, -323, -321, -323, 211;
      data.values, 213, 211, 213, 111, 221, 331, 113, 223;
      data.values, 333, 221, 331, 113, 223, 113, 223, 113;
      data.values, 223, 333, 223, 333, 321, 323, 321, 323;
      xembd(fem::float0), yembd(fem::float0), psembd(fem::float0),
          tmaxembd(fem::float0), phidecomp(fem::float0) struct common_xyembed
    }
    {
      fem::data_values data;
      static const int nxymax = 10001;
      int nxyjet;
      arr<float, 2> xyjet;
      common_xyembed()
          : nxyjet(fem::int0),
            xyjet(dimension(nxymax, 2), fem::fill0)
                const int common_xyembed::nxymax;
      struct common_arprnt arr<float> arpar1;
      arr<int> iapar2;
      data.values, 331, 333, 211, 213, 211, 213, 321, 323;
      arr<float> arint1;
      arr<int> iaint2;
      common_arprnt()
          : arpar1(dimension(100), fem::fill0),
            iapar2(dimension(50), fem::fill0),
            arint1(dimension(100), fem::fill0),
            iaint2(dimension(50), fem::fill0) struct common_arprc data.values,
            22,
            111,
            11,
            13,
            82,
            11,
            13,
            15;
      data.values, 1, 2, 3, 4, 21, 22, 11, 12;
      data.values, 13, 14, 15, 16, 1, 2, 3, 4;
      static const int maxstr = 150001;
      arr<int> itypar;
      arr<float> gxar;
      data.values, 223, 213, 113, -213, 313, -313, 323, -323;
      arr<float> gyar;
      arr<float> gzar;
      data.values, 421, 413, 423, 431, 433, 521, 511, 523;
      data.values, 513, 511, 521, 513, 523, 521, 511, 531;
      data.values, 533, 221, 213, -213, 211, 111, 321, 130;
      data.values, 211, 111, 321, 130, 443, 82, 553, 21;
      arr<float> ftar;
      arr<float> pxar;
      data.values, 523, 521, 511, 533, 213, -213, 10211, 10111;
      arr<float> pyar;
      arr<float> pzar;
      data.values, -313, 323, -323, 443, 82, 553, 21, 663;
      arr<float> pear;
      arr<float> xmar;
      common_arprc()
          : itypar(dimension(maxstr), fem::fill0),
            gxar(dimension(maxstr), fem::fill0),
            gyar(dimension(maxstr), fem::fill0),
            gzar(dimension(maxstr), fem::fill0),
    }
    {
      fem::data_values data;
      ftar(dimension(maxstr), fem::fill0), pxar(dimension(maxstr), fem::fill0),
          pyar(dimension(maxstr), fem::fill0), data.values, 111, 321, 130, 443,
          82, 553, 21, 663;
      pzar(dimension(maxstr), fem::fill0), pear(dimension(maxstr), fem::fill0),
          xmar(dimension(maxstr), fem::fill0) const int common_arprc::maxstr;
      struct common_dpert static const int maxr = 1;
      arr<float, 2> dpertt;
      arr<float> dpertp;
      arr<float> dplast;
      arr<float> dpdcy;
      arr<float, 2> dpdpi;
      arr<float, 2> dpt;
      arr<float, 2> dpp1;
      arr<float, 2> dppion;
      common_dpert()
          : data.values,
          3122, 3212, 3112, 3122, 3222, 3112, 3122, 3222;
      data.values, 3212, 3322, 3312, 3322, 3312, 3122, 3322, 3312;
      dpertt(dimension(maxstr, maxr), fem::fill0),
          dpertp(dimension(maxstr), fem::fill0),
          dplast(dimension(maxstr), fem::fill0),
          dpdcy(dimension(maxstr), fem::fill0),
    }
    {
      fem::data_values data;
      dpdpi(dimension(maxstr, maxr), fem::fill0),
          dpt(dimension(maxstr, maxr), fem::fill0),
          dpp1(dimension(maxstr, maxr), fem::fill0),
          dppion(dimension(maxstr, maxr), fem::fill0)
              const int common_dpert::maxstr;
      const int common_dpert::maxr;
      struct common_smearz double smearp;
      data.values, 14, 13, 11, 13, -211, -213, -211, -213;
      double smearh;
      common_smearz()
          : smearp(fem::double0),
            smearh(fem::double0) struct common_rndf77 data.values,
            -3,
            -4,
            -5,
            -6,
            -7,
            -8,
            21,
            -1;
      data.values, -2, -3, -4, -5, -6, -7, -8, -11;
      data.values, -13, -15, -17, -37, -1, -2, -3, -4;
      data.values, -5, -6, -7, -8, -11, -12, -13, -14;
      data.values, -15, -16, -17, -18, -37, 2, 4, 6;
      data.values, 8, 2, 4, 6, 8, 2, 4, 6;
      data.values, 8, 2, 4, 6, 8, 12, 14, 16;
      data.values, 18, -1, -2, -3, -4, -5, -6, -7;
      int nseed;
      data.values, -24, -1, -2, -3, -4, -5, -6, -7;
      data.values, -8, -11, -12, -13, -14, -15, -16, -17;
      data.values, -18, 2, 4, 6, 8, 12, 14, 16;
      data.values, 18, -3, -4, -5, -6, -7, -8, -13;
      data.values, -15, -17, -82, 12, 14, -1, -3, 11;
      data.values, 13, 15, 1, 4, 3, 4, 1, 3;
      data.values, 5, 3, 6, 4, 7, 5, 2, 4;
      data.values, 6, 8, 2, 4, 6, 8, 2, 4;
      data.values, 6, 8, 2, 4, 6, 8, 12, 14;
      common_rndf77()
          : nseed(fem::int0) struct common_para8 data.values,
          211, 213, 211, 213, 211, 213, 211, 213;
      int idpert;
      int npertd;
      int idxsec;
      common_para8()
          : idpert(fem::int0),
            npertd(fem::int0),
            idxsec(fem::int0) struct common_nzpc int nattzp;
      common_nzpc() : nattzp(fem::int0) struct common_hparnt arr<float> hipr1;
      arr<int> ihpr2;
      arr<float> hint1;
      arr<int> ihnt2;
      common_hparnt()
          : hipr1(dimension(100), fem::fill0), ihpr2(dimension(50), fem::fill0),
    }
    {
      fem::data_values data;
      hint1(dimension(100), fem::fill0),
          ihnt2(dimension(50), fem::fill0) struct common_arerc1 arr<int> multi1;
      common_arerc1()
          : multi1(dimension(maxr), fem::fill0) const int common_arerc1::maxr;
      struct common_arprc1 arr<int, 2> ityp1;
      ihnt2(dimension(50), fem::fill0) arr<float, 2> gx1;
      arr<float, 2> gy1;
      arr<float, 2> gz1;
      arr<float, 2> ft1;
      arr<float, 2> px1;
      arr<float, 2> py1;
      arr<float, 2> pz1;
      arr<float, 2> ee1;
      arr<float, 2> xm1;
      common_arprc1()
          : ityp1(dimension(maxstr, maxr), fem::fill0),
            data.values,
            22,
            -11,
            -13,
            -82,
            -11,
            -13,
            -15,
            -1;
      gx1(dimension(maxstr, maxr), fem::fill0),
          gy1(dimension(maxstr, maxr), fem::fill0),
          gz1(dimension(maxstr, maxr), fem::fill0), data.values, 223, 211, 111,
          211, 111, 223, 211, 111;
      ft1(dimension(maxstr, maxr), fem::fill0), data.values, 111, -211, 111,
          211, -311, 311, -321, 321;
      px1(dimension(maxstr, maxr), fem::fill0), data.values, -211, 111, 211,
          111, 211, 111, 211, 111;
      py1(dimension(maxstr, maxr), fem::fill0),
          pz1(dimension(maxstr, maxr), fem::fill0), data.values, 211, -211, 111,
          -321, 310, -211, 111, -321;
      ee1(dimension(maxstr, maxr), fem::fill0), data.values, 211, 111, -211,
          111, 211, 111, 211, 111;
      data.values, -211, 111, 321, 311, 111, -211, 111, 211;
      data.values, 111, -321, -311, 111, -211, 211, -211, 111;
      xm1(dimension(maxstr, maxr), fem::fill0) const int common_arprc1::maxstr;
      data.values, -321, -311, 311, -321, 321, 22, -82, 22;
      const int common_arprc1::maxr;
      data.values, -211, 111, -211, 111, -211, 211, -213, 113;
      struct common_tdecay data.values, 213, 113, 223, 221, 22, 211, 111, 211;
      arr<float> tfdcy;
      data.values, -211, 211, 321, 311;
      arr<float, 2> tfdpi;
    }
    {
      fem::data_values data;
      arr<float> tft;
      common_tdecay()
          : tfdcy(dimension(maxstr), fem::fill0),
            tfdpi(dimension(maxstr, maxr), fem::fill0),
            tft(dimension(maxstr), fem::fill0) data.values,
            -321,
            310,
            22,
            -82,
            22,
            21,
            22,
            21;
      const int common_tdecay::maxstr;
      const int common_tdecay::maxr;
      struct common_ludat2 data.values, 213, 211, 213, 211, 213, 111, 221, 331;
      data.values, 113, 223, 111, 221, 113, 223, 321, 323;
      data.values, 321, -211, -213, 111, 221, 331, 113, 223;
      data.values, 111, 221, 331, 113, 223, 211, 213, 211;
      data.values, 213, 321, 323, 321, 323, 321, 323, 311;
      arr<int, 2> kchg;
      arr<float, 2> pmas;
      data.values, 211, 22, -211, 111, 22, -211, 111, 211;
      arr<float> parf;
      ihnt2(dimension(50), fem::fill0) arr<float, 2> vckm;
      common_ludat2()
          : kchg(dimension(500, 3), fem::fill0),
            data.values,
            -211,
            111,
            11,
            -211,
            111,
            211,
            111,
            22;
      pmas(dimension(500, 4), fem::fill0), parf(dimension(2000), fem::fill0),
          vckm(dimension(4, 4), fem::fill0)
    }
    {
      fem::data_values data;
      struct common_arana1 arr<float> dy1ntb;
      arr<float> dy1ntp;
      arr<float> dy1hm;
      arr<float> dy1kp;
      arr<float> dy1km;
      arr<float> dy1k0s;
      arr<float> dy1la;
      arr<float> dy1lb;
      arr<float> dy1phi;
      arr<float> dm1pip;
      arr<float> dm1pim;
      data.values, 221, 331, 113, 223, 211, 111, 211, 111;
      arr<float> dmt1pr;
      arr<float> dmt1pb;
      data.values, 111, -211, 111, 211, 111, 211, -211, 111;
      arr<float> dmt1kp;
      arr<float> dm1km;
      arr<float> dm1k0s;
      arr<float> dmt1la;
      arr<float> dmt1lb;
      arr<float> dy1msn;
      arr<float> dy1pip;
      arr<float> dy1pim;
      common_smearz() : arr<float> dy1pi0;
      arr<float> dy1pr;
      arr<float> dy1pb;
      arr<float> dy1neg;
      arr<float> dy1ch;
      arr<float> de1neg;
      data.values, 331, 223, 111, 221, 331, 113, 223, 113;
      arr<float> de1ch;
      common_arana1()
          : dy1ntb(dimension(50), fem::fill0),
            dy1ntp(dimension(50), fem::fill0),
            dy1hm(dimension(50), fem::fill0),
            dy1kp(dimension(50), fem::fill0),
            data.values,
            221,
            331,
            333,
            321,
            311,
            221,
            331,
            333;
      dy1km(dimension(50), fem::fill0), dy1k0s(dimension(50), fem::fill0),
          dy1la(dimension(50), fem::fill0), dy1lb(dimension(50), fem::fill0),
          dy1phi(dimension(50), fem::fill0), dm1pip(dimension(50), fem::fill0),
          dm1pim(dimension(50), fem::fill0), dmt1pr(dimension(50), fem::fill0),
          dmt1pb(dimension(50), fem::fill0), dmt1kp(dimension(50), fem::fill0),
          dm1km(dimension(50), fem::fill0), dm1k0s(dimension(50), fem::fill0),
          dmt1la(dimension(50), fem::fill0), dmt1lb(dimension(50), fem::fill0),
          dy1msn(dimension(50), fem::fill0), dy1pip(dimension(50), fem::fill0),
          dy1pim(dimension(50), fem::fill0),
    }
    {
      fem::data_values data;
      dy1pi0(dimension(50), fem::fill0), data.values, 2112, 3122, 3212, 3214,
          2112, 2114, 2212, 2112;
      dy1pr(dimension(50), fem::fill0), dy1pb(dimension(50), fem::fill0),
          dy1neg(dimension(50), fem::fill0),
    }
    {
      fem::data_values data;
      dy1ch(dimension(50), fem::fill0), de1neg(dimension(50), fem::fill0),
          de1ch(dimension(50), fem::fill0) struct common_arana2 arr<float>
              dy2ntb;
      arr<float> dy2ntp;
      arr<float> dy2hm;
      arr<float> dy2kp;
      arr<float> dy2km;
      arr<float> dy2k0s;
      arr<float> dy2la;
      arr<float> dy2lb;
      arr<float> dy2phi;
      arr<float> dy1msn;
      arr<float> dm2pip;
      arr<float> dm2pim;
      arr<float> dmt2pr;
      arr<float> dmt2pb;
      arr<float> dmt2kp;
      arr<float> dm2km;
      arr<float> dm2k0s;
      arr<float> dmt2la;
      arr<float> dmt2lb;
      arr<float> dy2msn;
      arr<float> dy2pip;
      arr<float> dy2pim;
      arr<float> dy2pi0;
    }
    {
      fem::data_values data;
      arr<float> dy2pr;
      dy1k0s(dimension(50), fem::fill0), arr<float> dy2pb;
      arr<float> dy2neg;
      arr<float> dy2ch;
      arr<float> de2neg;
      arr<float> de2ch;
      common_arana2()
          : dy2ntb(dimension(50), fem::fill0),
            dy2ntp(dimension(50), fem::fill0),
    }
    {
      fem::data_values data;
      data.values, "d", "u", "s", "c", "b", "t", "l", "h";
      dy2hm(dimension(50), fem::fill0), dy2kp(dimension(50), fem::fill0),
          dy2km(dimension(50), fem::fill0), dy2k0s(dimension(50), fem::fill0),
          dy2la(dimension(50), fem::fill0), dy2lb(dimension(50), fem::fill0),
          dy2phi(dimension(50), fem::fill0), dm2pip(dimension(50), fem::fill0),
          dm2pim(dimension(50), fem::fill0), dmt2pr(dimension(50), fem::fill0),
          dmt2pb(dimension(50), fem::fill0), dmt2kp(dimension(50), fem::fill0),
          dm2km(dimension(50), fem::fill0), dm2k0s(dimension(50), fem::fill0),
          dmt2la(dimension(50), fem::fill0), dmt2lb(dimension(50), fem::fill0),
          dy2msn(dimension(50), fem::fill0), dy2pip(dimension(50), fem::fill0),
          dy2pim(dimension(50), fem::fill0), dy2pi0(dimension(50), fem::fill0),
          dy2pr(dimension(50), fem::fill0), dy2pb(dimension(50), fem::fill0),
          dy2neg(dimension(50), fem::fill0), dy2ch(dimension(50), fem::fill0),
          de2neg(dimension(50), fem::fill0),
          de2ch(dimension(50), fem::fill0) struct common_ee arr<int> id;
      arr<int> lb;
      common_ee()
          : id(dimension(maxstr), fem::fill0),
            lb(dimension(maxstr), fem::fill0) const int common_ee::maxstr;
      struct common_aa arr<float, 2> r;
      common_aa()
          : r(dimension(3, maxstr), fem::fill0) const int common_aa::maxstr;
      struct common_bb arr<float, 2> p;
    }
    {
      fem::data_values data;
      common_bb()
          : p(dimension(3, maxstr), fem::fill0) const int common_bb::maxstr;
      struct common_cc arr<float> e;
      common_cc()
          : e(dimension(maxstr), fem::fill0) const int common_cc::maxstr;
      struct common_bg float betax;
    }
    {
      float betay;
      float betaz;
    }
  }
  /// C
  float gamma;
  common_bg()
      :  /// C
        betax(fem::float0),
        /// C
        betay(fem::float0),
        /// C
        betaz(fem::float0),
        /// C
        gamma(fem::float0)
        /// C
        struct common_nn
  /// C
}

int nnn;

/// C
/// C*********************************************************************
/// C
common_nn() : FEM_CMN_SVE(blockdata_pydata);
/// COMMON pysubs
arr_ref<int> msub(cmn.msub, dimension(200));
arr_ref<int, 2> kfin(cmn.kfin, dim1(2).dim2(-40, 40));
arr_ref<float> ckin(cmn.ckin, dimension(200));
/// COMMON pypars
arr_ref<int> mstp(cmn.mstp, dimension(200));
arr_ref<float> parp(cmn.parp, dimension(200));
arr_ref<int> msti(cmn.msti, dimension(200));
arr_ref<float> pari(cmn.pari, dimension(200));
/// COMMON pyint1
arr_ref<int> mint(cmn.mint, dimension(400));
arr_ref<float> vint(cmn.vint, dimension(400));
/// COMMON pyint2
arr_ref<int> iset(cmn.iset, dimension(200));
arr_ref<int, 2> kfpr(cmn.kfpr, dimension(200, 2));
arr_ref<float, 2> coef(cmn.coef, dimension(200, 20));
arr_ref<int, 3> icol(cmn.icol, dimension(40, 4, 2));
/// COMMON pyint6
str_arr_ref<1> proc(cmn.proc, dim1(0, 200));
///
int i = fem::int0;
int j = fem::int0;
int k = fem::int0;
if (is_called_first_time) {
  cmn.msel = 1;
  nnn(fem::int0) {
    struct common_pa arr<float, 3> rpion;
    FEM_DO_SAFE(i, 1, 2) { common_pa() : }
  }
  {
    fem::data_values data;
    data.values, 2.0f, -1.0f, 0.0f, -1.0f, 1.0f, 1.0f, -10.f, 10.f;
    data.values, -10.f, 10.f, -10.f, 10.f, -10.f, 10.f, -10.f, 10.f;
    data.values, -1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f;
    data.values, -1.0f, 1.0f, -1.0f, 1.0f, 0.f, 0.f, 2.0f, -1.0f;
    data.values, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f;
    rpion(dimension(3, maxstr, maxr), fem::fill0) data, ckin;
  }
  {
    static const int values[] = { const int common_pa::maxstr;
    const int common_pa::maxr;
    struct common_pb arr<float, 3> ppion;
    common_pb() : fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    ppion(dimension(3, maxstr, maxr), fem::fill0)
  }
  {
    static const int values[] = { const int common_pb::maxstr;
    const int common_pb::maxr;
    struct common_pc struct common_pc arr<float, 2> epion;
    fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    common_pc() :
  }
  {
    static const float values[] = {
      epion(dimension(maxstr, maxr), fem::fill0) const int common_pc::maxstr;
    const int common_pc::maxstr;
    const int common_pc::maxr;
    const int common_pc::maxstr;
    struct common_pd arr<int, 2> lpion;
    common_pd()
        : lpion(dimension(maxstr, maxr), fem::fill0)
              const int common_pd::maxstr;
    fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
    const int common_pd::maxr;
  }
  {
    static const float values[] = { struct common_leadng int lb1;
    float px1;
    float py1;
    float py1;
    float py1;
    float py1;
    float py1;
    float pz1;
    fem::data_of_type<float> data(FEM_VALUES_AND_SIZE);
    float em1;
  }
  float e1;
  float xfnl;
  float yfnl;
  float zfnl;
  {
    static const int values[] = { float tfnl;
    float px1n;
    float py1n;
    float pz1n;
    float dp1n;
    common_leadng() : fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    lb1(fem::int0),
  }
  {
    static const int values[] = {
      px1(fem::float0), py1(fem::float0), pz1(fem::float0), em1(fem::float0),
      e1(fem::float0), xfnl(fem::float0),
      fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    yfnl(fem::float0),
  }
  {
    static const int values[] = {
      zfnl(fem::float0), tfnl(fem::float0), px1n(fem::float0),
      py1n(fem::float0), pz1n(fem::float0),
      dp1n(fem::float0) fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    FEM_DO_SAFE(i, 1, 50) { struct common_dpi }
  }
  {
    static const int values[] = { float em2;
    int lb2;
    common_dpi() : em2(fem::float0), int lb2;
    lb2(fem::int0) fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    FEM_DO_SAFE(i, 51, 100) { struct common_dpi }
  }
  {
    static const int values[] = { struct common_table arr<float> xarray;
    arr<float> earray;
    arr<float> earray;
    common_table()
        : xarray(dim1(0, 1000), fem::fill0),
          fem::data_of_type<int>
              data(FEM_VALUES_AND_SIZE);
    FEM_DO_SAFE(i, 101, 150) { struct common_dpi }
  }
  {
    static const int values[] = {
      earray(dim1(0, 1000), fem::fill0) struct common_arevt earray(
          dim1(0, 1000), fem::fill0)
          earray(dim1(0, 1000), fem::fill0) int iaevt;
    fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    FEM_DO_SAFE(i, 151, 200) { struct common_dpi }
  }
  int iarun;
  {
    static const int values[] = { int miss;
    common_arevt()
        : iaevt(fem::int0),
          iarun(fem::int0),
          miss(fem::int0) struct common_ff static const int mx = 4;
    static const int my = 4;
    static const int mz = 8;
    static const int mpx = 4;
    static const int mpx = 4;
    static const int mpx = 4;
    static const int mpx = 4;
    static const int mpy = 4;
    fem::data_of_type<int> data(FEM_VALUES_AND_SIZE);
    FEM_DO_SAFE(i, 1, 40) {
      FEM_DO_SAFE(j, 1, 4) { static const int mpz = 10; }
    }
  }
  proc(0) = "All included subprocesses   ";
  {
    static const char* values[] = { static const int mpzp = 10;
    arr<float, 6> f;
    common_ff()
        : f(dim1(-mx, mx)
                .dim2(-my, my)
                .dim3(-mz, mz)
                .dim4(-mpx, mpx)
                .dim5(-mpy, mpy)
                .dim6(-mpz, mpzp),
            fem::fill0) const int common_ff::mx;
    const int common_ff::my;
    const int common_ff::mz;
    const int common_ff::mpx;
    const int common_ff::mpy;
    fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
    const int common_ff::mpz;
  }
  {
    static const char* values[] = { const int common_ff::mpzp;
    struct common_input int nstar;
    int ndirct;
    float dir;
    common_input()
        : nstar(fem::int0),
          ndirct(fem::int0),
          dir(fem::float0) struct common_ppbmas fem::data_of_type_str data(
              FEM_VALUES_AND_SIZE);
    arr<int> niso;
  }
  {
    static const char* values[] = { int nstate;
    arr<float, 2> ppbm;
    arr<float> thresh;
    arr<float> weight;
    common_ppbmas()
        : niso(dimension(15), fem::fill0),
          nstate(fem::int0),
          ppbm(dimension(15, 2), fem::fill0),
          thresh(dimension(15), fem::fill0),
          weight(dimension(15), fem::fill0)
              fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
    struct common_ppb1
  }
  {
    static const char* values[] = { float ene;
    arr<float> factr2;
    float fsum;
    float ppinnb;
    float s;
    float wtot;
    common_ppb1()
        : ene(fem::float0),
          factr2(dimension(6), fem::fill0),
          fsum(fem::float0),
          fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
    ppinnb(fem::float0),
  }
  {
      static const char* values[] = {
    s(fem::float0),
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
    wtot(fem::float0)
struct common_ppmm
  float pprr;
      mpy).dim6(-mpz, mpzp), fem::fill0)
  float ppee;
      fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
      float pppe;
  }
  {
    static const char* values[] = { float rpre;
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
  float xopoe;
      float rree;
      common_ppmm() : pprr(fem::float0), float ppee;
      fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
      ppee(fem::float0),
  }
  {
      static const char* values[] = {
    pppe(fem::float0),
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
  float ppee;
      fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
      rpre(fem::float0),
  }
  {
      static const char* values[] = {
    xopoe(fem::float0),
    rree(fem::float0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
  float ppee;
      fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
      struct common_dd
  }
  {
    static const char* values[] = { static const int maxx = 20;
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
      mpy).dim6(-mpz, mpzp), fem::fill0)
  float ppee;
      fem::data_of_type_str data(FEM_VALUES_AND_SIZE);
      static const int maxz = 24;
  }
  {
    struct common_pa arr<float, 3> rho;
    arr<float, 3> rhop;
  }
}
/// C
arr<float, 3> rhon;
/// C
common_dd()
    :  /// C
      rho(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
      /// C
      rhop(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0),
      /// C
      rhon(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz), fem::fill0)
/// C
}  // namespace AMPT

const int common_dd::maxx;
int i;
int nspec1;
int nspec2;

const int common_dd::maxz;
}
;

/// C
/// C=======================================================================
struct common_hh FEM_CMN_SVE(getnp);
/// COMMON hmain1
int& natt = cmn.natt;
/// COMMON hmain2
const int maxstr = 150001;
arr_cref<int, 2> katt(cmn.katt, dimension(maxstr, 4));
arr_cref<float, 2> patt(cmn.patt, dimension(maxstr, 4));
/// COMMON hparnt
arr_cref<float> hint1(cmn.hint1, dimension(100));
arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
/// COMMON snn
int& npart1 = cmn.npart1;
int& npart2 = cmn.npart2;
float& epsipz = cmn.epsipz;
float& epsipt = cmn.epsipt;
float& pzproj = cmn.pzproj;
float& pztarg = cmn.pztarg;
///
/// SAVE
int& i = sve.i;
int& nspec1 = sve.nspec1;
int& nspec2 = sve.nspec2;
///
/// C
/// Cc      SAVE /HMAIN1/
/// Cc      SAVE /HMAIN2/
/// Cc      SAVE /HPARNT/
/// Cc      SAVE /snn/
/// C
if (natt == 0) {
  npart1 = 0;
  npart2 = 0;
  return;
}
/// C
pzproj = fem::sqrt(fem::pow2(hint1(6)) - fem::pow2(hint1(8)));
pztarg = fem::sqrt(fem::pow2(hint1(7)) - fem::pow2(hint1(9)));
epsipz = 0.01f;
arr<float> proper;
common_hh() : epsipt = 1e-6f;
/// C
nspec1 = 0;
nspec2 = 0;
FEM_DO_SAFE(i, 1, natt) {
  /// Clin-9/2011 determine spectator nucleons consistently
  proper(dimension(maxstr), fem::fill0) const int common_hh::maxstr;
  struct common_pe arr<float, 2> propi;
  if (patt(i, 3) > fem::amax1(0.f, pzproj - epsipz)) {
    nspec1++;
    common_pe() : nspec2++;
  }
}
}
npart1 = ihnt2(1) - nspec1;
npart2 = ihnt2(3) - nspec2;
/// C
}

propi(dimension(maxstr, maxr), fem::fill0) fem::variant_bindings prec2_bindings;
}
;

/// C
/// C*****************************************************************************
/// C
const int common_pe::maxstr;
FEM_CMN_SVE(blockdata_zpcbdt);
/// COMMON ana1
arr_ref<double> ts(cmn.ts, dimension(12));
///
common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
const int maxptn = 400001;
if (is_called_first_time) {
  using fem::mbr;  /// member of variant common or equivalence
  {
    mbr<double> gx(dimension(maxptn));
    mbr<double> gy(dimension(maxptn));
    mbr<double> gz(dimension(maxptn));
    mbr<double> ft(dimension(maxptn));
    mbr<double> px(dimension(maxptn));
    mbr<double> py(dimension(maxptn));
    mbr<double> pz(dimension(maxptn));
    mbr<double> e(dimension(maxptn));
    mbr<double> xmass(dimension(maxptn));
    mbr<int> ityp(dimension(maxptn));
    prec2.allocate(), gx, gy, gz, ft, px, py, pz, e, xmass, ityp;
  }
}
/* arr_cref<double> gx( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> gy( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> gz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> ft( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> px( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> py( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> pz( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> e( */ prec2.bind<double>() /* , dimension(maxptn)) */;
/* arr_cref<double> xmass( */ prec2.bind<double>() /* , dimension(
  maxptn)) */
    ;
/* arr_cref<int> ityp( */ prec2.bind<int>() /* , dimension(maxptn)) */;
if (is_called_first_time) {
  cmn.centy = 0e0;
  cmn.number = 0;
  {
    const int common_pe::maxr;
    struct common_rr arr<int> massr;
    common_rr() :
  }
}
massr(dim1(0, maxr), fem::fill0)
    /// C
    /// Cc      SAVE /para1/
    /// Cc      SAVE /para2/
    /// Cc      SAVE /para3/
    /// Cc      SAVE /para4/
    /// Cc      SAVE /para5/
    /// Cc      SAVE /para6/
    const int common_rr::maxr;
struct common_dpifsl int lbnn1;
/// Cc      SAVE /para7/
/// Cc      SAVE /prec1/
/// Cc      SAVE /prec2/
/// Cc      SAVE /prec3/
/// Cc      SAVE /prec4/
/// Cc      SAVE /prec5/
/// Cc      SAVE /prec6/
/// Cc      SAVE /aurec1/
/// Cc      SAVE /aurec2/
/// Cc      SAVE /ilist1/
/// Cc      SAVE /ilist2/
/// Cc      SAVE /ilist3/
/// Cc      SAVE /ilist4/
int lbnn2;
int lbnd1;
/// Cc      SAVE /ilist5/
/// Cc      SAVE /ilist6/
/// Cc      SAVE /ilist7/
/// Cc      SAVE /ilist8/
/// Cc      SAVE /rndm1/
/// Cc      SAVE /rndm2/
/// Cc      SAVE /rndm3/
/// Cc      SAVE /ana1/
/// Cc      SAVE /ana2/
/// Cc      SAVE /ana3/
/// Cc      SAVE /ana4/
int lbnn2;
int lbnd2;
int lbns1;
int lbns2;
/// C
}

int lbnp1;
double a;
int i;
int irused;
int isedng;
int iseed;
int iseed2;
fem::str<50> str;

int lbnp2;
      : a(fem::double0),
        i(fem::int0),
  int lbdd1;
      int lbdd2;
      iseed(fem::int0), int lbds1;
      int lbds2;
      }
      ;

      int lbdp1;
      FEM_CMN_SVE(readpa);
      common_write write(cmn);
      /// COMMON para4
      int& ireflg = cmn.ireflg;
      /// COMMON para5
      int& iconfg = cmn.iconfg;
      /// COMMON ilist3
      double& size1 = cmn.size1;
      double& size2 = cmn.size2;
      double& size3 = cmn.size3;
      double& v1 = cmn.v1;
      double& v2 = cmn.v2;
      double& v3 = cmn.v3;
      ///
      /// SAVE
      double& a = sve.a;
      int& irused = sve.irused;
      int& isedng = sve.isedng;
      int& iseed = sve.iseed;
      int& iseed2 = sve.iseed2;
      ///
      /// C
      /// Cc      SAVE /para2/
      /// Cc      SAVE /para3/
      /// Cc      SAVE /para4/
      /// Cc      SAVE /para5/
      /// Cc      SAVE /para7/
      /// Cc      SAVE /ilist3/
      /// Cc      SAVE /rndm1/
      /// Cc      SAVE /rndm2/
      /// Cc      SAVE /rndm3/
      /// C
      iseed = cmn.iseedp;
      int lbdp2;
      int lbss1;
      /// Cbz1/31/99
      int lbss2;
      /// Cbz1/31/99end
      /// C
      int lbsp1;
      int lbsp2;
      int lbpp1;
      /// Cbz1/31/99end
      /// C
      int lbpp2;
      /// Cbz1/25/99
      common_dpifsl()
          :  /// Cbz1/25/99end
             /// C
            lbnn1(fem::int0),
            /// Cbz1/31/99
            lbnn2(fem::int0),
            if (cmn.ioscar == 1){
                lbnd1(fem::int0),
                lbnd2(fem::int0),
            }  /// Cbz1/31/99end
               /// C
            lbns1(fem::int0),
            lbns2(fem::int0),
            lbnp1(fem::int0),
            cmn.xmp = 0e0;
      lbnp2(fem::int0), lbdd1(fem::int0),
          cmn.cutof2 = 4.5e0 * fem::pow2((cmn.alpha / cmn.xmu));
      lbdd2(fem::int0), cmn.rscut2 = 0.01e0;
      lbds1(fem::int0), cmn.nsevt = 1;
      lbds2(fem::int0), cmn.nevnt = 1;
      lbdp1(fem::int0), cmn.nsbrun = 1;
      lbdp2(fem::int0), cmn.iftflg = 0;
      lbss1(fem::int0), ireflg = 1;
      /// Cbz1/31/99
      if (ireflg == 0) {
        lbss2(fem::int0),
      }
      /// Cbz1/31/99end
      lbsp1(fem::int0), cmn.igeflg = 0;
      lbsp2(fem::int0), cmn.ibstfg = 0;
      lbpp1(fem::int0), iconfg = 1;
      lbpp2(fem::int0) cmn.iordsc = 11;
      struct common_dpifsm float xmnn1;
      v1 = 0.2e0;
      v2 = 0.2e0;
      v3 = 0.2e0;
      float xmnn2;
      size1 = 1.5e0;
      size2 = 1.5e0;
      size3 = 0.7e0;
      if (size1 == 0e0 || size2 == 0e0 || size3 == 0e0) {
        if (size1 != 0e0 || size2 != 0e0 || size3 != 0e0 || v1 != 0e0 ||
            v2 != 0e0 || v3 != 0e0) {
          write(6, star), "to get rid of space division:";
          write(6, star), "set all sizes and vs to 0";
          FEM_STOP("chker");
        }
      }
      cmn.size = fem::min(size1, size2, size3);
      float xmnd1;
      cmn.iff = -1;
      float xmnd2;
      /// C
      float xmns1;
      isedng = -iseed;
      float xmns2;
      a = ran1(cmn, isedng);
      float xmnp1;
      irused = 2;
      FEM_DO_SAFE(sve.i, 1, irused - 1) {
        float xmnp2;
        iseed2 = 2;
        a = ran1(cmn, iseed2);
      }
      float xmdd1;
      /// C
      if (iconfg == 2 || iconfg == 3) {
        v1 = 0e0;
        v2 = 0e0;
      }
      /// C
      if (iconfg == 4 || iconfg == 5) {
        v1 = 0e0;
        v2 = 0e0;
        v3 = 0e0;
      }
      /// C
      cmn.io.close(5);
      /// C
      }

      float xmdd2;
      /// C
      /// Cc      SAVE /para4/
      /// Cc      SAVE /para6/
      /// C
      if (cmn.ibstfg != 0) {
        cmn.centy = -6e0;
      }
      /// C
      }

      float xmds1;
      double a;
      int i;

      float xmds2;
      }
      ;

      float xmdp1;
      FEM_CMN_SVE(inian1);
      /// COMMON ana1
      arr_ref<double> ts(cmn.ts, dimension(12));
      ///
      /// SAVE
      double& a = sve.a;
      int& i = sve.i;
      ///
      /// C
      /// Cc      SAVE /para4/
      /// Cc      SAVE /ana1/
      if (cmn.ibstfg != 0) {
        a = fem::cosh(6e0);
        float xmdp2;
      }
      /// C
      }

      /// C
      /// C*****************************************************************************
      /// C
      float xmss1;
      /// C
      readpa(cmn);
      /// C
      inipar(cmn);
      /// C
      inian1(cmn);
      /// C
      }

      float xmss2;
      fem::variant_bindings prec2_bindings;
      float diff2;
      arr<float> dnrg1b;
      arr<float> dtg1b;
      float gx0;
      float gy0;
      int i;
      int ir;
      int isevt;
      int isrun;
      int it;
      int iw;
      int j;
      int k;
      float r0;
      arr<float> snrg1b;
      arr<float> stg1b;
      float tau7;

      float xmsp1;
      : diff2(fem::float0),
  float xmsp2;
      float xmpp1;
      gx0(fem::float0), gy0(fem::float0), i(fem::int0), ir(fem::int0),
          isevt(fem::int0), isrun(fem::int0), it(fem::int0), iw(fem::int0),
          j(fem::int0), k(fem::int0), r0(fem::float0), float xmpp2;
      common_dpifsm() : tau7(fem::float0) {}
      }
      ;

      /// C
      /// C-----------------------------------------------------------------------
      /// C
      xmnn1(fem::float0),
          /// C
          xmnn2(fem::float0), FEM_CMN_SVE(hjan1b);
      common_write write(cmn);
      const int maxptn = 400001;
      arr_cref<int> lstrg1(cmn.lstrg1, dimension(maxptn));
      int& nsp = cmn.nsp;
      int& nst = cmn.nst;
      arr_cref<float, 2> yp(cmn.yp, dimension(3, 300));
      arr_cref<float, 2> yt(cmn.yt, dimension(3, 300));
      const int maxstr = 150001;
      arr_cref<int, 2> iasg(cmn.iasg, dimension(maxstr, 3));
      int& iaevt = cmn.iaevt;
      int& iarun = cmn.iarun;
      ///
      common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
      float& diff2 = sve.diff2;
      arr_ref<float> dnrg1b(sve.dnrg1b, dimension(50));
      arr_ref<float> dtg1b(sve.dtg1b, dimension(50));
      float& gx0 = sve.gx0;
      float& gy0 = sve.gy0;
      int& i = sve.i;
      int& ir = sve.ir;
      int& isevt = sve.isevt;
      int& isrun = sve.isrun;
      int& it = sve.it;
      int& iw = sve.iw;
      int& j = sve.j;
      int& k = sve.k;
      float& r0 = sve.r0;
      arr_ref<float> snrg1b(sve.snrg1b, dimension(50));
      arr_ref<float> stg1b(sve.stg1b, dimension(50));
      float& tau7 = sve.tau7;
      if (is_called_first_time) {
        using fem::mbr;  /// member of variant common or equivalence
        {
          mbr<double> gx5(dimension(maxptn));
          mbr<double> gy5(dimension(maxptn));
          mbr<double> gz5(dimension(maxptn));
          mbr<double> ft5(dimension(maxptn));
          mbr<double> px5(dimension(maxptn));
          mbr<double> py5(dimension(maxptn));
          mbr<double> pz5(dimension(maxptn));
          mbr<double> e5(dimension(maxptn));
          mbr<double> xmass5(dimension(maxptn));
          mbr<int> ityp5(dimension(maxptn));
          prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5,
              ityp5;
        }
      }
      arr_cref<double> gx5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> gy5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> gz5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
      /* arr_cref<double> px5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> py5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> pz5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> e5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> xmass5( */ prec2.bind<double>() /* , dimension(
        maxptn)) */
          ;
      /* arr_cref<int> ityp5( */ prec2.bind<int>() /* , dimension(maxptn)) */;
      if (is_called_first_time) {
        iw = 0;
      }
      const float dr = 0.2f;
      const float dt = 0.2f;
      /// Cc      SAVE /PARA1/
      /// Cc      SAVE /prec2/
      /// Cc      SAVE /ilist8/
      /// Cc      SAVE /SREC1/
      /// Cc      SAVE /hjcrdn/
      /// Cc      SAVE /HJJET2/
      /// Cc      SAVE /AREVT/
      /// Cc      SAVE /AROUT/
      /// C
      if (isevt == iaevt && isrun == iarun) {
        FEM_DO_SAFE(i, 1, 50) {
          dnrg1b(i) = snrg1b(i);
          dtg1b(i) = stg1b(i);
        }
      } else {
        FEM_DO_SAFE(i, 1, 50) {
          snrg1b(i) = dnrg1b(i);
          stg1b(i) = dtg1b(i);
        }
        isevt = iaevt;
        isrun = iarun;
        iw++;
      }
      /// C.....analysis
      FEM_DO_SAFE(i, 1, cmn.mul) {
        j = lstrg1(i);
        /// C
        if (j <= nsp) {
          k = j;
          gx0 = yp(1, j);
          gy0 = yp(2, j);
          xmnd1(fem::float0), k = j - nsp;
          gx0 = yt(1, k);
          gy0 = yt(2, k);
        } else {
          k = j - nsp - nst;
          gx0 = 0.5f * (yp(1, iasg(k, 1)) + yt(1, iasg(k, 2)));
          gy0 = 0.5f * (yp(2, iasg(k, 1)) + yt(2, iasg(k, 2)));
        }
        r0 = fem::sqrt(fem::pow2((fem::sngl(gx5(i)) - gx0)) +
                       fem::pow2((fem::sngl(gy5(i)) - gy0)));
        ir = 1 + fem::fint(r0 / dr);
        if (ir > 50 || ir < 1) {
          goto statement_100;
        }
        dnrg1b(ir) += 1.0f;
      statement_100:
        /// Clin-9/2015 to avoid Floating-Point Exception:
        /// C         TAU7 = SQRT(sngl(FT5(I) ** 2 - GZ5(I) ** 2))
        diff2 = fem::sngl(fem::pow2(ft5(i)) - fem::pow2(gz5(i)));
        if (diff2 < 0.f) {
          write(6, star), "5:I,ft5,gz5,diff2=", i, ft5(i), gz5(i), diff2;
          tau7 = 1e-6f;
        } else {
          tau7 = fem::sqrt(diff2);
        }
        /// C
        it = 1 + fem::fint(tau7 / dt);
        if (it > 50 || it < 1) {
          goto statement_200;
        }
        dtg1b(it) += 1.0f;
      statement_200:;
      }
      /// C
      }

      xmnd2(fem::float0), fem::variant_bindings prec2_bindings;
      arr<float> dgxg1a;
      arr<float> dgyg1a;
      float diff2;
      arr<float> dtg1a;
      int i;
      int igx;
      int igy;
      int isevt;
      int isrun;
      int it;
      int iw;
      arr<float> sgxg1a;
      arr<float> sgyg1a;
      arr<float> stg1a;

      xmns1(fem::float0), xmns2(fem::float0), xmnp1(fem::float0),
          diff2(fem::float0), xmnp2(fem::float0), i(fem::int0), igx(fem::int0),
          igy(fem::int0), isevt(fem::int0), isrun(fem::int0), it(fem::int0),
          iw(fem::int0), xmdd1(fem::float0), xmdd2(fem::float0),
          xmds1(fem::float0),
      }
      ;

      /// C
      /// C-----------------------------------------------------------------------
      /// C
      xmds2(fem::float0), xmdp1(fem::float0),
          /// C
          xmdp2(fem::float0), FEM_CMN_SVE(hjan1a);
      common_write write(cmn);
      int& iaevt = cmn.iaevt;
      int& iarun = cmn.iarun;
      ///
      const int maxptn = 400001;
      common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
      arr_ref<float> dgxg1a(sve.dgxg1a, dimension(50));
      arr_ref<float> dgyg1a(sve.dgyg1a, dimension(50));
      float& diff2 = sve.diff2;
      arr_ref<float> dtg1a(sve.dtg1a, dimension(50));
      int& i = sve.i;
      int& igx = sve.igx;
      int& igy = sve.igy;
      int& isevt = sve.isevt;
      int& isrun = sve.isrun;
      int& it = sve.it;
      int& iw = sve.iw;
      arr_ref<float> sgxg1a(sve.sgxg1a, dimension(50));
      arr_ref<float> sgyg1a(sve.sgyg1a, dimension(50));
      arr_ref<float> stg1a(sve.stg1a, dimension(50));
      if (is_called_first_time) {
        using fem::mbr;  /// member of variant common or equivalence
        {
          mbr<double> gx5(dimension(maxptn));
          mbr<double> gy5(dimension(maxptn));
          mbr<double> gz5(dimension(maxptn));
          mbr<double> ft5(dimension(maxptn));
          mbr<double> px5(dimension(maxptn));
          mbr<double> py5(dimension(maxptn));
          mbr<double> pz5(dimension(maxptn));
          mbr<double> e5(dimension(maxptn));
          mbr<double> xmass5(dimension(maxptn));
          mbr<int> ityp5(dimension(maxptn));
          prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5,
              ityp5;
        }
      }
      arr_cref<double> gx5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> gy5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> gz5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
      /* arr_cref<double> px5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> py5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> pz5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> e5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> xmass5( */ prec2.bind<double>() /* , dimension(
        maxptn)) */
          ;
      /* arr_cref<int> ityp5( */ prec2.bind<int>() /* , dimension(maxptn)) */;
      if (is_called_first_time) {
        iw = 0;
      }
      const float dgx = 0.2f;
      const float dgy = 0.2f;
      const float dt = 0.2f;
      /// Cc      SAVE /PARA1/
      /// Cc      SAVE /prec2/
      /// Cc      SAVE /AREVT/
      /// Cc      SAVE /AROUT/
      /// C
      if (isevt == iaevt && isrun == iarun) {
        FEM_DO_SAFE(i, 1, 50) {
          dgxg1a(i) = sgxg1a(i);
          dgyg1a(i) = sgyg1a(i);
          dtg1a(i) = stg1a(i);
        }
      } else {
        FEM_DO_SAFE(i, 1, 50) {
          sgxg1a(i) = dgxg1a(i);
          sgyg1a(i) = dgyg1a(i);
          stg1a(i) = dtg1a(i);
        }
        isevt = iaevt;
        isrun = iarun;
        iw++;
      }
      /// C.....analysis
      FEM_DO_SAFE(i, 1, cmn.mul) {
        igx = 1 + fem::fint(fem::sngl(fem::abs(gx5(i))) / dgx);
        /// Clin-4/2008 protect against out-of-bound errors:
        xmss1(fem::float0), if (igx > 50 || igx < 1) { goto statement_100; }
        dgxg1a(igx) += 1.0f;
      statement_100:
        igy = 1 + fem::fint(fem::sngl(fem::abs(gy5(i))) / dgy);
        if (igy > 50 || igy < 1) {
          goto statement_200;
        }
        dgyg1a(igy) += 1.0f;
      statement_200:
        /// Clin-9/2015 to avoid Floating-Point Exception:
        xmss2(fem::float0),
            diff2 = fem::sngl(fem::pow2(ft5(i)) - fem::pow2(gz5(i)));
        if (diff2 < 0.f) {
          write(6, star), "1:I,ft5,gz5,diff2=", i, ft5(i), gz5(i), diff2;
          it = 1;
        } else {
          it = 1 + fem::fint(fem::sqrt(diff2) / dt);
        }
        /// C
        if (it > 50 || it < 1) {
          goto statement_300;
        }
        dtg1a(it) += 1.0f;
        xmsp1(fem::float0),
      }
      hjan1b(cmn);
      /// C
      }

      xmsp2(fem::float0), arr<float> deyh3;
      arr<float> dmyh3;
      arr<float> dndyh3;
      float dxmt;
      float ee;
      int i;
      int imt;
      int ityp;
      int iw;
      int iy;
      int j;
      float px;
      float py;
      float pz;
      float xm;
      float xmt;
      float y;

      xmpp1(fem::float0), xmpp2(fem::float0) struct common_dpisig float sdmel;
      dxmt(fem::float0), ee(fem::float0), i(fem::int0), imt(fem::int0),
          ityp(fem::int0), iw(fem::int0), iy(fem::int0), j(fem::int0),
          px(fem::float0), py(fem::float0), pz(fem::float0), xm(fem::float0),
          xmt(fem::float0), y(fem::float0) {}
      }
      ;

      /// C
      /// C-----------------------------------------------------------------------
      /// C
      float sdmnn;
      float sdmnd;
      FEM_CMN_SVE(hjana3);
      common_write write(cmn);
      const int maxr = 1;
      arr_cref<int> multi1(cmn.multi1, dimension(maxr));
      const int maxstr = 150001;
      arr_cref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
      arr_cref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
      arr_cref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
      ///
      arr_ref<float> deyh3(sve.deyh3, dimension(50));
      arr_ref<float> dmyh3(sve.dmyh3, dimension(50));
      arr_ref<float> dndyh3(sve.dndyh3, dimension(50));
      float& dxmt = sve.dxmt;
      int& i = sve.i;
      int& imt = sve.imt;
      int& ityp = sve.ityp;
      int& iw = sve.iw;
      int& iy = sve.iy;
      int& j = sve.j;
      float& px = sve.px;
      float& py = sve.py;
      float& pz = sve.pz;
      float& xm = sve.xm;
      float& xmt = sve.xmt;
      float& y = sve.y;
      if (is_called_first_time) {
        iw = 0;
      }
      const float dy = 0.2f;
      const float ymin = -1.0f;
      const float ymax = 1.0f;
      const float dmt = 0.05f;
      /// C
      /// C.....y cut for mt spectrum
      float sdmns;
      /// C.....bin width for mt spectrum and y spectrum
      /// Cc      SAVE /RUN/
      /// Cc      SAVE /ARERC1/
      /// Cc      SAVE /ARPRC1/
      /// Cc      SAVE /AROUT/
      float sdmnp;
      /// C
      iw++;
      FEM_DO_SAFE(j, 1, cmn.num) {
        FEM_DO_SAFE(i, 1, multi1(j)) {
          ityp = ityp1(i, j);
          float sdmdd;
          goto statement_200;
        }
        px = px1(i, j);
        py = py1(i, j);
        pz = pz1(i, j);
        sve.ee = ee1(i, j);
        xm = xm1(i, j);
        xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(xm));
        dxmt = xmt - xm;
        /// Clin-9/2012 determine rapidity more generally:
        /// C            IF (ABS(PZ) .GE. EE) THEN
        float sdmds;
        float sdmdp;
        /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ',
        /// PY C               PRINT *, ' PZ = ', PZ, ' EE = ', EE C PRINT *, '
        /// XM = ', XM C               GOTO 200 C            END IF C Y = 0.5 *
        /// LOG((EE + PZ +1e-5) / (EE - PZ + 1e-5))
        if (xmt > 0.f) {
          y = asinh(pz / xmt);
        } else {
          write(6, star), " IN HJANA3 mt=0";
          y = 1000000.0f * fem::sign(1.f, pz);
        }
        /// C
        /// C.....rapidity cut for the rapidity distribution
        float sdmss;
        float sdmsp;
        float sdmpp;
        iy = 1 + fem::fint(y / dy);
        common_dpisig()
            :  /// C            IF (IY .GT. 50) GOTO 100
              if (iy < 1 || iy > 50) {
          goto statement_100;
        }
        dndyh3(iy) += 1.0f;
        deyh3(iy) += xmt;
      statement_100:
        sdmel(fem::float0), if (y < ymin || y >= ymax) { goto statement_200; }
        imt = 1 + fem::fint(dxmt / dmt);
        if (imt > 50) {
          goto statement_200;
        }
        dmyh3(imt) += 1.0f / xmt;
      statement_200:;
      }
      }
      /// C
      }

      sdmnn(fem::float0), arr<float> deyh4;
      arr<float> dmyh4;
      arr<float> dndyh4;
      float dxmt;
      float ee;
      int i;
      int imt;
      int ityp;
      int iw;
      int iy;
      int j;
      float px;
      float py;
      float pz;
      float xm;
      float xmt;
      float y;

      sdmnd(fem::float0), sdmns(fem::float0), sdmnp(fem::float0),
          sdmdd(fem::float0), dxmt(fem::float0), ee(fem::float0), i(fem::int0),
          imt(fem::int0), ityp(fem::int0), iw(fem::int0), iy(fem::int0),
          j(fem::int0), px(fem::float0), py(fem::float0), pz(fem::float0),
          xm(fem::float0), xmt(fem::float0), y(fem::float0) {}
      }
      ;

      /// C
      /// C-----------------------------------------------------------------------
      /// C
      sdmds(fem::float0), sdmdp(fem::float0), FEM_CMN_SVE(hjana4);
      common_write write(cmn);
      const int maxr = 1;
      arr_cref<int> multi1(cmn.multi1, dimension(maxr));
      const int maxstr = 150001;
      arr_cref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
      arr_cref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> pz1(static_cast<common_arprc1&>(cmn).pz1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> ee1(cmn.ee1, dimension(maxstr, maxr));
      arr_cref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
      ///
      arr_ref<float> deyh4(sve.deyh4, dimension(50));
      arr_ref<float> dmyh4(sve.dmyh4, dimension(50));
      arr_ref<float> dndyh4(sve.dndyh4, dimension(50));
      float& dxmt = sve.dxmt;
      int& i = sve.i;
      int& imt = sve.imt;
      int& ityp = sve.ityp;
      int& iw = sve.iw;
      int& iy = sve.iy;
      int& j = sve.j;
      float& px = sve.px;
      float& py = sve.py;
      float& pz = sve.pz;
      float& xm = sve.xm;
      float& xmt = sve.xmt;
      float& y = sve.y;
      if (is_called_first_time) {
        iw = 0;
      }
      const float dy = 0.2f;
      const float ymin = -1.0f;
      const float ymax = 1.0f;
      const float dmt = 0.05f;
      /// C.....y cut for mt spectrum
      sdmss(fem::float0), sdmsp(fem::float0), float sdmns;
      /// C.....bin width for mt spectrum and y spectrum
      /// C
      /// Cc      SAVE /RUN/
      /// Cc      SAVE /ARERC1/
      /// Cc      SAVE /ARPRC1/
      /// Cc      SAVE /AROUT/
      sdmpp(fem::float0)
          /// C
          iw++;
      FEM_DO_SAFE(j, 1, cmn.num) {
        FEM_DO_SAFE(i, 1, multi1(j)) {
          ityp = ityp1(i, j);
          float sdmdd;
          goto statement_200;
        }
        px = px1(i, j);
        py = py1(i, j);
        pz = pz1(i, j);
        sve.ee = ee1(i, j);
        xm = xm1(i, j);
        xmt = fem::sqrt(fem::pow2(px) + fem::pow2(py) + fem::pow2(xm));
        dxmt = xmt - xm;
        /// Clin-9/2012 determine rapidity more generally:
        /// C            IF (ABS(PZ) .GE. EE) THEN
        struct common_ludat1 float sdmdp;
        /// C               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ',
        /// PY C               PRINT *, ' PZ = ', PZ, ' EE = ', EE C PRINT *, '
        /// XM = ', XM C               GOTO 200 C            END IF C Y = 0.5 *
        /// LOG((EE + PZ +1e-5) / (EE - PZ + 1e-5))
        if (xmt > 0.f) {
          y = asinh(pz / xmt);
        } else {
          write(6, star), " IN HJANA4 mt=0";
          y = 1000000.0f * fem::sign(1.f, pz);
        }
        /// C
        /// C.....rapidity cut for the rapidity distribution
        float sdmss;
        float sdmsp;
        float sdmpp;
        iy = 1 + fem::fint(y / dy);
        common_dpisig()
            :  /// C            IF (IY .GT. 50) GOTO 100
              if (iy < 1 || iy > 50) {
          goto statement_100;
        }
        dndyh4(iy) += 1.0f;
        deyh4(iy) += xmt;
      statement_100:
        sdmel(fem::float0), if (y < ymin || y >= ymax) { goto statement_200; }
        imt = 1 + fem::fint(dxmt / dmt);
        if (imt > 50) {
          goto statement_200;
        }
        dmyh4(imt) += 1.0f / xmt;
      statement_200:;
      }
      }
      /// C
      }

      arr<int> mstu;
      float ene;
      int i;
      int ia;
      int ianh;
      int ic;
      int ifanim;
      int ii;
      int iloop;
      int iy;
      int j;
      int mult;
      int nhadrn;
      double pt2;
      float px;
      float py;
      float rap;
      arr<float> tsh;
      double v2hadr;
      arr<double> v2hevt;
      float xperp2;

      arr<float> paru;
      : ene(fem::float0),
        i(fem::int0),
        ia(fem::int0),
  arr<int> mstj;
      ic(fem::int0), arr<float> parj;
      ii(fem::int0),
          common_ludat1()
          : iy(fem::int0),
            j(fem::int0),
            mstu(dimension(200), fem::fill0),
            paru(dimension(200), fem::fill0),
            pt2(fem::double0),
            px(fem::float0),
            py(fem::float0),
            rap(fem::float0),
            mstj(dimension(200), fem::fill0),
            parj(dimension(200),
                 fem::fill0) struct common_ludat4 arr<fem::str<8> > chaf;
      }
      ;

      /// C
      common_ludat4()
          : chaf(dimension(500), fem::fill0) struct common_lujets int n;
      arr<int, 2> k;
      arr<float, 2> v;
      common_lujets()
          : n(fem::int0),
            k(dimension(9000, 5), fem::fill0),
            p(dimension(9000, 5), fem::fill0),
            v(dimension(9000, 5),
              fem::fill0) struct common_ludat3 arr<int, 2> mdcy;
      arr<int, 2> mdme;
      arr<float> brat;
      arr<int, 2> kfdp;
      common_ludat3()
          : mdcy(dimension(500, 3), fem::fill0),
            mdme(dimension(2000, 2), fem::fill0),
            brat(dimension(2000), fem::fill0),
            kfdp(dimension(2000, 5), fem::fill0) struct common_resdcy int nsav;
      int iksdcy;
      common_resdcy()
          : nsav(fem::int0), iksdcy(fem::int0) struct common_phidcy int iphidcy;
      float pttrig;
      int ntrig;
      int maxmiss;
      int ipi0dcy;
      common_phidcy()
          : iphidcy(fem::int0),
            pttrig(fem::float0),
            ntrig(fem::int0),
            maxmiss(fem::int0),
            ipi0dcy(fem::int0) struct common_ss arr<int> inout;
      common_ss()
          : inout(dimension(20), fem::fill0) struct common_kkk arr<float> tkaon;
      arr<float, 2> ekaon;
      common_kkk()
          : tkaon(dimension(7), fem::fill0),
            ekaon(dim1(7).dim2(0, 2000),
                  fem::fill0) struct common_kaon arr<float, 3> ak;
      arr<float, 3> speck;
      int mf;
      common_kaon()
          : ak(dimension(3, 50, 36), fem::fill0),
            speck(dimension(50, 36, 7), fem::fill0),
            mf(fem::int0) struct common_lastt int itimeh;
      float bimp;
      common_lastt()
          : itimeh(fem::int0),
            bimp(fem::float0) struct common_hbt arr<int> lblast;
      arr<float, 2> xlast;
      arr<float, 2> plast;
      int nlast;
      common_hbt()
          : lblast(dimension(maxstr), fem::fill0),
            xlast(dimension(4, maxstr), fem::fill0),
            plast(dimension(4, maxstr), fem::fill0),
            nlast(fem::int0) const int common_hbt::maxstr;
      struct common_ftmax arr<float> ftsv;
      arr<float, 2> ftsvt;
      common_ftmax()
          : ftsv(dimension(maxstr), fem::fill0),
            ftsvt(dimension(maxstr, maxr), fem::fill0) const
            int common_ftmax::maxstr;
      const int common_ftmax::maxr;
      struct common_ddpi arr<float, 3> pirho;
      common_ddpi()
          : pirho(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
                  fem::fill0) const int common_ddpi::maxx;
      const int common_ddpi::maxz;
      struct common_tt arr<float, 3> pel;
      arr<float, 3> rxy;
      common_tt()
          : pel(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
                fem::fill0),
            rxy(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
                fem::fill0) const int common_tt::maxx;
      const int common_tt::maxz;
      struct common_bbb arr<float, 3> bxx;
      arr<float, 3> byy;
      arr<float, 3> bzz;
      common_bbb()
          : bxx(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
                fem::fill0),
            byy(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
                fem::fill0),
            bzz(dim1(-maxx, maxx).dim2(-maxx, maxx).dim3(-maxz, maxz),
                fem::fill0) const int common_bbb::maxx;
      const int common_bbb::maxz;
      struct common_snn float efrm;
      int npart1;
      int npart2;
      float epsipz;
      float epsipt;
      float pzproj;
      float pztarg;
      common_snn()
          : efrm(fem::float0),
            npart1(fem::int0),
            npart2(fem::int0),
            epsipz(fem::float0),
            epsipt(fem::float0),
            pzproj(fem::float0),
            pztarg(fem::float0) struct common_oscar1 int iap;
      int izp;
      int iat;
      int izt;
      common_oscar1()
          : iap(fem::int0),
            izp(fem::int0),
            iat(fem::int0),
            const int common_ftmax::maxstr;
      izt(fem::int0) struct common_oscar2 fem::str<8> frame;
      arr<int> inout;
      fem::str<25> amptvn;
      common_oscar2()
          : frame(fem::char0), amptvn(fem::char0) struct common_hjglbr int nelt;
      int ninthj;
      int nelp;
      const int common_ftmax::maxstr;
      int ninp;
      common_hjglbr()
          : nelt(fem::int0),
            ninthj(fem::int0),
            nelp(fem::int0),
            ninp(fem::int0) struct common_phihj int iphirp;
      float phirp;
      common_phihj()
          : iphirp(fem::int0),
            phirp(fem::float0) struct common_pp arr<float, 2> prho;
      common_pp()
          : prho(dim1(-20, 20).dim2(-24, 24),
                 fem::fill0) struct common_qq arr<float, 2> phrho;
      common_qq()
          : phrho(dim1(-maxz, maxz).dim2(-24, 24), fem::fill0) const
            int common_qq::maxz;
      struct common_arercp arr<float, 2> pro1;
      common_arercp() : const int common_ddpi::maxx;
      pro1(dimension(maxstr, maxr), fem::fill0) const int common_arercp::maxstr;
      const int common_arercp::maxr;
      struct common_para1 int mul;
      common_para1() : mul(fem::int0) struct common_hjcrdn arr<float, 2> yp;
      arr<float, 2> yt;
      common_hjcrdn()
          : yp(dimension(3, 300), fem::fill0),
            yt(dimension(3, 300), fem::fill0) struct common_hjjet1 arr<int> npj;
      arr<int, 2> kfpj;
      arr<float, 2> pjpx;
      arr<float, 2> pjpy;
      arr<float, 2> pjpz;
      arr<float, 2> pjpe;
      arr<float, 2> pjpm;
      arr<int> ntj;
      arr<int, 2> kftj;
      arr<float, 2> pjtx;
      arr<float, 2> pjty;
      arr<float, 2> pjtz;
      arr<float, 2> pjte;
      arr<float, 2> pjtm;
      common_hjjet1()
          : npj(dimension(300), fem::fill0),
            kfpj(dimension(300, 500), fem::fill0),
            pjpx(dimension(300, 500), fem::fill0),
            pjpy(dimension(300, 500), fem::fill0),
            pjpz(dimension(300, 500), fem::fill0),
            const int common_ftmax::maxstr;
      pjpe(dimension(300, 500), fem::fill0),
          pjpm(dimension(300, 500), fem::fill0),
          ntj(dimension(300), fem::fill0),
          kftj(dimension(300, 500), fem::fill0),
          pjtx(dimension(300, 500), fem::fill0),
          pjty(dimension(300, 500), fem::fill0),
          pjtz(dimension(300, 500), fem::fill0),
          pjte(dimension(300, 500), fem::fill0),
          pjtm(dimension(300, 500), fem::fill0) struct common_hjjet2 int nsg;
      arr<int> njsg;
      arr<int, 2> iasg;
      arr<int, 2> k1sg;
      arr<int, 2> k2sg;
      arr<float, 2> pxsg;
      arr<float, 2> pysg;
      arr<float, 2> pzsg;
      arr<float, 2> pesg;
      arr<float, 2> pmsg;
      common_hjjet2()
          : nsg(fem::int0),
            njsg(dimension(maxstr), fem::fill0),
            iasg(dimension(maxstr, 3), fem::fill0),
            k1sg(dimension(maxstr, 100), fem::fill0),
            k2sg(dimension(maxstr, 100), fem::fill0),
            pxsg(dimension(maxstr, 100), fem::fill0),
            pysg(dimension(maxstr, 100), fem::fill0),
            pzsg(dimension(maxstr, 100), fem::fill0),
            pesg(dimension(maxstr, 100), fem::fill0),
            pmsg(dimension(maxstr, 100), fem::fill0) const
            int common_hjjet2::maxstr;
      struct common_prec1 static const int maxptn = 400001;
      arr<double> gx0;
      arr<double> gy0;
      arr<double> gz0;
      arr<double> ft0;
      arr<double> px0;
      arr<double> py0;
      arr<double> pz0;
      arr<double> e0;
      arr<double> xmass0;
      arr<int> ityp0;
      common_prec1()
          : gx0(dimension(maxptn), fem::fill0),
            gy0(dimension(maxptn), fem::fill0),
            gz0(dimension(maxptn), fem::fill0),
            ft0(dimension(maxptn), fem::fill0),
            px0(dimension(maxptn), fem::fill0),
            py0(dimension(maxptn), fem::fill0),
            pz0(dimension(maxptn), fem::fill0),
            e0(dimension(maxptn), fem::fill0),
            xmass0(dimension(maxptn), fem::fill0),
            common_prec1()
          : ityp0(dimension(maxptn), fem::fill0) const int common_prec1::maxptn;
      struct common_arout int iout;
      common_arout()
          : iout(fem::int0) iasg(dimension(maxstr, 3), fem::fill0),
            struct common_ilist8 arr<int> lstrg1;
      arr<int> lpart1;
      common_ilist8() : lstrg1(dimension(maxptn), fem::fill0), arr<int> lstrg1;
      lpart1(dimension(maxptn), fem::fill0) const int common_ilist8::maxptn;
      struct common_srec1 int nsp;
      int nst;
      iout(fem::int0) int nsi;
      arr<int> lstrg1;
      common_srec1()
          : nsp(fem::int0),
            nst(fem::int0),
            nsi(fem::int0) struct common_srec2 arr<double> ataui;
      arr<double> zt1;
      arr<double> zt2;
      arr<double> zt3;
      common_srec2()
          : ataui(dimension(maxstr), fem::fill0),
            zt1(dimension(maxstr), fem::fill0),
            arr<int> lstrg1;
      zt2(dimension(maxstr), fem::fill0),
          zt3(dimension(maxstr), fem::fill0) const int common_srec2::maxstr;
      struct common_soft arr<double, 2> pxsgs;
      arr<double> ataui;
      arr<double, 2> pysgs;
      arr<double, 2> pzsgs;
      iout(fem::int0) arr<double, 2> pesgs;
      arr<double, 2> pmsgs;
      arr<double, 2> gxsgs;
      arr<double, 2> gysgs;
      arr<double, 2> gzsgs;
      arr<double, 2> ftsgs;
      arr<int, 2> k1sgs;
      arr<int, 2> k2sgs;
      arr<int> njsgs;
      common_soft()
          : pxsgs(dimension(maxstr, 3), fem::fill0),
            pysgs(dimension(maxstr, 3), fem::fill0),
            pzsgs(dimension(maxstr, 3), fem::fill0),
            pesgs(dimension(maxstr, 3), fem::fill0),
            iout(fem::int0) pmsgs(dimension(maxstr, 3), fem::fill0),
            gxsgs(dimension(maxstr, 3), fem::fill0),
            gysgs(dimension(maxstr, 3), fem::fill0),
            gzsgs(dimension(maxstr, 3), fem::fill0),
            ftsgs(dimension(maxstr, 3), fem::fill0),
            k1sgs(dimension(maxstr, 3), fem::fill0),
            k2sgs(dimension(maxstr, 3), fem::fill0),
            njsgs(dimension(maxstr), fem::fill0) const int common_soft::maxstr;
      struct common_hijdat arr<float, 2> hidat0;
      arr<float> hidat;
      common_hijdat()
          : hidat0(dimension(10, 10), fem::fill0),
            hidat(dimension(10), fem::fill0) struct common_pypars arr<int> mstp;
      arr<float> parp;
      arr<int> msti;
      arr<float> pari;
      common_pypars()
          : mstp(dimension(200), fem::fill0),
            parp(dimension(200), fem::fill0),
            msti(dimension(200), fem::fill0),
            pari(dimension(200), fem::fill0) struct common_pyint1
            iout(fem::int0) arr<int> mint;
      arr<float> vint;
      common_pyint1()
          : mint(dimension(400), fem::fill0),
            vint(dimension(400), fem::fill0) struct common_pysubs int msel;
      arr<int> msub;
      arr<int, 2> kfin;
      arr<float> ckin;
      const int common_ftmax::maxstr;
      common_pysubs()
          : common_srec2()
          : msel(fem::int0),
            msub(dimension(200), fem::fill0),
            pari(dimension(200), fem::fill0)
                kfin(dim1(2).dim2(-40, 40), fem::fill0),
            ckin(dimension(200), fem::fill0) iout(fem::int0) const
            int common_ftmax::maxstr;
      parp(dimension(200), fem::fill0), msti(dimension(200), fem::fill0),
          pari(dimension(200), fem::fill0) struct common_pyint1
          iout(fem::int0) struct common_pyint2 common_srec2()
          : arr<int> iset;
      arr<int, 2> kfpr;
      pari(dimension(200), fem::fill0) arr<float, 2> coef;
      arr<int, 3> icol;
      iout(fem::int0) common_pyint2()
          : iset(dimension(200), fem::fill0),
            struct common_pysubs kfpr(dimension(200, 2), fem::fill0),
            coef(dimension(200, 20), fem::fill0),
            icol(dimension(40, 4, 2), fem::fill0)
                iout(fem::int0) struct common_pyint4 arr<float, 2> widp;
      arr<float, 2> wide;
      gysgs(dimension(maxstr, 3), fem::fill0), arr<float, 2> wids;
      int izt;
      const int common_ftmax::maxstr;
      common_pyint4()
          : widp(dim1(21, 40).dim2(0, 40), fem::fill0),
            wide(dim1(21, 40).dim2(0, 40), fem::fill0),
            wids(dim1(21, 40).dim2(3),
                 fem::fill0) struct common_pyint3 arr<float, 2> xsfx;
      arr<int, 2> isig;
      arr<float> sigh;
      common_pyint3() : arr<int, 2> k1sg;
      xsfx(dim1(2).dim2(-40, 40), fem::fill0),
          isig(dimension(1000, 3), fem::fill0),
          sigh(dimension(1000),
               fem::fill0) struct common_pyint5 arr<int, 2> ngen;
      arr<float, 2> xsec;
      common_pyint5()
          : ngen(dim1(0, 200).dim2(3), fem::fill0),
            xsec(dim1(0, 200).dim2(3), fem::fill0)
                ftsgs(dimension(maxstr, 3), fem::fill0),
            struct common_hjjet4 int ndr;
      arr<int, 2> iadr;
      arr<int> kfdr;
      arr<float, 2> pdr;
      common_hjjet4()
          : gysgs(dimension(maxstr, 3), fem::fill0),
            ftsgs(dimension(maxstr, 3), fem::fill0),
            const int common_ftmax::maxstr;
      ndr(fem::int0), iadr(dimension(maxstr, 2), fem::fill0),
          kfdr(dimension(maxstr), fem::fill0),
          pdr(dimension(maxstr, 5), fem::fill0) const int common_hjjet4::maxstr;
      arr<int> lstrg1;
      struct common_xydr arr<float, 2> rtdr;
      common_xydr()
          : rtdr(dimension(maxstr, 2), fem::fill0) const
            int common_xydr::maxstr;
      struct common_hpint int mint4;
      arr<int> lstrg1;
      int mint5;
      arr<float, 2> atco;
      arr<float> atxs;
      common_hpint() : mint4(fem::int0), arr<double> ataui;
      mint5(fem::int0), arr<double, 2> pzsgs;
      const int common_ddpi::maxx;
      atco(dimension(200, 20), fem::fill0),
          atxs(dim1(0, 200),
               fem::fill0) struct common_pyint6 arr<fem::str<28> > proc;
      common_pyint6()
          : proc(dim1(0, 200), fem::fill0) struct common_besel float x4;
      common_besel()
          : x4(fem::float0) struct common_hijhb
            iasg(dimension(maxstr, 3), fem::fill0),
            gysgs(dimension(maxstr, 3), fem::fill0),
            arr<float, 2> rr;
      arr<float, 2> xx;
      common_hijhb()
          : rr(dimension(10, 201), fem::fill0),
            xx(dimension(10, 201), fem::fill0) struct common_dpmcm1 int jjp;
      int jjt;
      float amp;
      float amt;
      arr<int> inout;
      float apx0;
      float atx0;
      float ampn;
      float amtn;
      const int common_ftmax::maxstr;
      float amp0;
      float amt0;
      int nfdp;
      int nfdt;
      float wp;
      float wm;
      float sw;
      float xremp;
      float xremt;
      float dpkc1;
      float dpkc2;
      float pp11;
      arr<int> inout;
      float pp12;
      float pt11;
      const int common_ftmax::maxstr;
      float pt12;
      float ptp2;
      float ptt2;
      common_dpmcm1()
          : jjp(fem::int0),
            jjt(fem::int0),
            amp(fem::float0),
            gysgs(dimension(maxstr, 3), fem::fill0),
            amt(fem::float0),
            apx0(fem::float0),
            const int common_ftmax::maxstr;
      arr<int> lstrg1;
      atx0(fem::float0), ampn(fem::float0), amtn(fem::float0),
          amp0(fem::float0), amt0(fem::float0), nfdp(fem::int0),
          nfdt(fem::int0), wp(fem::float0), arr<int> inout;
      wm(fem::float0), sw(fem::float0), const int common_ftmax::maxstr;
      xremp(fem::float0), xremt(fem::float0),
          gysgs(dimension(maxstr, 3), fem::fill0), arr<int> inout;
      arr<int> lstrg1;
      dpkc1(fem::float0), dpkc2(fem::float0), pp11(fem::float0),
          pp12(fem::float0), pt11(fem::float0), float pp12;
      pt12(fem::float0), ptp2(fem::float0),
          gysgs(dimension(maxstr, 3), fem::fill0), arr<int> lstrg1;
      ptt2(fem::float0) struct common_dpmcm2 int ndpm;
      arr<int, 2> kdpm;
      arr<float, 2> pdpm1;
      float pt11;
      arr<float, 2> pdpm2;
      common_dpmcm2()
          : gysgs(dimension(maxstr, 3), fem::fill0), arr<int> lstrg1;
      ndpm(fem::int0), kdpm(dimension(20, 2), fem::fill0),
          pdpm1(dimension(20, 5), fem::fill0),
          pdpm2(dimension(20, 5), fem::fill0) struct common_lor wm(fem::float0),
          double enenew;
      double pxnew;
      gysgs(dimension(maxstr, 3), fem::fill0), arr<int> lstrg1;
      double pynew;
      double pznew;
      common_lor()
          : enenew(fem::double0),
            pxnew(fem::double0),
            sw(fem::float0),
            pynew(fem::double0),
            pznew(fem::double0) gysgs(dimension(maxstr, 3), fem::fill0),
            struct common_decom arr<double, 2> ptwo;
      common_decom()
          : ptwo(dimension(2, 5), fem::fill0) struct common_hmain1 float eatt;
      int jatt;
      int natt;
      int nt;
      int np;
      int n0;
      int n01;
      int n10;
      int n11;
      common_hmain1() : eatt(fem::float0), jatt(fem::int0), float x4;
      natt(fem::int0), nt(fem::int0), np(fem::int0), n0(fem::int0),
          n01(fem::int0), arr<int> lstrg1;
      n10(fem::int0), n11(fem::int0) struct common_hmain2 arr<int, 2> katt;
      arr<float, 2> patt;
      int izt;
      common_hmain2()
          : k2sgs(dimension(maxstr, 3), fem::fill0),
            pztarg(fem::float0) katt(dimension(maxstr, 4), fem::fill0),
            patt(dimension(maxstr, 4), fem::fill0) const
            int common_hmain2::maxstr;
      gysgs(dimension(maxstr, 3), fem::fill0),
          struct common_ilist7 arr<int> lstrg0;
      arr<int> lpart0;
      common_ilist7()
          : lstrg0(dimension(maxptn), fem::fill0),
            lpart0(dimension(maxptn), fem::fill0) const
            int common_ilist7::maxptn;
      struct common_noprec static const int maxidl = 4001;
      int nnozpc;
      int izt;
      arr<int> itypn;
      arr<float> gxn;
      arr<float> gyn;
      arr<float> gzn;
      arr<float> ftn;
      arr<float> pxn;
      arr<float> pyn;
      arr<float> pzn;
      arr<float> een;
      arr<int> lstrg1;
      arr<float> xmn;
      common_noprec()
          : nnozpc(fem::int0),
            itypn(dimension(maxidl), fem::fill0),
            gxn(dimension(maxidl), fem::fill0),
            gyn(dimension(maxidl), fem::fill0),
            gzn(dimension(maxidl), fem::fill0),
            ftn(dimension(maxidl), fem::fill0),
            pxn(dimension(maxidl), fem::fill0),
            pyn(dimension(maxidl), fem::fill0),
            pzn(dimension(maxidl), fem::fill0),
            een(dimension(maxidl), fem::fill0),
            xmn(dimension(maxidl), fem::fill0) arr<int> lstrg1;
      const int common_noprec::maxidl;
      struct common_precpa arr<double> vxp0;
      arr<double> vyp0;
      arr<double> vzp0;
      arr<double> xstrg0;
      arr<double> ystrg0;
      arr<double> xstrg;
      arr<double> ystrg;
      arr<int> istrg0;
      arr<int> istrg;
      iasg(dimension(maxstr, 3), fem::fill0),
          gysgs(dimension(maxstr, 3), fem::fill0),
          common_precpa()
          : vxp0(dimension(maxptn), fem::fill0),
            vyp0(dimension(maxptn), fem::fill0),
            vzp0(dimension(maxptn), fem::fill0),
            xstrg0(dimension(maxptn), fem::fill0),
            ystrg0(dimension(maxptn), fem::fill0),
            xstrg(dimension(maxptn), fem::fill0),
            ystrg(dimension(maxptn), fem::fill0),
            istrg0(dimension(maxptn), fem::fill0),
            istrg(dimension(maxptn), fem::fill0) const
            int common_precpa::maxptn;
      struct common_loclco arr<double> gxp;
      arr<double> gyp;
      arr<double> gzp;
      arr<double> ftp;
      arr<double> pxp;
      arr<double> pyp;
      arr<double> pzp;
      arr<double> pep;
      arr<double> pmp;
      common_loclco()
          : gxp(dimension(3), fem::fill0),
            gyp(dimension(3), fem::fill0),
            gzp(dimension(3), fem::fill0),
            ftp(dimension(3), fem::fill0),
            pxp(dimension(3), fem::fill0),
            pyp(dimension(3), fem::fill0),
            gysgs(dimension(maxstr, 3), fem::fill0),
            const int common_ftmax::maxstr;
      pzp(dimension(3), fem::fill0), pep(dimension(3), fem::fill0),
          pmp(dimension(3), fem::fill0) struct common_prtn23 arr<float> ftn;
      arr<float> pxn;
      arr<float> pyn;
      arr<float> pzn;
      arr<float> een;
      nnozpc(fem::int0), itypn(dimension(maxidl), fem::fill0),
          gxn(dimension(maxidl), fem::fill0),
          gyn(dimension(maxidl), fem::fill0), arr<double> gxp0;
      arr<double> gyp0;
      arr<double> gzp0;
      double ft0fom;
      common_prtn23()
          : gxp0(dimension(3), fem::fill0),
            gyp0(dimension(3), fem::fill0),
            gzp0(dimension(3), fem::fill0),
            arr<int> inout;
      ft0fom(fem::double0) struct common_strg const int common_ftmax::maxstr;
      arr<int> np;
      common_strg() : arr<int> itypn;
      /// C=======================================================================
      np(dimension(maxstr), fem::fill0) const int common_strg::maxstr;
      struct common_frzprc FEM_CMN_SVE(flowh);
      common_write write(cmn);
      arr_ref<double, 2> v2h(cmn.v2h, dimension(30, 3));
      arr_ref<double, 2> xnhadr(cmn.xnhadr, dimension(30, 3));
      arr_ref<double, 2> eth(cmn.eth, dimension(30, 3));
      arr_ref<double, 2> v2h2(cmn.v2h2, dimension(30, 3));
      arr_ref<double, 2> s2h(cmn.s2h, dimension(30, 3));
      arr_ref<double> v2hp(cmn.v2hp, dimension(3));
      arr_ref<double> xnhadp(cmn.xnhadp, dimension(3));
      arr_ref<double> v2hsum(cmn.v2hsum, dimension(3));
      arr_ref<double> v2h2sm(cmn.v2h2sm, dimension(3));
      int& itimeh = cmn.itimeh;
      int& num = cmn.num;
      const int maxstr = 150001;
      arr_cref<float, 2> r(static_cast<common_aa&>(cmn).r,
                           dimension(3, maxstr));
      arr_cref<float, 2> p(static_cast<common_bb&>(cmn).p,
                           dimension(3, maxstr));
      arr_cref<float> e(static_cast<common_cc&>(cmn).e, dimension(maxstr));
      arr_cref<int> lb(cmn.lb, dimension(maxstr));
      const int maxr = 1;
      arr_cref<int> massr(cmn.massr, dim1(0, maxr));
      ///
      float& ene = sve.ene;
      int& i = sve.i;
      int& ia = sve.ia;
      int& ianh = sve.ianh;
      int& ic = sve.ic;
      int& ifanim = sve.ifanim;
      int& ii = sve.ii;
      int& iloop = sve.iloop;
      int& iy = sve.iy;
      int& j = sve.j;
      int& mult = sve.mult;
      int& nhadrn = sve.nhadrn;
      double& pt2 = sve.pt2;
      float& px = sve.px;
      float& py = sve.py;
      float& rap = sve.rap;
      arr_ref<float> tsh(sve.tsh, dimension(31));
      double& v2hadr = sve.v2hadr;
      arr_ref<double> v2hevt(sve.v2hevt, dimension(3));
      float& xperp2 = sve.xperp2;
      arr<double> gxfrz;
      arr<double> gyfrz;
      /// Cc      SAVE /lastt/
      /// Cc      SAVE /RUN/
      /// Cc      SAVE /AA/
      /// Cc      SAVE /BB/
      /// Cc      SAVE /CC/
      /// Cc      SAVE /EE/
      /// Cc      SAVE /RR/
      /// Cc      SAVE /anim/
      /// Cc      SAVE /AREVT/
      /// C
      arr<double> gzfrz;
      /// C
      FEM_DO_SAFE(ianh, 1, 30) {
        if ((ct + 0.0001f) < tsh(ianh + 1) && (ct + 0.0001f) >= tsh(ianh)) {
          if (ianh == itimeh) {
            goto statement_101;
          }
          ia = 0;
          FEM_DO_SAFE(j, 1, num) {
            mult = massr(j);
            ia += massr(j - 1);
            FEM_DO_SAFE(ic, 1, mult) {
              i = ia + ic;
              arr<double> ftfrz;
              if (fem::iabs(lb(i) - 10000) < 100) {
                goto statement_100;
              }
              px = p(1, i);
              py = p(2, i);
              pt2 = fem::pow2(fem::dble(px)) + fem::pow2(fem::dble(py));
              arr<double> pxfrz;
              arr<double> pyfrz;
              arr<double> pzfrz;
              rap = 0.5f * fem::alog((ene + p(3, i)) / (ene - p(3, i)));
              arr<double> efrz;
              arr<double> xmfrz;
              arr<double> tfrz;
              arr<int> ifrz;
              arr<int> idfrz;
              int itlast;
              common_frzprc() : iloop = 1;
              if (fem::abs(rap) <= 1) {
                iloop = 2;
                if (fem::abs(rap) <= 0.5f) {
                  iloop = 3;
                }
              }
              FEM_DO_SAFE(iy, 1, iloop) {
                if (pt2 > 0e0) {
                  gxfrz(dimension(maxptn), fem::fill0),
                      gyfrz(dimension(maxptn), fem::fill0),
                      v2h(ianh, iy) += v2hadr;
                  v2h2(ianh, iy) += fem::pow2(v2hadr);
                  if (fem::dabs(v2hadr) > 1e0) {
                    write(1, star), "v2hadr>1", v2hadr, px, py;
                  }
                }
                xperp2 = fem::pow2(r(1, i)) + fem::pow2(r(2, i));
                if (xperp2 > 0.f) {
                  gzfrz(dimension(maxptn), fem::fill0),
                      ftfrz(dimension(maxptn), fem::fill0),
                }
                pxfrz(dimension(maxptn), fem::fill0),
                    pyfrz(dimension(maxptn), fem::fill0),
                    pzfrz(dimension(maxptn), fem::fill0),
                    efrz(dimension(maxptn), fem::fill0),
                    xmfrz(dimension(maxptn), fem::fill0),
                    xnhadr(ianh, iy) += 1e0;
              }
            statement_100:;
            }
          }
          itimeh = ianh;
          tfrz(dimension(302), fem::fill0), if (ianh == 30) {
            FEM_DO_SAFE(iy, 1, 3) {
              nhadrn = idint(xnhadr(ianh, iy) - xnhadp(iy));
              if (nhadrn != 0) {
                v2hevt(iy) = (v2h(ianh, iy) - v2hp(iy)) / fem::dble(nhadrn);
                v2hsum(iy) += v2hevt(iy);
                v2h2sm(iy) += fem::pow2(v2hevt(iy));
                v2hp(iy) = v2h(ianh, iy);
                xnhadp(iy) = xnhadr(ianh, iy);
              }
            }
            write(88, "(i10,3(2x,f9.5))"), cmn.iaevt, v2hevt;
          }
          goto statement_101;
        }
      }
      ifrz(dimension(maxptn), fem::fill0), idfrz(dimension(maxptn), fem::fill0),
          itlast(fem::int0) const int common_frzprc::maxptn;
      ifanim = 0;
      if (ifanim == 1) {
        ia = 0;
        FEM_DO_SAFE(j, 1, num) {
          mult = massr(j);
          ia += massr(j - 1);
          write(10, star), ct;
          write(10, star), mult;
          FEM_DO_SAFE(ic, 1, mult) {
            i = ia + ic;
            struct common_para3 int nsevt;
            int nevnt;
            int nsbrun;
            int ievt;
          }
          else {
            int isbrun;
            common_para3() :
          }
        }
      }
      return;
      }
      }

      nsevt(fem::int0), int ii;
      int iy;
      int nunit;
      arr<float> tsh;
      arr<double> v2havg;
      arr<double> varv2h;
      float xmulth;

      nevnt(fem::int0), nsbrun(fem::int0), iy(fem::int0), ievt(fem::int0),
          mstj(dimension(200), fem::fill0),
          isbrun(fem::int0) struct common_rndm1 int number;
      }
      ;

      /// C
      /// C=======================================================================
      common_rndm1() : FEM_CMN_SVE(flowh0);
      common_write write(cmn);
      /// COMMON hflow
      arr_ref<double, 2> v2h(cmn.v2h, dimension(30, 3));
      arr_ref<double, 2> xnhadr(cmn.xnhadr, dimension(30, 3));
      arr_ref<double, 2> eth(cmn.eth, dimension(30, 3));
      arr_ref<double, 2> v2h2(cmn.v2h2, dimension(30, 3));
      arr_ref<double, 2> s2h(cmn.s2h, dimension(30, 3));
      /// COMMON ebe
      arr_ref<double> v2hp(cmn.v2hp, dimension(3));
      arr_ref<double> xnhadp(cmn.xnhadp, dimension(3));
      arr_ref<double> v2hsum(cmn.v2hsum, dimension(3));
      arr_ref<double> v2h2sm(cmn.v2h2sm, dimension(3));
      ///
      /// SAVE
      int& ii = sve.ii;
      int& iy = sve.iy;
      int& nunit = sve.nunit;
      arr_ref<float> tsh(sve.tsh, dimension(31));
      arr_ref<double> v2havg(sve.v2havg, dimension(3));
      arr_ref<double> varv2h(sve.varv2h, dimension(3));
      float& xmulth = sve.xmulth;
      ///
      static const char* format_240 = "(a30,3(2x,f9.5))";
      /// C
      arr<double> gxfrz;
      arr<double> gyfrz;
      /// Cc      SAVE /input1/
      /// Cc      SAVE /INPUT2/
      /// Cc      SAVE /lastt/
      /// C
      number(fem::int0) if (idd == 0) {
        cmn.itimeh = 0;
        /// C
        struct common_rndm3
        /// C
        FEM_DO_SAFE(ii, 1, 30) {
          FEM_DO_SAFE(iy, 1, 3) {
            v2h(ii, iy) = 0e0;
            xnhadr(ii, iy) = 0e0;
            eth(ii, iy) = 0e0;
            v2h2(ii, iy) = 0e0;
            s2h(ii, iy) = 0e0;
          }
        } FEM_DO_SAFE(iy, 1, 3) {
          v2hp(iy) = 0e0;
          xnhadp(iy) = 0e0;
          v2hsum(iy) = 0e0;
          v2h2sm(iy) = 0e0;
          if (iy == 1) {
            nunit = 59;
            int iseedp;
            nunit = 68;
          } else {
            nunit = 69;
          }
          common_rndm3() : iseedp(fem::int0)
        }
        struct common_ilist3 double size1;
        double size2;
        FEM_DO_SAFE(ii, 1, 30) {
          FEM_DO_SAFE(iy, 1, 3) {
            if (xnhadr(ii, iy) == 0) {
              xmulth = 0.f;
              double size3;
              v2h(ii, iy) = v2h(ii, iy) / xnhadr(ii, iy);
              eth(ii, iy) = eth(ii, iy) / fem::dble(nevnt);
              double v1;
              double v2;
              double v3;
              s2h(ii, iy) = s2h(ii, iy) / xnhadr(ii, iy);
              xmulth = fem::sngl(xnhadr(ii, iy) / nevnt);
            }
            if (iy == 1) {
              nunit = 59;
              double size;
              nunit = 68;
            } else {
              nunit = 69;
            }
            if (tsh(ii) <= (cmn.ntmax * cmn.dt)) {
              common_ilist3() : size1(fem::double0),
            }
          }
        }
        size2(fem::double0), FEM_DO_SAFE(iy, 1, 3) {
          v2havg(iy) = v2hsum(iy) / fem::dble(nevnt);
          size3(fem::double0), v1(fem::double0),
        }
        write(88, format_240), "EBE v2h,v2h(y2),v2h(y1): avg=", v2havg;
        write(88, format_240), "EBE v2h,v2h(y2),v2h(y1): var=", varv2h;
      }
      }

      v2(fem::double0), int i;
      int ityp;
      int j;
      float pt2;
      float px;
      float py;
      float xh;
      float xm;
      float xt2;
      float yh;

      v3(fem::double0), : i(fem::int0),
                          ityp(fem::int0),
                          j(fem::int0),
                          size(fem::double0) px(fem::float0),
                          py(fem::float0),
                          struct common_para2 xm(fem::float0),
                          xt2(fem::float0),
                          double xmp;
      }
      ;

      /// C
      /// C=======================================================================
      double xmu;
      double alpha;
      FEM_CMN_SVE(iniflw);
      const int maxr = 1;
      arr_cref<int> multi1(cmn.multi1, dimension(maxr));
      const int maxstr = 150001;
      arr_cref<int, 2> ityp1(cmn.ityp1, dimension(maxstr, maxr));
      arr_cref<float, 2> gx1(cmn.gx1, dimension(maxstr, maxr));
      arr_cref<float, 2> gy1(cmn.gy1, dimension(maxstr, maxr));
      arr_cref<float, 2> px1(static_cast<common_arprc1&>(cmn).px1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> py1(static_cast<common_arprc1&>(cmn).py1,
                             dimension(maxstr, maxr));
      arr_cref<float, 2> xm1(cmn.xm1, dimension(maxstr, maxr));
      double& v2i = cmn.v2i;
      double& eti = cmn.eti;
      double& xmulti = cmn.xmulti;
      double& v2mi = cmn.v2mi;
      double& s2mi = cmn.s2mi;
      double& xmmult = cmn.xmmult;
      double& v2bi = cmn.v2bi;
      double& s2bi = cmn.s2bi;
      double& xbmult = cmn.xbmult;
      ///
      int& i = sve.i;
      int& ityp = sve.ityp;
      int& j = sve.j;
      float& pt2 = sve.pt2;
      float& px = sve.px;
      float& py = sve.py;
      float& xh = sve.xh;
      float& xm = sve.xm;
      float& xt2 = sve.xt2;
      float& yh = sve.yh;
      /// Cc      SAVE /RUN/
      /// Cc      SAVE /ARERC1/
      /// Cc      SAVE /ARPRC1/
      float sdmnp;
      /// C
      if (idd == 0) {
        v2i = 0e0;
        eti = 0e0;
        xmulti = 0e0;
        v2mi = 0e0;
        s2mi = 0e0;
        xmmult = 0e0;
        v2bi = 0e0;
        s2bi = 0e0;
        xbmult = 0e0;
        double rscut2;
        FEM_DO_SAFE(j, 1, cmn.num) {
          FEM_DO_SAFE(i, 1, multi1(j)) {
            ityp = ityp1(i, j);
            double cutof2;
            common_para2() : goto statement_100;
          }
          xmulti += 1.e0;
          px = px1(i, j);
          py = py1(i, j);
          xm = xm1(i, j);
          pt2 = fem::pow2(px) + fem::pow2(py);
          xh = gx1(i, j);
          yh = gy1(i, j);
          xt2 = fem::pow2(xh) + fem::pow2(yh);
          if (pt2 > 0) {
            v2i += fem::dble((fem::pow2(px) - fem::pow2(py)) / pt2);
          }
          xmp(fem::double0), xmu(fem::double0), alpha(fem::double0),
              rscut2(fem::double0), xbmult += 1.e0;
          if (pt2 > 0) {
            v2bi += fem::dble((fem::pow2(px) - fem::pow2(py)) / pt2);
          }
          if (xt2 > 0) {
            s2bi += fem::dble((fem::pow2(xh) - fem::pow2(yh)) / xt2);
          }
          cutof2(fem::double0)
        }
        else {
          xmmult += 1.e0;
          if (pt2 > 0) {
            v2mi += fem::dble((fem::pow2(px) - fem::pow2(py)) / pt2);
          }
          if (xt2 > 0) {
            s2mi += fem::dble((fem::pow2(xh) - fem::pow2(yh)) / xt2);
          }
        }
      statement_100:;
      }
      }
      double size2;
      if (xmulti != 0) {
        v2i = v2i / xmulti;
      }
      eti = eti / fem::dble(nevnt);
      xmulti = xmulti / fem::dble(nevnt);
      if (xmmult != 0) {
        v2mi = v2mi / xmmult;
        s2mi = s2mi / xmmult;
      }
      xmmult = xmmult / fem::dble(nevnt);
      if (xbmult != 0) {
        v2bi = v2bi / xbmult;
        s2bi = s2bi / xbmult;
      }
      xbmult = xbmult / fem::dble(nevnt);
      }
      /// C
      }

      struct common_para5 fem::variant_bindings prec2_bindings;
      double detf;
      double detp;
      double dxnf;
      double dxnp;
      double etf;
      double eth0;
      double eth2;
      double etp;
      int ii;
      int ip;
      arr<double> tsf;
      double xnf;
      double xnp;

      int iconfg;
      int iordsc;
      common_para5()
          : iconfg(fem::int0),
            iordsc(fem::int0) struct common_prec5 arr<double> eta;
      arr<double> rap;
      arr<double> tau;
      ii(fem::int0), ip(fem::int0),
          common_prec5()
          : eta(dimension(maxptn), fem::fill0),
            rap(dimension(maxptn), fem::fill0),
      }
      ;

      /// C
      /// C=======================================================================
      tau(dimension(maxptn), fem::fill0) const int common_prec5::maxptn;
      struct common_para6 FEM_CMN_SVE(frztm);
      common_write write(cmn);
      /// COMMON prec1
      const int maxptn = 400001;
      arr_cref<double> ft0(cmn.ft0, dimension(maxptn));
      arr_cref<double> px0(cmn.px0, dimension(maxptn));
      arr_cref<double> py0(cmn.py0, dimension(maxptn));
      arr_cref<double> xmass0(cmn.xmass0, dimension(maxptn));
      /// COMMON frzout
      arr_ref<double> xnprod(cmn.xnprod, dimension(30));
      arr_ref<double> etprod(cmn.etprod, dimension(30));
      arr_ref<double> xnfrz(cmn.xnfrz, dimension(30));
      arr_ref<double> etfrz(cmn.etfrz, dimension(30));
      arr_ref<double> dnprod(cmn.dnprod, dimension(30));
      arr_ref<double> detpro(cmn.detpro, dimension(30));
      arr_ref<double> dnfrz(cmn.dnfrz, dimension(30));
      arr_ref<double> detfrz(cmn.detfrz, dimension(30));
      ///
      common_variant prec2(cmn.common_prec2, sve.prec2_bindings);
      /// SAVE
      double& detf = sve.detf;
      double& detp = sve.detp;
      double& dxnf = sve.dxnf;
      double& dxnp = sve.dxnp;
      double& etf = sve.etf;
      double& eth0 = sve.eth0;
      double& eth2 = sve.eth2;
      double& etp = sve.etp;
      int& ii = sve.ii;
      int& ip = sve.ip;
      arr_ref<double> tsf(sve.tsf, dimension(31));
      double& xnf = sve.xnf;
      double& xnp = sve.xnp;
      ///
      if (is_called_first_time) {
        using fem::mbr;  /// member of variant common or equivalence
        {
          mbr<double> gx5(dimension(maxptn));
          mbr<double> gy5(dimension(maxptn));
          mbr<double> gz5(dimension(maxptn));
          mbr<double> ft5(dimension(maxptn));
          mbr<double> px5(dimension(maxptn));
          mbr<double> py5(dimension(maxptn));
          mbr<double> pz5(dimension(maxptn));
          mbr<double> e5(dimension(maxptn));
          mbr<double> xmass5(dimension(maxptn));
          mbr<int> ityp5(dimension(maxptn));
          prec2.allocate(), gx5, gy5, gz5, ft5, px5, py5, pz5, e5, xmass5,
              ityp5;
        }
      }
      /* arr_cref<double> gx5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> gy5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> gz5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      arr_cref<double> ft5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> px5(prec2.bind<double>(), dimension(maxptn));
      arr_cref<double> py5(prec2.bind<double>(), dimension(maxptn));
      /* arr_cref<double> pz5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      /* arr_cref<double> e5( */ prec2
          .bind<double>() /* , dimension(maxptn)) */;
      arr_cref<double> xmass5(prec2.bind<double>(), dimension(maxptn));
      /* arr_cref<int> ityp5( */ prec2.bind<int>() /* , dimension(maxptn)) */;
      if (is_called_first_time) {
        {
          fem::data_values data;
          data.values, 0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f;
          data.values, 0.8f, 0.9f, 1.0f, 1.1f, 1.2f, 1.3f, 1.4f, 1.5f;
          data.values, 1.6f, 1.7f, 1.8f, 1.9f, 2, 3, 4, 5;
          data.values, 6, 7, 8, 9, 10, 20, 30;
          data, tsf;
        }
      }
      static const char* format_200 = "(2x,f9.2,4(2x,f10.2))";
      /// C
      /// Cc      SAVE /PARA1/
      /// Cc      SAVE /prec1/
      /// Cc      SAVE /prec2/
      /// Cc      SAVE /frzout/
      /// C
      if (idd == 0) {
        FEM_DO_SAFE(ii, 1, 30) {
          xnprod(ii) = 0e0;
          etprod(ii) = 0e0;
          xnfrz(ii) = 0e0;
          etfrz(ii) = 0e0;
          dnprod(ii) = 0e0;
          detpro(ii) = 0e0;
          dnfrz(ii) = 0e0;
          detfrz(ii) = 0e0;
        }
        double centy;
        common_para6() : double rscut2;
        FEM_DO_SAFE(ip, 1, cmn.mul) {
          FEM_DO_SAFE(ii, 1, 30) {
        eth0 = fem::dsqrt(fem::pow2(px0(ip)) + fem::pow2(py0(ip)) +
    centy(fem::double0)
        eth2 = fem::dsqrt(fem::pow2(px5(ip)) + fem::pow2(py5(ip)) +
struct common_para4
  int iftflg;
        if (ft0(ip) < tsf(ii + 1)) {
        xnprod(ii) += 1e0;
        etprod(ii) += eth0;
        int ireflg;
        if (ft0(ip) >= tsf(ii)) {
          dnprod(ii) += 1e0;
          detpro(ii) += eth0;
        }
        }
  int igeflg;
        if (ft5(ip) < tsf(ii + 1)) {
        xnfrz(ii) += 1e0;
        etfrz(ii) += eth2;
        int ibstfg;
        if (ft5(ip) >= tsf(ii)) {
          dnfrz(ii) += 1e0;
          detfrz(ii) += eth2;
        }
        }
          }
        }
        double size2;
        common_para4()
            : iftflg(fem::int0),
              ireflg(fem::int0),
              igeflg(fem::int0),
              FEM_DO_SAFE(ii, 1, 30) {
          xnp = xnprod(ii) / fem::dble(nevnt);
          xnf = xnfrz(ii) / fem::dble(nevnt);
          etp = etprod(ii) / fem::dble(nevnt);
          etf = etfrz(ii) / fem::dble(nevnt);
          dxnp = dnprod(ii) / fem::dble(nevnt) / (tsf(ii + 1) - tsf(ii));
          dxnf = dnfrz(ii) / fem::dble(nevnt) / (tsf(ii + 1) - tsf(ii));
          detp = detpro(ii) / fem::dble(nevnt) / (tsf(ii + 1) - tsf(ii));
          detf = detfrz(ii) / fem::dble(nevnt) / (tsf(ii + 1) - tsf(ii));
          write(86, format_200), tsf(ii + 1), xnp, dxnp, etp, detp;
          write(87, format_200), tsf(ii + 1), xnf, dxnf, etf, detf;
        }
      }
      /// C
      }

      ibstfg(fem::int0) float bmax;
      float bmin;
      int i;
      int iamax;
      int ihjsed;
      int imiss;
      int ipop;
      int j;
      int k;
      int nevnt;
      int nseedr;
      fem::str<8> proj;
      fem::str<8> targ;

      struct common_par1 double formt;
      bmin(fem::float0), i(fem::int0),
          common_par1()
          : formt(fem::double0) struct common_prec4 arr<double> vx;
      j(fem::int0), k(fem::int0), nevnt(fem::int0), arr<double> vy;
      arr<double> vz;
      common_prec4() :
      }
      ;

      vx(dimension(maxptn), fem::fill0),
          vy(dimension(maxptn), fem::fill0), common cmn(argc, argv);
      blockdata_ardata(cmn);
      blockdata_ppbdat(cmn);
      blockdata_hidata(cmn);
      blockdata_ludata(cmn);
      blockdata_pydata(cmn);
      blockdata_zpcbdt(cmn);
      FEM_CMN_SVE(program_ampt);
      common_read read(cmn);
      common_write write(cmn);
      int& natt = cmn.natt;
      arr_ref<float> hipr1(cmn.hipr1, dimension(100));
      arr_ref<int> ihpr2(cmn.ihpr2, dimension(50));
      arr_cref<float> hint1(cmn.hint1, dimension(100));
      arr_cref<int> ihnt2(cmn.ihnt2, dimension(50));
      arr_ref<float> parj(cmn.parj, dimension(200));
      arr_ref<float> arpar1(cmn.arpar1, dimension(100));
      arr_ref<int> iaint2(cmn.iaint2, dimension(50));
      int& iaevt = cmn.iaevt;
      int& iarun = cmn.iarun;
      int& nseed = cmn.nseed;
      int& isoft = cmn.isoft;
      float& efrm = cmn.efrm;
      int& num = cmn.num;
      int& iap = cmn.iap;
      int& izp = cmn.izp;
      int& iat = cmn.iat;
      int& izt = cmn.izt;
      fem::str<8>& frame = cmn.frame;
      fem::str<25>& amptvn = cmn.amptvn;
      ///
      float& bmax = sve.bmax;
      float& bmin = sve.bmin;
      int& i = sve.i;
      int& iamax = sve.iamax;
      int& ihjsed = sve.ihjsed;
      int& imiss = sve.imiss;
      int& ipop = sve.ipop;
      int& j = sve.j;
      int& k = sve.k;
      int& nevnt = sve.nevnt;
      int& nseedr = sve.nseedr;
      fem::str<8>& proj = sve.proj;
      fem::str<8>& targ = sve.targ;
      static const char* format_111 = "(a8)";
      static const char* format_50 =
          vz(dimension(maxptn), fem::fill0) const int common_prec4::maxptn;
      struct common_ilist4 int ifmpt;
      int ichkpt;
      arr<int> indx;
      /// C
      common_ilist4()
          : ifmpt(fem::int0),
            ichkpt(fem::int0),
            indx(dimension(maxptn), fem::fill0) const int common_ilist4::maxptn;
      /// Clin-7/2009:
      /// Clin-2/2012 allow random orientation of reaction plane:
      /// C
      struct common_ilist5 arr<double> ct;
      arr<double> ot;
      read(24, star), efrm;
      double tlarge;
      read(24, format_111), frame;
      read(24, format_111), proj;
      read(24, format_111), targ;
      read(24, star), iap;
      read(24, star), izp;
      read(24, star), iat;
      read(24, star), izt;
      read(24, star), nevnt;
      read(24, star), bmin;
      read(24, star), bmax;
      common_ilist5() : read(24, star), isoft;
      ct(dimension(maxptn), fem::fill0), read(24, star), cmn.ntmax;
      read(24, star), cmn.dt;
      ot(dimension(maxptn), fem::fill0), tlarge(fem::double0) read(24, star),
          parj(41);
      read(24, star), parj(42);
      const int common_ilist5::maxptn;
      struct common_prec3 read(24, star), ipop;
      if (ipop == 1) {
        ihpr2(11) = 3;
      }
      arr<double> gxs;
      read(24, star), parj(5);
      arr<double> gys;
      read(24, star), ihpr2(6);
      arr<double> gzs;
      read(24, star), ihpr2(4);
      arr<double> fts;
      read(24, star), hipr1(14);
      arr<double> pxs;
      read(24, star), hipr1(8);
      arr<double> pys;
      read(24, star), cmn.xmu;
      read(24, star), cmn.izpc;
      read(24, star), cmn.alpha;
      arr<double> pzs;
      read(24, star), cmn.dpcoal;
      read(24, star), cmn.drcoal;
      arr<double> es;
      arr<double> xmasss;
      read(24, star), ihjsed;
      arr<int> ityps;
      common_prec3() : read(24, star), nseed;
      read(24, star), cmn.iseedp;
      read(24, star), cmn.iksdcy;
      read(24, star), cmn.iphidcy;
      read(24, star), cmn.ipi0dcy;
      gxs(dimension(maxptn), fem::fill0), read(24, star), cmn.ioscar;
      gys(dimension(maxptn), fem::fill0), read(24, star), cmn.idpert;
      read(24, star), cmn.npertd;
      read(24, star), cmn.idxsec;
      gzs(dimension(maxptn), fem::fill0), read(24, star), cmn.pttrig;
      read(24, star), cmn.maxmiss;
      read(24, star), ihpr2(2);
      read(24, star), ihpr2(5);
      fts(dimension(maxptn), fem::fill0), read(24, star), cmn.iembed;
      read(24, star), cmn.pxqembd, cmn.pyqembd;
      read(24, star), cmn.xembd, cmn.yembd;
      read(24, star), cmn.nsembd, cmn.psembd, cmn.tmaxembd;
      pxs(dimension(maxptn), fem::fill0), read(24, star), cmn.ishadow;
      read(24, star), cmn.dshadow;
      read(24, star), cmn.iphirp;
      /// C
      cmn.io.close(24);
      pys(dimension(maxptn), fem::fill0), pzs(dimension(maxptn), fem::fill0),
          es(dimension(maxptn), fem::fill0),
          xmasss(dimension(maxptn), fem::fill0),
          /// C
          if (isoft == 1) {
        amptvn = "1.26t7 (Default)";
        ityps(dimension(maxptn), fem::fill0) amptvn = "2.26t7 (StringMelting)";
      }
      else {
        amptvn = "Test-Only";
      }
      write(6, format_50), amptvn;
      write(12, format_50), amptvn;
      const int common_prec3::maxptn;
      struct common_prec6 if (ihjsed == 11) {
        write(6, star),
            "# Read in NSEED in HIJING at run time (e.g. 20030819):";
      }
      read(6, star), nseedr;
      if (ihjsed == 11) {
        nseed = nseedr;
      }
      if (ihjsed == 11) {
        write(6, star), "#   read in: ", nseed;
        write(12, star), "# Read in NSEED in HIJING at run time:", nseed;
      }
      cmn.io.close(12);
      arr<double> etas;
      arr<double> raps;
      nseed = 2 * nseed + 1;
      arr<double> taus;
      srand(nseed);
      /// C
      common_prec6() : ihpr2(10) = 1;
      etas(dimension(maxptn), fem::fill0), arpar1(1) = 0.7f;
      raps(dimension(maxptn), fem::fill0),
          taus(dimension(maxptn), fem::fill0) const int common_prec6::maxptn;
      cmn.smearp = 0e0;
      iamax = fem::max(iap, iat);
      struct common_precpb arr<double> vxp;
      cmn.nevent = nevnt;
      /// C
      arr<double> vyp;
      arr<double> vzp;
      common_precpb()
          :  /// Ctest off for resonance (phi, K*) studies:
            vxp(dimension(maxptn), fem::fill0),
            vyp(dimension(maxptn), fem::fill0),
            hijset(cmn, efrm, frame, proj, targ, iap, izp, iat, izt);
      artset(cmn);
      inizpc(cmn);
      vzp(dimension(maxptn), fem::fill0) const int common_precpb::maxptn;
      struct common_ilist1 int iscat;
      int jscat;
      /// C
      FEM_DO_SAFE(j, 1, nevnt) {
        iaevt = j;
        FEM_DO_SAFE(k, 1, num) {
          iarun = k;
          if (iaevt == nevnt && iarun == num) {
            cmn.iout = 1;
          }
          write(6, star), " EVENT ", j, ", RUN ", k;
          imiss = 0;
        statement_100:
          hijing(cmn, frame, bmin, bmax);
          iaint2(1) = natt;
          /// C
          arr<int> next;
          arr<int> last;
          write(98, star), hipr1;
          write(98, star), " ";
          write(98, star), ihpr2;
          write(98, star), " ";
          {
            write_loop wloop(cmn, 98, star);
            int ictype;
          }
          write(98, star), " ";
          {
            write_loop wloop(cmn, 98, star);
            arr<int> icsta;
          }
          write(98, star), " ";
          {
            write_loop wloop(cmn, 98, star);
            arr<int> nic;
          }
          write(98, star), " ";
          {
            write_loop wloop(cmn, 98, star);
            arr<int> icels;
          }
          write(98, star), " ";
          {
            write_loop wloop(cmn, 98, star);
            common_ilist1() :
          }
          write(98, star), " ";
          write(98, star), ihnt2;
        }
        /// C
        iscat(fem::int0), jscat(fem::int0), getnp(cmn);
        next(dimension(maxptn), fem::fill0), if (ihpr2(20) == 0) {
          goto statement_2000;
        }
        last(dimension(maxptn), fem::fill0), ictype(fem::int0),
            icsta(dimension(maxptn), fem::fill0), if (natt == 0) {
          imiss++;
          if (imiss <= 20) {
            write(6, star), "repeated event: natt=0,j,imiss=", j, imiss;
            goto statement_100;
          } else {
            write(6, star), "missed event: natt=0,j=", j;
            goto statement_2000;
          }
        }
        nic(dimension(maxptn), fem::fill0), arini(cmn);
        arini2(cmn, k);
      }
      /// C
      artan1(cmn);
      icels(dimension(maxptn), fem::fill0) const int common_ilist1::maxptn;
      artmn(cmn);
      icels(dimension(maxptn), fem::fill0) struct common_ilist2 artan2(cmn);
      int icell;
      }
      /// C
      artout(cmn, nevnt);
      vzp(dimension(maxptn), fem::fill0) arr<int, 3> icel;
      common_ilist2()
          : icell(fem::int0),
            icel(dimension(10, 10, 10), fem::fill0)
            /// C
            FEM_STOP(0);
      }

      struct common_ilist6

          double t;
      int iopern;
 AMPT::program_ampt);
 }
